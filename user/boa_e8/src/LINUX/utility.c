/*
 *      Utiltiy function to communicate with TCPIP stuffs
 *
 *      Authors: David Hsu	<davidhsu@realtek.com.tw>
 *
 *      $Id: utility.c,v 1.845 2013/01/25 07:31:11 kaohj Exp $
 *
 */

#define _GNU_SOURCE	//for vasprintf

/*-- System inlcude files --*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <sys/file.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <net/route.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <errno.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/sysinfo.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <sys/mount.h>
#include <sys/resource.h>

#include <netinet/if_ether.h>
#include <linux/if.h>
#include <linux/sockios.h>
#ifdef EMBED
#include <linux/config.h>
#endif

/*-- Local include files --*/
#include "mib.h"
#include "boa_timer.h"
#include "utility.h"

/* for open(), lseek() */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "debug.h"

#include <linux/wireless.h>

#include <linux/if_bridge.h>
#include <netdb.h>
#include <netinet/ip_icmp.h>
// Kaohj -- get_net_link_status() and get_net_link_info()
#include <linux/ethtool.h>
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
#include "rtusr_rg_api.h"
#endif


#ifdef CONFIG_MIDDLEWARE
#include <rtk/midwaredefs.h>
#endif

//#if defined(SUPPORT_MCAST_TEST) && defined(CONFIG_GPON_FEATURE)
#if defined(CONFIG_RTK_L34_ENABLE)
#include <rtk_rg_liteRomeDriver.h>
#include "rtusr_rg_api.h"
#else
#include "rtk/ponmac.h"
#include "rtk/gponv2.h"
#include "rtk/epon.h"
#include "hal/chipdef/chip.h"
#include "rtk/pon_led.h"
#include "rtk/stat.h"
#endif
//#endif

#if defined(CONFIG_USER_PPTP_CLIENT_PPTP) && defined(CONFIG_USER_L2TPD_L2TPD)
#include <regex.h>
#endif

#ifdef CONFIG_CT_AWIFI_JITUAN_SMARTWIFI
#include "../../ctcyueme/awifi/awifi.h"
int g_wan_modify=0;
#endif

#ifdef CONFIG_USER_CUMANAGEDEAMON
#ifdef CONFIG_RTK_OMCI_V1
#include <omci_api.h>
#include <gos_type.h>
#endif
#endif

#define PR_VC_START	1
#define	PR_PPP_START	16

#ifdef POLICY_ROUTING_DNSV4RELAY
static int g_vc_entry = 0;
#endif

#if defined CONFIG_IPV6
#include "ipv6_info.h"
#endif

#ifdef CONFIG_USER_CUSPEEDTEST
#include "cJSON.h"
#endif

#include <common/util/rt_util.h>
#include <sys/timerfd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

const char LANIF[] = "br0";
const char LAN_ALIAS[] = "br0:0";	// alias for secondary IP
const char LAN_IPPT[] = "br0:1";	// alias for IP passthrough
const char ELANIF[] = "eth0";
#ifdef CONFIG_RTL_MULTI_LAN_DEV
const char* ELANVIF[] = {ALIASNAME_ELAN0, ALIASNAME_ELAN1, ALIASNAME_ELAN2, ALIASNAME_ELAN3};
const char* SW_LAN_PORT_IF[] = {ALIASNAME_ELAN0, ALIASNAME_ELAN1, ALIASNAME_ELAN2, ALIASNAME_ELAN3}; // used for iptables
#else
const char* ELANVIF[] = {"eth0"};
const char* SW_LAN_PORT_IF[] = {ALIASNAME_ELAN0, ALIASNAME_ELAN1, ALIASNAME_ELAN2, ALIASNAME_ELAN3}; // used for iptables
#endif
const char BRIF[] = "br0";
#if defined(CONFIG_RTL8681_PTM) && !defined(CONFIG_RTL867X_PACKET_PROCESSOR)
const char PTMIF[] = "ptm0";
#else
const char PTMIF[] = "ptm0_pp";
#endif
#ifdef CONFIG_USB_ETH
const char USBETHIF[] = "usb0";
#endif //CONFIG_USB_ETH
//the name of wlan
#if defined(CONFIG_SLAVE_WLAN1_ENABLE) && !defined(CONFIG_MASTER_WLAN0_ENABLE)
const char*  wlan[]   = {"wlan1", "wlan1-vap0", "wlan1-vap1", "wlan1-vap2", "wlan1-vap3", ""};
#else
#ifdef WLAN_8_SSID_SUPPORT
const char*  wlan[]   = {"wlan0", "wlan0-vap0", "wlan0-vap1", "wlan0-vap2", "wlan0-vap3", "wlan0-vap4", "wlan0-vap5", "wlan0-vap6",
						 "wlan1", "wlan1-vap0", "wlan1-vap1", "wlan1-vap2", "wlan1-vap3", "wlan1-vap4", "wlan1-vap5", "wlan1-vap6", ""};
#else
const char*  wlan[]   = {"wlan0", "wlan0-vap0", "wlan0-vap1", "wlan0-vap2", "wlan0-vap3",
						 "wlan1", "wlan1-vap0", "wlan1-vap1", "wlan1-vap2", "wlan1-vap3", ""};
#endif

#endif
#ifdef WLAN_SUPPORT
#ifdef WLAN_8_SSID_SUPPORT
const int wlan_en[] = {1 //wlan0
#ifdef WLAN_MBSSID
	,1, 1, 1, 1, 1, 1, 1 //wlan0-vap0 ~ wlan0-vap6
#else
	,0, 0, 0, 0, 0, 0, 0
#endif
#ifdef WLAN_DUALBAND_CONCURRENT
	,1 //wlan1
#ifdef WLAN_MBSSID
	,1, 1, 1, 1, 1, 1, 1 //wlan1-vap0 ~ wlan1-vap6
#else
	,0, 0, 0, 0, 0, 0, 0
#endif
#else
	,0, 0, 0, 0, 0, 0, 0, 0
#endif
};
#else
const int wlan_en[] = {1 //wlan0
#ifdef WLAN_MBSSID
	,1, 1, 1, 1 //wlan0-vap0 ~ wlan0-vap3
#else
	,0, 0, 0, 0
#endif
#ifdef WLAN_DUALBAND_CONCURRENT
	,1 //wlan1
#ifdef WLAN_MBSSID
	,1, 1, 1, 1 //wlan1-vap0 ~ wlan1-vap3
#else
	,0, 0, 0, 0
#endif
#else
	,0, 0, 0, 0, 0
#endif
};
#endif
#else
const int wlan_en[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#endif
const char VC_BR[] = "0";
const char LLC_BR[] = "1";
const char VC_RT[] = "3";
const char LLC_RT[] = "4";
const char PORT_DNS[] = "53";
const char PORT_DHCP[] = "67";
const char BLANK[] = "";
const char ARG_ADD[] = "add";
const char ARG_CHANGE[] = "change";
const char ARG_DEL[] = "del";
const char ARG_ENCAPS[] = "encaps";
const char ARG_QOS[] = "qos";
const char ARG_255x4[] = "255.255.255.255";
const char ARG_0x4[] = "0.0.0.0";
const char ARG_BKG[] = "&";
const char ARG_I[] = "-i";
const char ARG_O[] = "-o";
const char ARG_T[] = "-t";
const char ARG_TCP[] = "TCP";
const char ARG_UDP[] = "UDP";
#ifdef NEW_IP_QOS_SUPPORT
const char ARG_TCPUDP[] = "TCP/UDP";
#endif
const char ARG_NO[] = "!";
const char ARG_ICMP[] = "ICMP";
const char FW_BLOCK[] = "block";
const char FW_INACC[] = "inacc";
const char FW_FTP_ACCOUNT[] = "ftp_account";
const char FW_SAMBA_ACCOUNT[] = "samba_account";
const char FW_IN_COMMING[] = "in_comming_filter";
const char FW_TELNET_ACCOUNT[] = "telnet_account";
const char FW_TELNET_ACCOUNT_V6[] = "telnet_account_v6";
const char FW_VPNGRE[] = "vpngre";
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
const char FW_IPFILTER_IN[] = "ipfilter_in";
const char FW_IPFILTER_OUT[] = "ipfilter_out";
#else
const char FW_IPFILTER[] = "ipfilter";
#endif
const char FW_BR_WAN[] = "br_wan";
const char FW_BR_WAN_OUT[] = "br_wan_out";
const char FW_VPN_ROUTE_POLICY[] = "vpn_route_policy";
const char *VPN_ROUTE_POLICY_MARK[] = {"0x20000", "0x40000", "0x80000", "0x100000"};
#ifdef NEW_PORTMAPPING
const char FW_DHCPS_DIS[] = "dhcps_disable";
const char FW_DNS_DIS[] = "dns_disable";
#endif
const char PORTMAP_IGMP[] = "portmapping_igmp"; // ebtables INPUT IGMP blocking

const char FW_BR_PPPOE[] = "br_pppoe";
//const char FW_MACFILTER[] = "macfilter";
const char FW_MACFILTER[] = "macfilter_b";
const char FW_MACFILTER_ROUTER[] = "macfilter_r";
const char FW_APPFILTER[] = "appfilter";
const char FW_APP_P2PFILTER[] = "appp2pfilter";
const char FW_IPQ_MANGLE_DFT[] = "m_ipq_dft";
const char FW_IPQ_MANGLE_USER[] = "m_ipq_user";

const char FW_INTERNET_ACCESSRIGHT_BRIDGE[] = "internet_accessright_b";
const char FW_INTERNET_ACCESSRIGHT_ROUTER[] = "internet_accessright_r";
const char FW_STORAGE_ACCESSRIGHT_ROUTER[] = "storage_accessright_r";

#ifdef PORT_FORWARD_ADVANCE
const char FW_PPTP[] = "pptp";
const char FW_L2TP[] = "l2tp";
#endif
const char PORT_FW[] = "portfw";
const char IPTABLE_DMZ[] = "dmz";
const char IPTABLE_IPFW[] = "ipfw";
const char IPTABLE_IPFW2[] = "ipfw_PostRouting";
const char IPTABLES_PORTTRIGGER[] = "portTrigger";
const char IPTABLE_TR069[] = "tr069";
const char FW_DROP[] = "DROP";
const char FW_ACCEPT[] = "ACCEPT";
const char FW_RETURN[] = "RETURN";
const char FW_FORWARD[] = "FORWARD";
const char FW_INPUT[] = "INPUT";
const char FW_OUTPUT[] = "OUTPUT";
const char FW_PREROUTING[] = "PREROUTING";
const char FW_POSTROUTING[] = "POSTROUTING";
const char IPTABLE_VTLSUR[]="virtual_server";
const char FW_DPORT[] = "--dport";
const char FW_SPORT[] = "--sport";
const char FW_ADD[] = "-A";
const char FW_DEL[] = "-D";
const char FW_INSERT[] = "-I";
const char RMACC_MARK[] = "0x1000";
const char CONFIG_HEADER[] = "<Config_Information_File_8671>";
const char CONFIG_TRAILER[] = "</Config_Information_File_8671>";
const char CONFIG_HEADER_HS[] = "<Config_Information_File_HS>";
const char CONFIG_TRAILER_HS[] = "</Config_Information_File_HS>";
const char CONFIG_XMLFILE[] = "/tmp/config.xml";
const char CONFIG_RAWFILE[] = "/tmp/config.bin";
const char CONFIG_XMLFILE_HS[] = "/tmp/config_hs.xml";
const char CONFIG_RAWFILE_HS[] = "/tmp/config_hs.bin";
const char CONFIG_XMLENC[] = "/tmp/config.enc";
const char PPP_SYSLOG[] = "/tmp/ppp_syslog";
const char PPP_DEBUG_LOG[] = "/tmp/ppp_debug_log";
const char BACKUP_DIRNAME[] = "e8_Config_Backup";

#ifdef CONFIG_CMCC_FORWARD_RULE_SUPPORT
const char CMCC_FORWARDRULE[]="cmcc_forwardrule";
const char CMCC_FORWARDRULE_POST[]="cmcc_forwardrule_post";
#endif
#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
const char IP6SEC[]="/bin/ip6sec";
const char IP6SECCTRL[]="/bin/ip6sec_ctrl";
#endif
const char ADSLCTRL[] = "/bin/adslctrl";
const char IFCONFIG[] = "/bin/ifconfig";
const char BRCTL[] = "/bin/brctl";
const char MPOAD[] = "/bin/mpoad";
const char MPOACTL[] = "/bin/mpoactl";
const char DHCPD[] = "/bin/udhcpd";
const char DHCPC[] = "/bin/udhcpc";
const char DNSRELAY[] = "/bin/dnsmasq";
const char DNSRELAYPID[] = "/var/run/dnsmasq.pid";
const char SPPPD[] = "/bin/spppd";
const char SPPPCTL[] = "/bin/spppctl";
const char WEBSERVER[] = "/bin/boa";
const char SNMPD[] = "/bin/snmpd";
const char ROUTE[] = "/bin/route";
const char IPTABLES[] = "/bin/iptables";
#ifdef CONFIG_IPV6
const char IP6TABLES[] = "/bin/ip6tables";
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
const char FW_IPV6FILTER_IN[] = "ipv6filter_in";
const char FW_IPV6FILTER_OUT[] = "ipv6filter_out";
#else
const char FW_IPV6FILTER[] = "ipv6filter";
#endif
const char FW_IPV6REMOTEACC[] = "ipv6remoteacc";
const char ARG_ICMPV6[] = "ICMPV6";
#endif
const char EMPTY_MAC[MAC_ADDR_LEN] = {0};
/*ql 20081114 START need ebtables support*/
const char EBTABLES[] = "/bin/ebtables";
const char ZEBRA[] = "/bin/zebra";
const char RIPD[] = "/bin/ripd";
#ifdef CONFIG_USER_ZEBRA_OSPFD_OSPFD
const char OSPFD[] = "/bin/ospfd";
#endif
const char ROUTED[] = "/bin/routed";
const char IGMPROXY[] = "/bin/igmpproxy";
const char MLDPROXY[] = "/bin/ecmh";		// Mason Yu. MLD Proxy
const char VSFTPD[] = "/bin/vsftpd";
const char NAS[] = "/bin/nas";
#if defined(CONFIG_RTL867X_NETLOG) && defined(CONFIG_USER_NETLOGGER_SUPPORT)
const char NETLOGGER[]="/bin/netlogger";
#endif
const char TC[] = "/bin/tc";
const char STARTUP[] = "/bin/startup";
const char OMCICLI[] = "/bin/omcicli";
#ifdef TIME_ZONE
const char SNTPC[] = "/bin/vsntp";
const char SNTPC_PID[] = "/var/run/vsntp.pid";
#endif
#ifdef CONFIG_CMCC_OSGIMANAGE
const char OSGIMANAGE_PID[] = "/var/run/osgiManage.pid";
#endif
#ifdef CONFIG_USER_CUMANAGEDEAMON
const char CUMANAGE_PID[] = "/var/run/cumanagedaemon.pid";
#endif
#ifdef CONFIG_USER_DDNS
const char DDNSC_PID[] = "/var/run/updatedd.pid";
#endif
const char ROUTED_PID[] = "/var/run/routed.pid";
#ifdef CONFIG_USER_ZEBRA_OSPFD_OSPFD
const char ZEBRA_PID[] = "/var/run/zebra.pid";
const char OSPFD_PID[] = "/var/run/ospfd.pid";
#endif
const char IGMPPROXY_PID[] = "/var/run/igmp_pid";
const char MLDPROXY_PID[] = "/var/run/ecmh.pid";	// Mason Yu. MLD Proxy

const char PROC_DYNADDR[] = "/proc/sys/net/ipv4/ip_dynaddr";
const char PROC_IPFORWARD[] = "/proc/sys/net/ipv4/ip_forward";
#ifdef CONFIG_IPV6
#if defined(CONFIG_USER_DHCPV6_ISC_DHCP411) || defined(CONFIG_USER_RADVD)
const char RADVD_CONF[] = "/var/radvd.conf";
const char RADVD_PID[] = "/var/run/radvd.pid";
#endif
const char PROC_IP6FORWARD[] = "/proc/sys/net/ipv6/conf/all/forwarding";
const char PROC_MC6FORWARD[] = "/proc/sys/net/ipv6/conf/all/mc_forwarding";
#endif // of CONFIG_IPV6
const char PROC_NET_ATM_PVC[] = "/proc/net/atm/pvc";
#ifdef _LINUX_2_6_
const char PROC_FORCE_IGMP_VERSION[] = "/proc/sys/net/ipv4/conf/default/force_igmp_version";
#else
const char PROC_FORCE_IGMP_VERSION[] = "/proc/sys/net/ipv4/conf/default/force_igmp_version";
#endif
const char PPP_CONF[] = "/var/ppp/ppp.conf";
const char PPPD_FIFO[] = "/tmp/ppp_serv_fifo";
const char MPOAD_FIFO[] = "/tmp/serv_fifo";
const char DHCPC_PID[] = "/var/run/udhcpc.pid";
const char DHCPC_ROUTERFILE[] = "/var/udhcpc/router";
const char DHCPC_SCRIPT[] = "/etc/scripts/udhcpc.sh";
const char DHCPC_SCRIPT_NAME[] = "/var/udhcpc/udhcpc";
const char DHCPD_CONF[] = "/var/udhcpd/udhcpd.conf";
const char DHCPD_LEASE[] = "/var/udhcpd/udhcpd.leases";
const char DHCPSERVERPID[] = "/var/run/udhcpd.pid";
const char DHCPRELAYPID[] = "/var/run/dhcrelay.pid";
const char IPOA_IPINFO[] = "/tmp/IPoAHalfBridge";
const char MER_GWINFO[] = "/tmp/MERgw";
#ifdef CONFIG_USER_CUPS
const char CUPSDPRINTERCONF[] = "/var/cups/conf/printers.conf";
#endif // CONFIG_USER_CUPS
#define MINI_UPNPDPID  "/var/run/mini_upnpd.pid"	//cathy
#define MINIUPNPDPID  "/var/run/linuxigd.pid"
const char MINIDLNAPID[] = "/var/run/minidlna.pid";
const char STR_DISABLE[] = "Disabled";
const char STR_ENABLE[] = "Enabled";
const char STR_AUTO[] = "Auto";
const char STR_MANUAL[] = "Manual";
const char STR_UNNUMBERED[] = "unnumbered";
const char STR_ERR[] = "err";
const char STR_NULL[] = "null";
const char rebootWord0[] = "The System is Restarting ...";
const char rebootWord1[] = "This device has been configured and is rebooting.";
const char rebootWord2[] = "Close the Configuration window and wait"
			" for a minute before reopening your web browser."
			" If necessary, reconfigure your PC's IP address to match"
			" your new configuration.";
// TR-111: ManufacturerOUI, ProductClass
const char MANUFACTURER_OUI[] = DEF_MANUFACTUREROUI_STR;//"00E04C";
const char PRODUCT_CLASS[] = DEF_PRODUCTCLASS_STR;//"IGD";

#ifdef CONFIG_BOA_WEB_E8B_CH
const char PW_HOME_DIR[] = "/mnt";
#else
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
const char PW_HOME_DIR[] = "/mnt";
#else
const char PW_HOME_DIR[] = "/tmp";
#endif
#endif
#ifdef CONFIG_USER_CLI
const char PW_CMD_SHELL[] = "/bin/cli";
#else
const char PW_CMD_SHELL[] = "/bin/sh";
#endif
#ifdef CONFIG_USER_SAMBA
const char SMBDPID[] = "/var/run/smbd.pid";
#ifdef CONFIG_USER_NMBD
const char NMBDPID[] = "/var/run/nmbd.pid";
#endif
#endif

static struct process_nice_table_entry process_nice_table[] = {
	//processName, nice
	{"iwcontrol", -19},
	{"boa", -18},
	{"runomci.sh", -18},
	{"omci_app", -18},
	{"eponoamd", -18},
	{"VoIP_maserati", -18},
	{"cwmpClient", -18},
	{"spppd", -17}, 
	{"auth", -17},
	{"wscd", -17},
	{"reg_server", -17},
	{"dbus-daemon", -17}
};

#if defined(IP_QOS) || defined(NEW_IP_QOS_SUPPORT)
const char *n0to7[] = {
	"n/a", "0", "1", "2", "3", "4", "5", "6", "7"
};

// Note: size of prioLevel depends on the IPQOS_NUM_PKT_PRIO
const char *prioLevel[] = {
	"p0", "p1", "p2", "p3", "p4", "p5", "p6", "p7"
};

//alex_huang
#ifdef CONFIG_8021P_PRIO
const char *set1ptable[]={"set1ptbl0","set1ptbl1","set1ptbl2","set1ptbl3","set1ptbl4","set1ptbl5","set1ptbl6","set1ptbl7"};
#ifdef NEW_IP_QOS_SUPPORT
const char *setpredtable[]={"setpredtbl0", "setpredtbl1", "setpredtbl2", "setpredtbl3", "setpredtbl4", "setpredtbl5", "setpredtbl6", "setpredtbl7"};
#endif
#endif
// priority mapping of packet priority against priority queue
// ex, priomap[3] == 2 means packet priority 3 is mapping to priority queue_2 by default
//const int priomap[8] = {3, 3, 2, 2, 2, 1, 1, 1};
//const int priomap[8] = {4, 4, 3, 3, 2, 2, 1, 1};
const int priomap[8] = {3, 4, 4, 3, 2, 2, 1, 1}; //cathy
const char *ipTos[] = {
	"n/a", "Normal Service", "Minimize Cost", "Maximize Reliability",
	"Maximize Throughput", "Minimize Delay"
};
#endif

const char *ppp_auth[] = {
	"AUTO", "PAP", "CHAP", "NONE"
};

const char errGetEntry[] = "Get table entry error!";

// Added by Davian
#ifdef CONFIG_USER_XMLCONFIG
const char shell_name[] = "/bin/ash";
#endif

//Alan 20160728
const char hideErrMsg1[] = ">/dev/null";
const char hideErrMsg2[] = "2>&1";

static char base64_chars[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                              "abcdefghijklmnopqrstuvwxyz0123456789+/=";

void filter_set_domain_default(void);

/*setup mac addr if mac[n-1]++ > 0xff and set mac[n-2]++, etc.*/
void setup_mac_addr(unsigned char *macAddr, int index)
{
	if((macAddr[5]+index) > 0xff)
	{
	  printf("macAddr[5]+%d = %x > 0xff\n",index,macAddr[5]+index);
	  //macAddr[4]++;
	  if((macAddr[4]+1) > 0xff)
	  {
	  	printf("macAddr[4]+1 = %x > 0xff\n",macAddr[4]+1);	  
	  	if((macAddr[3]+1) > 0xff)
		{
		  printf("something wrong for setting your macAddr[3] > 0xff!!\n");
		}
		macAddr[3]+=1;
	  }
	  macAddr[4]+=1;
    }
	AUG_PRT("macAddr[5]+%d = %x\n",index,macAddr[5]+index);

	macAddr[5]+=index;
}

/*
 * Name: base64_encode()
 *
 * Description: Encodes a buffer using BASE64.
 */
void base64_encode(unsigned char *from, char *to, int len)
{
	while (len) {
		unsigned long k;
		int c;

		c = (len < 3) ? len : 3;
		k = 0;
		if(len>=3) {
			len -= c;
			while (c--)
				k = (k << 8) | *from++;
			*to++ = base64_chars[ (k >> 18) & 0x3f ];
			*to++ = base64_chars[ (k >> 12) & 0x3f ];
			*to++ = base64_chars[ (k >> 6) & 0x3f ];
			*to++ = base64_chars[ k & 0x3f ];

		} else {
			switch (len) {
				case 1:
					k = (k << 8) | *from;
					*to++ = base64_chars[ (k >> 2) & 0x3f ];
					*to++ = base64_chars[ (k << 4) & 0x3f ];
					*to++ = base64_chars[ 64 ];
					*to++ = base64_chars[ 64 ];
					break;
				case 2:
					k = (k << 8) | *from++;
					k = (k << 8) | *from;
					*to++ = base64_chars[ (k >> 10) & 0x3f ];
					*to++ = base64_chars[ (k >> 4) & 0x3f ];
					*to++ = base64_chars[ (k << 2) & 0x3f ];
					*to++ = base64_chars[ 64 ];
					break;
			}
			len = 0;
		}

	}
	*to++ = 0;
}

/*
 * Name: base64encode()
 *
 * Description: Encodes a buffer using BASE64.
 */
void base64encode(unsigned char *from, char *to, int len)
{
	char base64chars[64] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./";

  while (len) {
    unsigned long k;
    int c;

    c = (len < 3) ? len : 3;
    k = 0;
    len -= c;
    while (c--)
      k = (k << 8) | *from++;
    *to++ = base64chars[ (k >> 18) & 0x3f ];
    *to++ = base64chars[ (k >> 12) & 0x3f ];
    *to++ = base64chars[ (k >> 6) & 0x3f ];
    *to++ = base64chars[ k & 0x3f ];
  }
  *to++ = 0;
}

int base64_decode(void *dst,char *src,int maxlen)
{
 int bitval,bits;
 int val;
 int len,x,y;

 len = strlen(src);
 bitval=0;
 bits=0;
 y=0;

 for(x=0;x<len;x++)
  {
   if ((src[x]>='A')&&(src[x]<='Z')) val=src[x]-'A'; else
   if ((src[x]>='a')&&(src[x]<='z')) val=src[x]-'a'+26; else
   if ((src[x]>='0')&&(src[x]<='9')) val=src[x]-'0'+52; else
   if (src[x]=='+') val=62; else
   if (src[x]=='-') val=63; else
    val=-1;
   if (val>=0)
    {
     bitval=bitval<<6;
     bitval+=val;
     bits+=6;
     while (bits>=8)
      {
       if (y<maxlen)
        ((char *)dst)[y++]=(bitval>>(bits-8))&0xFF;
       bits-=8;
       bitval &= (1<<bits)-1;
      }
    }
  }
 if (y<maxlen)
   ((char *)dst)[y++]=0;
 return y;
}

int isIPAddr(char * IPStr)	//check is ip or domain name
{
	char tmpBuf[300];
	char * delim = ".";
	char * p;
	int count = 0;

	strcpy(tmpBuf,IPStr);
	p = strtok(tmpBuf,delim);
	while(p)
	{
		int i;
		int data;

		count++;
		if(strlen(p) > 3 || strlen(p) < 1)
			return 0;
		for(i=0;i<strlen(p);i++){
			if(*(p+i) < '0' || *(p+i) > '9')
				return 0;
		}
		data = atoi(p);
		if(data > 255 || data < 0)
			return 0;
		p=strtok(NULL,delim);
	}
	if(count != 4)
		return 0;

	return 1;
}

int startSSDP()
{
#ifdef CONFIG_USER_MINI_UPNPD
	char *argv[10];
	int i = 0, pid = 0;

	pid = read_pid((char *)MINI_UPNPDPID);
	if (pid > 0)
	{
		kill(pid, 9);
		unlink(MINI_UPNPDPID);
	}

	argv[i++]="/bin/mini_upnpd";
#ifdef WLAN_SUPPORT
#ifdef CONFIG_WIFI_SIMPLE_CONFIG
	char wscd_pid_name[32];
	getWscPidName(wscd_pid_name);
	if (read_pid(wscd_pid_name) > 0){
		argv[i++]="-wsc";
		argv[i++]="/tmp/wscd_config";
	}
#endif
#endif

#ifdef CONFIG_USER_MINIUPNPD
	if (read_pid((char *)MINIUPNPDPID) > 0){
		argv[i++]="-igd";
		argv[i++]="/tmp/igd_config";
	}
#endif
	argv[i++]="&";
	argv[i]=NULL;
	do_nice_cmd( argv[0], argv, 0 );
#endif
	return 0;
}

extern inline int caculate_tblid_ITF_SourceRoute(uint32_t ifid);
/*
vc0 return 1, vc1 return 2 ...
ppp0 return 11, ppp1 return 12 ...
*/
inline int caculate_tblid_ITF_SourceRoute(uint32_t ifid)
{
	int tbl_id;

	uint32_t ifindex;

	ifindex = ifid;

	//ifindex of vc* is 0xff01, 0xff02, ...
	//ifindex 0f ppp* is 0x00, 0x0101, 0x0202 ...
#ifdef CONFIG_ETHWAN
	//if(CHECK_NAS_IDX(ifindex))
	if( MEDIA_INDEX(ifindex)==MEDIA_ETH )
	{
		if(PPP_INDEX(ifindex) == DUMMY_PPP_INDEX)
			tbl_id = ETH_INDEX(ifindex) + ITF_SOURCE_ROUTE_NAS_START;
		else
			tbl_id = PPP_INDEX(ifindex) + ITF_SOURCE_ROUTE_PPP_START;
	}
	else
#endif /*CONFIG_ETHWAN*/
	{
	//ifindex of vc* is 0xff01, 0xff02, ...
	//ifindex of ppp* is 0x00, 0x0101, 0x0202 ...
	if (PPP_INDEX(ifindex) == DUMMY_PPP_INDEX)
		tbl_id = VC_INDEX(ifindex) + ITF_SOURCE_ROUTE_VC_START;
	else
		tbl_id = PPP_INDEX(ifindex) + ITF_SOURCE_ROUTE_PPP_START;
	}

	// Mason Yu.
	//printf("ifindex=0x%x, tbl_id=0x%x\n", ifindex, tbl_id);
	return tbl_id;
}

//rule_mark[0] = "0x20000"  which means:  mark the 0 as 0x20000/0xe0000
const char*  rule_mark[] = {"0x20000/0xe0000",    "0x40000/0xe0000",
						   "0x60000/0xe0000",
						   "0x80000/0xe0000",
						   ""};

const char*  rule_mark_ppp[] = {"0xa0000/0xe0000", "0xc0000/0xe0000", "0xe0000/0xe0000",""};

#define ITF_SourceRoute_DHCP_MARK_NUM	4
#define ITF_SourceRoute_PPP_MARK_NUM	3

//eason
#ifdef _PRMT_USB_ETH_
//0:ok, -1:error
int getUSBLANMacAddr( char *p )
{
	unsigned char *hwaddr;
	struct ifreq ifr;
	strcpy(ifr.ifr_name, USBETHIF);
	do_ioctl(SIOCGIFHWADDR, &ifr);
	hwaddr = (unsigned char *)ifr.ifr_hwaddr.sa_data;
//	printf("The result of SIOCGIFHWADDR is type %d  "
//	       "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x.\n",
//	       ifr.ifr_hwaddr.sa_family, hwaddr[0], hwaddr[1],
//	       hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);
	memcpy( p, hwaddr, 6 );
	return 0;
}

//0:high, 1:full, 2:low
int getUSBLANRate( void )
{
	struct ifreq ifr;
	strcpy(ifr.ifr_name, USBETHIF);
	do_ioctl( SIOCUSBRATE, &ifr );
//	fprintf( stderr, "getUSBLANRate=%d\n", *(int*)(&ifr.ifr_ifindex) ); //ifr_ifru.ifru_ivalue );
	return ifr.ifr_ifindex;//ifr_ifru.ifru_ivalue;
}

//0:up, 1:nolink
int getUSBLANStatus(void )
{
	struct ifreq ifr;
	strcpy(ifr.ifr_name, USBETHIF);
	do_ioctl( SIOCUSBSTAT, &ifr );
//	fprintf( stderr, "getUSBLANStatus=%d\n", *(int*)(&ifr.ifr_ifindex) ); //ifr_ifru.ifru_ivalue );
	return ifr.ifr_ifindex; //ifr_ifru.ifru_ivalue;
}
#endif

static char adslDevice[] = "/dev/adsl0";

static FILE* adslFp = NULL;

static const char *dhcp_mode[] = {
	"None", "DHCP Relay", "DHCP Server"
};

#ifdef IP_PASSTHROUGH
static void set_IPPT_LAN_access();
#endif

int virtual_port_enabled;
const int virt2user[] = {
	1, 2, 3, 4, 5
};

// Timer for auto search PVC
#if defined(AUTO_PVC_SEARCH_TR068_OAMPING) || defined(AUTO_PVC_SEARCH_PURE_OAMPING) || defined(AUTO_PVC_SEARCH_AUTOHUNT)
int autoHunt_found = 0;
int fin_AutoSearchPVC = 0;
#endif

// Mason Yu
#ifdef PORT_FORWARD_ADVANCE
const char *PFW_Gategory[] = {"VPN", "Game"};
const char *PFW_Rule[] = {"PPTP", "L2TP"};
#endif

//keep the same order with ITF_T
//if want to convert lan device name to br0, call LANDEVNAME2BR0() macro
const char *strItf[] = {
	"",		//ITF_ALL
	"",		//ITF_WAN
	"br0",		//ITF_LAN

	"eth0",		//ITF_ETH0
	"eth0_sw0",	//ITF_ETH0_SW0
	"eth0_sw1",	//ITF_ETH0_SW1
	"eth0_sw2",	//ITF_ETH0_SW2
	"eth0_sw3",	//ITF_ETH0_SW3

	"wlan0",	//ITF_WLAN0
	"wlan0-vap0",	//ITF_WLAN0_VAP0
	"wlan0-vap1",	//ITF_WLAN0_VAP1
	"wlan0-vap2",	//ITF_WLAN0_VAP2
	"wlan0-vap3",	//ITF_WLAN0_VAP3

	"wlan1",	//ITF_WLAN0
	"wlan1-vap0",	//ITF_WLAN0_VAP0
	"wlan1-vap1",	//ITF_WLAN0_VAP1
	"wlan1-vap2",	//ITF_WLAN0_VAP2
	"wlan1-vap3",	//ITF_WLAN0_VAP3

	"usb0",		//ITF_USB0

	""		//ITF_END
};

int IfName2ItfId(char *s)
{
	int i;
	if( !s || s[0]==0 ) return ITF_ALL;
	if( (strncmp(s, "ppp", 3)==0) || (strncmp(s, "vc", 2)==0)
		|| (strncmp(s, "nas", 3)==0) || (strncmp(s, "ptm", 3)==0))
		return ITF_WAN;

	for( i=0;i<ITF_END;i++ )
	{
		if( strcmp( strItf[i],s )==0 ) return i;
	}

	return -1;
}

// Mason Yu. 090903
int do_ioctl(unsigned int cmd, struct ifreq *ifr)
{
	int skfd, ret;

	if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		perror("socket");
		return (-1);
	}

	ret = ioctl(skfd, cmd, ifr);
	close(skfd);
	return ret;
}

/*
 *	Check if a host is direct connected to local interfaces.
 *	pEntry: check with local interface pEntry; null to check all local interfaces.
 */
int isDirectConnect(struct in_addr *haddr, MIB_CE_ATM_VC_Tp pEntry)
{
	char buff[256];
	int flgs;
	struct in_addr dest, mask;
	FILE *fp;

	if (pEntry) {
		dest = *((struct in_addr *)pEntry->ipAddr);
		mask = *((struct in_addr *)pEntry->netMask);
		if ((dest.s_addr & mask.s_addr) == (haddr->s_addr & mask.s_addr)) {
			//printf("dest=0x%x, mask=0x%x\n", dest.s_addr, mask.s_addr);
			return 1;
		}
	}
	else { // pEntry == NULL
		if (!(fp = fopen("/proc/net/route", "r"))) {
			printf("Error: cannot open /proc/net/route - continuing...\n");
			return 0;
		}
		fgets(buff, sizeof(buff), fp);
		while (fgets(buff, sizeof(buff), fp) != NULL) {
			if (sscanf(buff, "%*s%x%*x%x%*d%*d%*d%x", &dest, &flgs, &mask) != 3) {
				printf("Unsuported kernel route format\n");
				fclose(fp);
				return 0;
			}
			if ((flgs & RTF_UP) && mask.s_addr != 0) {
				if ((dest.s_addr & mask.s_addr) == (haddr->s_addr & mask.s_addr)) {
					//printf("dest=0x%x, mask=0x%x\n", dest.s_addr, mask.s_addr);
					fclose(fp);
					return 1;
				}
			}
		}
		fclose(fp);
	}
	return 0;
}

void get_dns_by_wan(MIB_CE_ATM_VC_T *pEntry, char *dns1, char *dns2)
{
	unsigned char zero[IP_ADDR_LEN] = {0};

	if ( ((pEntry->cmode == CHANNEL_MODE_RT1483) || (pEntry->cmode == CHANNEL_MODE_IPOE)) && (pEntry->dnsMode == REQUEST_DNS_NONE) )
	{
		//manual
		if(memcmp(zero, pEntry->v4dns1, IP_ADDR_LEN) != 0)
		{
			//v4dns1 is already in network byte order
			inet_ntop(AF_INET, pEntry->v4dns1, dns1, INET_ADDRSTRLEN);
		}
		if(memcmp(zero, pEntry->v4dns2, IP_ADDR_LEN) != 0)
		{
			//v4dns2 is already in network byte order
			inet_ntop(AF_INET, pEntry->v4dns2, dns2, INET_ADDRSTRLEN);
		}
	}
	else
	{
		FILE *infdns = NULL;
		char line[128] = {0};
		char ifname[IFNAMSIZ] = {0};

		ifGetName(pEntry->ifIndex,ifname,sizeof(ifname));
		if ((DHCP_T)pEntry->ipDhcp == DHCP_CLIENT)
			snprintf(line, 64, "%s.%s", (char *)DNS_RESOLV, ifname);
		if (pEntry->cmode == CHANNEL_MODE_PPPOE || pEntry->cmode == CHANNEL_MODE_PPPOA)
			snprintf(line, 64, "%s.%s", (char *)PPP_RESOLV, ifname);

		infdns=fopen(line,"r");
		if(infdns)
		{
			char *p = NULL;
			int cnt = 0;

			while(fgets(line,sizeof(line),infdns))
			{
				if((strlen(line)==0))
					continue;

				p = strchr(line, '@');
				if (p)
				{
					if(cnt == 0)
					{
						memcpy(dns1, line, p-line);
						dns1[p-line] = '\0';
						cnt++;
					}
					else
					{
						memcpy(dns2, line, p-line);
						dns2[p-line] = '\0';
						cnt++;
						break;
					}
				}
			}
			fclose(infdns);
		}
	}
}

#ifdef CONFIG_IPV6
void get_dns6_by_wan(MIB_CE_ATM_VC_T *pEntry, char *dns1, char *dns2)
{
	if ( (pEntry->Ipv6Dhcp == 1) || ((pEntry->Ipv6DhcpRequest & 0x2) == 0x2)
			|| pEntry->AddrMode == IPV6_WAN_STATIC)
	{
		FILE* infdns;
		char file[64] = {0};
		char line[128] = {0};
		char ifname[IFNAMSIZ] = {0};

		ifGetName(pEntry->ifIndex,ifname,sizeof(ifname));

		if(pEntry->dnsv6Mode==REQUEST_DNS_NONE || pEntry->AddrMode == IPV6_WAN_STATIC){//dnsv6 server setting from user
			snprintf(file, 64, "%s.%s_static", (char *)DNS6_RESOLV, ifname);
		}
		else{ //dnsv6 server setting from dhcpv6 server
			snprintf(file, 64, "%s.%s", (char *)DNS6_RESOLV, ifname);
		}

		infdns=fopen(file,"r");
		if(infdns)
		{
			int cnt = 0;

			while(fgets(line,sizeof(line),infdns) != NULL)
			{
				char *new_line = NULL;

				new_line = strrchr(line, '\n');
				if(new_line)
					*new_line = '\0';

				if((strlen(line)==0))
					continue;

				if(cnt == 0)
					strcpy(dns1, line);
				else
				{
					strcpy(dns2, line);
					break;
				}

				cnt++;
			}
			fclose(infdns);
		}
	}
}
#endif

/*
 * Get Interface Addr (MAC, IP, Mask)
 */
int getInAddr(char *interface, ADDR_T type, void *pAddr)
{
	struct ifreq ifr;
	int found=0;
	struct sockaddr_in *addr;

	strcpy(ifr.ifr_name, interface);
	if (do_ioctl(SIOCGIFFLAGS, &ifr) < 0)
		return (0);

	if (type == HW_ADDR) {
		if (do_ioctl(SIOCGIFHWADDR, &ifr) >= 0) {
			memcpy(pAddr, &ifr.ifr_hwaddr, sizeof(struct sockaddr));
			found = 1;
		}
	}
	else if (type == IP_ADDR) {
		if (do_ioctl(SIOCGIFADDR, &ifr) == 0) {
			addr = ((struct sockaddr_in *)&ifr.ifr_addr);
			*((struct in_addr *)pAddr) = *((struct in_addr *)&addr->sin_addr);
			found = 1;
		}
	}
	else if (type == DST_IP_ADDR) {
		if (do_ioctl(SIOCGIFDSTADDR, &ifr) == 0) {
			addr = ((struct sockaddr_in *)&ifr.ifr_addr);
			*((struct in_addr *)pAddr) = *((struct in_addr *)&addr->sin_addr);
			found = 1;
		}
	}
	else if (type == SUBNET_MASK) {
		if (do_ioctl(SIOCGIFNETMASK, &ifr) >= 0) {
			addr = ((struct sockaddr_in *)&ifr.ifr_addr);
			*((struct in_addr *)pAddr) = *((struct in_addr *)&addr->sin_addr);
			found = 1;
		}
	}
	return found;
}

int getInFlags(char *interface, int *flags)
{
	struct ifreq ifr;
	int found=0;

#ifdef EMBED
	strcpy(ifr.ifr_name, interface);

	if (do_ioctl(SIOCGIFFLAGS, &ifr) == 0) {
		if (flags)
			*flags = ifr.ifr_flags;
		found = 1;
	}
#endif
	return found;
}

int setInFlags(char *interface, int flags)
{
	struct ifreq ifr;
	int ret=0;

#ifdef EMBED
	strcpy(ifr.ifr_name, interface);
	ifr.ifr_flags = flags;

	if (do_ioctl(SIOCSIFFLAGS, &ifr) == 0)
		ret = 1;
#endif
	return ret;
}

int INET_resolve(char *name, struct sockaddr *sa)
{
	struct sockaddr_in *s_in = (struct sockaddr_in *)sa;

	s_in->sin_family = AF_INET;
	s_in->sin_port = 0;

	/* Default is special, meaning 0.0.0.0. */
	if (strcmp(name, "default")==0) {
		s_in->sin_addr.s_addr = INADDR_ANY;
		return 1;
	}
	/* Look to see if it's a dotted quad. */
	if (inet_aton(name, &s_in->sin_addr)) {
		return 0;
	}
	/* guess not.. */
	return -1;
}

enum { ROUTE_ADD, ROUTE_DEL };
/*
 *	Add a route
 */
static int route_modify(struct rtentry *rt, int action)
{
	int skfd;

	if (rt==0)
		return -1;

	rt->rt_flags = RTF_UP;
	if (((struct sockaddr_in *)(&rt->rt_gateway))->sin_addr.s_addr)
		rt->rt_flags |= RTF_GATEWAY;

	/* Create a socket to the INET kernel. */
	if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		perror("socket");
		return -1;
	}

	// Added by Mason Yu. According the netmask, we input the correct dst address.
	((struct sockaddr_in *)(&rt->rt_dst))->sin_addr.s_addr =
	(((struct sockaddr_in *)(&rt->rt_dst))->sin_addr.s_addr & ((struct sockaddr_in *)(&rt->rt_genmask))->sin_addr.s_addr );

	if (action == ROUTE_ADD) {
	/* Tell the kernel to accept this route. */
		if (ioctl(skfd, SIOCADDRT, rt) < 0) {
			perror("SIOCADDRT");
			close(skfd);
			return -1;
		}
	} else {
		if (ioctl(skfd, SIOCDELRT, rt) < 0) {
			perror("SIOCDELRT");
			close(skfd);
			return -1;
		}
	}

	/* Close the socket. */
	(void) close(skfd);
	return 0;

}

static inline int INET_addroute(struct rtentry *rt)
{
	return route_modify(rt, ROUTE_ADD);
}

/*
*	Del a route
*/
static inline int INET_delroute(struct rtentry *rt)
{
	return route_modify(rt, ROUTE_DEL);
}

void setup_ipforwarding(int enable)
{
	FILE *fp;
	int ipv6forward;

	if (enable != 0)
		enable = 1;
	fp = fopen(PROC_IPFORWARD, "w");
	if(fp)
	{
		fprintf(fp, "%d\n", enable);
		fclose(fp);
	}
#ifdef CONFIG_IPV6
	//  Because the /proc/.../conf/all/forwarding value, will affect /proc/.../conf/vc0/forwarding value.
	fp = fopen(PROC_IP6FORWARD, "r+");
	if(fp)
	{
		fscanf(fp,"%d",&ipv6forward);
		if(ipv6forward !=enable)
			fprintf(fp, "%d\n", enable);
		fclose(fp);
	}
	if (fp = fopen(PROC_MC6FORWARD, "w"))
	{
		fprintf(fp, "%d\n", enable);
		fclose(fp);
	}
#endif
}

// update corresponding field of rtentry from MIB_CE_IP_ROUTE_T
static void updateRtEntry(MIB_CE_IP_ROUTE_T *pSrc, struct rtentry *pDst)
{
	struct sockaddr_in *s_in;

	//pDst->rt_flags = RTF_UP;
	s_in = (struct sockaddr_in *)&pDst->rt_dst;
	s_in->sin_family = AF_INET;
	s_in->sin_port = 0;
	s_in->sin_addr = *(struct in_addr *)pSrc->destID;

	s_in = (struct sockaddr_in *)&pDst->rt_genmask;
	s_in->sin_family = AF_INET;
	s_in->sin_port = 0;
	s_in->sin_addr = *(struct in_addr *)pSrc->netMask;

	//if (pSrc->nextHop[0]&&pSrc->nextHop[1]&&pSrc->nextHop[2]&&pSrc->nextHop[3]) {
	if (pSrc->nextHop[0] || pSrc->nextHop[1] || pSrc->nextHop[2] ||pSrc->nextHop[3]) {
		s_in = (struct sockaddr_in *)&pDst->rt_gateway;
		s_in->sin_family = AF_INET;
		s_in->sin_port = 0;
		s_in->sin_addr = *(struct in_addr *)pSrc->nextHop;
	}
}

/* When systemd renew ip need check the static route bound to the interface too, IulianWu */
void check_staticRoute_change(char *ifname)
{
	unsigned int totalEntry =0;
	int i=0;
	MIB_CE_IP_ROUTE_T Entry;
	char ifname_tmp[IFNAMSIZ];
	struct rtentry rt;
	
	totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL);
	for (i=0; i< totalEntry; i++){
		mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry);
		ifGetName(Entry.ifIndex, ifname_tmp, sizeof(ifname_tmp));
		if(!strcmp(ifname, ifname_tmp)){
			memset(&rt, 0, sizeof(rt));
			updateRtEntry(&Entry, &rt);
			rt.rt_dev = ifGetName(Entry.ifIndex, ifname_tmp, sizeof(ifname_tmp));
			if (Entry.FWMetric > -1)
				rt.rt_metric = Entry.FWMetric + 1;
			INET_addroute(&rt); 
		}
	}
}

/*del=>  1: delete the route entry,
         0: add the route entry(skip ppp part),
        -1: add the route entry*/
void route_cfg_modify(MIB_CE_IP_ROUTE_T *pRoute, int del, int entryID)
{
	struct rtentry rt;
	char ifname[IFNAMSIZ];
	struct in_addr gateway;

	if( pRoute==NULL ) return;
	if(!pRoute->Enable) return;

	memset(&rt, 0, sizeof(rt));
	updateRtEntry(pRoute, &rt);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	if(pRoute->intfEnable==1)
#endif
	{
		rt.rt_dev = ifGetName(pRoute->ifIndex, ifname, sizeof(ifname));
	}
	if (pRoute->FWMetric > -1)
		rt.rt_metric = pRoute->FWMetric + 1;


	if (del>0) {
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
		// rg delete static route
		RG_del_static_route(pRoute, entryID);
#endif
		INET_delroute(&rt);
		return;
	}
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
	rg_add_route(pRoute, entryID);
#endif
	if(((struct sockaddr_in *)&rt.rt_gateway)->sin_addr.s_addr || !get_wan_gateway(pRoute->ifIndex, &gateway))
	{
		struct sockaddr_in *s_in;
		AUG_PRT("gateway=%x\n",gateway);
		s_in = (struct sockaddr_in *)&rt.rt_gateway;
		s_in->sin_family = AF_INET;
		s_in->sin_port = 0;
		if (!((struct sockaddr_in *)&rt.rt_gateway)->sin_addr.s_addr)
			s_in->sin_addr = gateway;
		INET_addroute(&rt);
	}
}

#ifdef CONFIG_IPV6
int checkIPv6Route(MIB_CE_IPV6_ROUTE_Tp new_entry)
{
	MIB_CE_IPV6_ROUTE_T Entry;
	unsigned int totalEntry = mib_chain_total(MIB_IPV6_ROUTE_TBL);
	int i;

	for (i=0; i<totalEntry; i++) {
		if (mib_chain_get(MIB_IPV6_ROUTE_TBL, i, (void *)&Entry)) {
			if( (strcmp(new_entry->Dstination,Entry.Dstination)==0 ) &&
				(strcmp(new_entry->NextHop,Entry.NextHop)==0 ) )
				return 0;
		}
	}
	return 1;
}

void route_v6_cfg_modify(MIB_CE_IPV6_ROUTE_T *pRoute, int del, int entryID)
{
	char ifname[IFNAMSIZ];
	char metric[5];

	if( pRoute==NULL ) return;
	if(!pRoute->Enable) return;
	ifGetName(pRoute->DstIfIndex, ifname, sizeof(ifname));
	sprintf(metric,"%d",pRoute->FWMetric);

	if(pRoute->DstIfIndex== DUMMY_IFINDEX)
	{
		if (del>0) {
			va_cmd("/bin/route", 8, 1,
					"-A", "inet6", "del", pRoute->Dstination, "gw",  pRoute->NextHop, "metric", metric);
		}
		else{
			ifGetName(pRoute->DstIfIndex, ifname, sizeof(ifname));
			//route -A inet6 add  2003::/3 gw 2003::1 metric 10 dev nas0_0
			va_cmd("/bin/route", 8, 1,
				"-A", "inet6", "add", pRoute->Dstination, "gw",  pRoute->NextHop, "metric", metric);
		}
	}
	else
	{
		if (del>0) {
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			if(pRoute->nextHopEnable==1)
#endif
			{
				va_cmd("/bin/route", 10, 1,
						"-A", "inet6", "del", pRoute->Dstination, "gw",  pRoute->NextHop, "metric", metric,"dev", ifname);
			}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			else
			{
				va_cmd("/bin/route", 8, 1,
						"-A", "inet6", "del", pRoute->Dstination, "metric", metric,"dev", ifname);
			}
#endif
		}
		else{
			ifGetName(pRoute->DstIfIndex, ifname, sizeof(ifname));
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			if(pRoute->nextHopEnable==1)
#endif
			{
				va_cmd("/bin/route", 10, 1,
					"-A", "inet6", "add", pRoute->Dstination, "gw",  pRoute->NextHop, "metric", metric,"dev", ifname);
			}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			else{
				va_cmd("/bin/route", 8, 1,
					"-A", "inet6", "add", pRoute->Dstination, "metric", metric,"dev", ifname);
			}
#endif
		}
	}

#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
	if(del>0)
	{
		RG_del_static_route_v6(pRoute, entryID);
	}
	else
	{
		RG_add_static_route_v6(pRoute, entryID);
	}
#endif

}
#endif

void route_ppp_ifup(unsigned long pppGW, char *ifname)
{
	unsigned int entryNum, i;
	char ifname0[IFNAMSIZ];//, *ifname;
	MIB_CE_IP_ROUTE_T Entry;
	struct rtentry rt;
#ifdef CONFIG_USER_CWMP_TR069
	int cwmp_msgid;
	struct cwmp_message cwmpmsg;
#endif

	entryNum = mib_chain_total(MIB_IP_ROUTE_TBL);

	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
		{
			continue;
		}
		if( !Entry.Enable ) continue;

		memset(&rt, 0, sizeof(rt));

		rt.rt_dev = ifGetName(Entry.ifIndex, ifname0, sizeof(ifname0));

		if (rt.rt_dev && !strncmp(rt.rt_dev, "ppp", 3)) {
			updateRtEntry(&Entry, &rt);
			rt.rt_metric = Entry.FWMetric + 1;
			route_modify(&rt, ROUTE_ADD);
		}
		else if (Entry.ifIndex == DUMMY_IFINDEX) {	// Interface "any"
			struct in_addr *addr;
			addr = (struct in_addr *)&Entry.nextHop;
			if (addr->s_addr == pppGW) {
				updateRtEntry(&Entry, &rt);
				rt.rt_metric = Entry.FWMetric + 1;
				route_modify(&rt, ROUTE_ADD);
			}
		}
	}

#ifdef CONFIG_USER_CWMP_TR069
	SetTR069WANInterfacePPP();
#endif
#ifdef CONFIG_USER_CWMP_TR069
#ifdef CONFIG_E8B
	int numOfIpv6 = 0;
	struct ipv6_ifaddr ipv6_addr;
	numOfIpv6 = getifip6(ifname, IPV6_ADDR_UNICAST, &ipv6_addr, 1);
	//fprintf(stderr, "ifname = %s, numOfIpv6 = %d \n", __FILE__, __FUNCTION__, __LINE__, ifname, numOfIpv6);
	if (numOfIpv6 == 0) // IPv6 not up
	{
		unsigned char InformType = 0;
		mib_get(PROVINCE_CWMP_INFORM_TYPE, &InformType);

		if (InformType == CWMP_INFORM_TYPE_GUD)
		{
			unsigned int vUint = 0;
			if (mib_get(CWMP_INFORM_USER_EVENTCODE, &vUint)) {
				if (!(vUint & EC_X_CT_COM_BIND_1)) {
					vUint = vUint | EC_X_CT_COM_BIND_1;
					mib_set(CWMP_INFORM_USER_EVENTCODE, &vUint);
				}
			}
		}
	}
#endif

	if((cwmp_msgid = msgget((key_t)1234, 0)) > 0 )
	{
		cwmpmsg.msg_type = MSG_ACTIVE_NOTIFY;
		msgsnd(cwmp_msgid, (void *)&cwmpmsg, MSG_SIZE, 0);
	}
#endif
}

void ppp_if6up(char *ifname)
{
#ifdef CONFIG_E8B
	struct in_addr inAddr;
	if (getInAddr(ifname, IP_ADDR, (void *)&inAddr) == 0) // IPv4 not up
	{
		int numOfIpv6 = 0;
		struct ipv6_ifaddr ipv6_addr;
		numOfIpv6 = getifip6(ifname, IPV6_ADDR_UNICAST, &ipv6_addr, 1);
		//fprintf(stderr, "ifname = %s, numOfIpv6 = %d \n", __FILE__, __FUNCTION__, __LINE__, ifname, numOfIpv6);
		if (numOfIpv6 == 1)
		{
			unsigned char InformType = 0;
			mib_get(PROVINCE_CWMP_INFORM_TYPE, &InformType);

			if (InformType == CWMP_INFORM_TYPE_GUD)
			{
				unsigned int vUint = 0;
				if (mib_get(CWMP_INFORM_USER_EVENTCODE, &vUint)) {
					if (!(vUint & EC_X_CT_COM_BIND_1)) {
						vUint = vUint | EC_X_CT_COM_BIND_1;
						mib_set(CWMP_INFORM_USER_EVENTCODE, &vUint);
					}
				}
			}
		}
	}
#endif
	return;
}

/*
* Convert ifIndex to system interface name, e.g. eth0,vc0...
*/
char *ifGetName(int ifindex, char *buffer, unsigned int len)
{
	MEDIA_TYPE_T mType;

	if ( ifindex == DUMMY_IFINDEX )
		return 0;
	if (PPP_INDEX(ifindex) == DUMMY_PPP_INDEX)
	{
		mType = MEDIA_INDEX(ifindex);
		if (mType == MEDIA_ETH)
#ifdef CONFIG_RTL_MULTI_ETH_WAN
			snprintf( buffer, len, "%s%d", ALIASNAME_MWNAS, ETH_INDEX(ifindex));
#else
			snprintf( buffer, len,  "%s%u", ALIASNAME_NAS, ETH_INDEX(ifindex) );
#endif
		else if (mType == MEDIA_IPIP)    // Mason Yu. Add VPN ifIndex
			snprintf( buffer, len, "ipip%u", IPIP_INDEX(ifindex));
		else
			return 0;

	}else{
		snprintf( buffer, len,  "ppp%u", PPP_INDEX(ifindex) );

	}
	return buffer;
}


int isAnyPPPoEWan()
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
  			printf("Get chain record error!\n");
			return -1;
		}

		if (Entry.enable == 0)
			continue;

		if(Entry.cmode == CHANNEL_MODE_PPPOE)
			return 1;
	}
	return 0;
}

int getNameByIP(char *ip, char *buffer, unsigned int len)
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	char ifname[IFNAMSIZ];
	struct in_addr inAddr;
	char *itfIP;

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
  			printf("getNameByIP: Get chain record error!\n");
			return 0;
		}

		if (Entry.enable == 0)
			continue;

		ifGetName(Entry.ifIndex,ifname,sizeof(ifname));
		if (getInAddr(ifname, IP_ADDR, (void *)&inAddr) == 1) {
			itfIP = inet_ntoa(inAddr);
			if(!strcmp(itfIP, ip)){
				strncpy(buffer, ifname, len);
				buffer[len-1]='\0';
				//printf("getNameByIP: The %s IPv4 address is %s. Found\n", ifname, itfIP);
				break;
			}
		}
	}

	if(i>= entryNum){
		printf("getNameByIP: not find this interface!\n");
		return 0;
	}

	return 1;
}

int getIfIndexByName(char *pIfname)
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	char ifname[IFNAMSIZ];
#ifdef _PRMT_X_CT_COM_IPoEDiagnostics_
		int major,minor,simu;
		if(sscanf(pIfname,"nas%u_%u_%u",&major,&minor,&simu)==3){
			char major_ifname[32+1];
			snprintf(major_ifname,sizeof(major_ifname)-1,"nas%u_%u",major,minor);
			entryNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
			for (i=0; i<entryNum; i++) {
				if (!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&Entry))
				{
					printf("Get chain record error!\n");
					return -1;
				}
	
				if (Entry.enable == 0)
					continue;
	
				ifGetName(Entry.ifIndex,ifname,sizeof(ifname));
	
				if(!strcmp(ifname,major_ifname)){
					break;
				}
			}
	
			if(i>= entryNum){
				//printf("not find this interface!\n");
				return -1;
			}
	
			return(Entry.ifIndex);
		}
#endif

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
  			printf("Get chain record error!\n");
			return -1;
		}

		if (Entry.enable == 0)
			continue;

		ifGetName(Entry.ifIndex,ifname,sizeof(ifname));

		if(!strcmp(ifname,pIfname)){
			break;
		}
	}

	if(i>= entryNum){
		//printf("not find this interface!\n");
		return DUMMY_IFINDEX;
	}

	return(Entry.ifIndex);
}

/*ericchung add, get applicationtype by interface name */
int getapplicationtypeByName(char *pIfname)
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	char ifname[IFNAMSIZ];

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
  			printf("Get chain record error!\n");
			return -1;
		}

		if (Entry.enable == 0)
			continue;

		ifGetName(Entry.ifIndex,ifname,sizeof(ifname));

		if(!strcmp(ifname,pIfname)){
			break;
		}
	}

	if(i> entryNum){
		printf("not find this interface!\n");
		return -1;
	}

	return(Entry.applicationtype);
}

// Mason Yu. combine_1p_4p_PortMapping
#if defined(ITF_GROUP_1P) && defined(ITF_GROUP)
int setVlan(struct ifreq *ifr)
{
	int ret=0;

#ifdef EMBED
	if (do_ioctl(SIOCS8305VLAN, ifr) == 0)
		ret = 1;
#endif

	return ret;
}
#endif


#ifdef CONFIG_USER_CWMP_TR069
int set_TR069_Firewall(int enable)
{
	va_cmd(IPTABLES, 2, 1, "-F", (char *)IPTABLE_TR069);

	if (enable)
	{
#ifdef CONFIG_YUEME
		unsigned int conreq_port = 0;
		char strPort[8] = {0}, ifname[IFNAMSIZ] = {0};
		mib_get(CWMP_CONREQ_PORT, (void *)&conreq_port);
		if (conreq_port == 0) 
			conreq_port = 7547;

		sprintf(strPort, "%u", conreq_port);

		int i = 0, total = mib_chain_total(MIB_ATM_VC_TBL);
		MIB_CE_ATM_VC_T entry;
	
		for (i = 0; i < total; i++)
		{
			if (mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
				continue;
	
			if (entry.applicationtype & X_CT_SRV_TR069)
			{
				ifGetName(entry.ifIndex, ifname, IFNAMSIZ);
				break;
			}
		}

		// LAN side
		// iptables -A tr069 -i br0 -p tcp --dport 7547 -j REJECT --reject-with tcp-reset
		va_cmd(IPTABLES, 12, 1, "-A", IPTABLE_TR069, (char *)ARG_I, (char *)LANIF, "-p", "tcp", (char *)FW_DPORT, strPort, "-j", "REJECT", "--reject-with", "tcp-reset");

		// WAN side
		if (strlen(ifname) > 0)
		{
			// iptables -A tr069 ! -i nas0_0 -p tcp --dport 7547 -j REJECT --reject-with tcp-reset
			va_cmd(IPTABLES, 13, 1, "-A", IPTABLE_TR069, "!", (char *)ARG_I, ifname, "-p", "tcp", (char *)FW_DPORT, strPort, "-j", "REJECT", "--reject-with", "tcp-reset");
		}
#endif
	}
	return 0;
}
#endif

#ifdef _PRMT_X_CT_COM_WANEXT_
void set_IPForward_by_WAN(int wan_idx)
{
	int ipver = 0, flags = 0, flags_found = 0, isPPP = 0;
	char *pToken = NULL, *pSave = NULL, *pTmp = NULL;
	char ifname[IFNAMSIZ]= {0}, gw_v4[INET_ADDRSTRLEN] = {0}, tmpList[512] = {0}, tmpIP_s[64] = {0}, tmpIP_e[64] = {0};
	unsigned char ip_s[sizeof(struct in6_addr)] = {0}, ip_e[sizeof(struct in6_addr)] = {0};
	MIB_CE_ATM_VC_T wan_entry;
	mib_chain_get(MIB_ATM_VC_TBL, wan_idx, &wan_entry);
#ifdef CONFIG_IPV6
	char gw_v6[INET6_ADDRSTRLEN] = {0};
#endif

	if (wan_entry.IPForwardList[0] != '\0') {
		ifGetName(wan_entry.ifIndex, ifname, sizeof(ifname));
		flags_found = getInFlags(ifname, &flags);
		switch (wan_entry.cmode) {
			case CHANNEL_MODE_BRIDGE:
				isPPP = 0;
				break;
			case CHANNEL_MODE_IPOE:
				isPPP = 0;
				break;
			case CHANNEL_MODE_PPPOE:
				isPPP = 1;
				break;
			case CHANNEL_MODE_PPPOA:
				isPPP = 1;
				break;
			default:
				isPPP = 0;
				break;
		}
		if (flags_found) {
			if (isPPP) {
				struct in_addr inAddr;
				if (getInAddr(ifname, DST_IP_ADDR, &inAddr) == 1)
					strcpy(gw_v4, inet_ntoa(inAddr));
			}
			else {
				if(wan_entry.ipDhcp == (char)DHCP_CLIENT) {
					FILE *fp = NULL;
					char fname[128] = {0};
					sprintf(fname, "%s.%s", MER_GWINFO, ifname);
					if (fp = fopen(fname, "r")) {
						fscanf(fp, "%s", gw_v4);
						fclose(fp);
					}
				}
				else {
					unsigned char zero[IP_ADDR_LEN] = {0};
					if (memcmp(wan_entry.remoteIpAddr, zero, IP_ADDR_LEN))
						strcpy(gw_v4, inet_ntoa(*((struct in_addr *)wan_entry.remoteIpAddr)));
				}
			}
#ifdef CONFIG_IPV6
			if ((wan_entry.cmode != CHANNEL_MODE_BRIDGE) && (wan_entry.IpProtocol & IPVER_IPV6)) {
				unsigned char zero[IP6_ADDR_LEN] = {0};
				if (memcmp(wan_entry.RemoteIpv6Addr, zero, IP6_ADDR_LEN))
					inet_ntop(AF_INET6, &wan_entry.RemoteIpv6Addr, gw_v6, INET6_ADDRSTRLEN);
			}
#endif
		}

		sprintf(tmpList, "%s", wan_entry.IPForwardList);
		pToken = strtok_r(tmpList, ",", &pSave);
		while (pToken) {
			tmpIP_s[0] = '\0';
			tmpIP_e[0] = '\0';
			pTmp = strchr(pToken, '-');
			if (pTmp != NULL) {
				*pTmp = 0;
				pTmp++;
				sprintf(tmpIP_e, "%s", pTmp);
			}
			sprintf(tmpIP_s, "%s", pToken);
#if defined(CONFIG_WIFI_SIMPLE_CONFIG)
			if ((wan_entry.IpProtocol & IPVER_IPV4) && (inet_pton(AF_INET, tmpIP_s, ip_s) == 1) && (tmpIP_e[0] == '\0' || inet_pton(AF_INET, tmpIP_e, ip_e) == 1)) {
				ipver = IPVER_IPV4;

				printf("[%s@%d] rg_wan_idx = %d, ipver = %d\n", __FUNCTION__, __LINE__, wan_entry.rg_wan_idx, ipver);
				printf("[%s@%d] IP [%s]-[%s], Gateway [%s]\n", __FUNCTION__, __LINE__,tmpIP_s, (tmpIP_e[0] == '\0')?tmpIP_s:tmpIP_e, gw_v4);
				RG_add_static_route_by_acl(wan_entry.rg_wan_idx, ipver, tmpIP_s, (tmpIP_e[0] == '\0')?tmpIP_s:tmpIP_e, gw_v4);
			}
#ifdef CONFIG_IPV6
			else if ((wan_entry.IpProtocol & IPVER_IPV6) && (inet_pton(AF_INET6, tmpIP_s, ip_s) == 1) && (tmpIP_e[0] == '\0' || inet_pton(AF_INET6, tmpIP_e, ip_e) == 1)) {
				ipver = IPVER_IPV6;

				printf("[%s@%d] rg_wan_idx = %d, ipver = %d\n", __FUNCTION__, __LINE__, wan_entry.rg_wan_idx, ipver);
				printf("[%s@%d] IP [%s]-[%s], Gateway [%s]\n", __FUNCTION__, __LINE__,tmpIP_s, (tmpIP_e[0] == '\0')?tmpIP_s:tmpIP_e, gw_v6);
				RG_add_static_route_by_acl(wan_entry.rg_wan_idx, ipver, tmpIP_s, (tmpIP_e[0] == '\0')?tmpIP_s:tmpIP_e, gw_v6);
			}
#endif
#endif
			pToken = strtok_r(NULL, ",", &pSave);
		}
	}
}

static int startAddressMap(MIB_CE_ATM_VC_Tp pEntry);

void handle_IPForwardMode(int wan_idx)
{
	unsigned char enable = 0;
	int i = 0, total_entry = 0;
	MIB_CE_ATM_VC_T wan_entry;
	mib_get(CWMP_CT_IP_FORWARD_MODE_ENABLED, (void *)&enable);
	total_entry = mib_chain_total(MIB_ATM_VC_TBL);

	if (enable) {
		int isRemove = 0;
		for (i = 0 ; i < total_entry ; i++) {
			if(mib_chain_get(MIB_ATM_VC_TBL, i, &wan_entry) == 0)
				continue;

			int isModify = 0;
			if ((wan_entry.applicationtype & X_CT_SRV_VOICE) && wan_entry.napt == 0) {
				wan_entry.napt = 1;

			char wanif[IFNAMSIZ] = {0};
			ifGetName(wan_entry.ifIndex, wanif, sizeof(wanif));
			if (((CHANNEL_MODE_T)wan_entry.cmode == CHANNEL_MODE_IPOE)  ||
				((CHANNEL_MODE_T)wan_entry.cmode == CHANNEL_MODE_RT1483) ||
				((CHANNEL_MODE_T)wan_entry.cmode == CHANNEL_MODE_RT1577) )
			{
#ifdef CONFIG_IPV6
				if (wan_entry.IpProtocol & IPVER_IPV4) {
#endif
					if ((DHCP_T)wan_entry.ipDhcp == DHCP_DISABLED)
					{
						if (wan_entry.napt == 1)
						{
							// Setup one NAT Rule for the specfic interface
							startAddressMap(&wan_entry);
						}
					}
					else
					{
						if (wan_entry.napt == 1)
						{	// Enable NAPT
							va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_ADD, "POSTROUTING", ARG_O, wanif, "-j", "MASQUERADE");
						}
					}
#ifdef CONFIG_IPV6
				}
#endif
			}
			else if (((CHANNEL_MODE_T)wan_entry.cmode == CHANNEL_MODE_PPPOE) ||
						((CHANNEL_MODE_T)wan_entry.cmode == CHANNEL_MODE_PPPOA))
			{
#ifdef CONFIG_IPV6
				if (wan_entry.IpProtocol & IPVER_IPV4) {
#endif
					if (wan_entry.napt == 1)
					{	// Enable NAPT
						va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-o", wanif, "-j", "MASQUERADE");
					}
#ifdef CONFIG_IPV6
				}
#endif
			}
				isModify = 1;
			}
#ifdef NEW_PORTMAPPING
			if (wan_entry.itfGroup) { // Remove port-based mapping
				wan_entry.itfGroup = 0;
				isRemove = 1;
				isModify = 1;
			}
#endif
			if (isModify)
				mib_chain_update(MIB_ATM_VC_TBL, (void *)&wan_entry, i);
		}

#ifdef NEW_PORTMAPPING
		if (isRemove) {
			setupnewEth2pvc();
		}
#endif
	}

	if (wan_idx == (-1)) { // All WAN
		for (i = 0 ; i < total_entry ; i++) {
			if(mib_chain_get(MIB_ATM_VC_TBL, i, &wan_entry) == 0)
				continue;
#if defined(CONFIG_WIFI_SIMPLE_CONFIG)
			if (wan_entry.rg_wan_idx > 0) {
				RG_del_static_route_by_acl(wan_entry.rg_wan_idx);
			}
#endif
			if (enable) {
				set_IPForward_by_WAN(i);
			}
		}
	}
	else {
		mib_chain_get(MIB_ATM_VC_TBL, wan_idx, &wan_entry);
#if defined(CONFIG_WIFI_SIMPLE_CONFIG)
		if (wan_entry.rg_wan_idx > 0) {
			RG_del_static_route_by_acl(wan_entry.rg_wan_idx);
		}
#endif
		if (enable) {
			set_IPForward_by_WAN(wan_idx);
		}
	}
}
#endif

#ifdef _PRMT_X_CU_EXTEND_
void handle_WANIPForwardMode(int wan_idx)
{
	MIB_CE_ATM_VC_T wan_entry;
	
	if(mib_chain_get(MIB_ATM_VC_TBL, wan_idx, &wan_entry) == 0)
		return;
	
	if(wan_entry.IPForwardModeEnabled)
	{
#ifdef NEW_PORTMAPPING	
		int isRemove = 0;
		if (wan_entry.itfGroup) 
		{ // Remove port-based mapping
			wan_entry.itfGroup = 0;
			isRemove = 1;
			mib_chain_update(MIB_ATM_VC_TBL, (void *)&wan_entry, wan_idx);
		}

		if (isRemove) {
			setupnewEth2pvc();
		}
#endif	

		if (wan_entry.rg_wan_idx > 0) {
			RG_del_static_route_by_acl(wan_entry.rg_wan_idx);
		}

		set_IPForward_by_WAN(wan_idx);
		
	}

}
#endif

int get_wan_gateway(unsigned int ifIndex, struct in_addr *gateway)
{
        int i=0;
        unsigned int totalEntry;
        char str_ipaddr[20] = {0};
        char str_netmask[20] = {0};
        char str_gateway[20] = {0};
        char ifname[IFNAMSIZ];

        MIB_CE_ATM_VC_T Entry;

        totalEntry = mib_chain_total(MIB_ATM_VC_TBL);

        for (i=0; i<totalEntry; i++) { // check the gw of static route exist on other wan ?
                if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
                        return -1;

                if (Entry.ifIndex == ifIndex) {
                        ifGetName(Entry.ifIndex,ifname,sizeof(ifname));
                        getIPaddrInfo(&Entry, str_ipaddr, str_netmask, str_gateway);
                        if(strcmp(str_gateway, "")==0){
                                return -1;
                        }
                        else{
                                inet_aton(str_gateway, gateway);
                                //printf("get_wan_gateway gateway %s\n", str_gateway);
                                return 0;
                        }
                }
        }

        return -1;
}

int get_wan6_gateway(unsigned int ifIndex, struct in_addr *gateway)
{
        unsigned int entryNum, i;
        MIB_CE_ATM_VC_T Entry;

        entryNum = mib_chain_total(MIB_ATM_VC_TBL);
        for (i=0; i<entryNum; i++) {
                if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
                {
                        printf("Get chain record error!\n");
                        return -1;
                }

                if (Entry.enable == 0)
                        continue;

                if(Entry.ifIndex == ifIndex){
                        memcpy(gateway, Entry.RemoteIpv6Addr, IP6_ADDR_LEN);
                        return 0;
                }
        }

        return -1;
}


#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
void handleIGMPandMLD(int isIGMPenable, int isMLDenable)
{
	/*
	 * romDriver version after from 1984.
	 *
	 * ??romeDriver?????gmpSnooping???
	 *
	 * ???????proc/rg/mcast_protocol?
	 * echo 1 > /proc/rg/mcast_protocol => IGMP_only
	 * echo 2 > /proc/rg/mcast_protocol => MLD_only
	 */

	printf("%s: isIGMPenable:%d, isMLDenable:%d\n",__func__,isIGMPenable,isMLDenable);

#if defined(CONFIG_RTK_RG_INIT)
	unsigned char mode;
	mib_get(MIB_MPMODE, (void *)&mode);
	/*
	* if IGMP/MLD snooping state change, then we restart IGMP/MLD proxy
	* for reset rg_flow_idx that igmpproxy/ecmh have recorded
	* & flush the MC HW flow we for according IP version
	*/
#if defined(CONFIG_IGMPPROXY_MULTIWAN)
	if(!!(mode&MP_IGMP_MASK) != isIGMPenable) {
		AUG_PRT("Restart IGMP proxy only\n");
		setting_Igmproxy();
	}
#endif
#if defined(CONFIG_IPV6) && defined(CONFIG_USER_ECMH)
	if(!!(mode&MP_MLD_MASK) != isMLDenable) {
		AUG_PRT("Restart MLD proxy only\n");
		startMLDproxy();
	}
#endif
	/*
	* if both IGMP snooping & proxy disabled
	* we change mcast_protocol to MLD only
	* and do not trap IGMP to PS anymore
	* vice versa
	*/
	checkIGMPMLDProxySnooping(isIGMPenable, isMLDenable, isIgmproxyEnabled(), isMLDProxyEnabled());
#endif
	return;	
}

int isIGMPSnoopingEnabled(void)
{
	unsigned char mode;
#ifdef CONFIG_CMCC	
	unsigned char isCMCCTestMode = 0;
	mib_get(MIB_IGMP_MLD_SNOOPING_CMCC_TEST,  (void *)&isCMCCTestMode);
	if(isCMCCTestMode) //Always enable IGMP/MLD snooping for customer's request
	{
		return 1;
	}
#endif
	mib_get(MIB_MPMODE, (void *)&mode);
	return ((mode&MP_IGMP_MASK)==MP_IGMP_MASK)?1:0;
}

int isMLDSnoopingEnabled(void)
{
	unsigned char mode;
#ifdef CONFIG_CMCC	
	unsigned char isCMCCTestMode = 0;
	mib_get(MIB_IGMP_MLD_SNOOPING_CMCC_TEST,  (void *)&isCMCCTestMode);
	if(isCMCCTestMode) //Always enable IGMP/MLD snooping for customer's request
	{
		return 1;
	}
#endif
	mib_get(MIB_MPMODE, (void *)&mode);
	return ((mode&MP_MLD_MASK)==MP_MLD_MASK)?1:0;
}

unsigned int hextol(unsigned char *hex)
{
	return ( (hex[0] << 24) | (hex[1] << 16) | (hex[2] << 8) | (hex[3]));
}

#if defined(CONFIG_CMCC) || defined(CONFIG_CU) 
/*	Add policy route for CMCC special test environment, 
	the diffnernet wan have the same IP network address and gateway IP/MAC
	such like wan1 is 173.31.12.77/24 gateway 173.31.12.254
			wan2 is 173.31.12.86/24 gateway 173.31.12.254
	need add policy route for the case.
	return 0 , don't need add policy route 
	return -1 , add failed
	return aclIdx , succeed
*/
int check_RG_policy_route_on_static(int entryID)
{
	int i=0, hit=0, rg_wan_idx=0, acl_idx=0;
	unsigned int totalEntry;
	char str_ipaddr[20] = {0};
	char str_netmask[20] = {0};
	char str_gateway[20] = {0};
	char str_gateway_2[20] = {0};
	char ip_start[20] = {0};
	char ip_end[20] = {0};
	char ifname[IFNAMSIZ];

	uint32_t _in_netmask;
	uint32_t _ipaddr;
	struct in_addr inAddr;
	struct in_addr start_net_addr;
	struct in_addr end_net_addr;
	struct in_addr gwAddr;
	MIB_CE_ATM_VC_T Entry;
	MIB_CE_IP_ROUTE_T entry;

	if (!mib_chain_get(MIB_IP_ROUTE_TBL, entryID, (void *)&entry))
		return -1;
	strcpy(str_gateway, inet_ntoa(*((struct in_addr *)entry.nextHop)));
	totalEntry = mib_chain_total(MIB_ATM_VC_TBL);

	if (entry.ifIndex == DUMMY_IFINDEX)
	{
		return 0;
	}

	for (i=0; i<totalEntry; i++) { // check the gw of static route exist on other wan ?
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;
		if (Entry.ifIndex == entry.ifIndex) {
			rg_wan_idx = Entry.rg_wan_idx;
			continue;
		}
		
		ifGetName(Entry.ifIndex,ifname,sizeof(ifname));
		getIPaddrInfo(&Entry, str_ipaddr, str_netmask, str_gateway_2);
		if(strcmp(str_gateway, str_gateway_2)==0)
			hit++;
	}


	/* 	3 case on CMCC static route sceniaro
		1. Gateway IP address has been set, Interface has been set ->  check the policy route need add or not
		2. Gateway IP address has been set, Interface didn't been set -> didn't need add policy route
		3. Gateway IP address didn't been set, Interface has been set -> must set policy route */
	if((hit>0) || ((Entry.ifIndex != DUMMY_IFINDEX) && (strcmp(str_gateway, "0.0.0.0")==0))) { //match 2 or more WAN 
		_in_netmask = (*((struct in_addr *)entry.netMask)).s_addr;
		_ipaddr = (*((struct in_addr *)entry.destID)).s_addr;
		start_net_addr.s_addr = _ipaddr & _in_netmask;
		end_net_addr.s_addr = _ipaddr | ~_in_netmask;
		strcpy(ip_start, (const char *)inet_ntoa(start_net_addr));
		strcpy(ip_end, (const char *)inet_ntoa(end_net_addr));
		if (entry.rg_acl_idx <= 0 ) { //PPPoE will read twice netlink event.
			if ( (acl_idx = RG_add_policy_route_by_acl(rg_wan_idx, 1, ip_start, ip_end, str_gateway)) > 0 )
			{
				entry.rg_acl_idx = acl_idx;
				mib_chain_update(MIB_IP_ROUTE_TBL, &entry, entryID);
			}
			else {
				return -1;
			}
		}
	}

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)

	if(entry.nextHopEnable == 0 ){
		if(get_wan_gateway(entry.ifIndex, &gwAddr)!=0){
			return -1;
		}
	}
#endif
	return acl_idx;
}


int Flush_RG_policy_route_on_static(void)
{
 	unsigned int totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL); /* get chain record size */
	MIB_CE_IP_ROUTE_T Entry;
	int i;

	for (i=0; i<totalEntry; i++) {
		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
			return 0;
		if (Entry.rg_acl_idx > 0) {
			RG_del_policy_route_by_acl(Entry.rg_acl_idx);
			Entry.rg_acl_idx = -1;
			mib_chain_update(MIB_IP_ROUTE_TBL,(void *)&Entry,i);
		}
	}
	return 1;
}

int Set_RG_policy_route_on_static(void)
{
 	unsigned int totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL); /* get chain record size */
	MIB_CE_IP_ROUTE_T Entry;
	int i;

	for (i=0; i<totalEntry; i++) {
		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
			return 0;
		if (check_RG_policy_route_on_static(i)<0){
			AUG_PRT("%s-%d add policy route for special case failed!\n",__func__,__LINE__);
		}
	}
	return 1;
}


#endif

void rg_add_route(MIB_CE_IP_ROUTE_T *entry, int entryID)
{
	int i, n;
	FILE *fp;
	int flags, ret=0;
	uint32_t mask, gateway;
	uint32_t dest, tmask, nH;
	struct IFADDRLIST *al;
	char buf[256], tdevice[256], device[256];
	struct in_addr gw_addr;
	char mac_str[20]={0};
	char *str;
	fp = fopen("/proc/net/route", "r");
	n = 0;
	mask = 0;
	device[0] = '\0';
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	if(entry->nextHopEnable==1)
#endif
	{
		//nH = hextol(entry->nextHop);
		nH = *((unsigned int*)(entry->nextHop));
	}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	else{
		ret = get_wan_gateway(entry->ifIndex, (struct in_addr *)&nH);
	}
#else
	if (entry->nextHop[0] == 0)
	{
		get_wan_gateway(entry->ifIndex, (struct in_addr *)&nH);
	}
#endif
		
//printf("%s-%d nH=%x\n",__func__,__LINE__,nH);
	while (fgets(buf, sizeof(buf), fp) != NULL) {
		++n;
		if (n == 1 && strncmp(buf, "Iface", 5) == 0)
			continue;
		i = sscanf(buf, "%255s %lx %lx %x %*s %*s %*s %x",
					tdevice, &dest, &gateway, &flags, &tmask);
//printf("tdevice:%s, dest=%x, gateway=%x, tmask=%x\n",tdevice,dest,gateway,tmask);
		if ((nH & tmask) == dest
		 && (tmask > mask || mask == 0) && (flags & RTF_UP) && (dest != 0x7f000000) && (dest !=0)
		) {
			mask = tmask;
			strcpy(device, tdevice);
//printf("[%s-%d] n:%d tdevice:%s, dest=%x, gateway=%x, tmask=%x\n",__func__,__LINE__,n,tdevice,dest,gateway,tmask);
			break;
		}
	}
	fclose(fp);
	if (device[0] == '\0'){
		printf("can't find interface ");
		return;
	}
	else{
#if defined(CONFIG_CMCC) || defined(CONFIG_CU) //add policy route for CMCC test environment

		if ((ret = check_RG_policy_route_on_static(entryID))<0){
			AUG_PRT("%s-%d add policy route for special case failed!\n",__func__,__LINE__);
		}
		if (ret == 0) //didn't need add policy route, add normal static route
#endif
		{
			ret = RG_add_static_route(entry, entryID);
			if(ret !=SUCCESS){
				printf("RG_add_static_route add fail!!!\n");
			}			
		}
	}
	return;
}
/*use in reboot time to add static route*/
int Flush_RG_static_route(void)
{
 	unsigned int totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL); /* get chain record size */
	MIB_CE_IP_ROUTE_T Entry;
	int i;
	//AUG_PRT("%s-%d totalEntry=%d\n",__func__,__LINE__,totalEntry);
		for (i=0; i<totalEntry; i++) {
			if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
				continue;
	//AUG_PRT("%s-%d Entry.ifIndex=%x\n",__func__,__LINE__,Entry.ifIndex);
			RG_del_static_route(&Entry, i);
			mib_chain_update(MIB_IP_ROUTE_TBL,(void *)&Entry,i);
		}
	return 0;
}

int Flush_RG_static_route_per_WAN(unsigned int ifIndex)
{
 	unsigned int totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL); /* get chain record size */
	MIB_CE_IP_ROUTE_T Entry;
	int i;
	AUG_PRT("%s-%d totalEntry=%d\n",__func__,__LINE__,totalEntry);
		for (i=0; i<totalEntry; i++) {
			if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
				return 0;
	AUG_PRT("%s-%d WAN ifIndex=%d Entry.ifIndex=%x\n",__func__,__LINE__,ifIndex, Entry.ifIndex);
			if (ifIndex == Entry.ifIndex) {
				RG_del_static_route(&Entry, i);
				mib_chain_update(MIB_IP_ROUTE_TBL,(void *)&Entry,i);
			}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	if (Entry.ifIndex == DUMMY_IFINDEX) {
		RG_del_static_route(&Entry, i);
		mib_chain_update(MIB_IP_ROUTE_TBL,(void *)&Entry,i);
	}
#endif
		}
	return 0;
}

int check_RG_static_route(void)
{
 	unsigned int totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL); /* get chain record size */
	MIB_CE_IP_ROUTE_T Entry;
	int i;

	for (i=0; i<totalEntry; i++) {
		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
			continue;
		route_cfg_modify(&Entry,0, i);
	}

	return 1;
}

int check_RG_static_route_per_WAN(unsigned int ifIndex)
{
 	unsigned int totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL); /* get chain record size */
	MIB_CE_IP_ROUTE_T Entry;
	int i;

	for (i=0; i<totalEntry; i++) {
		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
			return 0;
		if (ifIndex == Entry.ifIndex)
			rg_add_route(&Entry, i);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		if (Entry.ifIndex == DUMMY_IFINDEX) {
			rg_add_route(&Entry, i);
		}
#endif		
	}

	return 1;
}

#endif

#if defined(CONFIG_RTL_IGMP_SNOOPING)
// enable/disable IGMP snooping
void __dev_setupIGMPSnoop(int flag)
{
	struct ifreq ifr;
	struct ifvlan ifvl;
	unsigned char mode;

#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
		mib_get(MIB_MPMODE, (void *)&mode);
		handleIGMPandMLD(flag, ((mode&MP_MLD_MASK)==MP_MLD_MASK)?1:0);
#else
	if(flag){
		system("/bin/echo 1 > /proc/br_igmpsnoop");
		system("/bin/echo 1 > /proc/br_igmpquery");
	}
	else{
		system("/bin/echo 0 > /proc/br_igmpsnoop");
		system("/bin/echo 0 > /proc/br_igmpquery");
	}
#endif
	printf("IGMP Snooping: %s\n", flag?"enabled":"disabled");

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
#if defined(CONFIG_MCAST_VLAN) && defined(CONFIG_RTK_L34_ENABLE)
	RTK_RG_ACL_Flush_mVlan();
	RTK_RG_ACL_Add_mVlan();
#endif
#endif
}
#endif

// Mason Yu. MLD snooping
//#ifdef CONFIG_IPV6
#if defined(CONFIG_RTL_MLD_SNOOPING)
// enable/disable MLD snooping
void __dev_setupMLDSnoop(int flag)
{
	unsigned char mode;

#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
	mib_get(MIB_MPMODE, (void *)&mode);
	handleIGMPandMLD(((mode&MP_IGMP_MASK)==MP_IGMP_MASK)?1:0, flag);
#else
	if(flag){
		system("/bin/echo 1 > /proc/br_mldsnoop");
		system("/bin/echo 1 > /proc/br_mldquery");
	}
	else{
		system("/bin/echo 0 > /proc/br_mldsnoop");
		system("/bin/echo 0 > /proc/br_mldquery");
	}
#endif
	printf("MLD Snooping: %s\n", flag?"enabled":"disabled");

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
#if defined(CONFIG_MCAST_VLAN) && defined(CONFIG_RTK_L34_ENABLE)
	RTK_RG_ACL_Flush_mVlan();
	RTK_RG_ACL_Add_mVlan();
	RTK_RG_add_acl_rule_for_v6_icmp();
#endif
#endif
}
#endif
#ifndef CONFIG_KERNEL_4_4_x
// ioctl for direct bridge mode, jiunming
void __dev_setupDirectBridge(int flag)
{
	struct ifreq ifr;
	int ret;

	strcpy(ifr.ifr_name, ELANIF);
	ifr.ifr_ifru.ifru_ivalue = flag;
#ifdef EMBED
	if( do_ioctl(SIOCDIRECTBR, &ifr)==0 ) {
		ret = 1;
		//printf("Set direct bridge mode %s!\n", flag?"enable":"disable" );
	}
	else {
		ret = 0;
		//printf("Set direct bridge mode error!\n");
	}
#endif

}
#endif
#ifdef CONFIG_KERNEL_4_4_x
#define RG_add_simu_wan(...) 
#define RG_Add_Simu_Trap_ACL(...)
#define RG_Del_Simu_Trap_ACL(...)
//#define addSimuEthWANdev(...)
//#define setup_simu_ethernet_config(...)
#endif


// enable/disable IPQoS
void __dev_setupIPQoS(int flag)
{
//ql 20081117 START for ip qos
#ifdef CONFIG_USER_IP_QOS
	if ( flag == 0 )
		va_cmd("/bin/ethctl", 2, 1, "setipqos", "0");
	else if (flag == 1)
		va_cmd("/bin/ethctl", 2, 1, "setipqos", "1");
#endif
}

#ifdef QOS_DIFFSERV
static char* proto2layer2[] = {
    [0]" ",
    [1]"6",
    [2]"17",
    [3]"1",
};

static char* strPolicing[] = {
    [0]" ",
    [1]"drop",
    [2]"continue",
};

void cleanupDiffservRule(int idx)
{
	unsigned int num, i;
	MIB_CE_IP_QOS_T qEntry;
	char wanif[IFNAMSIZ];

	mib_chain_get(MIB_IP_QOS_TBL, idx, (void *)&qEntry);
	ifGetName(qEntry.ifIndex, wanif, sizeof(wanif));

	// tc qdisc del dev vc0 root
	va_cmd(TC, 5, 1, "qdisc", (char *)ARG_DEL, "dev", wanif, "root");
}


static void diffserv_filter_rule(MIB_CE_IP_QOS_Tp qEntry, char *prio, char *classid)
{
	char *argv[60], wanif[IFNAMSIZ];
	char saddr[20], daddr[20], sport[6], dport[6], strdscp[6] = {0}, strUpLinkRate[10];
	char *psaddr, *pdaddr;
	int idx, i;

	ifGetName(qEntry->ifIndex, wanif, sizeof(wanif));

	// source ip, mask
	snprintf(saddr, 20, "%s", inet_ntoa(*((struct in_addr *)qEntry->sip)));
	if (strcmp(saddr, ARG_0x4) == 0)
		psaddr = 0;
	else {
		if (qEntry->smaskbit!=0)
			snprintf(saddr, 20, "%s/%d", saddr, qEntry->smaskbit);
		psaddr = saddr;
	}
	// destination ip, mask
	snprintf(daddr, 20, "%s", inet_ntoa(*((struct in_addr *)qEntry->dip)));
	if (strcmp(daddr, ARG_0x4) == 0)
		pdaddr = 0;
	else {
		if (qEntry->dmaskbit!=0)
			snprintf(daddr, 20, "%s/%d", daddr, qEntry->dmaskbit);
		pdaddr = daddr;
	}
	snprintf(sport, 6, "%d", qEntry->sPort);
	snprintf(dport, 6, "%d", qEntry->dPort);

	// Classifier setup for 1:0
	// tc filter add dev vc0 parent 1:0 protocol ip prio 1 u32
	//	match ip src 192.168.1.3/32 match ip dst 192.168.8.11/32
	//	match ip tos 0x38 0xff match ip protocol 6 0xff
	//	match ip sport 1090 0xff match ip dport 21 0xff
	//	police rate 500kbit burst 10k drop classid 1:1
	argv[1] = "filter";
	argv[2] = (char *)ARG_ADD;
	argv[3] = "dev";
	argv[4] = wanif;
	argv[5] = "parent";
	argv[6] = "1:0";
	argv[7] = "protocol";
	argv[8] = "ip";
	argv[9] = "prio";
	argv[10] = prio;
	argv[11] = "u32";
	idx = 12;

	// match filter
	// src ip
	if (psaddr != 0) {
		argv[idx++] = "match";
		argv[idx++] = "ip";
		argv[idx++] = "src";
		argv[idx++] = psaddr;
	}
	// dst ip
	if (pdaddr != 0) {
		argv[idx++] = "match";
		argv[idx++] = "ip";
		argv[idx++] = "dst";
		argv[idx++] = pdaddr;
	}
	//dscp match
#ifdef QOS_DSCP_MATCH
	if (0 != qEntry->qosDscp) {
		argv[idx++] = "match";
		argv[idx++] = "ip";
		argv[idx++] = "tos";
		snprintf(strdscp, 6, "0x%x", (qEntry->qosDscp-1)&0xFF);
		argv[idx++] = strdscp;
		argv[idx++] = "0xff";
	}
#endif
	// protocol
	if (qEntry->protoType != PROTO_NONE) {
		argv[idx++] = "match";
		argv[idx++] = "ip";
		argv[idx++] = "protocol";
		argv[idx++] = proto2layer2[qEntry->protoType];
		argv[idx++] = "0xff";
	}
	// src port
	if ((qEntry->protoType==PROTO_TCP ||
		qEntry->protoType==PROTO_UDP) &&
		qEntry->sPort != 0) {
		argv[idx++] = "match";
		argv[idx++] = "ip";
		argv[idx++] = "sport";
		argv[idx++] = sport;
		argv[idx++] = "0xff";
	}
	// dst port
	if ((qEntry->protoType==PROTO_TCP ||
		qEntry->protoType==PROTO_UDP) &&
		qEntry->dPort != 0) {
		argv[idx++] = "match";
		argv[idx++] = "ip";
		argv[idx++] = "dport";
		argv[idx++] = dport;
		argv[idx++] = "0xff";
	}

	// police
	if (0 != qEntry->limitSpeed) {
		argv[idx++] = "police";
		argv[idx++] = "rate";
		snprintf(strUpLinkRate, 10, "%dKbit", qEntry->limitSpeed);
		argv[idx++] = strUpLinkRate;
		argv[idx++] = "burst";
		argv[idx++] = "10k";
		argv[idx++] = strPolicing[qEntry->policing];
	}

	argv[idx++] = "classid";
	argv[idx++] = classid;
	argv[idx++] = NULL;

	printf("%s", TC);
	for (i=1; i<idx-1; i++)
		printf(" %s", argv[i]);
	printf("\n");
	do_cmd(TC, argv, 1);
}

static void diffserv_HTB_bw_div(MIB_CE_IP_QOS_Tp qEntry, char *classid)
{
	unsigned short ceil, rateBE;
	char wanif[IFNAMSIZ], strCeil[10], strRate[10], strRateBE[10];
	int htbrate = 0;

	ifGetName(qEntry->ifIndex, wanif, sizeof(wanif));

	//patch: actual bandwidth maybe a little greater than configured limit value, so I minish 7% of the configured limit value ahead.
	//ceil = qEntry->totalBandwidth / 100 * 93;
	ceil = qEntry->totalBandwidth;
	htbrate = (qEntry->htbRate>=qEntry->totalBandwidth)?qEntry->totalBandwidth-100:qEntry->htbRate;
	rateBE = ceil - htbrate;
	snprintf(strCeil, 10, "%dKbit", ceil);
	snprintf(strRate, 10, "%dKbit", htbrate);
	snprintf(strRateBE, 10, "%dKbit", rateBE);

	// tc qdisc add dev vc0 parent 1:0 handle 2:0 htb
	va_cmd(TC, 9, 1, "qdisc", (char *)ARG_ADD, "dev", wanif, "parent", "1:0", "handle", "2:0", "htb");
	// tc class add dev vc0 parent 2:0 classid 2:1 htb rate 1Mbit ceil 1Mbit
	va_cmd(TC, 13, 1, "class", (char *)ARG_ADD, "dev", wanif, "parent", "2:0", "classid", "2:1", "htb", "rate", strCeil, "ceil", strCeil);
	// tc class add dev vc0 parent 2:1 classid 2:2 htb rate 1Mbit ceil 1Mbit
	va_cmd(TC, 13, 1, "class", (char *)ARG_ADD, "dev", wanif, "parent", "2:1", "classid", "2:2", "htb", "rate", strRate, "ceil", strCeil);
	// tc class add dev vc0 parent 2:1 classid 2:3 htb rate 1Mbit ceil 1Mbit
	va_cmd(TC, 13, 1, "class", (char *)ARG_ADD, "dev", wanif, "parent", "2:1", "classid", classid, "htb", "rate", strRateBE, "ceil", strCeil);
}

static void calculate_RED(MIB_CE_IP_QOS_Tp qEntry, char *strLimit, char *strMin, char *strMax, char *strBurst)
{
	int max, min, limit, burst;

	max = (int)(qEntry->totalBandwidth / 8 * qEntry->latency / 1000);
	min = (int)(max / 3);
	limit = (int)(8 * max);
	burst = (int)(( 2 * min * 1000 + max * 1000 ) / ( 3* 1000 ));

	snprintf(strLimit, 10, "%dKB", limit);
	snprintf(strMin, 10, "%dKB", min);
	snprintf(strMax, 10, "%dKB", max);
	snprintf(strBurst, 6, "%d", burst);
}

static void diffserv_be_queue(MIB_CE_IP_QOS_Tp qEntry, char *classid)
{
	char wanif[IFNAMSIZ], strMax[10], strMin[10], strLimit[10], strBurst[6], strBw[10];

	ifGetName(qEntry->ifIndex, wanif, sizeof(wanif));
	snprintf(strBw, 10, "%dKbit", qEntry->totalBandwidth);
	calculate_RED(qEntry, strLimit, strMin, strMax, strBurst);

	// tc qdisc add dev vc0 parent 2:3 red limit 6KB min 1.5KB max 4.5KB burst 20 avpkt 1000 bandwidth 1Mbit probability 0.4
	printf("%s qdisc %s dev %s parent %s red limit %s min %s max %s burst %s avpkt 1000 bandwidth %s probability 0.4\n", TC
		, (char *)ARG_ADD, wanif, classid, strLimit, strMin, strMax, strBurst, strBw);
	va_cmd(TC, 21, 1, "qdisc", (char *)ARG_ADD, "dev", wanif, "parent", classid,
		"red", "limit", strLimit, "min", strMin, "max", strMax, "burst", strBurst,
		"avpkt", "1000", "bandwidth", strBw, "probability", "0.4");
}

static int setupEFTraffic(int efindex)
{
	MIB_CE_IP_QOS_T qEntry;
	char wanif[IFNAMSIZ], prio[2], classid[6], strdscp[6];
	int phb;

	mib_chain_get(MIB_IP_QOS_TBL, efindex, (void *)&qEntry);
	phb = qEntry.m_ipprio << 3 | qEntry.m_iptos << 1;
	ifGetName(qEntry.ifIndex, wanif, sizeof(wanif));

	// Create the egress root "dsmark" qdisc on wan interface
	// tc qdisc add dev vc0 root handle 1:0 dsmark indices 64 default_index 2
	va_cmd(TC, 12, 1, "qdisc", (char *)ARG_ADD, "dev", wanif,
		"root", "handle", "1:0", "dsmark", "indices", "64", "default_index", "2");

	snprintf(prio, 2, "1");
	snprintf(classid, 6, "1:1");

	// Classifier setup for 1:0
	diffserv_filter_rule(&qEntry, prio, classid);

	// Classes to specify DSCPs
	// tc class change dev vc0 parent 1:0 classid 1:1 dsmark mask 0x3 value 0xb8
	snprintf(strdscp, 6, "0x%x", (phb << 2)&0xFF);
	va_cmd(TC, 13, 1, "class", "change", "dev", wanif,
		"parent", "1:0", "classid", classid, "dsmark", "mask", "0x3", "value", strdscp);
	// BE
	va_cmd(TC, 13, 1, "class", "change", "dev", wanif, "parent", "1:0", "classid", "1:2", "dsmark", "mask", "0x3", "value", "0x0");

	// bandwidth division with HTB
	snprintf(classid, 6, "2:3");
	diffserv_HTB_bw_div(&qEntry, classid);

	// queue setup
	// tc qdisc add dev vc0 parent 2:2 pfifo limit 5
	va_cmd(TC, 9, 1, "qdisc", (char *)ARG_ADD, "dev", wanif, "parent", "2:2", "pfifo", "limit", "5");
	diffserv_be_queue(&qEntry, classid);

	// classifier setup for 2:1
	// tc filter add dev vc0 parent 2:0 protocol ip prio 1 handle 1 tcindex classid 2:2
	va_cmd(TC, 15, 1, "filter", (char *)ARG_ADD, "dev", wanif, "parent", "2:0", "protocol", "ip",
		"prio", "1", "handle", "1", "tcindex", "classid", "2:2");
	// tc filter add dev vc0 parent 2:0 protocol ip prio 2 handle 2 tcindex classid 2:3
	va_cmd(TC, 15, 1, "filter", (char *)ARG_ADD, "dev", wanif, "parent", "2:0", "protocol", "ip",
		"prio", "2", "handle", "2", "tcindex", "classid", classid);

	return 0;
}

static int setupAFTraffic(int *afindex, int aftotal, char *wanif)
{
	MIB_CE_IP_QOS_T qEntry;
	char prio[2], classid[6], strdscp[6];
	int i, phb;
	//int htbrate = 0;
	char strMax[10], strMin[10], strLimit[10], strBurst[6], strBw[10], strDP[2], strProbability[6];

	// Create the root "dsmark" qdisc on wan interface
	// tc qdisc add dev vc0 handle 1:0 root dsmark indices 64
	va_cmd(TC, 10, 1, "qdisc", (char *)ARG_ADD, "dev", wanif,
		"handle", "1:0", "root", "dsmark", "indices", "64");

	// dsmark classes to specify DSCPs
	// tc class change dev vc0 parent 1:0 classid 1:11 dsmark mask 0x3 value 0x28
	for (i = 0; i < aftotal; i ++) {
		mib_chain_get(MIB_IP_QOS_TBL, afindex[i], (void *)&qEntry);
		phb = qEntry.m_ipprio << 3 | qEntry.m_iptos << 1;
		snprintf(strdscp, 6, "0x%x", (phb << 2)&0xFF);
		snprintf(classid, 6, "1:%d%d", qEntry.m_ipprio, qEntry.m_iptos);
		va_cmd(TC, 13, 1, "class", "change", "dev", wanif,
			"parent", "1:0", "classid", classid, "dsmark", "mask", "0x3", "value", strdscp);
	}
	// BE
	va_cmd(TC, 13, 1, "class", "change", "dev", wanif, "parent", "1:0", "classid", "1:5", "dsmark", "mask", "0x3", "value", "0x0");

	// Classifier setup for 1:0
	for (i = 0; i < aftotal; i ++) {
		mib_chain_get(MIB_IP_QOS_TBL, afindex[i], (void *)&qEntry);
		snprintf(prio, 2, "%d", i + 1);
		snprintf(classid, 6, "1:%d%d", qEntry.m_ipprio, qEntry.m_iptos);
		//htbrate += qEntry.limitSpeed;
		diffserv_filter_rule(&qEntry, prio, classid);
	}
	// BE: tc filter add dev vc0 parent 1:0 protocol ip prio 5 u32 match ip protocol 0 0 flowid 1:5
	va_cmd(TC, 18, 1, "filter", (char *)ARG_ADD, "dev", wanif,
		"parent", "1:0", "protocol", "ip", "prio", "5", "u32", "match", "ip", "protocol", "0", "0", "flowid", "1:5");

	// bandwidth division with HTB
	snprintf(classid, 6, "2:6");
	//htbrate = (htbrate>qEntry.totalBandwidth)?qEntry.totalBandwidth-100:htbrate;
	diffserv_HTB_bw_div(&qEntry, classid);

	// queue setup
	// GRED setup for AF class
	// tc qdisc add dev vc0 parent 2:2 gred setup DPs 3 default 2 grio
	va_cmd(TC, 13, 1, "qdisc", (char *)ARG_ADD, "dev", wanif,
		"parent", "2:2", "gred", "setup", "DPs", "3", "default", "2", "grio");
	// tc qdisc change dev vc0 parent 2:2 gred limit 6KB min 1.5KB max 4.5KB burst 20 avpkt 1000 bandwidth 1Mbit DP 1 probability 0.02 prio 2
	snprintf(strBw, 10, "%dKbit", qEntry.totalBandwidth);
	for (i = 0; i < 3; i ++) {
		calculate_RED(&qEntry, strLimit, strMin, strMax, strBurst);
		snprintf(strDP, 2, "%d", i + 1);
		snprintf(strProbability, 6, "0.0%d", 2 * (i + 1));
		snprintf(prio, 2, "%d", i + 2);
		va_cmd(TC, 25, 1, "qdisc", "change", "dev", wanif, "parent", "2:2",
			"gred", "limit", strLimit, "min", strMin, "max", strMax, "burst", strBurst,
			"avpkt", "1000", "bandwidth", strBw, "DP", strDP, "probability", strProbability, "prio", prio);
		printf("%s qdisc change dev %s parent 2:2 gred limit %s min %s max %s burst %s avpkt 1000 bandwidth %s DP %s probability %s prio %s\n"
			, TC, wanif, strLimit, strMin, strMax, strBurst, strBw, strDP, strProbability, prio);
	}
	// RED setup for BE
	diffserv_be_queue(&qEntry, classid);

	// classifier setup for 2:1
	// tc filter add dev vc0 parent 2:0 protocol ip prio 1 handle 17 tcindex classid 2:2
	for (i = 0; i < aftotal; i ++) {
		mib_chain_get(MIB_IP_QOS_TBL, afindex[i], (void *)&qEntry);
		snprintf(strdscp, 6, "%d", qEntry.m_ipprio * 16 + qEntry.m_iptos);
		va_cmd(TC, 15, 1, "filter", (char *)ARG_ADD, "dev", wanif, "parent", "2:0", "protocol", "ip",
			"prio", "1", "handle", strdscp, "tcindex", "classid", "2:2");
	}
	// tc filter add dev vc0 parent 2:0 protocol ip prio 1 handle 5 tcindex classid 2:3
	va_cmd(TC, 15, 1, "filter", (char *)ARG_ADD, "dev", wanif, "parent", "2:0", "protocol", "ip",
		"prio", "1", "handle", "5", "tcindex", "classid", classid);

	return 0;
}

int setupDiffServ(void)
{
	unsigned int num, i;
	MIB_CE_IP_QOS_T qEntry;
	char wanif[IFNAMSIZ];
	unsigned char phbclass;
	int efIndex=0, afIndex[3], afcount = 0;

	mib_get(MIB_DIFFSERV_PHBCLASS, (void *)&phbclass);
	num = mib_chain_total(MIB_IP_QOS_TBL);
	for (i = 0; i < num; i ++) {
		if (!mib_chain_get(MIB_IP_QOS_TBL, i, (void *)&qEntry))
			continue;
		if (qEntry.enDiffserv == 0) // non-Diffserv entry
			continue;
		//if (qEntry.m_ipprio == 5 && qEntry.m_iptos == 3) {	// EF
		if (phbclass == qEntry.m_ipprio) {
			if (phbclass == 5) {	// EF
				efIndex = i;
				break;
			}
			else {	// AF
				afIndex[afcount] = i;
				afcount ++;
				ifGetName(qEntry.ifIndex, wanif, sizeof(wanif));
			}
		}
	}
	if (num > 0) {
		if (afcount > 0)
			setupAFTraffic(afIndex, afcount, wanif);
		else
			setupEFTraffic(efIndex);
	}

	return 0;
}
#endif // #ifdef QOS_DIFFSERV

/*
 * FUNCTION: conver host byte order ip address to number-and-dot notation.
 * ipAddr is in host byte order
 */
char *convertIPAddrToString(unsigned int ipAddr, unsigned char *pAddrStr)
{
	unsigned int tmpAddr;

	tmpAddr = htonl(ipAddr);
	inet_ntop(AF_INET, &tmpAddr, pAddrStr, INET_ADDRSTRLEN);

	return pAddrStr;
}

/*------------------------------------------------------------------
 * Get a list of interface info. (itfInfo) of the specified ifdomain.
 * where,
 * info: a list of interface info entries
 * len: max length of the info list
 * ifdomain: interface domain
 *-----------------------------------------------------------------*/
int get_domain_ifinfo(struct itfInfo *info, int len, int ifdomain)
{
	unsigned int swNum, vcNum;
	int i, num;
	int mib_wlan_num;
	char mygroup;
	char strlan[]="LAN0";
	char wanif[IFNAMSIZ];
	MIB_CE_ATM_VC_T pvcEntry;
	num=0;

#ifdef WLAN_SUPPORT
	int ori_wlan_idx;
#endif

	if (ifdomain&DOMAIN_ELAN) {
		// LAN ports
#ifdef IP_QOS_VPORT
		swNum = SW_LAN_PORT_NUM;
		for (i=0; i<swNum; i++) {
			strlan[3] = '0' + virt2user[i];	// user index
			info[num].ifdomain = DOMAIN_ELAN;
			info[num].ifid=i;	// virtual index
			strncpy(info[num].name, strlan, 8);
			num++;
			if (num > len)
				break;
		}
#else
		info[num].ifdomain = DOMAIN_ELAN;
		info[num].ifid=0;
		strncpy(info[num].name, strlan, 8);
		num++;
#endif
	}

#ifdef WLAN_SUPPORT
	if (ifdomain&DOMAIN_WLAN) {
		ori_wlan_idx = wlan_idx;

		for( wlan_idx = 0; wlan_idx < NUM_WLAN_INTERFACE; wlan_idx++ )
		{
			// wlan0
			mib_get(MIB_WLAN_ITF_GROUP, (void *)&mygroup);
			info[num].ifdomain = DOMAIN_WLAN;
			info[num].ifid = 0 + wlan_idx * 10;  // Magician: ifid of wlan0 = 0; ifid of wlan1 = 10
			strncpy(info[num].name, getWlanIfName(), 8);
			num++;

//jim luo add it to support QoS on Virtual AP...
#ifdef WLAN_MBSSID
			for (i=1; i<IFGROUP_NUM; i++) {
				mib_get(MIB_WLAN_VAP0_ITF_GROUP + ((i-1)<<1), (void *)&mygroup);
				info[num].ifdomain = DOMAIN_WLAN;
				info[num].ifid = i + wlan_idx * 10;  // Magician: ifid of wlan0-vap0~3 = 1~4; ifid of wlan1-vap0~3 = 11~14
				sprintf(info[num].name, "wlan%d-vap%d", wlan_idx, i-WLAN_VAP_ITF_INDEX);
				num++;
			}
#endif  // WLAN_MBSSID
		}
		wlan_idx = ori_wlan_idx;
	}
#endif  // WLAN_SUPPORT

#ifdef CONFIG_USB_ETH
	if (ifdomain&DOMAIN_ULAN) {
		// usb0
		mib_get(MIB_USBETH_ITF_GROUP, (void *)&mygroup);
		info[num].ifdomain = DOMAIN_ULAN;
		info[num].ifid=0;
		sprintf(info[num].name, "%s", USBETHIF );
		num++;
	}
#endif //CONFIG_USB_ETH

	if (ifdomain&DOMAIN_WAN) {
		// vc
		vcNum = mib_chain_total(MIB_ATM_VC_TBL);

		for (i=0; i<vcNum; i++) {
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&pvcEntry))
			{
  				//boaError(wp, 400, "Get chain record error!\n");
  				printf("Get chain record error!\n");
				return -1;
			}

			if (pvcEntry.enable == 0)
				continue;

			info[num].ifdomain = DOMAIN_WAN;
			info[num].ifid=pvcEntry.ifIndex;
			ifGetName(pvcEntry.ifIndex, wanif, sizeof(wanif));
			strncpy(info[num].name, wanif, 8);
			num++;

			if (num > len)
				break;
		}
	}

	return num;
}

int read_pid(const char *filename)
{
	FILE *fp;
	int pid = 0;

	if ((fp = fopen(filename, "r")) == NULL)
		return -1;
	if(fscanf(fp, "%d", &pid) != 1 || kill(pid, 0) != 0){
		pid = 0;
	}
	fclose(fp);

	return pid;
}

int checkNiceOfProcess(unsigned char *processName)
{
	unsigned int i, totalProcess = ((sizeof(process_nice_table))/(sizeof(struct process_nice_table_entry)));
	unsigned char cmd[128] = {0};

	if(!processName)
		return 0;

	for(i=0 ; i<totalProcess ; i++)
	{
		if(!strcmp(process_nice_table[i].processName, processName)) {
			setpriority(PRIO_PROCESS, getpid(), process_nice_table[i].nice);
			return 1;
		}
	}

	setpriority(PRIO_PROCESS, getpid(), 0);
	return 0;
}

// Added by Kaohj
//return 0:OK, other:fail
int _do_cmd(const char *filename, char *argv[], int dowait, int donice)
{
	pid_t pid, wpid;
	int ret, status;
	sigset_t tmpset, origset;

	sigfillset(&tmpset);
	sigprocmask(SIG_BLOCK, &tmpset, &origset);
	pid = vfork();
	sigprocmask(SIG_SETMASK, &origset, NULL);

	if (pid == 0) {
		/* the child */
#ifndef CONFIG_LUNA
		char *env[3];
#endif
		if(donice)
			checkNiceOfProcess(basename(filename));	

		signal(SIGINT, SIG_IGN);
		argv[0] = (char *)filename;
#ifndef CONFIG_LUNA
		env[0] = "PATH=/bin:/usr/bin:/etc:/sbin:/usr/sbin";
		env[1] = NULL;
#endif

#ifndef CONFIG_LUNA
		execve(filename, argv, env);
#else
		execv(filename, argv);
#endif

		fprintf(stderr, "exec %s failed\n", filename);
		_exit(EXIT_FAILURE);
	} else if (pid > 0) {
		if (!dowait)
			ret = 0;
		else {
			/* parent, wait till rc process dies before spawning */
			while ((wpid = waitpid(pid,&status,0)) != pid) {
				if (wpid == -1 && errno == ECHILD) {	/* see wait(2) manpage */
					break;
				}
			}

			ret = WIFEXITED(status) ? WEXITSTATUS(status) : -1;
		}
	} else if (pid < 0) {
		fprintf(stderr, "fork of %s failed\n", filename);
		ret = -1;
	}

	return ret;
}

//return 0:OK, other:fail
int do_cmd_ex(const char *filename, char *argv[], int dowait, int noError)
{
	pid_t pid, wpid;
	int ret, status;
	sigset_t tmpset, origset;

	sigfillset(&tmpset);
	sigprocmask(SIG_BLOCK, &tmpset, &origset);
	pid = vfork();
	sigprocmask(SIG_SETMASK, &origset, NULL);

	if (pid == 0) {
		/* the child */
#ifndef CONFIG_LUNA
		char *env[3];
#endif

		signal(SIGINT, SIG_IGN);
		argv[0] = (char *)filename;
#ifndef CONFIG_LUNA
		env[0] = "PATH=/bin:/usr/bin:/etc:/sbin:/usr/sbin";
		env[1] = NULL;
#endif
		//no error output
		if(noError==1){
			int fd = open("/dev/null", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
			dup2(fd, 1);
			dup2(fd, 2);
			close(fd);
		}
#ifndef CONFIG_LUNA
		execve(filename, argv, env);
#else
		execv(filename, argv);
#endif

		fprintf(stderr, "exec %s failed\n", filename);
		_exit(EXIT_FAILURE);
	} else if (pid > 0) {
		if (!dowait)
			ret = 0;
		else {
			/* parent, wait till rc process dies before spawning */
			while ((wpid = waitpid(pid,&status,0)) != pid) {
				if (wpid == -1 && errno == ECHILD) {	/* see wait(2) manpage */
					break;
				}
			}

			ret = WIFEXITED(status) ? WEXITSTATUS(status) : -1;
		}
	} else if (pid < 0) {
		fprintf(stderr, "fork of %s failed\n", filename);
		ret = -1;
	}

	return ret;
}


//return 0:OK, other:fail
int va_niced_cmd(const char *cmd, int num, int dowait, ...)
{
	va_list ap;
	int k;
	char *s;
	char *argv[24];
	int status;

	TRACE(STA_SCRIPT, "%s ", cmd);
	va_start(ap, dowait);

	for (k=0; k<num; k++)
	{
		s = va_arg(ap, char *);
		argv[k+1] = s;
		TRACE(STA_SCRIPT|STA_NOTAG, "%s ", s);
	}

	TRACE(STA_SCRIPT|STA_NOTAG, "\n");
	argv[k+1] = NULL;
	status = do_nice_cmd(cmd, argv, dowait);
	va_end(ap);

	return status;
}

//return 0:OK, other:fail
int va_cmd(const char *cmd, int num, int dowait, ...)
{
	va_list ap;
	int k;
	char *s;
	char *argv[39];
	int status;

	TRACE(STA_SCRIPT, "%s ", cmd);
	va_start(ap, dowait);

	for (k=0; k<num; k++)
	{
		s = va_arg(ap, char *);
		argv[k+1] = s;
		TRACE(STA_SCRIPT|STA_NOTAG, "%s ", s);
	}

	TRACE(STA_SCRIPT|STA_NOTAG, "\n");
	argv[k+1] = NULL;
	status = do_cmd(cmd, argv, dowait);
	va_end(ap);

	return status;
}

//return 0:OK, other:fail
int va_cmd_no_error(const char *cmd, int num, int dowait, ...)
{
	va_list ap;
	int k;
	char *s;
	char *argv[24];
	int status;

	TRACE(STA_SCRIPT, "%s ", cmd);
	va_start(ap, dowait);

	for (k=0; k<num; k++)
	{
		s = va_arg(ap, char *);
		argv[k+1] = s;
		TRACE(STA_SCRIPT|STA_NOTAG, "%s ", s);
	}

	TRACE(STA_SCRIPT|STA_NOTAG, "\n");
	argv[k+1] = NULL;
	status = do_cmd_ex(cmd, argv, dowait, 1);
	va_end(ap);

	return status;
}

//return 0:OK, other:fail
/*same function as va_cmd(). Execute silently.
  No print out command string in console.
*/
int va_cmd_no_echo(const char *cmd, int num, int dowait, ...)
{
	va_list ap;
	int k;
	char *s;
	char *argv[24];
	int status;

	va_start(ap, dowait);

	for (k=0; k<num; k++)
	{
		s = va_arg(ap, char *);
		argv[k+1] = s;
	}

	argv[k+1] = NULL;
	status = do_cmd(cmd, argv, dowait);
	va_end(ap);

	return status;
}

//return 0:OK, other:fail
int call_cmd(const char *filename, int num, int dowait, ...)
{
	va_list ap;
	char *s;
	char *argv[24];
	int status=0, st, k;
	pid_t pid, wpid;

	va_start(ap, dowait);

	for (k=0; k<num; k++)
	{
		s = va_arg(ap, char *);
		argv[k+1] = s;
	}

	argv[k+1] = NULL;
	if((pid = vfork()) == 0) {
		/* the child */
		char *env[3];

		signal(SIGINT, SIG_IGN);
		argv[0] = (char *)filename;
		env[0] = "PATH=/bin:/usr/bin:/etc:/sbin:/usr/sbin";
		env[1] = NULL;

		execve(filename, argv, env);

		printf("exec %s failed\n", filename);
		_exit(2);
	} else if(pid > 0) {
		if (!dowait)
			status = 0;
		else {
			/* parent, wait till rc process dies before spawning */
			while ((wpid = wait(&st)) != pid)
				if (wpid == -1 && errno == ECHILD) { /* see wait(2) manpage */
					break;
				}
		}
	} else if(pid < 0) {
		printf("fork of %s failed\n", filename);
		status = -1;
	}
	if (wpid>0)
		if (WIFEXITED(st))
			status = WEXITSTATUS(st);
	va_end(ap);

	return status;
}

void write_to_pppd(struct data_to_pass_st *pmsg)
{
#if defined(CONFIG_LUNA) && defined(GEN_WAN_MAC)
	//Chuck: use system call to trigger spppd main.c pause(), fit for ql_xu performance tune fix
	system(pmsg->data);
#else
	int pppd_fifo_fd=-1;

	pppd_fifo_fd = open(PPPD_FIFO, O_WRONLY);
	if (pppd_fifo_fd == -1)
		fprintf(stderr, "Sorry, no spppd server\n");
	else
	{
		write(pppd_fifo_fd, pmsg, sizeof(*pmsg));
		close(pppd_fifo_fd);
	}
#endif
}

// return value:
// 0  : successful
// -1 : failed
int write_to_mpoad(struct data_to_pass_st *pmsg)
{
	int mpoad_fifo_fd=-1;
	int status=0;
	int ret=0;
	return status;
}

static void WRITE_DHCPC_FILE(int fh, unsigned char *buf)
{
	if ( write(fh, buf, strlen(buf)) != strlen(buf) ) {
		printf("Write udhcpc script file error!\n");
		close(fh);
	}
}

static void write_to_dhcpc_script(char *fname, MIB_CE_ATM_VC_Tp pEntry, int is_diag)
{
	int fh;
	int mark;
	char buff[64];
#ifdef POLICY_ROUTING_DNSV4RELAY
	char buff2[128];
	int32_t tbl_id;
	char str_tblid[10]="";
	unsigned char Dnsmode;
	char iproutecmd2[80];	// Mason Yu. for ACS and NTP
#endif
#ifdef DEFAULT_GATEWAY_V2
	unsigned int dgw;
#endif
#ifdef IP_POLICY_ROUTING
	int i, num, found;
	MIB_CE_IP_QOS_T qEntry;
#endif
#ifdef NEW_PORTMAPPING
	char iproutecmd[80];
	int  tableId;
#endif
	char ifname[30];

	ifGetName(pEntry->ifIndex, ifname, sizeof(ifname));

	fh = open(fname, O_RDWR|O_CREAT|O_TRUNC, S_IXUSR);

	if (fh == -1) {
		printf("Create udhcpc script file %s error!\n", fname);
		return;
	}

	WRITE_DHCPC_FILE(fh, "#!/bin/sh\n");
	snprintf(buff, 64, "RESOLV_CONF=\"/var/udhcpc/resolv.conf.%s\"\n", ifname);
	WRITE_DHCPC_FILE(fh, buff);
	WRITE_DHCPC_FILE(fh, "[ \"$broadcast\" ] && BROADCAST=\"broadcast $broadcast\"\n");
	WRITE_DHCPC_FILE(fh, "[ \"$subnet\" ] && NETMASK=\"netmask $subnet\"\n");
	WRITE_DHCPC_FILE(fh, "MER_GW_INFO=\"/tmp/MERgw.\"$interface\n");	// Jenny, write MER1483 gateway info
	WRITE_DHCPC_FILE(fh, "echo $router > $MER_GW_INFO\n");
	snprintf(buff, 64, "ifconfig $interface mtu %d\n", pEntry->mtu);
	WRITE_DHCPC_FILE(fh, buff);
	WRITE_DHCPC_FILE(fh, "echo interface=$interface\n");
	WRITE_DHCPC_FILE(fh, "echo ciaddr=$ciaddr\n");
	WRITE_DHCPC_FILE(fh, "echo ip=$ip\n");
	WRITE_DHCPC_FILE(fh, "if [ \"$ip\" != \"$ciaddr\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "if [ \"\" == \"$ciaddr\" -o \"0.0.0.0\" == \"$ciaddr\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "ciaddr=`ifconfig $interface 2>/dev/null|awk '/inet addr:/ {print $2}'|sed 's/addr://'`\n");
	WRITE_DHCPC_FILE(fh, "echo \"update ciaddr=\"$ciaddr\n");
	WRITE_DHCPC_FILE(fh, "fi\n");
	WRITE_DHCPC_FILE(fh, "if [ \"\" != \"$ciaddr\" -a \"$ip\" != \"$ciaddr\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "echo clear_ip\n");	
	WRITE_DHCPC_FILE(fh, "ifconfig $interface 0.0.0.0\n");
	WRITE_DHCPC_FILE(fh, "fi\n");
	WRITE_DHCPC_FILE(fh, "fi\n");
	WRITE_DHCPC_FILE(fh, "ifconfig $interface $ip $BROADCAST $NETMASK -pointopoint\n");

#ifdef DEFAULT_GATEWAY_V2
	mib_get( MIB_ADSL_WAN_DGW_ITF, (void *)&dgw);	// Jenny, check default gateway
	if ((dgw == pEntry->ifIndex)
#ifdef AUTO_PPPOE_ROUTE
		 || (dgw == DGW_AUTO && (CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_IPOE)
#endif
	)
#else
	if (pEntry->dgw)
#endif
	{
		WRITE_DHCPC_FILE(fh, "if [ \"$router\" ]; then\n");
#ifdef DEFAULT_GATEWAY_V2
		if (ifExistedDGW() == 1)	// Jenny, delete existed default gateway first
			WRITE_DHCPC_FILE(fh, "\troute del default\n");
#endif
		WRITE_DHCPC_FILE(fh, "\twhile route del -net default gw 0.0.0.0 dev $interface\n");
		WRITE_DHCPC_FILE(fh, "\tdo :\n");
		WRITE_DHCPC_FILE(fh, "\tdone\n\n");
#ifdef NEW_PORTMAPPING
		tableId = caculate_tblid(pEntry->ifIndex);
		snprintf(iproutecmd, 80, "\tip route del default table %d\n", tableId);
		WRITE_DHCPC_FILE(fh, iproutecmd);
		snprintf(iproutecmd, 80, "\tip route del default table %d\n", PMAP_DEFAULT_TBLID);
		WRITE_DHCPC_FILE(fh, iproutecmd);
#endif
		WRITE_DHCPC_FILE(fh, "\tfor i in $router\n");
		WRITE_DHCPC_FILE(fh, "\tdo\n");
		WRITE_DHCPC_FILE(fh, "\troute add -net default gw $i dev $interface\n");
#ifdef NEW_PORTMAPPING
		//tableId = caculate_tblid(pEntry->ifIndex);
		if (is_diag) {
			tableId += ITF_SOURCE_ROUTE_SIMU_START;
		}
		snprintf(iproutecmd, 80, "\tip route add default dev $interface via $i table %d\n", tableId);
		WRITE_DHCPC_FILE(fh, iproutecmd);
		snprintf(iproutecmd, 80, "\tip route add default dev $interface via $i table %d\n", PMAP_DEFAULT_TBLID);
		WRITE_DHCPC_FILE(fh, iproutecmd);
#endif
		WRITE_DHCPC_FILE(fh, "\tdone\n");
		WRITE_DHCPC_FILE(fh, "fi\n");
	}
	else {
#ifdef DEFAULT_GATEWAY_V2	// Jenny, assign default gateway by remote WAN IP
		unsigned char dgwip[16];
		if (mib_get(MIB_ADSL_WAN_DGW_ITF, (void *)&dgw) != 0) {
			if (dgw == DGW_NONE && getMIB2Str(MIB_ADSL_WAN_DGW_IP, dgwip) == 0) {
				if (ifExistedDGW() == 1)
					WRITE_DHCPC_FILE(fh, "\troute del default\n");
				// route add default gw remotip
				snprintf(buff, 64, "\troute add default gw %s\n", dgwip);
				WRITE_DHCPC_FILE(fh, buff);
			}
		}
#endif
#ifdef NEW_PORTMAPPING
		tableId = caculate_tblid(pEntry->ifIndex);
		if (is_diag) {
			tableId += ITF_SOURCE_ROUTE_SIMU_START;
		}
		WRITE_DHCPC_FILE(fh, "if [ \"$router\" ]; then\n");
		snprintf(iproutecmd, 80, "\tip route del default table %d\n", tableId);
		WRITE_DHCPC_FILE(fh, iproutecmd);
		snprintf(iproutecmd, 80, "\tip route add default dev $interface via $i table %d\n", tableId);
		WRITE_DHCPC_FILE(fh, "\tfor i in $router\n");
		WRITE_DHCPC_FILE(fh, "\tdo\n");
		WRITE_DHCPC_FILE(fh, iproutecmd);
		WRITE_DHCPC_FILE(fh, "\tdone\n");
		WRITE_DHCPC_FILE(fh, "fi\n");
#endif
	}

#ifdef CONFIG_USER_RTK_WAN_CTYPE
	if (pEntry->applicationtype&X_CT_SRV_TR069)
	{
		char ifname[10];
		char cmd[64];

		//snprintf(ifname,sizeof(ifname),"vc%d",VC_INDEX(pEntry->ifIndex));
		ifGetName(pEntry->ifIndex, ifname, sizeof(ifname));
		sprintf(buff,"%s.%s", DHCPC_ROUTERFILE, ifname);
		WRITE_DHCPC_FILE(fh, "if [ \"$router\" ]; then\n");
		WRITE_DHCPC_FILE(fh, "\tfor i in $router\n");
		WRITE_DHCPC_FILE(fh, "\tdo\n");
		unlink(buff);
		sprintf(cmd,"\techo $router > %s\n",buff);
		WRITE_DHCPC_FILE(fh, cmd);
		WRITE_DHCPC_FILE(fh, "\tdone\n");
		WRITE_DHCPC_FILE(fh, "fi\n");
	}
#endif

	/**************************** Important *****************************/
	/* Should set policy route before write resolv.conf, or there are   */
	/* still some packets may go to wrong pvc.                          */
	/*************************************** ****************************/
	set_dhcp_source_route(fh, pEntry, is_diag);

	WRITE_DHCPC_FILE(fh, "if [ \"$dns\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "\trm $RESOLV_CONF\n");
	WRITE_DHCPC_FILE(fh, "\tfor i in $dns\n");
	WRITE_DHCPC_FILE(fh, "\tdo\n");
	WRITE_DHCPC_FILE(fh, "\tif [ $i = '0.0.0.0' ]|| [ $i = '255.255.255.255' ]; then\n");
	WRITE_DHCPC_FILE(fh, "\t\tcontinue\n");
	WRITE_DHCPC_FILE(fh, "\tfi\n");
	WRITE_DHCPC_FILE(fh, "\techo 'DNS=' $i\n");
	//WRITE_DHCPC_FILE(fh, "\techo nameserver $i >> $RESOLV_CONF\n");
	// echo 192.168.88.21@192.168.99.100
	snprintf(buff, 64, "\techo $i@$ip >> $RESOLV_CONF\n");
	WRITE_DHCPC_FILE(fh, buff);
	WRITE_DHCPC_FILE(fh, "\tdone\n");
	WRITE_DHCPC_FILE(fh, "fi\n");

#ifdef IP_POLICY_ROUTING
	num = mib_chain_total(MIB_IP_QOS_TBL);
	found = 0;
	// set advanced-routing rule
	for (i=0; i<num; i++) {
		if (!mib_chain_get(MIB_IP_QOS_TBL, i, (void *)&qEntry))
			continue;
#ifdef QOS_DIFFSERV
		if (qEntry.enDiffserv == 1) // Diffserv entry
			continue;
#endif
		if (qEntry.outif == pEntry->ifIndex) {

			found = 1;
			mark = get_classification_mark(i);
			if (mark != 0) {
				WRITE_DHCPC_FILE(fh, "if [ \"$router\" ]; then\n");
				snprintf(buff, 64, "\tip ru add fwmark %x table %d\n", mark, VC_INDEX(pEntry->ifIndex)+PR_VC_START);
				WRITE_DHCPC_FILE(fh, buff);
			}
		}
	}
	if (found) {
		snprintf(buff, 64, "\tip ro add default via $router dev $interface table %d\n", VC_INDEX(pEntry->ifIndex)+PR_VC_START);
		WRITE_DHCPC_FILE(fh, buff);
		WRITE_DHCPC_FILE(fh, "fi\n");
	}
#endif

#ifdef CONFIG_CWMP_TR181_SUPPORT
	// Collect DHCP Information for Device.DHCPv4.Client.{i}.
	WRITE_DHCPC_FILE(fh, "\nINFO_FILE=\"/tmp/udhcpc_info.$interface\"\n");
	WRITE_DHCPC_FILE(fh, "rm $INFO_FILE\n");

	// IP Address
	WRITE_DHCPC_FILE(fh, "if [ \"$ip\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "	echo ip=$ip >> $INFO_FILE\n");
	WRITE_DHCPC_FILE(fh, "fi\n");

	// DHCP Server
	WRITE_DHCPC_FILE(fh, "if [ \"$siaddr\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "	echo siaddr=$siaddr >> $INFO_FILE\n");
	WRITE_DHCPC_FILE(fh, "fi\n");

	// Gateway info
	WRITE_DHCPC_FILE(fh, "if [ \"$router\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "	echo router=$router >> $INFO_FILE\n");
	WRITE_DHCPC_FILE(fh, "fi\n");

	// DNS Servers
	WRITE_DHCPC_FILE(fh, "DNS=''\n");
	WRITE_DHCPC_FILE(fh, "if [ \"$dns\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "	for i in $dns\n");
	WRITE_DHCPC_FILE(fh, "	do\n");
	WRITE_DHCPC_FILE(fh, "		DNS=\"$DNS$i,\"\n");
	WRITE_DHCPC_FILE(fh, "	done\n");
	WRITE_DHCPC_FILE(fh, "	echo dns=$DNS >> $INFO_FILE\n");
	WRITE_DHCPC_FILE(fh, "fi\n");

	// Expire time
	WRITE_DHCPC_FILE(fh, "if [ \"$expire\" ]; then\n");
	WRITE_DHCPC_FILE(fh, "	echo expire=$expire >> $INFO_FILE\n");
	WRITE_DHCPC_FILE(fh, "fi\n");
#endif
	close(fh);
}

int set_dhcp_source_route(int fh, MIB_CE_ATM_VC_Tp pEntry, int is_diag)
{
	char buff[64];
	char buff2[128];
	int32_t tbl_id;
	char str_tblid[10]="";
	char iproutecmd[80];	// Mason Yu. for ACS and NTP

	//This interface is not default route
	if ( pEntry->dgw== 0)
	{
		tbl_id = caculate_tblid_ITF_SourceRoute(pEntry->ifIndex);
		if (is_diag) {
			tbl_id += ITF_SOURCE_ROUTE_SIMU_START;
		}
		snprintf(str_tblid, sizeof(str_tblid), "%d", tbl_id);

		//(1) ip route flush table 64
		snprintf(buff, 64, "\tip route flush table %s\n", str_tblid);
		WRITE_DHCPC_FILE(fh, buff);

		// (2) ip rule del fwmark 1 table 200
		snprintf(buff, 64, "\tip rule del table %s\n", str_tblid);
		WRITE_DHCPC_FILE(fh, buff);

		// (3) Add default route for policy route table
		WRITE_DHCPC_FILE(fh, "if [ \"$router\" ]; then\n");
		//ip route add default dev vc0 via 192.168.1.254 table 64
		snprintf(iproutecmd, 80, "\tip route add default dev $interface via $i table %s\n", str_tblid);
		WRITE_DHCPC_FILE(fh, "\tfor i in $router\n");
		WRITE_DHCPC_FILE(fh, "\tdo\n");
		WRITE_DHCPC_FILE(fh, iproutecmd);
		WRITE_DHCPC_FILE(fh, "\tdone\n");
		WRITE_DHCPC_FILE(fh, "fi\n");

		// (4) Add net route for this policy route table
		// ip route add 192.168.8.0/24 via 192.168.8.1 table 200
		snprintf(buff2, 128, "\tip route add $netip/$mask via $ip table %s\n", str_tblid);
		WRITE_DHCPC_FILE(fh, buff2);

		// (5) Add source IP rule
		snprintf(buff2, 128, "\tip rule add from $ip table %s\n", str_tblid);
		WRITE_DHCPC_FILE(fh, buff2);
	}
	return 0;
}

int set_static_source_route(MIB_CE_ATM_VC_Tp pEntry)
{
	int32_t tbl_id;
	char str_tblid[10]="";
	char ifname[10];
	char *temp;
	char ipAddr[20], remoteIp[20];
	unsigned int wanmask, wanmbit, wanip, wansubnet;
	unsigned char wansubnetStr[20];
	char wansubnetStr_tmp[30];
	char wanipStr[20];

	ifGetName(pEntry->ifIndex, ifname, sizeof(ifname));
	// If this interface set DNS IP manually, and this interface is not default route
	if ( ((pEntry->cmode == CHANNEL_MODE_RT1483) || (pEntry->cmode == CHANNEL_MODE_IPOE)) && ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) && (pEntry->dgw== 0))
	{
		tbl_id = caculate_tblid_ITF_SourceRoute(pEntry->ifIndex);
		snprintf(str_tblid, sizeof(str_tblid), "%d", tbl_id);

		// (1) flush source route
		//( ip route flush table 64
		va_cmd("/bin/ip", 4, 1, "route", "flush", "table", str_tblid);

		// (2) Get some WAN IP address
		//temp = inet_ntoa(*((struct in_addr *)pEntry->ipAddr));
		//if (strcmp(temp, "0.0.0.0"))
		//{
		//	strcpy(ipAddr, temp);
		//}
		//convertIPAddrToString(*(unsigned int *)pEntry->ipAddr, ipAddr);
		inet_ntop(AF_INET, pEntry->ipAddr, ipAddr, INET_ADDRSTRLEN);

		wanip = *(unsigned int *)(pEntry->ipAddr);
		wanmask = *(unsigned int *)(pEntry->netMask);
		wansubnet = (wanip&wanmask);
		//printf("***** wanip=0x%x, wanmask=0x%x, wansubnet=0x%x\n", wanip, wanmask, wansubnet);
		//strncpy(wansubnetStr, inet_ntoa(*((struct in_addr *)&wansubnet)), 16);
		//convertIPAddrToString(wansubnet, wansubnetStr);
		inet_ntop(AF_INET, &wansubnet, wansubnetStr, INET_ADDRSTRLEN);
		wansubnetStr[15] = '\0';
		//strncpy(wanipStr, inet_ntoa(*((struct in_addr *)&wanip)), 16);
		//convertIPAddrToString(wanip, wanipStr);
		inet_ntop(AF_INET, &wanip, wanipStr, INET_ADDRSTRLEN);
		wanipStr[15] = '\0';

		wanmbit=0;
		while (1) {
			if (wanmask&0x80000000) {
				wanmbit++;
				wanmask <<= 1;
			}
			else
				break;
		}
		snprintf(wansubnetStr_tmp,30,"%s/%d",wansubnetStr,wanmbit);

		// (3) Add default route for policy route table
		//temp = inet_ntoa(*((struct in_addr *)pEntry->remoteIpAddr));
		//convertIPAddrToString(*(unsigned int *)pEntry->remoteIpAddr, remoteIp);
		inet_ntop(AF_INET, pEntry->remoteIpAddr, remoteIp, INET_ADDRSTRLEN);
		if (strcmp(remoteIp, "0.0.0.0"))
		{
			//strcpy(remoteIp, temp);
			//ip route add default dev vc0 via 192.168.1.254 table 64
			va_cmd("/bin/ip", 9, 1, "route", "add", "default", "dev", ifname, "via", remoteIp, "table", str_tblid);
		}

		// (4) Add net route for this policy route table
		// ip route add 192.168.8.0/24 via 192.168.8.1 table 200
		if (pEntry->cmode != CHANNEL_MODE_RT1483) // p-to-p link do not need interface route.
			va_cmd("/bin/ip", 7, 1, "route", "add", wansubnetStr_tmp, "via", ipAddr, "table", str_tblid);

		// (5) Add source rule from this interface
		// ip rule del table 64
		// delete rule before adding it.
		va_cmd("/bin/ip", 4, 1, "rule", "del", "table", str_tblid);
		va_cmd("/bin/ip", 6, 1, "rule", "add", "from", wanipStr, "table", str_tblid);
	}
	return 0;
}

int set_ipv6_static_source_route(MIB_CE_ATM_VC_T *pEntry, char *ifname, struct in6_addr * ip6addr)
{
	int32_t tbl_id;
	unsigned int ifIndex;
	char str_tblid[10]={0};
	char SourceRouteIp[64]={0};
	int applicationtype=0;
	struct ipv6_ifaddr ipv6_addr;
	int numOfIpv6;

	if(!ifname || !ip6addr){
		printf("Error! NULL input!\n");
		return -1;
	}
	inet_ntop(AF_INET6, (const void *)ip6addr, SourceRouteIp, INET6_ADDRSTRLEN);
	AUG_PRT("ifname=%s pEntry->dgw=%d SourceRouteIp=%s\n",ifname,pEntry->dgw,SourceRouteIp);

	//This interface is not default route
	if ( pEntry->dgw== 0)
	{
		struct in6_addr prefix = {0};
		const char *dst = NULL;
		char	buf[64]={0};
		char	*buf1 = NULL;
		ifIndex = getIfIndexByName(ifname);
		applicationtype=getapplicationtypeByName(ifname);
		tbl_id = caculate_tblid_ITF_SourceRoute(ifIndex);

		snprintf(str_tblid, sizeof(str_tblid), "%d", tbl_id);

		//ip -6 route flush table 64
		va_cmd("/bin/ip", 5, 1, "-6", "route", "flush", "table", str_tblid);
		// ip -6 rule del table 64
		va_cmd("/bin/ip", 5, 1, "-6", "rule", "del", "table", str_tblid);

		inet_ntop(AF_INET6, (const void *)pEntry->RemoteIpv6Addr, SourceRouteIp, INET6_ADDRSTRLEN);

		//del default route
		sprintf(buf,"echo 0 > /proc/sys/net/ipv6/conf/%s/accept_ra_defrtr",ifname);
		AUG_PRT("buf=%s\n",buf);

		system(buf);

		if(!strcmp(SourceRouteIp,"::")){
			//remote gateway not get yet!
			AUG_PRT("remote gateway not get yet ::\n");

		}else{
			AUG_PRT("del ipv6 secondary default route %s\n",SourceRouteIp);
			//del ipv6 secondary default route
			//ip -6 route del default via fe80::a00:27ff:fe29:3e63 dev nas0_2
			va_cmd("/bin/ip", 8, 1, "-6", "route", "del", "default", "via", SourceRouteIp,"dev", ifname);
		}

		// Add source rule
		//add gateway ip
		//ip -6 rule
		//from fe80::a00:27ff:fe29:3e63 lookup 114
		//ip -6 rule add from  fe80::a00:27ff:fe29:3e63 table 114
		va_cmd("/bin/ip", 7, 1, "-6", "rule", "add", "from", SourceRouteIp,"table", str_tblid);
		//ip -6 route add default via fe80::a00:27ff:fe29:3e63 dev nas0_2 table 114
		va_cmd("/bin/ip", 10, 1, "-6", "route", "add", "default", "via", SourceRouteIp, "dev", ifname, "table", str_tblid);
		memset(&ipv6_addr, 0, sizeof(struct ipv6_ifaddr));
		//get global addr
		numOfIpv6 = getifip6(ifname, IPV6_ADDR_UNICAST, &ipv6_addr, 1);
		if(numOfIpv6 > 0){
			inet_ntop(AF_INET6, &ipv6_addr.addr, SourceRouteIp, INET6_ADDRSTRLEN);
			//AUG_PRT("global ip=%s, prefix-len=%d\n",SourceRouteIp,ipv6_addr.prefix_len);
		}
		ip6toPrefix(&ipv6_addr.addr, ipv6_addr.prefix_len, &prefix);
		dst = inet_ntop(AF_INET6, &prefix, buf, sizeof(buf));
		//AUG_PRT("dst=%s, buf=%s prefix-len=%d\n",dst,buf,ipv6_addr.prefix_len);
		if(dst){
			sprintf(buf, "%s/%d", buf,ipv6_addr.prefix_len);
			buf1 = strdup(buf);
			//AUG_PRT("buf=%s, buf1=%s prefix-len=%d\n",buf,buf1,ipv6_addr.prefix_len);
		}
		//get ipv6-linklocal addr
		numOfIpv6=getifip6(ifname, IPV6_ADDR_LINKLOCAL, &ipv6_addr, 1);
		if(numOfIpv6 > 0){
			inet_ntop(AF_INET6, &ipv6_addr.addr, SourceRouteIp, INET6_ADDRSTRLEN);
			//sprintf(netmask, "%d\0", ipv6_addr.prefix_len);
			//AUG_PRT("aaaLINKLOCAL=%s, prefix-len=%d\n",SourceRouteIp,ipv6_addr.prefix_len);
		}
		//AUG_PRT("aaaLINKLOCAL=%s, prefix-len=%d numOfIpv6=%d buf1=%s\n",SourceRouteIp,ipv6_addr.prefix_len,numOfIpv6,buf1);
		//ip -6 route add 2004::/64 via fe80::2e0:4cff:fe86:511e dev nas0_2 table 114
		va_cmd("/bin/ip", 10, 1, "-6", "route", "add", buf1, "via", SourceRouteIp, "dev", ifname, "table", str_tblid);
		if(buf1 != NULL){
			free(buf1);
		}
	}

	return 0;
}


int set_pppv6_source_route(MIB_CE_ATM_VC_T *pEntry, char *ifname, struct in6_addr * ip6addr)
{
	int32_t tbl_id;
	unsigned int ifIndex;
	char str_tblid[10]="";
	char SourceRouteIp[64]={0};
	int applicationtype=0;
//AUG_PRT("%s-%d ifname=%s pEntry->dgw=%d\n",__func__,__LINE__,ifname,pEntry->dgw);

	if(!ifname || !ip6addr){
		printf("Error! NULL input!\n");
		return -1;
	}
	inet_ntop(AF_INET6, (const void *)ip6addr, SourceRouteIp, 64);

AUG_PRT("%s-%d ifname=%s pEntry->dgw=%d SourceRouteIp=%s\n",__func__,__LINE__,ifname,pEntry->dgw,SourceRouteIp);

	//This interface is not default route
	if ( pEntry->dgw== 0)
	{
		char	buf[128]={0};
		ifIndex = getIfIndexByName(ifname);
		applicationtype=getapplicationtypeByName(ifname);
		tbl_id = caculate_tblid_ITF_SourceRoute(ifIndex);
AUG_PRT("ifname=%s ifIndex=%x applicationtype=%d tbl_id=%d\n",ifname,ifIndex,applicationtype,tbl_id);
		snprintf(str_tblid, sizeof(str_tblid), "%d", tbl_id);
		//del default route, and add policy route
		sprintf(buf,"echo 0 > /proc/sys/net/ipv6/conf/%s/accept_ra_defrtr",ifname);
		AUG_PRT("buf=%s\n",buf);
		system(buf);
		inet_ntop(AF_INET6, (const void *)pEntry->RemoteIpv6Addr, SourceRouteIp, 64);
		if(!strcmp(SourceRouteIp,"::")){
			//remote gateway not get yet!
			AUG_PRT("remote gateway not get yet ::\n");

		}else{
			AUG_PRT("del ipv6 secondary default route %s\n",SourceRouteIp);
			//del ipv6 secondary default route
			//ip -6 route del default via fe80::a00:27ff:fe29:3e63 dev ppp1
			va_cmd("/bin/ip", 8, 1, "-6", "route", "del", "default", "via", SourceRouteIp,"dev", ifname);
		}

		//ip -6 route flush table 64
		va_cmd("/bin/ip", 5, 1, "-6", "route", "flush", "table", str_tblid);
		// ip -6 rule del table 64
		va_cmd("/bin/ip", 5, 1, "-6", "rule", "del", "table", str_tblid);

		inet_ntop(AF_INET6, (const void *)ip6addr, SourceRouteIp, 64);
AUG_PRT("%s-%d SourceRouteIp=%s\n",__func__,__LINE__,SourceRouteIp);

		//strcpy(SourceRouteIp,inet_ntoa(*((struct in_addr *)&ppp_info->myip)) );
		// Add source rule
		//ip -6 rule add from 2004::2e0:4cff:fe86:5120 table 64
		va_cmd("/bin/ip", 7, 1, "-6", "rule", "add", "from", SourceRouteIp,"table", str_tblid);
		// ip -6 route add default dev ppp0 table 200
		va_cmd("/bin/ip", 8, 1, "-6", "route", "add", "default", "dev", ifname, "table", str_tblid);

	}

	return 0;
}

int set_ppp_source_route(struct ppp_policy_route_info *ppp_info)
{
	int32_t tbl_id;
	unsigned int ifIndex;
	char str_tblid[10]="";
	char SourceRouteIp[20]={0};
	char sourceroute_tmp[50];
	int applicationtype;

	ifIndex = getIfIndexByName(ppp_info->if_name);
	applicationtype=getapplicationtypeByName(ppp_info->if_name);
	tbl_id = caculate_tblid_ITF_SourceRoute(ifIndex);
	snprintf(str_tblid, sizeof(str_tblid), "%d", tbl_id);

	//ip route flush table 64
	va_cmd("/bin/ip", 4, 1, "route", "flush", "table", str_tblid);
	// ip rule del table 64
	va_cmd("/bin/ip", 4, 1, "rule", "del", "table", str_tblid);

	strcpy(SourceRouteIp,inet_ntoa(*((struct in_addr *)&ppp_info->myip)) );
	//snprintf(sourceroute_tmp,50,"%s/%d",SourceRouteIp,24);
	// Add source rule
	va_cmd("/bin/ip", 6, 1, "rule", "add", "from", SourceRouteIp,"table", str_tblid);
	// ip route add default dev ppp0 table 200
	va_cmd("/bin/ip", 7, 1, "route", "add", "default", "dev", ppp_info->if_name, "table", str_tblid);

	return 0;
}

// DHCP client configuration
// return value:
// 1  : successful
int startDhcpc(char *inf, MIB_CE_ATM_VC_Tp pEntry, int is_diag)
{
	unsigned char value[32], value2[32];
	char devName[MAX_NAME_LEN];
	FILE *fp;
	DNS_TYPE_T dnsMode;
	char * argv[16];

	unsigned int i, vcTotal, resolvopt, dhcpc_idx=1;

	mib_get(MIB_DEVICE_NAME, (void *)devName);

	argv[1] = inf;
	argv[2] = "up";
	argv[3] = NULL;
	TRACE(STA_SCRIPT, "%s %s %s\n", IFCONFIG, argv[1], argv[2]);
	do_cmd(IFCONFIG, argv, 1);

	// udhcpc -i vc0 -p pid -s script
	argv[dhcpc_idx++] = (char *)ARG_I;
	argv[dhcpc_idx++] = inf;
	if(is_diag)
		argv[dhcpc_idx++] = "-d";	//diagnostics
	argv[dhcpc_idx++] = "-p";
	snprintf(value2, 32, "%s.%s", (char*)DHCPC_PID, inf);
	argv[dhcpc_idx++] = (char *)value2;
	argv[dhcpc_idx++] = "-s";
	snprintf(value, 32, "%s.%s", (char *)DHCPC_SCRIPT_NAME, inf);
	write_to_dhcpc_script(value, pEntry, is_diag);
	argv[dhcpc_idx++] = (char *)DHCPC_SCRIPT;
#ifdef  _PRMT_X_CT_COM_IPoEDiagnostics_
	int major;
	int minor;
	int simu;
	printf("inf=%s\n",inf);
	if(sscanf(inf,"nas%d_%d_%d",&major,&minor,&simu)==3){
		//check if simulate interface,if yes, need dump error infomation for IPOE simulate
		printf("major=%d minor=%d simu=%d\n",major,minor,simu);
		argv[dhcpc_idx++] = "-t";
	}
#endif		
	// Add option 12 Host Name
	if(strlen(devName) > 0){
		argv[dhcpc_idx++] = "-H";
		argv[dhcpc_idx++] = (char *)devName;
		argv[dhcpc_idx++] = NULL;
	}
	else
		argv[dhcpc_idx++] = NULL;

	if (strcmp(inf, LANIF) == 0)
	{
		// LAN interface
		// enable Microsoft auto IP configuration
		argv[dhcpc_idx++] = "-a";
		argv[dhcpc_idx++] = NULL;
	}

	TRACE(STA_SCRIPT, "%s %s %s %s ", DHCPC, argv[1], argv[2], argv[3]);
	TRACE(STA_SCRIPT, "%s %s %s\n", argv[4], argv[5], argv[6]);
	do_nice_cmd(DHCPC, argv, 0);

	return 1;
}

int reWriteAllDhcpcScript()
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	char wanif[IFNAMSIZ];
	unsigned char value[32];

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < entryNum; i++) {
		/* Retrieve entry */
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
			printf("reWriteAllDhcpcScript: cannot get ATM_VC_TBL(ch=%d) entry\n", i);
			return 0;
		}

		if ((DHCP_T)Entry.ipDhcp == DHCP_CLIENT)
		{
			ifGetName(PHY_INTF(Entry.ifIndex),wanif,sizeof(wanif));
			snprintf(value, 32, "%s.%s", (char *)DHCPC_SCRIPT_NAME, wanif);
			write_to_dhcpc_script(value, &Entry, 0);
		}

	}
}

int clean_SourceRoute(MIB_CE_ATM_VC_Tp pEntry)
{
	//char buff2[128];
	int32_t tbl_id;
	char str_tblid[10]="";

	if ( ((pEntry->cmode == CHANNEL_MODE_RT1483) || (pEntry->cmode == CHANNEL_MODE_IPOE) || (pEntry->cmode == CHANNEL_MODE_PPPOE) || (pEntry->cmode == CHANNEL_MODE_PPPOA))
	    && (pEntry->dgw== 0))
	{
		tbl_id = caculate_tblid_ITF_SourceRoute(pEntry->ifIndex);
		snprintf(str_tblid, sizeof(str_tblid), "%d", tbl_id);

		//ip route flush table 64
		va_cmd("/bin/ip", 4, 1, "route", "flush", "table", str_tblid);
		// ip rule del table 64 for fwmark
		va_cmd("/bin/ip", 4, 1, "rule", "del", "table", str_tblid);
	}
	return 0;
}

int cleanAll_SourceRoute()
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < entryNum; i++) {
		/* Retrieve entry */
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
			printf("cleanAll_SourceRoute: cannot get ATM_VC_TBL(ch=%d) entry\n", i);
			return 0;
		}

		clean_SourceRoute(&Entry);
	}
}

#define BRNF_MODULE_MAC_FILTER	(0x01 << 0)
#define BRNF_MODULE_URLBLOCK		(0x01 << 1)
/*
  * Unified Control functio for Brctl brnf on/off
  * trigger : 0-> off,  1 -> on
  * module, the module identifier, must be in format of (0x1 << x)
*/
static void brnfctrl(int trigger, int module)
{
	static unsigned int br_nf_flag = 0;
	int total = 0;
	int	orig;

	orig = br_nf_flag;
	total = ifWanNum("br");

	if (total == 0)//no WAN in bridge mode
	{
		if (br_nf_flag!=0)
			va_cmd("/bin/brctl", 2, 0, "brnf", "off");
		br_nf_flag = 0;
		return;
	}


	if (trigger == 0){
		br_nf_flag = br_nf_flag & (~module);
		if ((orig != 0)&&(br_nf_flag == 0))
			va_cmd("/bin/brctl", 2, 0, "brnf", "off");
	}
	else {
		br_nf_flag = br_nf_flag | module;
		if ((orig == 0)&& (br_nf_flag != 0))
			va_cmd("/bin/brctl", 2, 0, "brnf", "on");
	}


}

#ifdef ADDRESS_MAPPING
#ifdef MULTI_ADDRESS_MAPPING
static int GetIP_AddressMap(MIB_CE_MULTI_ADDR_MAPPING_LIMIT_T *entry, ADDRESSMAP_IP_T *ip_info)
{
	unsigned char value[32];

        // Get Local Start IP
	if (((struct in_addr *)entry->lsip)->s_addr != 0)
	{
		strncpy(ip_info->lsip, inet_ntoa(*((struct in_addr *)entry->lsip)), 16);
		ip_info->lsip[15] = '\0';
	}
	else
		ip_info->lsip[0] = '\0';


	// Get Local End IP
	if (((struct in_addr *)entry->leip)->s_addr != 0)
	{
		strncpy(ip_info->leip, inet_ntoa(*((struct in_addr *)entry->leip)), 16);
		ip_info->leip[15] = '\0';
	}
	else
		ip_info->leip[0] = '\0';

	// Get Global Start IP
	if (((struct in_addr *)entry->gsip)->s_addr != 0)
	{
		strncpy(ip_info->gsip, inet_ntoa(*((struct in_addr *)entry->gsip)), 16);
		ip_info->gsip[15] = '\0';
	}
	else
		ip_info->gsip[0] = '\0';

	// Get Global End IP
	if (((struct in_addr *)entry->geip)->s_addr != 0)
	{
		strncpy(ip_info->geip, inet_ntoa(*((struct in_addr *)entry->geip)), 16);
		ip_info->geip[15] = '\0';
	}
	else
		ip_info->geip[0] = '\0';

	sprintf(ip_info->srcRange, "%s-%s", ip_info->lsip, ip_info->leip);
	sprintf(ip_info->globalRange, "%s-%s", ip_info->gsip, ip_info->geip);
//	printf( "\r\nGetIP_AddressMap %s-%s", ip_info->lsip, ip_info->leip);
//	printf( "\r\nGetIP_AddressMap %s-%s", ip_info->gsip, ip_info->geip);
	return 1;
}
#else //!MULTI_ADDRESS_MAPPING
static int GetIP_AddressMap(ADDRESSMAP_IP_T *ip_info)
{
	unsigned char value[32];

        // Get Local Start IP
        if (mib_get(MIB_LOCAL_START_IP, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(ip_info->lsip, inet_ntoa(*((struct in_addr *)value)), 16);
			ip_info->lsip[15] = '\0';
		}
		else
			ip_info->lsip[0] = '\0';
	}

	// Get Local End IP
        if (mib_get(MIB_LOCAL_END_IP, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(ip_info->leip, inet_ntoa(*((struct in_addr *)value)), 16);
			ip_info->leip[15] = '\0';
		}
		else
			ip_info->leip[0] = '\0';
	}

	// Get Global Start IP
	if (mib_get(MIB_GLOBAL_START_IP, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(ip_info->gsip, inet_ntoa(*((struct in_addr *)value)), 16);
			ip_info->gsip[15] = '\0';
		}
		else
			ip_info->gsip[0] = '\0';
	}

	// Get Global End IP
	if (mib_get(MIB_GLOBAL_END_IP, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(ip_info->geip, inet_ntoa(*((struct in_addr *)value)), 16);
			ip_info->geip[15] = '\0';
		}
		else
			ip_info->geip[0] = '\0';
	}

	sprintf(ip_info->srcRange, "%s-%s", ip_info->lsip, ip_info->leip);
	sprintf(ip_info->globalRange, "%s-%s", ip_info->gsip, ip_info->geip);

	return 1;
}
#endif //end of !MULTI_ADDRESS_MAPPING
#endif


// Setup one NAT rule for a specfic interface
static int startAddressMap(MIB_CE_ATM_VC_Tp pEntry)
{
	char wanif[IFNAMSIZ];
	char myip[16];
#ifdef ADDRESS_MAPPING
	ADDRESSMAP_IP_T ip_info;
#ifdef MULTI_ADDRESS_MAPPING
	MIB_CE_MULTI_ADDR_MAPPING_LIMIT_T		entry;
	int		i,entryNum;


#else // ! MULTI_ADDRESS_MAPPING
	char vChar;
	ADSMAP_T mapType;

	GetIP_AddressMap(&ip_info);

	mib_get( MIB_ADDRESS_MAP_TYPE,  (void *)&vChar);
        mapType = (ADSMAP_T)vChar;
#endif  //end of !MULTI_ADDRESS_MAPPING
#endif

	if ( !pEntry->enable || ((DHCP_T)pEntry->ipDhcp != DHCP_DISABLED)
		|| ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_BRIDGE)
		|| ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOE)
		|| ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOA)
		|| (!pEntry->napt)
		)
		return -1;

	//snprintf(wanif, 6, "vc%u", VC_INDEX(pEntry->ifIndex));
	ifGetName( PHY_INTF(pEntry->ifIndex), wanif, sizeof(wanif));
	strncpy(myip, inet_ntoa(*((struct in_addr *)pEntry->ipAddr)), 16);
	myip[15] = '\0';

#ifdef ADDRESS_MAPPING
#ifdef MULTI_ADDRESS_MAPPING
	entryNum = mib_chain_total(MULTI_ADDRESS_MAPPING_LIMIT_TBL);

	for (i = 0; i<entryNum; i++)
	{
		mib_chain_get(MULTI_ADDRESS_MAPPING_LIMIT_TBL, i, &entry);
		GetIP_AddressMap(&entry, &ip_info);

		// add customized mapping
		if ( entry.addressMapType == ADSMAP_ONE_TO_ONE ) {
			va_cmd(IPTABLES, 12, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-s", ip_info.lsip,
				ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.gsip);

		}
		else if ( entry.addressMapType == ADSMAP_MANY_TO_ONE ) {
			va_cmd(IPTABLES, 14, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-m", "iprange", "--src-range", ip_info.srcRange,
				ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.gsip);

		}
		else if ( entry.addressMapType == ADSMAP_MANY_TO_MANY ) {
			va_cmd(IPTABLES, 14, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-m", "iprange", "--src-range", ip_info.srcRange,
				ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.globalRange);

		}
		else if ( entry.addressMapType == ADSMAP_ONE_TO_MANY ) {
			va_cmd(IPTABLES, 12, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-s", ip_info.lsip,
				ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.globalRange);
		}

	}
#else //!MULTI_ADDRESS_MAPPING
	// add customized mapping
	if ( mapType == ADSMAP_ONE_TO_ONE ) {
		va_cmd(IPTABLES, 12, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-s", ip_info.lsip,
			ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.gsip);

	}
	else if ( mapType == ADSMAP_MANY_TO_ONE ) {
		va_cmd(IPTABLES, 14, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-m", "iprange", "--src-range", ip_info.srcRange,
			ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.gsip);

	}
	else if ( mapType == ADSMAP_MANY_TO_MANY ) {
		va_cmd(IPTABLES, 14, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-m", "iprange", "--src-range", ip_info.srcRange,
			ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.globalRange);

	}
	// Mason Yu on True
#if 1
	else if ( mapType == ADSMAP_ONE_TO_MANY ) {
		va_cmd(IPTABLES, 12, 1, "-t", "nat", FW_ADD, "POSTROUTING", "-s", ip_info.lsip,
			ARG_O, wanif, "-j", "SNAT", "--to-source", ip_info.globalRange);

	}
#endif
#endif //end of !MULTI_ADDRESS_MAPPING
#endif
	// add default mapping
	va_cmd(IPTABLES, 10, 1, "-t", "nat", FW_ADD, "POSTROUTING",
		ARG_O, wanif, "-j", "SNAT", "--to-source", myip);
}

// Delete one NAT rule for a specfic interface
static void stopAddressMap(MIB_CE_ATM_VC_Tp pEntry)
{
	char *argv[16];
	char wanif[IFNAMSIZ];
	char myip[16];

#ifdef ADDRESS_MAPPING
	ADDRESSMAP_IP_T ip_info;
#ifdef MULTI_ADDRESS_MAPPING
	MIB_CE_MULTI_ADDR_MAPPING_LIMIT_T		entry;
	int		i,entryNum;


#else //MULTI_ADDRESS_MAPPING
	char vChar;
	ADSMAP_T mapType;

	GetIP_AddressMap(&ip_info);

	mib_get( MIB_ADDRESS_MAP_TYPE,  (void *)&vChar);
        mapType = (ADSMAP_T)vChar;
#endif //!MULTI_ADDRESS_MAPPING
#endif

	if ( !pEntry->enable || ((DHCP_T)pEntry->ipDhcp != DHCP_DISABLED)
		|| ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_BRIDGE)
		|| ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOE)
		|| ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOA)
		|| (!pEntry->napt)
		)
		return;

	//snprintf(wanif, 6, "vc%u", VC_INDEX(pEntry->ifIndex));
	ifGetName( PHY_INTF(pEntry->ifIndex), wanif, sizeof(wanif));
	strncpy(myip, inet_ntoa(*((struct in_addr *)pEntry->ipAddr)), 16);
	myip[15] = '\0';

	if (pEntry->cmode != CHANNEL_MODE_BRIDGE && pEntry->napt == 1)
	{	// Enable NAPT
		argv[1] = "-t";
		argv[2] = "nat";
		argv[3] = (char *)FW_DEL;
		argv[4] = "POSTROUTING";

		// remove default mapping
		argv[5] = "-o";
		argv[6] = wanif;
		argv[7] = "-j";
		if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
			strncpy(myip, inet_ntoa(*((struct in_addr *)pEntry->ipAddr)), 16);
			myip[15] = '\0';
			argv[8] = "SNAT";
			argv[9] = "--to-source";
			argv[10] = myip;
			argv[11] = NULL;
		}
		else {
			argv[8] = "MASQUERADE";
			argv[9] = NULL;
		}
		do_cmd(IPTABLES, argv, 1);

#ifdef ADDRESS_MAPPING
#ifdef MULTI_ADDRESS_MAPPING
		entryNum = mib_chain_total(MULTI_ADDRESS_MAPPING_LIMIT_TBL);

		for (i = 0; i<entryNum; i++)
		{
			mib_chain_get(MULTI_ADDRESS_MAPPING_LIMIT_TBL, i, &entry);
			GetIP_AddressMap(&entry, &ip_info);

			// remove customized mapping
			if ( entry.addressMapType  == ADSMAP_ONE_TO_ONE ) {
				argv[5] = "-s";
				argv[6] = ip_info.lsip;
				argv[7] = "-o";
				argv[8] = wanif;
				argv[9] = "-j";
				if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
					argv[10] = "SNAT";
					argv[11] = "--to-source";
					argv[12] = ip_info.gsip;
					argv[13] = NULL;
				}
				else {
					argv[8] = "MASQUERADE";
					argv[9] = NULL;
				}

			} else if ( entry.addressMapType  == ADSMAP_MANY_TO_ONE ) {

				argv[5] = "-m";
				argv[6] = "iprange";
				argv[7] = "--src-range";
				argv[8] = ip_info.srcRange;
				argv[9] = "-o";
				argv[10] = wanif;
				argv[11] = "-j";

				if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
					argv[12] = "SNAT";
					argv[13] = "--to-source";
					argv[14] = ip_info.gsip;
					argv[15] = NULL;
				}
				else {
					argv[8] = "MASQUERADE";
					argv[9] = NULL;
				}

			} else if ( entry.addressMapType  == ADSMAP_MANY_TO_MANY ) {
				argv[5] = "-m";
				argv[6] = "iprange";
				argv[7] = "--src-range";
				argv[8] = ip_info.srcRange;
				argv[9] = "-o";
				argv[10] = wanif;
				argv[11] = "-j";
				if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
					argv[12] = "SNAT";
					argv[13] = "--to-source";
					argv[14] = ip_info.globalRange;
					argv[15] = NULL;
				}
				else {
					argv[8] = "MASQUERADE";
					argv[9] = NULL;
				}

			}

			else if ( entry.addressMapType  == ADSMAP_ONE_TO_MANY ) {
				argv[5] = "-s";
				argv[6] = ip_info.lsip;
				argv[7] = "-o";
				argv[8] = wanif;
				argv[9] = "-j";
				if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
					argv[10] = "SNAT";
					argv[11] = "--to-source";
					argv[12] = ip_info.globalRange;
					argv[13] = NULL;
				}
				else {
					argv[8] = "MASQUERADE";
					argv[9] = NULL;
				}
			}

			else
				return;
			TRACE(STA_SCRIPT, "%s %s %s %s %s ", IPTABLES, argv[1], argv[2], argv[3], argv[4]);
			TRACE(STA_SCRIPT, "%s %s %s %s\n", argv[5], argv[6], argv[7], argv[8]);
			do_cmd(IPTABLES, argv, 1);
		}
#else //!MULTI_ADDRESS_MAPPING
		// remove customized mapping
		if ( mapType == ADSMAP_ONE_TO_ONE ) {
			argv[5] = "-s";
			argv[6] = ip_info.lsip;
			argv[7] = "-o";
			argv[8] = wanif;
			argv[9] = "-j";
			if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
				argv[10] = "SNAT";
				argv[11] = "--to-source";
				argv[12] = ip_info.gsip;
				argv[13] = NULL;
			}
			else {
				argv[8] = "MASQUERADE";
				argv[9] = NULL;
			}

		} else if ( mapType == ADSMAP_MANY_TO_ONE ) {
			argv[5] = "-m";
			argv[6] = "iprange";
			argv[7] = "--src-range";
			argv[8] = ip_info.srcRange;
			argv[9] = "-o";
			argv[10] = wanif;
			argv[11] = "-j";
			if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
				argv[12] = "SNAT";
				argv[13] = "--to-source";
				argv[14] = ip_info.gsip;
				argv[15] = NULL;
			}
			else {
				argv[8] = "MASQUERADE";
				argv[9] = NULL;
			}

		} else if ( mapType == ADSMAP_MANY_TO_MANY ) {
			argv[5] = "-m";
			argv[6] = "iprange";
			argv[7] = "--src-range";
			argv[8] = ip_info.srcRange;
			argv[9] = "-o";
			argv[10] = wanif;
			argv[11] = "-j";
			if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
				argv[12] = "SNAT";
				argv[13] = "--to-source";
				argv[14] = ip_info.globalRange;
				argv[15] = NULL;
			}
			else {
				argv[8] = "MASQUERADE";
				argv[9] = NULL;
			}

		}

		// Msason Yu on True
#if 1
		else if ( mapType == ADSMAP_ONE_TO_MANY ) {
			argv[5] = "-s";
			argv[6] = ip_info.lsip;
			argv[7] = "-o";
			argv[8] = wanif;
			argv[9] = "-j";
			if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED) {
				argv[10] = "SNAT";
				argv[11] = "--to-source";
				argv[12] = ip_info.globalRange;
				argv[13] = NULL;
			}
			else {
				argv[8] = "MASQUERADE";
				argv[9] = NULL;
			}
		}
#endif
		else
			return;
		TRACE(STA_SCRIPT, "%s %s %s %s %s ", IPTABLES, argv[1], argv[2], argv[3], argv[4]);
		TRACE(STA_SCRIPT, "%s %s %s %s\n", argv[5], argv[6], argv[7], argv[8]);
		do_cmd(IPTABLES, argv, 1);

#endif //end of !MULTI_ADDRESS_MAPPING
#endif // of ADDRESS_MAPPING
	}

}

// Config all NAT rules.
// If action= ACT_STOP, delete all NAT rules.
// If action= ACT_START, setup all NAT rules.
void config_AddressMap(int action)
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	char wanif[6];
	char myip[16];

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < entryNum; i++) {
		/* Retrieve entry */
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
			printf("restartAddressMap: cannot get ATM_VC_TBL(ch=%d) entry\n", i);
			return;
		}

		if (Entry.enable == 0)
			continue;
		if ( action == ACT_STOP )
			stopAddressMap(&Entry);
		else if ( action == ACT_START) {
			startAddressMap(&Entry);
		}
	}

	if ( action == ACT_START) {
		va_cmd("/bin/ethctl", 2, 1, "conntrack", "killall");
	}

}

int startIP_v4(char *inf, MIB_CE_ATM_VC_Tp pEntry, CHANNEL_MODE_T ipEncap)
{
	char myip[16], remoteip[16], netmask[16];
#ifdef IP_PASSTHROUGH
	unsigned int ippt_itf;
	int ippt=0;
	struct in_addr net;
	char netip[16];
#endif
#ifdef DEFAULT_GATEWAY_V2
	unsigned int dgw;
	int isdgw = 0;
#endif
	FILE *fp;
	// Mason Yu
	unsigned int broadcastIpAddr;
	char broadcast[16];

#ifdef IP_PASSTHROUGH
	// check IP passthrough
	if (mib_get(MIB_IPPT_ITF, (void *)&ippt_itf) != 0)
	{
		if (ippt_itf == pEntry->ifIndex)
			ippt = 1; // this interface enable the IP passthrough
	}
#endif

#ifdef DEFAULT_GATEWAY_V2
	// Jenny, check default gateway
	if (mib_get(MIB_ADSL_WAN_DGW_ITF, (void *)&dgw) != 0)
	{
		if (dgw == pEntry->ifIndex)
			isdgw = 1; // this interface is default gateway
	}
#endif

	if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED)
	{
		if (!get_net_link_status(inf))
			return 0;
		// ifconfig vc0 ipaddr
		//strncpy(myip, inet_ntoa(*((struct in_addr *)pEntry->ipAddr)), 16);
		//convertIPAddrToString(*(unsigned int *)pEntry->ipAddr, myip);
		inet_ntop(AF_INET, pEntry->ipAddr, myip, INET_ADDRSTRLEN);
		myip[15] = '\0';
		//strncpy(remoteip, inet_ntoa(*((struct in_addr *)pEntry->remoteIpAddr)), 16);
		//convertIPAddrToString(*(unsigned int *)pEntry->remoteIpAddr, remoteip);
		inet_ntop(AF_INET, pEntry->remoteIpAddr, remoteip, INET_ADDRSTRLEN);
		remoteip[15] = '\0';
		//strncpy(netmask, inet_ntoa(*((struct in_addr *)pEntry->netMask)), 16);
		//convertIPAddrToString(*(unsigned int *)pEntry->netMask, netmask);
		inet_ntop(AF_INET, pEntry->netMask, netmask,INET_ADDRSTRLEN);
		netmask[15] = '\0';
		// Mason Yu
		broadcastIpAddr = ((struct in_addr *)pEntry->ipAddr)->s_addr | ~(((struct in_addr *)pEntry->netMask)->s_addr);
		//strncpy(broadcast, inet_ntoa(*((struct in_addr *)&broadcastIpAddr)), 16);
		//convertIPAddrToString(broadcastIpAddr, broadcast);
		inet_ntop(AF_INET, &broadcastIpAddr, broadcast, INET_ADDRSTRLEN);
		broadcast[15] = '\0';
		if (ipEncap == CHANNEL_MODE_RT1483)
		{
#ifdef IP_PASSTHROUGH
			if (!ippt)
			{
#endif
				if (pEntry->ipunnumbered)	// Jenny, for IP unnumbered determination temporarily
					va_cmd(IFCONFIG, 8, 1, inf, "10.0.0.1", "-arp",
						"-broadcast", "pointopoint", "10.0.0.2",
						"netmask", ARG_255x4);
				else
					// ifconfig vc0 myip -arp -broadcast pointopoint
					//   remoteip netmask 255.255.255.255
					va_cmd(IFCONFIG, 8, 1, inf, myip, "-arp",
						"-broadcast", "pointopoint", remoteip,
//						"netmask", netmask);	// Jenny, subnet mask added
						"netmask", ARG_255x4);
#ifdef IP_PASSTHROUGH
			}
			else	// IP passthrough
			{
				// ifconfig vc0 10.0.0.1 -arp -broadcast pointopoint
				//   10.0.0.2 netmask 255.255.255.255
				va_cmd(IFCONFIG, 8, 1, inf, "10.0.0.1", "-arp",
					"-broadcast", "pointopoint", "10.0.0.2",				// Jenny, for IP passthrough determination temporarily
					"netmask", netmask);
//				va_cmd(IFCONFIG, 8, 1, inf, "10.0.0.1", "-arp",
//					"-broadcast", "pointopoint", "10.0.0.2",
//					"netmask", ARG_255x4);
				// ifconfig br0:1 remoteip
				va_cmd(IFCONFIG, 2, 1, LAN_IPPT, remoteip);

				// Mason Yu. Add route for Public IP
               	net.s_addr = (((struct in_addr *)pEntry->remoteIpAddr)->s_addr) & (((struct in_addr *)pEntry->netMask)->s_addr);
               	//strncpy(netip, inet_ntoa(net), 16);
				//convertIPAddrToString(net.s_addr, netip);
				inet_ntop(AF_INET, &net, netip, INET_ADDRSTRLEN);
				netip[15] = '\0';
				va_cmd(ROUTE, 7, 1, ARG_DEL, "-net", netip, "netmask", netmask, "dev", LANIF);
				va_cmd(ROUTE, 5, 1, ARG_ADD, "-host", myip, "dev", LANIF);

				// write ip to file for DHCP server
				if (fp = fopen(IPOA_IPINFO, "w"))
				{
					fwrite( pEntry->ipAddr, 4, 1, fp);
					fwrite( pEntry->remoteIpAddr, 4, 1, fp);
					fwrite( pEntry->netMask, 4, 1, fp);
					fclose(fp);
				}
			}
#endif
#ifdef DEFAULT_GATEWAY_V2
			if (isdgw)
#else
			if (pEntry->dgw)
#endif
			{
#ifdef DEFAULT_GATEWAY_V2
				if (ifExistedDGW() == 1)	// Jenny, delete existed default gateway first
					va_cmd(ROUTE, 2, 1, ARG_DEL, "default");
#endif
				// route add default vc0
				va_cmd(ROUTE, 3, 1, ARG_ADD, "default", inf);
				//va_cmd(ROUTE, 4, 1, ARG_ADD, "default", "gw", remoteip);
			}
		}
		else
		{
			// Mason Yu. Set netmask and broadcast
			// ifconfig vc0 myip
			//va_cmd(IFCONFIG, 2, 1, inf, myip);

			va_cmd(IFCONFIG, 6, 1, inf, myip, "netmask", netmask, "broadcast",  broadcast);

#ifdef DEFAULT_GATEWAY_V2
			if (isdgw)
#else
			if (pEntry->dgw)
#endif
			{
#ifdef DEFAULT_GATEWAY_V2
					if (ifExistedDGW() == 1)	// Jenny, delete existed default gateway first
						va_cmd(ROUTE, 2, 1, ARG_DEL, "default");
#endif
				// route add default gw remotip
				va_cmd(ROUTE, 4, 1, ARG_ADD, "default", "gw", remoteip);
			}
			if (ipEncap == CHANNEL_MODE_IPOE) {
				unsigned char value[32];
				snprintf(value, 32, "%s.%s", (char *)MER_GWINFO, inf);
				if (fp = fopen(value, "w"))
				{
					fprintf(fp, "%s\n", remoteip);
					fclose(fp);
				}
			}
		}
	}
	else
	{
		int dhcpc_pid;
		unsigned char value[32];
		// Enabling support for a dynamically assigned IP (ISP DHCP)...
		va_cmd(IPTABLES, 16, 1, FW_ADD, FW_INPUT, ARG_I, inf, "-p",
			ARG_UDP, FW_DPORT, "69", "-d", ARG_255x4, "-m",
			"state", "--state", "NEW", "-j", FW_ACCEPT);

		if (fp = fopen(PROC_DYNADDR, "w"))
		{
			fprintf(fp, "1\n");
			fclose(fp);
		}
		else
		{
			printf("Open file %s failed !\n", PROC_DYNADDR);
		}

		snprintf(value, 32, "%s.%s", (char*)DHCPC_PID, inf);
		dhcpc_pid = read_pid((char*)value);
		if (dhcpc_pid > 0)
			kill(dhcpc_pid, SIGTERM);
		if (startDhcpc(inf, pEntry, 0) == -1)
		{
			printf("start DHCP client failed !\n");
		}
	}


#ifdef ROUTING
	// When interface IP reset, the static route will also be reseted.
	deleteStaticRoute_per_wan(pEntry->ifIndex);
	addStaticRoute_per_wan(pEntry->ifIndex);
#endif
	set_static_source_route(pEntry);

	return 1;
}
// IP interface: 1483-r or MER
// return value:
// 1  : successful
int startIP(char *inf, MIB_CE_ATM_VC_Tp pEntry, CHANNEL_MODE_T ipEncap)
{
	unsigned char buffer[7];

	// Set MTU for 1483-r or MER
	sprintf(buffer, "%u", pEntry->mtu);
	va_cmd(IFCONFIG,3,1,inf, "mtu", buffer);

#ifdef CONFIG_IPV6
	if (pEntry->IpProtocol & IPVER_IPV4) {
#endif
		startIP_v4(inf, pEntry, ipEncap);
#ifdef CONFIG_IPV6
	}
	if (pEntry->IpProtocol & IPVER_IPV6)
		startIP_for_V6(pEntry);
#endif
	return 1;
}

#ifdef _PRMT_X_CMCC_IPOEDIAGNOSTICS_
int ipoe_diag_debug = 1;

static int ipoe_diag_is_ip_got()
{
	FILE *fp = fopen(IPOE_DIAG_RESULT_DHCPC_FILE, "r");
	char line[256] = {0};
	int ret = 0;

	if(fp == NULL)
		return 0;

	if(fgets(line, sizeof(line), fp) == NULL || strstr(line, "OK") == NULL)
		ret = 0;
	else
		ret = 1;

	fclose(fp);
	return ret;
}

static int ipoe_diag_do_ping(char *ifname, char *ping_host, unsigned int repitation, unsigned int timeout)
{
	char cmdstr[256] = {0};

	if(ifname == NULL || ping_host == NULL)
		return -1;

	sprintf(cmdstr, "/bin/ping -4 -I %s", ifname);

	if (repitation)
		sprintf(cmdstr, "%s -c %d", cmdstr, repitation);

	if (timeout > 1000)
		sprintf(cmdstr, "%s -W %d", cmdstr, timeout/1000);

	sprintf(cmdstr, "%s %s", cmdstr, ping_host);

	sprintf(cmdstr, "%s > "IPOE_DIAG_RESULT_PING_FILE" 2>&1", cmdstr);

	fprintf(stderr, "<%s:%d> ping cmdstr=%s\n", __FUNCTION__, __LINE__, cmdstr);
	system(cmdstr);

	return 0;
}


/*
Manual start the IPoE simulation.
	ifIndex: ifIndex of the WAN interface to do simulation.
	ping_host: Host to ping after IP address is got.
	repitation: dial ppp password, NULL if no password
	timeout: ping timeout in ms

return :
	 0 : - start success
	-1 : - parameter invalid, null point.
	-2 : - mib operator failed
	-3 : - devname invalid, no such wan
*/
int ipoeSimulationStart(int ifIndex, unsigned char *mac, char* ping_host, unsigned int repitation, unsigned int timeout)
{
	int i;
	int totalNum;
	MIB_CE_ATM_VC_T Entry;
	MIB_CE_ATM_VC_T simuEntry;
	unsigned char ipt = 0;
	char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
	char buff[256];
	struct sysinfo info;
	int simStartTime = 0;
	unsigned char zero[MAC_ADDR_LEN] = {0};
	int pid = -1;
	FILE  *fp = NULL;

	if(ipoe_diag_debug)
		fprintf(stderr, "[IPDiag] %s\n", __func__);
	if(mac == NULL || ping_host == NULL)
		return -1;

	if(memcmp(mac, zero, MAC_ADDR_LEN) == 0)
		return -1;

	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -2;

		if(Entry.enable == 0)
			continue;

		if(Entry.ifIndex == ifIndex)
			break;
	}

	if(i == totalNum)
	{
		fprintf(stderr, "[IPDiag] <%s:%d> ifIndex(%x) not found in ATM_VC_TBL\n", __func__, __LINE__, ifIndex);
		return -3;
	}

	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			return -2;

		if(simuEntry.ifIndex == ifIndex)
			break;
	}

	memcpy(&simuEntry, &Entry, sizeof(MIB_CE_ATM_VC_T));
	simuEntry.applicationtype = X_CT_SRV_INTERNET;
	simuEntry.cmode = CHANNEL_MODE_IPOE;
	simuEntry.IpProtocol = IPVER_IPV4;	//force IPv4 only
	simuEntry.mbs = 1;
	simuEntry.ipDhcp = DHCP_CLIENT;
	memcpy(simuEntry.MacAddr, mac, MAC_ADDR_LEN);
	if(i != totalNum)
		mib_chain_update(MIB_SIMU_ATM_VC_TBL, &simuEntry, i);
	else
		mib_chain_add(MIB_SIMU_ATM_VC_TBL, &simuEntry);

	//generate Simulation WAN
	ifGetName(ifIndex, ifname, IFNAMSIZ);
	snprintf(ifname_simu, IFNAMSIZ,  "%s_0", ifname);
#ifdef CONFIG_RTK_L34_ENABLE
	RG_Add_Simu_Trap_ACL(simuEntry.MacAddr, &simuEntry.cdvt);
	RG_add_simu_wan(&simuEntry, i);
	if(ipoe_diag_debug)
		fprintf(stderr, "[IPDiag] <%s:%d>ADD ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#endif
	addSimuEthWANdev(&simuEntry, 0);
	setup_simu_ethernet_config(&simuEntry, ifname_simu);
	unlink(IPOE_DIAG_RESULT_DHCPC_FILE);

	//OK, simulation dial.
	startDhcpc(ifname_simu, &simuEntry, 1);

	while(fopen(IPOE_DIAG_RESULT_DHCPC_FILE, "r") == NULL)
		sleep(1);

	if(ipoe_diag_debug)
		printf("IPoE diagnostics result got\n");

	if(ipoe_diag_is_ip_got())
		ipoe_diag_do_ping(ifname_simu, ping_host, repitation, timeout);

	//Clean
	snprintf(buff, sizeof(buff), "%s.%s", (char*)DHCPC_PID, ifname_simu);
	pid = read_pid(buff);
	if ( pid > 0){
		if(ipoe_diag_debug)
			printf("Send signal TERM to pid %d to kill thread.\n",pid);
		kill(pid, SIGTERM);
	}
	va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
	if(ipoe_diag_debug)
		printf("[IPDiag] <%s:%d>DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
	RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
	RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
	mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);

	return 0;
}

#endif

#ifdef CONFIG_NO_REDIAL
void startReconnect()
{
	unsigned char vChar;
	struct data_to_pass_st msg;
#ifdef _PRMT_X_CT_COM_RECON_
	mib_get( CWMP_CT_RECON_ENABLE, (void *)&vChar);
	if(vChar==1){
		snprintf(msg.data, BUF_SIZE, "spppctl noredial 0");
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
	}else{
		snprintf(msg.data, BUF_SIZE, "spppctl noredial 1");
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
	}
#endif
}
#endif //CONFIG_NO_REDIAL

// Jenny, stop PPP
void stopPPP(void)
{
	int i;
	char tp[10];
	struct data_to_pass_st msg;
#ifdef CONFIG_USER_PPPOMODEM
	for (i=0; i<(MAX_PPP_NUM+MAX_MODEM_PPPNUM); i++)
#else
	for (i=0; i<MAX_PPP_NUM; i++)
#endif //CONFIG_USER_PPPOMODEM
	{
		sprintf(tp, "ppp%d", i);
		if (find_ppp_from_conf(tp)) {
			snprintf(msg.data, BUF_SIZE, "spppctl del %u", i);
			TRACE(STA_SCRIPT, "%s\n", msg.data);
			write_to_pppd(&msg);
		}
	}
#ifdef CONFIG_USER_PPPOE_PROXY
	for (i=9; i<=13; i++)  //maximum pppoe session count is 5
	{
		sprintf(tp, "ppp%d", i);
		if (find_ppp_from_conf(tp)) {
			snprintf(msg.data, BUF_SIZE, "spppctl delproxyunit %d", i);
			TRACE(STA_SCRIPT, "%s\n", msg.data);
			write_to_pppd(&msg);
		}
	}
#endif
#ifdef CONFIG_USER_PPTP_CLIENT_PPTP
	for (i=9; i<=10; i++)
	{
		sprintf(tp, "ppp%d", i);
		if (find_ppp_from_conf(tp)) {
			snprintf(msg.data, BUF_SIZE, "spppctl del %d pptp 0", i);
			TRACE(STA_SCRIPT, "%s\n", msg.data);
			write_to_pppd(&msg);
		}
	}
#endif
#ifdef CONFIG_USER_L2TPD_L2TPD
	for (i=11; i<=12; i++)
	{
		sprintf(tp, "ppp%d", i);
		if (find_ppp_from_conf(tp)) {
			snprintf(msg.data, BUF_SIZE, "spppctl del %u l2tp 0", i);
			TRACE(STA_SCRIPT, "%s\n", msg.data);
			write_to_pppd(&msg);
		}
	}
#endif
}

// PPP connection
// Input: inf == "vc0","vc1", ...
// pppEncap: 0 : PPPoE, 1 : PPPoA
// return value:
// 1  : successful
int startPPP(char *inf, MIB_CE_ATM_VC_Tp pEntry, char *qos, CHANNEL_MODE_T pppEncap)
{
	char ifIdx[3], pppif[6], stimeout[7];
#ifdef IP_PASSTHROUGH
	unsigned int ippt_itf;
	int ippt=0;
#endif
	struct data_to_pass_st msg;
#ifdef DEFAULT_GATEWAY_V2
	unsigned int dgw;
	int isdgw = 0;
#endif
	int lastArg, pppinf, pppdbg = 0;

#ifdef IP_PASSTHROUGH
	// check IP passthrough
	if (mib_get(MIB_IPPT_ITF, (void *)&ippt_itf) != 0)
	{
		if (ippt_itf == pEntry->ifIndex)
			ippt = 1; // this interface enable the IP passthrough
	}
#endif

#ifdef DEFAULT_GATEWAY_V2
	// Jenny, check default gateway
	if (mib_get(MIB_ADSL_WAN_DGW_ITF, (void *)&dgw) != 0) {
#ifdef AUTO_PPPOE_ROUTE
		if (DGW_AUTO == dgw)
			isdgw = 1;
#endif
		if (dgw == pEntry->ifIndex)
			isdgw = 1; // this interface is default gateway
	}
#endif

	snprintf(ifIdx, 3, "%u", PPP_INDEX(pEntry->ifIndex));
	snprintf(pppif, 6, "ppp%u", PPP_INDEX(pEntry->ifIndex));

#ifdef CONFIG_IPV6
	if(pEntry->IpProtocol & IPVER_IPV6){
		char cmdBuf[100]={0};
		// kaotest
		char ppp_dev[IFNAMSIZ];

		// kaotest
		if (pppEncap == CHANNEL_MODE_PPPOE) {
			// disable IPv6 for ppp device
			ifGetName(PHY_INTF(pEntry->ifIndex), ppp_dev, sizeof(ppp_dev));
			setup_disable_ipv6(ppp_dev, 1);
		}

		setup_disable_ipv6(pppif, 0);
		/*	Enable autoconf when selected autoconf and accept default route in RA only when the WAN belong to default GW , IulianWu */
		if (pEntry->AddrMode & IPV6_WAN_AUTO) { /* If select SLAAC */
			sprintf(cmdBuf, "/bin/echo 1 > /proc/sys/net/ipv6/conf/%s/autoconf", pppif);
			system(cmdBuf);

			if((pEntry->applicationtype & (X_CT_SRV_INTERNET|X_CT_SRV_TR069|X_CT_SRV_VOICE/*|X_CT_SRV_SPECIAL_SERVICE_ALL*/)) && pEntry->cmode != CHANNEL_MODE_BRIDGE)
			{ /* Accept the deafult router in RA only on default GW */
				sprintf(cmdBuf, "/bin/echo 1 > /proc/sys/net/ipv6/conf/%s/accept_ra_defrtr", pppif);
			}
			else {
				sprintf(cmdBuf, "/bin/echo 0 > /proc/sys/net/ipv6/conf/%s/accept_ra_defrtr", pppif);
			}
			system(cmdBuf);
		}
		else {
			sprintf(cmdBuf, "/bin/echo 0 > /proc/sys/net/ipv6/conf/%s/autoconf", pppif);
			system(cmdBuf);
		}

		if (pEntry->Ipv6Dhcp) {/* If select DHCPv6	*/
			if((pEntry->applicationtype & (X_CT_SRV_INTERNET|X_CT_SRV_TR069|X_CT_SRV_VOICE/*|X_CT_SRV_SPECIAL_SERVICE_ALL*/)) && pEntry->cmode != CHANNEL_MODE_BRIDGE)
			{ /* Accept the deafult router in RA only on default GW */
				sprintf(cmdBuf, "/bin/echo 1 > /proc/sys/net/ipv6/conf/%s/accept_ra_defrtr", pppif);
			}
			else {
				sprintf(cmdBuf, "/bin/echo 0 > /proc/sys/net/ipv6/conf/%s/accept_ra_defrtr", pppif);
			}
			system(cmdBuf);
		}

		if (pEntry->AddrMode & IPV6_WAN_STATIC) { /* If select Static IPV6	*/
			sprintf(cmdBuf, "/bin/echo 0 > /proc/sys/net/ipv6/conf/%s/accept_ra_defrtr", pppif);
			system(cmdBuf);
		}
	}
	else
	{
		setup_disable_ipv6(pppif, 1);
	}
#endif


	if (pppEncap == CHANNEL_MODE_PPPOE)	// PPPoE
	{
		// Kaohj -- set pppoe txqueuelen to 0 to make it no queue as the queueing is
		//		just in the underlying vc interface
		// ifconfig ppp0 txqueuelen 0
		// tc qdisc replace dev ppp0 root pfifo
		// tc qdisc del dev ppp0 root
		va_cmd(IFCONFIG, 3, 1, pppif, "txqueuelen", "0");
		// workaround to remove default qdisc if any.
		va_cmd(TC, 6, 1, "qdisc", "replace", "dev", pppif, "root", "pfifo");
		va_cmd(TC, 5, 1, "qdisc", (char *)ARG_DEL, "dev", pppif, "root");
//#ifdef CONFIG_USER_PPPOE_PROXY
#if 0
              printf("enable pppoe proxy %d \n",pEntry->PPPoEProxyEnable);
              printf("maxuser = %d ...",pEntry->PPPoEProxyMaxUser);
             if(pEntry->PPPoEProxyEnable)
	    {
                FILE  *fp_pap;
                pppoe_proxy pp_proxy;
	         if ((fp_pap = fopen(PPPD_PAPFILE, "a+")) == NULL)
		  {
			printf("Open file %s failed !\n", PPPD_PAPFILE);
			return -1;
		  }
		  fprintf(fp_pap, "%s * \"%s\"  *\n", pEntry->pppUsername, pEntry->pppPassword);
		  fclose(fp_pap);

		  if(!has_pppoe_init){
				pp_proxy.cmd =PPPOE_PROXY_ENABLE;
				ppp_proxy_ioctl(&pp_proxy,SIOCPPPOEPROXY);
				has_pppoe_init =1;
		   }
		    pp_proxy.wan_unit =PPP_INDEX(pEntry->ifIndex) ;
		    pp_proxy.cmd =PPPOE_WAN_UNIT_SET;
		    strcpy(pp_proxy.user,pEntry->pppUsername);
		    strcpy(pp_proxy.passwd,pEntry->pppPassword);
		    pp_proxy.maxShareNum = pEntry->PPPoEProxyMaxUser;
		    ppp_proxy_ioctl(&pp_proxy,SIOCPPPOEPROXY);

         	    if (pEntry->napt == 1)
        	   {	// Enable NAPT
		      va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_ADD, "POSTROUTING",
			 "-o", pppif, "-j", "MASQUERADE");
        	    }


		   	return 1;
             }
#endif

		if (pEntry->pppCtype != MANUAL){	// Jenny
			// spppctl add 0 pppoe vc0 username USER password PASSWORD
			//         gw 1 mru xxxx acname xxx
			snprintf(msg.data, BUF_SIZE,
				"spppctl add %s pppoe %s username \"%s\" password \"%s\""
				" gw %d mru %d", ifIdx,
				inf, pEntry->pppUsername, pEntry->pppPassword,
#ifdef DEFAULT_GATEWAY_V2
				isdgw, pEntry->mtu);
#else
				pEntry->dgw, pEntry->mtu);
#endif
			if (strlen(pEntry->pppACName))
				snprintf(msg.data, BUF_SIZE, "%s acname %s", msg.data, pEntry->pppACName);
		}
		else {
			snprintf(msg.data, BUF_SIZE,
				"spppctl new %s pppoe %s username \"%s\" password \"%s\""
				" gw %d mru %d", ifIdx,
				inf, pEntry->pppUsername, pEntry->pppPassword,
#ifdef DEFAULT_GATEWAY_V2
				isdgw, pEntry->mtu);
#else
				pEntry->dgw, pEntry->mtu);
#endif
			if (strlen(pEntry->pppACName))
				snprintf(msg.data, BUF_SIZE, "%s acname %s", msg.data, pEntry->pppACName);
		}
#ifdef CONFIG_SPPPD_STATICIP
		// Jenny, set PPPoE static IP
		if (pEntry->pppIp) {
			unsigned long addr;
			addr = *((unsigned long *)pEntry->ipAddr);
			if (addr)
				snprintf(msg.data, BUF_SIZE, "%s staticip %x", msg.data, addr);
		}
#endif
#ifdef _CWMP_MIB_
		// Set Service Name
		if (strlen(pEntry->pppServiceName))
			snprintf(msg.data, BUF_SIZE, "%s servicename %s", msg.data, pEntry->pppServiceName);
#endif
#ifdef CONFIG_USER_PPPOE_PROXY
		snprintf(msg.data, BUF_SIZE, "%s proxy %d maxuser %d itfgroup %d", msg.data, pEntry->PPPoEProxyEnable, pEntry->PPPoEProxyMaxUser, pEntry->itfGroup);
#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_USER_PPPOE_PROXY) //Add acl rule for PPPoE proxy usage
		if(pEntry->PPPoEProxyEnable){
			printf("Add acl rule for PPPoE proxy usage.\n");
			RTK_RG_PPPoEProxy_ACL_Rule_Set(pEntry);
			if(pEntry->itfGroup > 0){
				system("echo 1 > /proc/rg/pppoe_proxy_only_for_binding_packet");
				printf("echo 1 > /proc/rg/pppoe_proxy_only_for_binding_packet\n");
			}else{
				system("echo 0 > /proc/rg/pppoe_proxy_only_for_binding_packet");
				printf("echo 0 > /proc/rg/pppoe_proxy_only_for_binding_packet\n");
			}
		}
#endif
#endif
	}

	// Set Authentication Method
	if ((PPP_AUTH_T)pEntry->pppAuth >= PPP_AUTH_PAP && (PPP_AUTH_T)pEntry->pppAuth <= PPP_AUTH_CHAP)
		snprintf(msg.data, BUF_SIZE, "%s auth %s", msg.data, ppp_auth[pEntry->pppAuth]);

#ifdef IP_PASSTHROUGH
	// Set IP passthrough
	snprintf(msg.data, BUF_SIZE, "%s ippt %d", msg.data, ippt);
#endif

	// set PPP debug
	pppdbg = pppdbg_get(PPP_INDEX(pEntry->ifIndex));
	snprintf(msg.data, BUF_SIZE, "%s debug %d", msg.data, pppdbg);

#ifdef _CWMP_MIB_
	// Set Auto Disconnect Timer
	if (pEntry->autoDisTime > 0)
		snprintf(msg.data, BUF_SIZE, "%s disctimer %d", msg.data, pEntry->autoDisTime);
	// Set Warn Disconnect Delay
	if (pEntry->warnDisDelay > 0)
		snprintf(msg.data, BUF_SIZE, "%s discdelay %d", msg.data, pEntry->warnDisDelay);
#endif

#ifdef CONFIG_IPV6
	snprintf(msg.data, BUF_SIZE, "%s ipt %u", msg.data, pEntry->IpProtocol - 1);
#endif

	if (pEntry->pppCtype == CONTINUOUS)	// Continuous
	{
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
		// set the ppp keepalive timeout
		snprintf(msg.data, BUF_SIZE,
			"spppctl katimer 100");
		TRACE(STA_SCRIPT, "%s\n", msg.data);

		write_to_pppd(&msg);
		printf("PPP Connection (Continuous)...\n");
	}
	else if (pEntry->pppCtype == CONNECT_ON_DEMAND)	// On-demand
	{
		snprintf(msg.data, BUF_SIZE, "%s timeout %u", msg.data, pEntry->pppIdleTime);
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
		printf("PPP Connection (On-demand)...\n");
	}
	else if (pEntry->pppCtype == MANUAL)	// Manual
	{
		// Jenny, for PPP connecting/disconnecting manually
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
		printf("PPP Connection (Manual)...\n");
	}

#ifdef CONFIG_NO_REDIAL
	startReconnect();
#endif
	return 1;
}

#ifdef CONFIG_SUPPORT_AUTO_DIAG
#define MAX_CH 8
int omcistate = 0;
int simu_debug = 1;
struct webserver_callout autoSimulation_ch[MAX_CH];
enum PPP_AUTODIAG_RESULT {
	DIAG_INPROCESS, 					// 0
	DIAG_TIMEOUT,						// 1
	DIAG_PARAMNEGOFAIL,					// 2
	DIAG_USERAUTHENTICATIONFAIL,		// 3
	DIAG_PARAMNEGOFAIL_IPV4,			// 4
	DIAG_PARAMNEGOFAIL_IPV6,			// 5
	DIAG_USERSTOP,						// 6
	DIAG_UNKNOWN,						// 7
	DIAG_SERVER_OUT_OF_RESOURCE_IPV6,	// 8
	DIAG_SUCCESS 						// 9
};
const char* resultArray[] =
{
	"inProcess",		//reserved.
	"Timeout",							// 1
	"ParamNegoFail",					// 2
	"UserAuthenticationFail",			// 3
	"ParamNegoFail_IPv4",				// 4
	"ParamNegoFail_IPv6",				// 5
	"UserStop",							// 6
	"unKnown",							// 7
	"ERROR_SERVER_OUT_OF_RESOURCES_IPv6",		// 8
	"Success"							// 9
};

#ifdef CONFIG_RTL_MULTI_ETH_WAN
void addSimuEthWANdev(MIB_CE_ATM_VC_Tp pEntry, int autosimu)
{
	MEDIA_TYPE_T mType;
	char ifname[IFNAMSIZ];
	int flag=0;

	ifGetName(PHY_INTF(pEntry->ifIndex), ifname, sizeof(ifname));
	snprintf(ifname, IFNAMSIZ,  "%s_%d", ifname, autosimu);
	mType = MEDIA_INDEX(pEntry->ifIndex);

	if(((mType == MEDIA_ETH) && (WAN_MODE & MODE_Ethernet)))
	{
		int tmp_group;
		char cmd_str[100];
		//const char smux_brg_cmd[]="/bin/ethctl addsmux bridge %s %s";
		//const char smux_pppoe_cmd[]="/bin/ethctl addsmux pppoe %s %s";
		const char smux_ipoe_cmd[]="/bin/ethctl addsmux ipoe %s %s";

		/*
		if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_BRIDGE)
			snprintf(cmd_str, 100, smux_brg_cmd, rootdev, ifname);
		else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_IPOE || (CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_6RD)
			snprintf(cmd_str, 100, smux_ipoe_cmd, rootdev, ifname);
		else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOE)
			snprintf(cmd_str, 100, smux_pppoe_cmd, rootdev, ifname);
		*/

		snprintf(cmd_str, 100, smux_ipoe_cmd, ALIASNAME_NAS0, ifname);
		if (pEntry->napt)
			strncat(cmd_str, " napt", 100);

		if (pEntry->vlan)
		{
			unsigned int vlantag;
			vlantag = (pEntry->vid|((pEntry->vprio) << 13));
			snprintf(cmd_str, 100, "%s vlan %d", cmd_str, vlantag );
		}
		if(simu_debug)
			printf("TRACE: %s\n", cmd_str);
		system(cmd_str);

		while(getInFlags(ifname, &flag)==0)
		{
			//wait the device created successly, Iulian Wu
			if(simu_debug)
				printf("Ethernet WAN not ready!\n");
			sleep(2);
		}
	}
}
#endif

int setup_simu_ethernet_config(MIB_CE_ATM_VC_Tp pEntry, char *wanif)
{
	char *argv[8];
	int status=0;
	unsigned char devAddr[MAC_ADDR_LEN];
	char macaddr[MAC_ADDR_LEN*2+1];

#if defined(CONFIG_LUNA) && defined(GEN_WAN_MAC)
	snprintf(macaddr, 13, "%02x%02x%02x%02x%02x%02x",
		pEntry->MacAddr[0], pEntry->MacAddr[1], pEntry->MacAddr[2], pEntry->MacAddr[3], pEntry->MacAddr[4], pEntry->MacAddr[5]);

	argv[1]=wanif;
	argv[2]="hw";
	argv[3]="ether";
	argv[4]=macaddr;
	argv[5]=NULL;

	if(simu_debug)
		TRACE(STA_SCRIPT, "%s %s %s %s %s\n", IFCONFIG, argv[1], argv[2], argv[3], argv[4]);
	status|=do_cmd(IFCONFIG, argv, 1);
#endif

#ifdef CONFIG_RTK_L34_ENABLE
	char sysbuf[128]={0};
	int wanPhyPort;
#if 0
	if(mib_get(MIB_WAN_PHY_PORT,(void *)&wanPhyPort)){
		sprintf( sysbuf, "/bin/echo %d nas0 > /proc/rtl8686gmac/dev_port_mapping",wanPhyPort );
	}
#else
	wanPhyPort = RG_get_wan_phyPortId();
	if(wanPhyPort!=-1){
		sprintf( sysbuf, "/bin/echo %d nas0 > /proc/rtl8686gmac/dev_port_mapping",wanPhyPort );
	}
#endif

	if(simu_debug)
		printf( "system(): %s\n", sysbuf );
	system(sysbuf);

	//Temporary solution for netlink event down/up that will let spppd has ubnormal behavior.
	sleep(1);
#endif
	// ifconfig nas0_0_0 txqueuelen 10
	argv[1] = wanif;
	argv[2] = "txqueuelen";
#ifdef NEW_IP_QOS_SUPPORT
	argv[3] = "100";
#else
	argv[3] = "10";
#endif
	argv[4] = NULL;
	if(simu_debug)
		TRACE(STA_SCRIPT, "%s %s %s %s\n", IFCONFIG, argv[1], argv[2], argv[3]);
	status|=do_cmd(IFCONFIG, argv, 1);
#ifdef CONFIG_IPV6
	// Disable ipv6 in bridge
	if (pEntry->cmode == CHANNEL_MODE_BRIDGE)
		setup_disable_ipv6(wanif, 1);
	else
	{
		// enable ipv6 if applicable
		if (pEntry->IpProtocol & IPVER_IPV6)
			setup_disable_ipv6(wanif, 0);
		else
			setup_disable_ipv6(wanif, 1);
	}
#endif
	// ifconfig vc0 up
	argv[2] = "up";
	argv[3] = NULL;
	if(simu_debug)
		TRACE(STA_SCRIPT, "%s %s %s\n", IFCONFIG, argv[1], argv[2]);
	status|=do_cmd(IFCONFIG, argv, 1);

	//ethctl setsmux nas0 nas0_0_7 carrier 1
	argv[1] = "setsmux";
	argv[2] = ALIASNAME_NAS0;
	argv[3] = wanif;
	argv[4] = "carrier";
	argv[5] = "1";
	argv[6] = NULL;
	status |= do_cmd("/bin/ethctl", argv, 1);

	return status;
}

#ifdef CONFIG_IPV6
/*
 *	generate the ifupv6_pppx script
 */
int generate_ifupv6_script_manual(char* wanif, MIB_CE_ATM_VC_Tp pEntry)
{
	FILE *fp;
	char ifup_path[32];
	int ret = 0;

	if(simu_debug)
		printf("[%s %d]wan=%s, cmode=%d, Ipv6Dhcp=%d, Ipv6DhcpRequest=%d\n", __func__, __LINE__, wanif, pEntry->cmode, pEntry->Ipv6Dhcp, pEntry->Ipv6DhcpRequest);

	snprintf(ifup_path, 32, "/var/ppp/ifupv6_ppp7");
	if (fp=fopen(ifup_path, "w+") )
	{
		unsigned char pidfile[30], leasefile[30];
		unsigned char value[256];

		fprintf(fp, "#!/bin/sh\n\n");
		if((CHANNEL_MODE_BRIDGE != pEntry->cmode)&&(pEntry->AddrMode == IPV6_WAN_DHCP))
		{
			//DHCPv6 only
			fprintf(fp, "/bin/echo 0 > /proc/sys/net/ipv6/conf/ppp7/autoconf\n");
		}
		else
		{
			// DHCPv6&SLAAC, or SLAAC only
			if(CHANNEL_MODE_BRIDGE != pEntry->cmode)
			{
			    fprintf(fp, "/bin/echo 1 > /proc/sys/net/ipv6/conf/ppp7/autoconf\n");
			}
			fprintf(fp, "/bin/echo 0 > /proc/sys/net/ipv6/conf/ppp7/forwarding\n");
		}
#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
		if(((1==pEntry->Ipv6Dhcp)||(0x2==(pEntry->Ipv6DhcpRequest&0x2)))
			||(CHANNEL_MODE_BRIDGE == pEntry->cmode))
		{
			// Start DHCPv6 client
			// dhclient -6 -sf /var/dhclient-script -lf /var/dhclient6-leases -pf /var/run/dhclient6.pid ppp0 -d -q -N -P
			snprintf(leasefile, 30, "/var/%s%s.leases", DHCPCV6STR, "ppp7");
			snprintf(pidfile, 30, "/var/run/%s%s.pid", DHCPCV6STR, "ppp7");
			snprintf(value, sizeof(value), "/bin/dhclient -6 -sf /etc/simu_dhclient_script -lf %s -pf %s %s -d -q", leasefile, pidfile, "ppp7");	//
			// Request Address
			if((0x1==(pEntry->Ipv6DhcpRequest&0x1))||(CHANNEL_MODE_BRIDGE == pEntry->cmode))
				snprintf(value, sizeof(value), "%s -N", value);
			// Request Prefix
			if((0x2==(pEntry->Ipv6DhcpRequest&0x2))
                ||(CHANNEL_MODE_BRIDGE == pEntry->cmode)
#ifdef DUAL_STACK_LITE
                ||((pEntry->dslite_enable == 1) && (pEntry->dslite_aftr_mode == IPV6_DSLITE_MODE_AUTO))
#endif
            )
            {
				snprintf(value, sizeof(value), "%s -P", value);
            }

			// If dslite enabled, using dhcpv6 option 64 to request AFTR.
#if defined(DUAL_STACK_LITE)
			if((pEntry->dslite_enable == 1) && (pEntry->dslite_aftr_mode == IPV6_DSLITE_MODE_AUTO)){
				char fconf[64] = {0};
				FILE *fp_conf;

				sprintf(fconf, "/var/dhclient6_%s.conf", "ppp7");
				fp_conf = fopen(fconf, "w");
				if(fp_conf)
				{
					fprintf(fp_conf, "option dhcp6.dslite code 64 = domain-list; \n");
					fprintf(fp_conf, "also request dhcp6.dslite; \n");
					fclose(fp_conf);
				}
				snprintf(value, sizeof(value), "%s -cf %s ", value, fconf);
			}
#endif
			snprintf(value, sizeof(value), "%s &\n", value);
			fprintf(fp, value);
		}
#endif
		fclose(fp);
		chmod(ifup_path, 484);
	}

	return ret;
}

static int generate_ifupv6_script_get_PD(char* wanif, MIB_CE_ATM_VC_Tp pEntry)
{
	FILE *fp;
	char ifup_path[32];
	int ret = 0;

	if(simu_debug)
		printf("[%s %d]wan=%s, cmode=%d, Ipv6Dhcp=%d, Ipv6DhcpRequest=%d\n", __func__, __LINE__, wanif, pEntry->cmode, pEntry->Ipv6Dhcp, pEntry->Ipv6DhcpRequest);

	snprintf(ifup_path, 32, "/var/ppp/ifupv6_ppp7");
	if (fp=fopen(ifup_path, "w+") )
	{
		unsigned char pidfile[30], leasefile[30];
		unsigned char value[256];

		fprintf(fp, "#!/bin/sh\n\n");
#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
		if(((1==pEntry->Ipv6Dhcp)||(0x2==(pEntry->Ipv6DhcpRequest&0x2)))
			||(CHANNEL_MODE_BRIDGE == pEntry->cmode))
		{
			// Start DHCPv6 client
			// dhclient -6 -sf /var/dhclient-script -lf /var/dhclient6-leases -pf /var/run/dhclient6.pid ppp0 -d -q -N -P
			snprintf(leasefile, 30, "/var/%s%s.leases", DHCPCV6STR, "ppp7");
			snprintf(pidfile, 30, "/var/run/%s%s.pid", DHCPCV6STR, "ppp7");
			snprintf(value, sizeof(value), "/bin/dhclient -6 -sf /etc/simu_dhclient_script -lf %s -pf %s %s -d -q", leasefile, pidfile, "ppp7");	//
			// Request Address
			if((1==pEntry->Ipv6Dhcp)||(CHANNEL_MODE_BRIDGE == pEntry->cmode))
			{
				FILE *f;
				char devname[IFNAMSIZ];
				unsigned int scope, flags;
				int mflag = 0;

				f = fopen("/proc/net/if_inet6", "r");
				if (f == NULL){
					fclose(fp);
					return 0;
				}

				while (fscanf(f, "%*32s %*08x %*02x %02x %02x %16s\n", &scope, &flags, devname) != EOF) {
					printf("[%s %d]scope=0x%02x, flags=0x%02x, devname=%s\n", __func__, __LINE__, scope, flags, devname);
					if ((!strcmp(devname, "ppp7"))&&(scope==0x0000U) &&((flags&0x40)!=0)) {
						mflag = 1;
						break;
					}
				}
				if(mflag==1)
				{
					snprintf(value, sizeof(value), "%s -N", value);
				}
				fclose(f);
			}
			// Request Prefix
			if((0x2==(pEntry->Ipv6DhcpRequest&0x2))
                ||(CHANNEL_MODE_BRIDGE == pEntry->cmode)
#ifdef DUAL_STACK_LITE
                ||((pEntry->dslite_enable == 1) && (pEntry->dslite_aftr_mode == IPV6_DSLITE_MODE_AUTO))
#endif
                )
                {
				    snprintf(value, sizeof(value), "%s -P", value);
                }

			// If dslite enabled, using dhcpv6 option 64 to request AFTR.
#if defined(DUAL_STACK_LITE)
			if((pEntry->dslite_enable == 1) && (pEntry->dslite_aftr_mode == IPV6_DSLITE_MODE_AUTO)){
				char fconf[64] = {0};
				FILE *fp;

				sprintf(fconf, "/var/dhclient6_%s.conf", "ppp7");
				fp = fopen(fconf, "w");
				if(fp)
				{
					fprintf(fp, "option dhcp6.dslite code 64 = domain-list; \n");
					fprintf(fp, "also request dhcp6.dslite; \n");
					fclose(fp);
				}
				snprintf(value, sizeof(value), "%s -cf %s ", value, fconf);
			}
#endif
			snprintf(value, sizeof(value), "%s &\n", value);

			fprintf(fp, value);
		}
#endif
		fclose(fp);
		chmod(ifup_path, 484);
	}

	return ret;
}
#endif

unsigned int getOptionFromleases(char* filename, char* iaprfix, char* dns, char* aftr)
{
	FILE* fp=NULL;
	char buff[256];
	char *p, *str, *dns1;
	char *saveptr;
	unsigned int tok = 0;

	if(!filename)
	{
		printf("[%s %d]filename==NULL\n", __func__, __LINE__);
		return 0;
	}
	fp = fopen(filename, "r");
	if(!fp)
	{
		printf("[%s %d]open(%s) failed\n", __func__, __LINE__, filename);
		return 0;
	}
	while(fgets(buff, 256, fp)!=NULL)
	{
		if((iaprfix!=NULL)&&((p=strstr(buff, "iaprefix"))!=NULL))
		{
			str = strtok_r(p, " ", &saveptr);
			if(str)
			{
				str = strtok_r(NULL, " ", &saveptr);
				if(str)
				{
					memcpy(iaprfix, str, 64);
					tok |= 1;
				}
			}
		}
		else if((dns!=NULL)&&((p=strstr(buff, "name-servers"))!=NULL))
		{
			p += 13;
			str = strtok_r(p, ";", &saveptr);
			dns1 = strtok_r(str, ",", &saveptr);	//in case two dns addr exist.
			memcpy(dns, dns1, 64);
			tok |= 2;
		}
		else if((aftr!=NULL)&&((p=strstr(buff, "dslite"))!=NULL))
		{
			str = strtok_r(p, "\"", &saveptr);
			if(str)
			{
				str = strtok_r(NULL, "\"", &saveptr);
				if(str)
				{
					str[strlen(str)-1] = '\0';
					memcpy(aftr, str, strlen(str));
					tok |= 4;
				}
			}
		}

		continue;
	}

	fclose(fp);
	return tok;
}

/*
Manual start the pppoe simulation.
username: dial ppp username, NULL if no username
	password: dial ppp password, NULL if no password
	ipv6AddrMode: 1 - SLAAC; 2 - DHCPv6

return :
	  0 : - start success
	-1 : - parameter invalid, null point.
	-2 : - mib operator failed
	-3 : - devname invalid, no such wan
*/
int pppoeSimulationStart(char* devname, char* username, char* password, int ipv6AddrMode)
{
	int i;
	int totalNum;
	MIB_CE_ATM_VC_T Entry;
	MIB_CE_ATM_VC_T simuEntry;
	unsigned char ipt = 0;
	char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
	char buff[256];
	struct data_to_pass_st msg;
	struct sysinfo info;
	int simStartTime = 0;
	int autosimu = 0;

	if(simu_debug)
		printf("[SIMU]pppoeSimulationStart\n");
	if(NULL == devname)
		return -1;

	//ipv6AddrMode = 0;
	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				return -2;

		if(Entry.enable == 0)
			continue;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(Entry.ifIndex), ifname, sizeof(ifname));
		if(!strncmp(devname, ifname, IFNAMSIZ))
		{
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			ipt = 0; // IPv4 only
#else
			ipt = Entry.IpProtocol - 1;
#endif
			/*
			if((Entry.cmode != CHANNEL_MODE_BRIDGE)&&(ipt>0))
			{
				// 1 - SLAAC; 2 - DHCPv6
				ipv6AddrMode = (Entry.AddrMode&0x1)?1:2;
			}
			*/
			break;
		}
	}

	if(i == totalNum)
	{
		if(simu_debug)
			printf("[%s %d][SIMU]dev(%s) not found in ATM_VC_TBL\n", __func__, __LINE__, devname);
		return -3;
	}

	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			return -2;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(simuEntry.ifIndex), ifname, sizeof(ifname));
		if((!strncmp(devname, ifname, IFNAMSIZ))&&(1 == simuEntry.mbs))
		{
			//duplicate...
			break;
		}
	}

	memcpy(&simuEntry, &Entry, sizeof(MIB_CE_ATM_VC_T));
	simuEntry.applicationtype = X_CT_SRV_INTERNET;
	simuEntry.cmode = CHANNEL_MODE_PPPOE;
	simuEntry.mbs = 1;
	simuEntry.MacAddr[MAC_ADDR_LEN-1] = (simuEntry.MacAddr[MAC_ADDR_LEN-1] + 8);
	simuEntry.MacAddr[MAC_ADDR_LEN-2]++;
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	simuEntry.IpProtocol = IPVER_IPV4; // IPv4 only
#endif
#if defined(ITF_GROUP) || defined(NEW_PORTMAPPING)
    simuEntry.itfGroup = 0;     //simu connection, no need to bind with any lan dev
#endif
    simuEntry.brmode = BRIDGE_DISABLE;
    simuEntry.ifIndex &= ~(0xFF<<8);
    simuEntry.ifIndex |= (7<<8);

	if(i != totalNum)
	{
		mib_chain_update(MIB_SIMU_ATM_VC_TBL, &simuEntry, i);
	}
	else
	{
		mib_chain_add(MIB_SIMU_ATM_VC_TBL, &simuEntry);
	}

	//generate Simulation WAN
	snprintf(ifname_simu, IFNAMSIZ,  "%s_%d", devname, autosimu);
#ifdef CONFIG_RTK_L34_ENABLE
	RG_Add_Simu_Trap_ACL(simuEntry.MacAddr, &simuEntry.cdvt);
	RG_add_simu_wan(&simuEntry, i);
	if(simu_debug)
		printf("[%s %d][SIMU]ADD ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#endif
	addSimuEthWANdev(&simuEntry, autosimu);
	setup_simu_ethernet_config(&simuEntry, ifname_simu);

	//OK, simulation dial.
	snprintf(buff, 256, "rm -rf /tmp/ppp_manual_diag.%s", ifname_simu);
	system(buff);
	snprintf(msg.data, BUF_SIZE, "spppctl add 7 simulation 1 ipt %d pppoe %s", ipt, ifname_simu);
	if(username!=NULL)
	{
		snprintf(msg.data, BUF_SIZE, "%s username %s", msg.data, username);
	}
	if(password!=NULL)
	{
		snprintf(msg.data, BUF_SIZE, "%s password %s", msg.data, password);
	}
#ifdef CONFIG_IPV6
	if(ipt>0)
	{
		generate_ifupv6_script_manual(ifname_simu, &Entry);
	}
#endif
	//for debug
	//snprintf(msg.data, BUF_SIZE, "%s servicename linux247", msg.data);
	if(simu_debug)
		printf("[%s %d][SIMU]:%s\n", __func__, __LINE__, msg.data);
	//end

	write_to_pppd(&msg);
	sysinfo(&info);
	simStartTime = (int)info.uptime;

	mib_set(MIB_AUTO_DIAG_STARTTIME, (void *)&simStartTime);
	return 0;
}

int stopPPPoESimulation(char *devname)
{
	int i, totalNum;
	int if_unit=-1, resultNum=-1;
	MIB_CE_ATM_VC_T simuEntry;
	unsigned char ipt = 0;
	char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
	char filename[64];
	unsigned char buf[300];
	unsigned char strName[16];
	unsigned char strVal[256];
	FILE *fp=NULL;
	int autosimu = 0;
	unsigned int pid;

	if(simu_debug)
		printf("[SIMU]stopPPPoESimulation\n");
	if((NULL == devname))
		return -1;

	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			return -2;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(simuEntry.ifIndex), ifname, sizeof(ifname));
		if((!strncmp(devname, ifname, IFNAMSIZ))&&(1 == simuEntry.mbs))
		{
			//exist
			ipt = simuEntry.IpProtocol - 1;
			break;
		}
	}

	if(i == totalNum)
	{
		if(simu_debug)
			printf("[SIMU]No simulation on dev %s\n", devname);
		return 0;
	}

	snprintf(ifname_simu, IFNAMSIZ,  "%s_%d", devname, autosimu);
	snprintf(filename, 64, "/tmp/ppp_manual_diag.%s", ifname_simu);
	if(simu_debug)
	{
		printf("[SIMU]TimeOut and File(%s) not exist, dev=%s\n", filename, devname);
	}
	va_cmd("/bin/spppctl", 2, 1, "del", "7");
	va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
	if(simu_debug)
		printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
	RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
	RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
	mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);

	return 0;
}

/*
return :
	  0 : - get success
	-1 : - devname invalid(null or not exist)
	-2 : - mib operator failed
	-3 : - time-out!
	-4 : - result file not exist.
	-5 : - inprocess.
*/
int getSimulationResult(char* devname, struct DIAG_RESULT_T* state)
{
	long queryTime = 0;
	struct sysinfo info;
	int i, totalNum;
	int if_unit=-1, resultNum=-1;
	MIB_CE_ATM_VC_T simuEntry;
	unsigned char ipt = 0;
	char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
	char filename[64];
	unsigned char buf[300];
	unsigned char strName[16];
	unsigned char strVal[256];
	FILE *fp=NULL;
	struct DIAG_RESULT_T result;
	int simStartTime = 0;
	int autosimu = 0;
	unsigned int pid;

	if(simu_debug)
		printf("[SIMU]getSimulationResult\n");
	if((NULL == devname)||(NULL == state))
		return -1;

	sysinfo(&info);
	queryTime = (int)info.uptime;

	mib_get(MIB_AUTO_DIAG_STARTTIME, (void *)&simStartTime);

	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			return -2;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(simuEntry.ifIndex), ifname, sizeof(ifname));
		if((!strncmp(devname, ifname, IFNAMSIZ))&&(1 == simuEntry.mbs))
		{
			//exist
			ipt = simuEntry.IpProtocol - 1;
			break;
		}
	}

	if(i == totalNum)
	{
		if(simu_debug)
			printf("[SIMU]No simulation on dev %s\n", devname);
		return -1;
	}

	snprintf(ifname_simu, IFNAMSIZ,  "%s_%d", devname, autosimu);
	snprintf(filename, 64, "/tmp/ppp_manual_diag.%s", ifname_simu);
	fp = fopen(filename, "r");
	if(fp==NULL)
	{
		//result file not exist.
		if((queryTime-simStartTime)>=30)	//time-out
		{
			if(simu_debug)
			{
				printf("[SIMU]TimeOut and File(%s) not exist, dev=%s\n", filename, devname);
			}
			va_cmd("/bin/spppctl", 2, 1, "del", "7");
			va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
			if(simu_debug)
				printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#ifdef CONFIG_RTK_L34_ENABLE
			RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
			RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
#ifdef CONFIG_USER_IP_QOS_3
            restore_hw_queue();
#endif
#endif
            mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);

			memset(&result, 0, sizeof(struct DIAG_RESULT_T));
			memcpy(result.result, "unKnown", strlen("unKnown"));
			result.errCode = 6;
			memcpy(state, &result, sizeof(struct DIAG_RESULT_T));
			return 0;
		}
		else
		{
			if(simu_debug)
				printf("[SIMU]File(%s) not exist, dev=%s\n", filename, devname);
			return -5;
		}
	}

	memset(&result, 0, sizeof(struct DIAG_RESULT_T));
	while((fgets(buf, 300, fp))!=NULL)
	{
		if(sscanf(buf, "%s %s\n", strName, strVal)!= -1)
		{
			if(simu_debug)
			{
				printf("[%s %d][SIMU]strName=%s, strVal=%s\n", __func__, __LINE__, strName, strVal);
			}
			if(!strcmp(strName, "unit"))
			{
				if_unit = atoi(strVal);
			}
			else if(!strcmp(strName, "state"))
			{
				resultNum = atoi(strVal);
				if(DIAG_INPROCESS!=resultNum)
				{
					memcpy(result.result, resultArray[resultNum], 128);
				}
			}
			else if(!strcmp(strName, "errCode"))
			{
				result.errCode= atoi(strVal);
			}
			else if(!strcmp(strName, "authMSG"))
			{
				memcpy(result.authMSG, buf+8, 256);
				char *p = NULL;
				p = strchr(result.authMSG, '\n');
				if (p) *p = '\0';
				if(simu_debug)
				{
					printf("[SIMU]---->authMSG=%s\n", result.authMSG);
				}
			}
			else if(!strcmp(strName, "session"))
			{
				result.sessionId = atoi(strVal);
			}
			else if(!strcmp(strName, "ipAddr"))
			{
				memcpy(result.ipAddr, strVal, 16);
			}
			else if(!strcmp(strName, "gw"))
			{
				memcpy(result.gateWay, strVal, 16);
			}
			else if(!strcmp(strName, "dns"))
			{
				memcpy(result.dns, strVal, 16);
			}
			else if(!strcmp(strName, "ipv6GW"))
			{
				memcpy(result.ipv6GW, strVal, 256);
			}
		}
	}
	fclose(fp);
	result.ipType = ipt;

	if((DIAG_SUCCESS==resultNum)&&(result.ipType>0))
	{
		int num;
		struct ipv6_ifaddr ip6_addr;
		struct in6_addr ip6Prefix;
		unsigned char value[48], len;
		unsigned int ret = 0;
		char iaprfix[64], dns[64], aftr[64];

		snprintf(ifname, IFNAMSIZ, "ppp%d", if_unit);
		num=getifip6(ifname, IPV6_ADDR_UNICAST, &ip6_addr, 1);
		if (!num)
		{
			//IPv6 Address has be not get already.
			if(simu_debug)
				printf("[%s %d][SIMU]IP6Addr on %s is not ready.\n", __func__, __LINE__, ifname);
			sysinfo(&info);
			queryTime = (int)info.uptime;
			if((queryTime-simStartTime)>=30)
			{
				if(simu_debug)
					printf("[%s %d][SIMU]TimeOut, result=ERROR_SERVER_OUT_OF_RESOURCES_IPV6, errCode=9\n", __func__, __LINE__);
				pid = read_pid("/var/run/autoSimu.pid");
				if ( pid > 0){
					if(simu_debug)
						printf("Send signal USR1 to pid %d to kill thread.\n",pid);
					kill(pid, SIGUSR1);
				}
				if(if_unit==-1)
				{
					va_cmd("/bin/spppctl", 2, 1, "del", "7");
				}
				else
				{
					snprintf(buf, 64, "%d", if_unit);
					va_cmd("/bin/spppctl", 2, 1, "del", buf);
				}
				va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
				if(simu_debug)
					printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#ifdef CONFIG_RTK_L34_ENABLE
				RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
				RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
#ifdef CONFIG_USER_IP_QOS_3
                restore_hw_queue();
#endif
#endif
				mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);
				resultNum = DIAG_SERVER_OUT_OF_RESOURCE_IPV6;
				memcpy(result.result, resultArray[resultNum], 128);
				result.errCode = 9;
				memcpy(state, &result, sizeof(struct DIAG_RESULT_T));
				snprintf(buf, 256, "rm -rf /tmp/ppp_manual_diag.%s", ifname_simu);
				system(buf);
				return 0;
			}
			else
			{
				MIB_CE_ATM_VC_T Entry;
				int j, totalNum;
				int found = 0;

				//printf("[%s %d]simuEntry.ifIndex=%d\n", __func__, __LINE__, simuEntry.ifIndex);
				totalNum = mib_chain_total(MIB_ATM_VC_TBL);
				for(j = 0; j < totalNum; j++)
				{
					if(!mib_chain_get(MIB_ATM_VC_TBL, j, (void *)&Entry))
						continue;
					if(Entry.enable == 0)
						continue;

					//printf("[%s %d]Entry.ifIndex=%d\n", __func__, __LINE__, Entry.ifIndex);
					if(PHY_INTF(Entry.ifIndex) == PHY_INTF(simuEntry.ifIndex))
					{
						found = 1;
						//printf("[%s %d]found\n", __func__, __LINE__);
						break;
					}
				}

				if((1==found)&&(Entry.cmode==CHANNEL_MODE_BRIDGE))
				{
					char ifup_path[32];
					//printf("[%s %d]rewrite script and run it\n", __func__, __LINE__);
					generate_ifupv6_script_manual(ifname_simu, &Entry);
					snprintf(ifup_path, 32, "/var/ppp/ifupv6_ppp7");
					va_cmd(ifup_path, 0, 1);
					sleep(5);
				}
				resultNum = DIAG_INPROCESS;
			}
		}
		else
		{
			inet_ntop(PF_INET6, &ip6_addr.addr, buf, 256);
			sprintf(result.ipv6Addr, "%s/%d", buf, ip6_addr.prefix_len);

			memcpy(&ip6Prefix, &ip6_addr.addr, 16);
			{
				int j;
				for(j=0; j<(ip6_addr.prefix_len>>3); j++)
				{
					ip6Prefix.s6_addr[15-j] = 0;
				}

			}
			inet_ntop(PF_INET6, &ip6Prefix, buf, 256);
			sprintf(result.ipv6Prefix, "%s/%d", buf, ip6_addr.prefix_len);

#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
		if(((1==simuEntry.Ipv6Dhcp)||(0x2==(simuEntry.Ipv6DhcpRequest&0x2)))
			||(CHANNEL_MODE_BRIDGE == simuEntry.cmode)
#ifdef DUAL_STACK_LITE
			||((simuEntry.dslite_enable == 1) && (simuEntry.dslite_aftr_mode == IPV6_DSLITE_MODE_AUTO))
#endif
			)
            {
                snprintf(filename, 64, "/var/%sppp%d.leases", DHCPCV6STR, if_unit);
			    sleep(1);
			    ret = getOptionFromleases(filename, iaprfix, dns, aftr);
                if(0 == ret)
    			{
    				MIB_CE_ATM_VC_T Entry;
    				int j, totalNum;
    				int found = 0;

    				//printf("[%s %d]simuEntry.ifIndex=%d\n", __func__, __LINE__, simuEntry.ifIndex);
    				totalNum = mib_chain_total(MIB_ATM_VC_TBL);
    				for(j = 0; j < totalNum; j++)
    				{
    					if(!mib_chain_get(MIB_ATM_VC_TBL, j, (void *)&Entry))
    						continue;
    					if(Entry.enable == 0)
    						continue;

    					//printf("[%s %d]Entry.ifIndex=%d\n", __func__, __LINE__, Entry.ifIndex);
    					if(PHY_INTF(Entry.ifIndex) == PHY_INTF(simuEntry.ifIndex))
    					{
    						found = 1;
    						//printf("[%s %d]found\n", __func__, __LINE__);
    						break;
    					}
    				}

    				if(1==found)
    				{
    					char ifup_path[32];
                        if(CHANNEL_MODE_BRIDGE == simuEntry.cmode)
                        {
        					//printf("[%s %d]rewrite script and run it\n", __func__, __LINE__);
        					generate_ifupv6_script_get_PD(ifname_simu, &Entry);
        					snprintf(ifup_path, 32, "/var/ppp/ifupv6_ppp7");
        					va_cmd(ifup_path, 0, 1);
                        }
    					sleep(5);
    					ret = getOptionFromleases(filename, iaprfix, dns, aftr);
    					//printf("[%s %d]ret=%d\n", __func__, __LINE__, ret);
    				}
    			}
    			if(0!=(ret&1))
    			{
    				memcpy(result.ipv6LANPrefix, iaprfix, 256);
    			}
    			if(0!=(ret&2))
    			{
    				memcpy(result.ipv6DNS, dns, 256);
    			}
    			if(0!=(ret&4))
    			{
    				memcpy(result.aftr, aftr, 256);
    			}
            }
#endif

#if	defined(DUAL_STACK_LITE)
			if(simuEntry.dslite_enable == 1)
			{
				if(1==simuEntry.dslite_aftr_mode)
				{   
                    //manual mode, get aftr from mib_entry.
					memcpy(result.aftr, simuEntry.dslite_aftr_hostname, 64);

                    pid = read_pid("/var/run/autoSimu.pid");
    				if ( pid > 0){
    					if(simu_debug)
    						printf("Send signal USR2 to autoSimu pid %d\n",pid);
    					kill(pid, SIGUSR2);
    				}
				}

				sysinfo(&info);
				queryTime = (int)info.uptime;
				if((!simuEntry.dslite_aftr_addr[0])&&((queryTime-simStartTime)<30))
				{
					return -5;
				}
				if((simuEntry.dslite_aftr_addr[0])&&((queryTime-simStartTime)<30))
				{
					char str_gateway[64];
					inet_ntop(AF_INET6, (const void *) simuEntry.dslite_aftr_addr, str_gateway, 64);
					memcpy(result.aftr, str_gateway, 256);
				}

				if((queryTime-simStartTime)>=30)
				{
					memcpy(result.result, resultArray[DIAG_SERVER_OUT_OF_RESOURCE_IPV6], 128);
					result.errCode = 9;
					goto setok;
				}
			}
#endif
		}
	}


	if((queryTime-simStartTime)>=30)	//time-out
	{
		if(simu_debug)
		{
			printf("[%s %d]Time-Out\n", __func__, __LINE__);
		}
		pid = read_pid("/var/run/autoSimu.pid");
		if ( pid > 0){
			if(simu_debug)
				printf("Send signal USR1 to pid %d to kill thread.\n",pid);
			kill(pid, SIGUSR1);
		}
		if(if_unit==-1)
		{
			va_cmd("/bin/spppctl", 2, 1, "del", "7");
		}
		else
		{
			snprintf(buf, 64, "%d", if_unit);
			va_cmd("/bin/spppctl", 2, 1, "del", buf);
		}
		va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
		if(simu_debug)
			printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#ifdef CONFIG_RTK_L34_ENABLE
		RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
		RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
#endif
#ifdef CONFIG_USER_IP_QOS_3
        restore_hw_queue();
#endif
		mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);
		snprintf(buf, 256, "rm -rf /tmp/ppp_manual_diag.%s", ifname_simu);
		system(buf);

		memset(&result, 0, sizeof(struct DIAG_RESULT_T));
		memcpy(result.result, resultArray[DIAG_UNKNOWN], 128);
		result.errCode = 6;
		memcpy(state, &result, sizeof(struct DIAG_RESULT_T));
		return 0;
	}

	if(DIAG_INPROCESS==resultNum)
	{
		return -5;
	}

setok:
	pid = read_pid("/var/run/autoSimu.pid");
	if ( pid > 0){
		if(simu_debug)
			printf("Send signal USR1 to pid %d to kill thread.\n",pid);
		kill(pid, SIGUSR1);
	}
	if(if_unit==-1)
	{
		va_cmd("/bin/spppctl", 2, 1, "del", "7");
	}
	else
	{
		snprintf(buf, 64, "%d", if_unit);
		va_cmd("/bin/spppctl", 2, 1, "del", buf);
	}
	va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
	if(simu_debug)
		printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#ifdef CONFIG_RTK_L34_ENABLE
	RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
	RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
#endif
#ifdef CONFIG_USER_IP_QOS_3
    restore_hw_queue();
#endif
	mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);
#if	defined(DUAL_STACK_LITE)
	if(simuEntry.dslite_enable == 1)
	{
		cmd_set_dns_config(NULL);
		restart_dnsrelay();
	}
#endif
	memcpy(state, &result, sizeof(struct DIAG_RESULT_T));
	if((state->errCode == 14)&&(1==simu_debug))
	{
		printf("[SIMU]2---->authMSG=%s\n", state->authMSG);
	}
	return 0;
}

void startAutoBridgePppoeDail(void * ifIndex);

int getValidPPPidx()
{
    int i, totalNum;
    MIB_CE_ATM_VC_T entry;
    unsigned char pppmask = 0;

    totalNum = mib_chain_total(MIB_ATM_VC_TBL);
    for(i = 0; i < totalNum; i++)
    {
        if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&entry))
		{
			continue;
		}
        if(entry.cmode == CHANNEL_MODE_PPPOE)
        {
            pppmask |= (0x1<<PPP_INDEX(entry.ifIndex));
        }
    }

    totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
    for(i = 0; i < totalNum; i++)
    {
        if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&entry))
		{
			continue;
		}
        if(entry.cmode == CHANNEL_MODE_PPPOE)
        {
            pppmask |= (0x1<<PPP_INDEX(entry.ifIndex));
        }
    }

    for(i = 6; i >= 0; i--)
    {
        if(0 == (pppmask&(0x1<<i)))
        {
            return i;
        }
    }

    return -1;
}
void checkAutoSimulationResult(void * arg)
{
	int suceess=0;
	unsigned int time;
	MIB_CE_AUTO_DIAG_PARAM_T paramEntry;
	char ifname[IFNAMSIZ];
	char fileName[64];
	char buff[64];
	FILE *fp=NULL;
	int autosimu = 1;
    int ppp_idx = 0;
	unsigned int ifIndex;

	ifIndex = *((unsigned int*)arg);
    ppp_idx = PPP_INDEX(ifIndex);

    ifGetName(PHY_INTF(ifIndex), ifname, sizeof(ifname));
    if(simu_debug)
		printf("[SIMU]checkAutoSimulationResult, wan=%s\n", ifname);
	snprintf(ifname, IFNAMSIZ, "%s_%d", ifname, autosimu);
	snprintf(fileName, 64, "/tmp/ppp_auto_diag.%s", ifname);
    fp = fopen(fileName, "r");
	if(fp!=NULL)
	{
		char unit[16], result[32];
		if(((fgets(buff, 64, fp))!=NULL)&&(sscanf(buff, "%s %s\n", unit, result)!= -1))
		{
			if((0==atoi(result))||(14==atoi(result)))
			{
				suceess = 1;
			}
			if(simu_debug)
				printf("[%s %d][SIMU]del ppp unit %s\n", __func__, __LINE__, unit);
			snprintf(buff, 64, "/bin/spppctl del %s", unit);
			system(buff);
		}
		fclose(fp);
	}

    if(mib_chain_get(MIB_AUTO_DIAG_PARAM_TBL, 0, (void *)&paramEntry))
    {
        if(0==suceess)
		{
			time = paramEntry.failRetryTimeList*60 - 30;
		}
		else
		{
			time = paramEntry.timeList*60 - 30;
		}

		if(simu_debug)
			printf("[%s %d][SIMU]startAutoBridgePppoeDail after %d seconds\n", __func__, __LINE__, time);
		unsigned int *malloc_int;
		malloc_int = malloc(sizeof(unsigned int));
		*malloc_int = ifIndex ;
		TIMEOUT(startAutoBridgePppoeDail, (void *)malloc_int, time, autoSimulation_ch[ppp_idx]);
    }
	if(arg) free(arg);
	return; 
}

void startAutoBridgePppoeDail(void * arg)
{
    MIB_CE_AUTO_DIAG_PARAM_T paramEntry;
    struct data_to_pass_st msg;
    char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
    int autosimu = 1;
    int ppp_idx = 0;
	unsigned int ifIndex;

	ifIndex = *((unsigned int*)arg);
    ppp_idx = PPP_INDEX(ifIndex);
    if(mib_chain_get(MIB_AUTO_DIAG_PARAM_TBL, 0, (void *)&paramEntry))
    {
        ifGetName(PHY_INTF(ifIndex), ifname, sizeof(ifname));
        snprintf(ifname_simu, IFNAMSIZ, "%s_%d", ifname, autosimu);

        //start auto simulation for bridge wan.
    	snprintf(msg.data, BUF_SIZE, "spppctl add %d simulation 16 auth %s pppoe %s", ppp_idx, ppp_auth[paramEntry.authType], ifname_simu);
    	if(paramEntry.userName[0]!='\0')
    	{
    		snprintf(msg.data, BUF_SIZE, "%s username %s", msg.data, paramEntry.userName);
    	}
    	if(paramEntry.passWord[0]!='\0')
    	{
    		snprintf(msg.data, BUF_SIZE, "%s password %s", msg.data, paramEntry.passWord);
    	}
    	//for debug
    	//snprintf(msg.data, BUF_SIZE, "%s servicename linux247", msg.data);
    	if(simu_debug)
    		printf("[%s %d][SIMU]:%s\n", __func__, __LINE__, msg.data);
    	//end

    	write_to_pppd(&msg);
	unsigned int *malloc_int;
	malloc_int = malloc(sizeof(unsigned int));
	*malloc_int = ifIndex ;
        TIMEOUT(checkAutoSimulationResult, (void *)malloc_int, 30, autoSimulation_ch[ppp_idx]);
    }

    if(arg) free(arg);

    return;
}

void startAutoBridgePppoeSimulationTimeout(void* arg);

/*
  parameter:
  wanname: bridge wan's name(nas0_0/nas0_1..etc), can be null(means start all bridge&internet wan).
  return:
 */
int startAutoBridgePppoeSimulation(char* wanname)
{
	int i, totalNum, simu_idx, totalsimuNum;
	MIB_CE_ATM_VC_T Entry;
	MIB_CE_ATM_VC_T simuEntry;
	MIB_CE_AUTO_DIAG_PARAM_T paramEntry;
	char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
	unsigned char autoDiagEnable;
	int autosimu = 1;
	int ppp_idx = 0;

	if(simu_debug)
	{
		printf("[SIMU]startAutoBridgePppoeSimulation, for %s\n", (wanname==NULL)?"all interface":wanname);
	}

	if((mib_get(MIB_AUTO_DIAG_ENABLE, (void *)(&autoDiagEnable))) && (0==autoDiagEnable))
	{
		if(simu_debug)
			printf("[%s %d][SIMU]auto simulation disabled\n", __func__, __LINE__);
		return -1;
	}

	if((0 == omcistate) || !mib_chain_get(MIB_AUTO_DIAG_PARAM_TBL, 0, (void *)&paramEntry))
	{
		if(simu_debug)
			printf("[%s %d][SIMU]omci does not successed(omcistate=%d) or DIAG_PARAM get fail.\n", __func__, __LINE__, omcistate);
        if(0 == omcistate)
        {
            //if omci is not ready, try 10 seconds later.
            TIMEOUT(startAutoBridgePppoeSimulationTimeout, 0, 10, autoSimulation_ch[MAX_CH-1]);
        }
		return -1;
	}

	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
			if(simu_debug)
				printf("[%s %d][SIMU]Get mib[%d] failed\n", __func__, __LINE__, i);
			continue;
		}

		if((Entry.enable == 0)||(Entry.cmode != CHANNEL_MODE_BRIDGE)||(Entry.applicationtype!=X_CT_SRV_INTERNET))
		{
			continue;
		}
		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(Entry.ifIndex), ifname, sizeof(ifname));

        if((wanname != NULL) && (strncmp(ifname, wanname, 6)))
        {
            //only start a bridge wan by wan name
            continue;
        }
		snprintf(ifname_simu, IFNAMSIZ, "%s_%d", ifname, autosimu);

		totalsimuNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
		for(simu_idx = 0; simu_idx < totalsimuNum; simu_idx++)
		{
			if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, simu_idx, (void *)&simuEntry))
			{
				continue;
			}

			if((PHY_INTF(simuEntry.ifIndex)==PHY_INTF(Entry.ifIndex))&&(2 == simuEntry.mbs))
			{
				//duplicate...delete the simulation first.
				va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
				if(simu_debug)
					printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#ifdef CONFIG_RTK_L34_ENABLE
				RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
				RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
#endif
#ifdef CONFIG_USER_IP_QOS_3
                restore_hw_queue();
#endif
				break;
			}
		}

        ppp_idx = getValidPPPidx();

        if(ppp_idx >= 0)
        {
            
            memcpy(&simuEntry, &Entry, sizeof(MIB_CE_ATM_VC_T));
            simuEntry.applicationtype = X_CT_SRV_INTERNET;
            simuEntry.cmode = CHANNEL_MODE_PPPOE;
            simuEntry.mbs = 2;
#if defined(ITF_GROUP) || defined(NEW_PORTMAPPING)
            simuEntry.itfGroup = 0;     //simu connection, no need to bind with any lan dev
#endif
            simuEntry.MacAddr[MAC_ADDR_LEN-1] = (simuEntry.MacAddr[MAC_ADDR_LEN-1] + 8);
            simuEntry.MacAddr[MAC_ADDR_LEN-2]++;
            simuEntry.brmode = BRIDGE_DISABLE;
            simuEntry.ifIndex &= ~(0xFF<<8);
            simuEntry.ifIndex |= (ppp_idx<<8);
            if(simu_idx != totalsimuNum)
            {
                mib_chain_update(MIB_SIMU_ATM_VC_TBL, &simuEntry, simu_idx);
            }
            else
            {
                mib_chain_add(MIB_SIMU_ATM_VC_TBL, &simuEntry);
            }
    
            //generate Simulation WAN
#ifdef CONFIG_RTK_L34_ENABLE
            RG_Add_Simu_Trap_ACL(simuEntry.MacAddr, &simuEntry.cdvt);
            RG_add_simu_wan(&simuEntry, simu_idx);
            if(simu_debug)
                printf("[%s %d][SIMU]ADD, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#endif
            addSimuEthWANdev(&simuEntry, autosimu);
            setup_simu_ethernet_config(&simuEntry, ifname_simu);

		unsigned int *malloc_int;
		malloc_int = malloc(sizeof(unsigned int));
		*malloc_int = simuEntry.ifIndex ;
            startAutoBridgePppoeDail((void *)malloc_int);
        }
	}

    return 0;
}

void startAutoBridgePppoeSimulationTimeout(void* arg)
{
	startAutoBridgePppoeSimulation((char *)arg);
}

/*
  parameter:
  wanname: bridge wan's name(nas0_0/nas0_1..etc), can be null(means stop all bridge wan).
  return:
 */
int stopAutoBridgePppoeSimulation(char* wanname)
{
	int i, totalNum;
	MIB_CE_ATM_VC_T simuEntry;
	char ifname[IFNAMSIZ];
    char ifname_simu[IFNAMSIZ];
	char fileName[64];
	char buff[64];
	FILE *fp=NULL;
	int autosimu = 1;

	if(simu_debug)
		printf("[SIMU]stopAutoBridgePppoeSimulation\n");
	
	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = totalNum-1; i >= 0; i--)
	{
		mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry);
		if(1 == simuEntry.mbs)
		{
			//for manual when mbs == 1;
			continue;
		}

		ifGetName(PHY_INTF(simuEntry.ifIndex), ifname, sizeof(ifname));
        if((wanname != NULL) && (strncmp(ifname, wanname, 6)))
        {
            //only stop the bridge wan by wan name
            continue;
        }
        UNTIMEOUT(0, 0, autoSimulation_ch[PPP_INDEX(simuEntry.ifIndex)]);
		snprintf(ifname_simu, IFNAMSIZ, "%s_%d", ifname, autosimu);
		snprintf(fileName, 64, "/tmp/ppp_auto_diag.%s", ifname_simu);
		fp = fopen(fileName, "r");
		if(fp!=NULL)
		{
			char unit[16], result[32];
			if(((fgets(buff, 64, fp))!=NULL)&&(sscanf(buff, "%s %s\n", unit, result)!= -1))
			{
				if(simu_debug)
					printf("[%s %d][SIMU]del ppp unit %s\n", __func__, __LINE__, unit);
				snprintf(buff, 64, "/bin/spppctl del %s", unit);
				system(buff);
			}
			fclose(fp);
		}
		//delete.
		va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
		if(simu_debug)
			printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#ifdef CONFIG_RTK_L34_ENABLE
		RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
		RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
#endif
#ifdef CONFIG_USER_IP_QOS_3
        restore_hw_queue();
#endif
		mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);
	}

	return 0;
}

int initAutoBridgeFIFO()
{
	int ret = 0;
	int server_fifo_fd = -1;

	unlink("/tmp/autoBridgePPP_fifo");
	ret = mkfifo("/tmp/autoBridgePPP_fifo", 0777);

	if(ret != 0)
	{
		printf("[%s %d][SIMU]errno = %d\n", __func__, __LINE__, errno);
	}

	server_fifo_fd = open("/tmp/autoBridgePPP_fifo", O_RDONLY|O_NONBLOCK);
	fcntl(server_fifo_fd, F_SETFD, fcntl(server_fifo_fd, F_GETFD) | FD_CLOEXEC);
	if (server_fifo_fd == -1)
	{
		printf("[SIMU]create ppp_autoBridge fifo failure\n");
	}

	return server_fifo_fd;
}

int setOmciState(int state)
{
	if((0==omcistate)&&(1==state))
	{
		omcistate = state;
		printf("[%s %d][SIMU]omcistate=%d\n", __func__, __LINE__, omcistate);
		startAutoBridgePppoeSimulation(NULL);
	}

	return 0;
}

int setSimuDebug(int debug)
{
	simu_debug = debug;
	printf("[%s %d][SIMU]Set simu_debug=%d\n", __FILE__, __LINE__, simu_debug);
	return 0;
}

int poll_msg(int fd)
{
	int bytesToRead = 0;

	if(fd < 0)
		return 0;
	(void)ioctl(fd, FIONREAD, (int *)&bytesToRead);
	return bytesToRead;
}
#endif //auto diag

#ifdef CONFIG_RG_BRIDGE_PPP_STATUS
/*
return :
	  0 : - get success
	-1 : - devname invalid(null or not exist)
	-2 : - mib operator failed
	-3 : - dev mode invalid.
	-4 : - result file not exist.
*/
int getWanPPPstate(char* devname, unsigned int* state)
{
	int i, pppunit, wanValid=0;
	int totalNum;
	int connectMode;
	MIB_CE_ATM_VC_T Entry;
	char ifname[IFNAMSIZ];
	struct in_addr inAddr;
	int flags, flags_found;
	int pppstate = 0;

	if((NULL == devname)||(NULL == state))
		return -1;

	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				return -2;

		if(Entry.enable == 0)
			continue;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(Entry.ifIndex), ifname, sizeof(ifname));

		if(!strncmp(devname, ifname, IFNAMSIZ))
		{
			wanValid = 1;
			connectMode = Entry.cmode;
			break;
		}
	}

	if(0 == wanValid)
		return -1;
	if((CHANNEL_MODE_BRIDGE != connectMode)&&(CHANNEL_MODE_PPPOE != connectMode))
		return -3;

	if(CHANNEL_MODE_BRIDGE != connectMode)
	{
		//route mode
		ifGetName(Entry.ifIndex, ifname, sizeof(ifname));
		flags_found = getInFlags(ifname, &flags);
		if(flags_found&&(flags & IFF_UP))
		{
			pppstate = 1;
		}
	}
	else
	{
		//bridge mode
		FILE *fp=NULL;
		unsigned char buff[4];

		fp = fopen("/proc/rg/brg_pppstate", "r");
		if(fp!=NULL)
		{
			if(fread(buff, 1, 1, fp)==1)
			{
				printf("The character input was: '%c'\n",buff[0]);
				if(buff[0]=='1')
				{
					pppstate = 1;
				}
			}
			fclose(fp);
		}
		else
		{
			return -4;
		}
	}

	*state = pppstate;
	return 0;
}
#endif

// find if pppif exists in /var/ppp/ppp.conf
int find_ppp_from_conf(char *pppif)
{
	char buff[256];
	FILE *fp;
	char strif[6];
	int found=0;

	if (!(fp=fopen(PPP_CONF, "r"))) {
		printf("%s not exists.\n", PPP_CONF);
	}
	else {
		fgets(buff, sizeof(buff), fp);
		while( fgets(buff, sizeof(buff), fp) != NULL ) {
			if(sscanf(buff, "%s", strif)!=1) {
				found=0;
				printf("Unsuported ppp configuration format\n");
				break;
			}

			if ( !strcmp(pppif, strif) ) {
				found = 1;
				break;
			}
		}
		fclose(fp);
	}
	return found;
}


// calculate the 15-0(bits) Cell Rate register value (PCR or SCR)
// return its corresponding register value
int cr2reg(int pcr)
{
#ifdef CONFIG_RTL8672
	return pcr;
#else
	int k, e, m, pow2, reg;

	k = pcr;
	e=0;

	while (k>1) {
		k = k/2;
		e++;
	}

	//printf("pcr=%d, e=%d\n", pcr,e);
	pow2 = 1;
	for (k = 1; k <= e; k++)
		pow2*=2;

	//printf("pow2=%d\n", pow2);
	//m = ((pcr/pow2)-1)*512;
	k = 0;
	while (pcr >= pow2) {
		pcr -= pow2;
		k++;
	}
	m = (k-1)*512 + pcr*512/pow2;
	//printf("m=%d\n", m);
	reg = (e<<9 | m );
	//printf("reg=%d\n", reg);
	return reg;
#endif
}

/*
 *	get the mark value for a traffic classification
 */

int _get_classification_mark( int entryNo, MIB_CE_IP_QOS_T *p )
{
	int mark=0;

	if(p==NULL) return 0;

	// mark the packet:  8-bits(high) |   8-bits(low)
	//                    class id    |  802.1p (if any)
	mark = ((entryNo+1) << 8);	// class id
	#if 0
	#ifdef QOS_SPEED_LIMIT_SUPPORT
	//use the first 3 bit
	if(p->limitSpeedEnabled)
		{
			int tmpmark=p->limitSpeedRank;

		  	mark|=tmpmark<<12;
			printf("limitSpeedRank=%d,mark=%d\n",p->limitSpeedRank,mark);
		}

	#endif
	#endif
	if (p->m_1p != 0)
		mark |= (p->m_1p-1);	// 802.1p

	return mark;
}

int get_classification_mark(int entryNo)
{
	MIB_CE_IP_QOS_T qEntry;
	int i, num, mark;

	mark = 0;
	num = mib_chain_total(MIB_IP_QOS_TBL);
	if (entryNo >= num)
		return 0;
	// get fwmark
	if (!mib_chain_get(MIB_IP_QOS_TBL, entryNo, (void *)&qEntry))
		return 0;

#if 1
	mark =  _get_classification_mark( entryNo, &qEntry );
#else
	// mark the packet:  8-bits(high) |   8-bits(low)
	//                    class id    |  802.1p (if any)
	mark = ((entryNo+1) << 8);	// class id
	if (qEntry.m_1p != 0)
		mark |= (qEntry.m_1p-1);	// 802.1p
#endif

	return mark;
}

void update_wan_routing(char *ifname)
{
#ifdef NEW_PORTMAPPING
    MIB_CE_ATM_VC_T Entry, *pEntry;
	unsigned int i,num;
    unsigned int ifIndex=0;
    char wanif[8];
    char strTblID[10], strDefTblID[10];
#ifdef CONFIG_IPV6
    char ipv6Enable =-1;
#endif

	pEntry = &Entry;
	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		if ( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)pEntry ) )
			continue;

		if (pEntry->cmode != CHANNEL_MODE_PPPOE){
			continue;
		}

        ifGetName(pEntry->ifIndex, wanif, sizeof(wanif));
        if (!strcmp(wanif, ifname))
        {
            ifIndex = pEntry->ifIndex;
            break;
        }
	}

    if (0 == ifIndex)
        return;

    snprintf(strTblID, 10, "%d", caculate_tblid(ifIndex));
    //ip route flush table 48
    va_cmd("/bin/ip", 4, 1, "route", "flush", "table", strTblID);
    //ip route add default dev ppp0 table 48
    va_cmd("/bin/ip", 7, 1, "route", "add", "default", "dev", ifname, "table", strTblID);

	// default table
	if (pEntry->applicationtype&X_CT_SRV_INTERNET) {
        snprintf(strDefTblID, 10, "%d", PMAP_DEFAULT_TBLID);
        //ip ro change default dev ppp0 table 252
        va_cmd("/bin/ip", 7, 1, "route", "change", "default", "dev", ifname, "table", strDefTblID);
#if defined(CONFIG_USER_PPPOE_PROXY)
		if(pEntry->PPPoEProxyEnable){
            //route add default ppp0
            va_cmd(ROUTE, 3, 1, "add", "default", ifname);
            //iptables -I  FORWARD  1 -i ppp+ -o ppp0 -j ACCEPT
            va_cmd(IPTABLES, 9, 1, "-I", "FORWARD", "1", "-i", "ppp+", "-o", ifname, "-j", "ACCEPT");
		}
#endif
	}

#ifdef CONFIG_IPV6
	mib_get(MIB_V6_IPV6_ENABLE, (void *)&ipv6Enable);
	if(ipv6Enable == 1)
	{
        //ip -6 route flush table 48
        va_cmd("/bin/ip", 5, 1, "-6", "route", "flush", "table", strTblID);
        //ip -6 route add default dev ppp0 table 48
        va_cmd("/bin/ip", 8, 1, "-6", "route", "add", "default", "dev", ifname, "table", strTblID);

		// default table
		if (pEntry->applicationtype&X_CT_SRV_INTERNET) {
            //ip -6 route flush table 252
            va_cmd("/bin/ip", 5, 1, "-6", "route", "flush", "table", strDefTblID);
            //ip -6 route add default dev ppp0 table 48
            va_cmd("/bin/ip", 8, 1, "-6", "route", "add", "default", "dev", ifname, "table", strDefTblID);
		}
	}
#endif//end of CONFIG_IPV6
#endif//end of NEW_PORTMAPPING
}

/*
 *	generate the ifup_ppp(vc)x script for WAN interface
 */
static int generate_ifup_script(unsigned int ifIndex, MIB_CE_ATM_VC_Tp pEntry)
{
	int mark, ret;
	FILE *fp;
	char wanif[8], ifup_path[32];
#ifdef IP_POLICY_ROUTING
	int i, num, found;
	MIB_CE_IP_QOS_T qEntry;
#endif
	char ipv6Enable =-1;

	ret = 0;

	ifGetName(ifIndex, wanif, sizeof(wanif));

	if (PPP_INDEX(ifIndex) != DUMMY_PPP_INDEX) {
		// PPP interface

		snprintf(ifup_path, 32, "/var/ppp/ifup_%s", wanif);
		if (fp=fopen(ifup_path, "w+") ) {
			fprintf(fp, "#!/bin/sh\n\n");
#ifdef IP_POLICY_ROUTING
			num = mib_chain_total(MIB_IP_QOS_TBL);
			found = 0;
			// set advanced-routing rule
			for (i=0; i<num; i++) {
				if (!mib_chain_get(MIB_IP_QOS_TBL, i, (void *)&qEntry))
					continue;
#ifdef QOS_DIFFSERV
				if (qEntry.enDiffserv == 1) // Diffserv entry
					continue;
#endif
				if (qEntry.outif == ifIndex) {

					found = 1;
					mark = get_classification_mark(i);
					if (mark != 0) {
						// Don't forget to point out that fwmark with
						// ipchains/iptables is a decimal number, but that
						// iproute2 uses hexadecimal number.
						fprintf(fp, "ip ru add fwmark %x table %d\n", mark, PPP_INDEX(ifIndex)+PR_PPP_START);
					}
				}
			}
			if (found) {
				fprintf(fp, "ip ro add default dev %s table %d\n", wanif, PPP_INDEX(ifIndex)+PR_PPP_START);
			}
#endif
#if defined(CONFIG_USER_UPNPD)||defined(CONFIG_USER_MINIUPNPD)
			// Added by Mason Yu for Start upnpd.
			fprintf(fp, "/bin/upnpctrl sync\n");
#endif
#ifdef NEW_PORTMAPPING
			//august: 2012 March 3rd for fixing the pppoe re-up portmapping bugs
			fprintf(fp, "ip ro flush table %d\n", caculate_tblid(ifIndex));
			fprintf(fp, "ip ro add default dev %s table %d\n", wanif, caculate_tblid(ifIndex));

			// default table
			if (pEntry->applicationtype&X_CT_SRV_INTERNET) {
				fprintf(fp, "ip ro flush table %d\n", PMAP_DEFAULT_TBLID);
				fprintf(fp, "ip ro add default dev %s table %d\n", wanif, PMAP_DEFAULT_TBLID);
#if defined(CONFIG_USER_PPPOE_PROXY)
				if(pEntry->PPPoEProxyEnable){
					fprintf(fp, "route add default %s \n", wanif);
					fprintf(fp, "iptables -I  FORWARD  1 -i ppp+ -o %s -j ACCEPT", wanif);
				}
#endif
			}
#endif

			fclose(fp);
			chmod(ifup_path, 484);

			// Added by Mason Yu. For IPV6
#ifdef CONFIG_IPV6
			mib_get(MIB_V6_IPV6_ENABLE, (void *)&ipv6Enable);
			if(ipv6Enable == 1)
			{
				snprintf(ifup_path, 32, "/var/ppp/ifupv6_%s", wanif);
				if (fp=fopen(ifup_path, "w+") ) {
					unsigned char Ipv6AddrStr[48], RemoteIpv6AddrStr[48];
					unsigned char pidfile[30], leasefile[30];
					unsigned char value[256];

					fprintf(fp, "#!/bin/sh\n\n");

					if ( ((pEntry->AddrMode & IPV6_WAN_STATIC)) == IPV6_WAN_STATIC ) {
						unsigned char zero_ip[IP6_ADDR_LEN] = {0};
						char dns_addr[48] = {0};
						int dns_set = 0;

						inet_ntop(PF_INET6, (struct in6_addr *)pEntry->Ipv6Addr, Ipv6AddrStr, sizeof(Ipv6AddrStr));
						inet_ntop(PF_INET6, (struct in6_addr *)pEntry->RemoteIpv6Addr, RemoteIpv6AddrStr, sizeof(RemoteIpv6AddrStr));

						// Add WAN static IP
						snprintf(Ipv6AddrStr, 48, "%s/%d", Ipv6AddrStr, pEntry->Ipv6AddrPrefixLen);
						fprintf(fp, "/bin/ifconfig %s add %s\n", wanif, Ipv6AddrStr);

						// Add default gw
						if (pEntry->dgw) {
							// route -A inet6 add ::/0 gw 3ffe::0200:00ff:fe00:0100 dev ppp0
							fprintf(fp, "/bin/route -A inet6  add ::/0 gw %s dev %s\n", RemoteIpv6AddrStr, wanif);
						}

						if(memcmp(zero_ip, pEntry->Ipv6Dns1, IP6_ADDR_LEN) != 0)
						{
							inet_ntop(AF_INET6, pEntry->Ipv6Dns1, dns_addr, 64);
							fprintf(fp, "echo %s > /var/resolv6.conf.%s\n", dns_addr, wanif);
							//Alan, fix local out can not access dns server,
							//dns server IPv6 address add to ipv6 route table will cause dns packet cannot be sent.
							//fprintf(fp, "/bin/route -A inet6 add %s dev %s\n", dns_addr, wanif);
							dns_set = 1;
						}
						if(memcmp(zero_ip, pEntry->Ipv6Dns2, IP6_ADDR_LEN) != 0)
						{
							inet_ntop(AF_INET6, pEntry->Ipv6Dns2, dns_addr, 64);
							fprintf(fp, "echo %s >> /var/resolv6.conf.%s\n", dns_addr, wanif);
							//Alan, fix local out can not access dns server,
							//dns server IPv6 address add to ipv6 route table will cause dns packet cannot be sent.
							//fprintf(fp, "/bin/route -A inet6 add %s dev %s\n", dns_addr, wanif);
							dns_set = 1;
						}

						if(dns_set)
							fprintf(fp, "/bin/kill -SIGUSR1 `cat /var/run/systemd.pid`\n");
					}

#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
					// Start DHCPv6 client
					// dhclient -6 -sf /var/dhclient-script -lf /var/dhclient6-leases -pf /var/run/dhclient6.pid ppp0 -d -q -N -P
					if ( (pEntry->Ipv6Dhcp == 1) || ((pEntry->Ipv6DhcpRequest & 0x2) == 0x2) ) {
						snprintf(leasefile, 30, "/var/%s%s.leases", DHCPCV6STR, wanif);
						snprintf(pidfile, 30, "/var/run/%s%s.pid", DHCPCV6STR, wanif);
						snprintf(value, sizeof(value), "/bin/dhclient -6 -sf /etc/dhclient-script -lf %s -pf %s %s -d -q", leasefile, pidfile, wanif);
						// Request Address
						if ( (pEntry->Ipv6DhcpRequest & 0x1) == 0x1 ) {
							snprintf(value, sizeof(value), "%s -N", value);
						}

						// Request Prefix
						if ( (pEntry->Ipv6DhcpRequest & 0x2) == 0x2 ) {
							snprintf(value, sizeof(value), "%s -P", value);
						}

						// If dsliet enabled, using dhcpv6 option 64 to request AFTR.
						if((pEntry->dslite_enable == 1) && (pEntry->dslite_aftr_mode == IPV6_DSLITE_MODE_AUTO)){
							char fconf[64] = {0};
							sprintf(fconf, "/var/dhclient6_%s.conf", wanif);

							FILE *fp = fopen(fconf, "w");

							if(fp)
							{

								if(pEntry->dslite_enable){
									fprintf(fp, "option dhcp6.dslite code 64 = domain-list; \n");
									fprintf(fp, "also request dhcp6.dslite; \n");
								}

								fclose(fp);
							}

							snprintf(value, sizeof(value), "%s -cf %s ", value, fconf);

						}
						else{
							//If dslite_aftr_mode is static, send signal to let systemd be prepared to setup dslite
							if(pEntry->dslite_enable &&
							 (pEntry->dslite_aftr_mode == IPV6_DSLITE_MODE_STATIC ) &&
							 (pEntry->dslite_aftr_hostname!=NULL)){
									fprintf(fp, "/bin/kill -SIGUSR2 `cat /var/run/systemd.pid`\n");
							}
						}

						snprintf(value, sizeof(value), "%s &\n", value);
						fprintf(fp, value);
					}
#endif

#ifdef NEW_PORTMAPPING
					fprintf(fp, "ip -6 ro flush table %d\n", caculate_tblid(ifIndex));
					fprintf(fp, "ip -6 ro add default dev %s table %d\n", wanif, caculate_tblid(ifIndex));

					// default table
					if (pEntry->applicationtype&X_CT_SRV_INTERNET) {
						fprintf(fp, "ip -6 ro flush table %d\n", PMAP_DEFAULT_TBLID);
						fprintf(fp, "ip -6 ro add default dev %s table %d\n", wanif, PMAP_DEFAULT_TBLID);
					}
#endif
					fclose(fp);
					chmod(ifup_path, 484);
				}
			}  //End of if(ipv6Enable == 1)
#endif

		}
		else
			ret = -1;
	}
	else {
		// not supported till now
		return -1;
	}

	return ret;
}

/*
 *	generate the ifdown_ppp(vc)x script for WAN interface
 */
static int generate_ifdown_script(unsigned int ifIndex, MIB_CE_ATM_VC_Tp pEntry)
{
	int mark, ret;
	FILE *fp;
	char wanif[6], ifdown_path[32];
	char devname[IFNAMSIZ];
	unsigned char vChar;

	ret = 0;

	if (PPP_INDEX(ifIndex) != DUMMY_PPP_INDEX) {
		// PPP interface
		snprintf(wanif, 6, "ppp%u", PPP_INDEX(ifIndex));
		snprintf(ifdown_path, 32, "/var/ppp/ifdown_%s", wanif);
		if (fp=fopen(ifdown_path, "w+") ) {
			fprintf(fp, "#!/bin/sh\n\n");
#ifdef NEW_PORTMAPPING
			if (pEntry->cmode == CHANNEL_MODE_PPPOE) {
				ifGetName(PHY_INTF(ifIndex), devname, sizeof(devname));
				fprintf(fp, "ip ro change default dev %s table %d\n", devname, caculate_tblid(ifIndex));
				// default table
				if (pEntry->applicationtype&X_CT_SRV_INTERNET) {
					fprintf(fp, "ip ro change default dev %s table %d\n", devname, PMAP_DEFAULT_TBLID);
				}
			}
#endif

#if defined(CONFIG_IPV6) && defined(CONFIG_BHS) && defined(CONFIG_USER_DHCPV6_ISC_DHCP411)
            /* For Telefonica IPv6 Test Plan, Test Case ID 20178, if PPPoE session is down,			   *
			 * LAN PC global IPv6 address must change the state from "Prefered" to "Obsolete".		   *
			 * So here, if PPPoE connection is down, and DHCPv6 is auto mode, kill the DHCPv6 process  */

			mib_get( MIB_DHCPV6_MODE, (void *)&vChar);
			if (vChar==3) {  // 3:auto mode
				fprintf(fp, "kill `cat /var/run/dhcpd6.pid`\n");
            }
#endif
			fclose(fp);
			chmod(ifdown_path, 484);
		}
		else
			ret = -1;
	}
	else {
		// not supported till now
		return -1;
	}

	return ret;
}

/*
 *	setup the policy-routing for static link
 */
#ifdef IP_POLICY_ROUTING
static int setup_static_PolicyRouting(unsigned int ifIndex)
{
	int i, num, mark, ret, found;
	char str_mark[8], str_rtable[8], ipAddr[32], wanif[IFNAMSIZ];
	struct in_addr inAddr;
	MIB_CE_IP_QOS_T qEntry;

	ret = -1;

	if (ifIndex == DUMMY_IFINDEX)
		return ret;
	else {
		if (PPP_INDEX(ifIndex) != DUMMY_PPP_INDEX) {
			// PPP interface
			return ret;
		}
		else {
			// vc interface
			ifGetName(ifIndex,wanif,sizeof(wanif));
			snprintf(str_rtable, 8, "%d", VC_INDEX(ifIndex)+PR_VC_START);
			if (getInAddr( wanif, DST_IP_ADDR, (void *)&inAddr) == 1)
			{
				strcpy(ipAddr, inet_ntoa(inAddr));
			}
			else
				return ret;
		}

		if (!getInFlags(wanif, 0))
			return ret;	// interface not found
	}

	num = mib_chain_total(MIB_IP_QOS_TBL);
	found = 0;
	// set advanced-routing rule
	for (i=0; i<num; i++) {
		if (!mib_chain_get(MIB_IP_QOS_TBL, i, (void *)&qEntry))
			continue;
#ifdef QOS_DIFFSERV
		if (qEntry.enDiffserv == 1) // Diffserv entry
			continue;
#endif
		if (qEntry.outif == ifIndex) {

			found = 1;
			mark = get_classification_mark(i);
			if (mark != 0) {
				snprintf(str_mark, 8, "%x", mark);
				// Don't forget to point out that fwmark with
				// ipchains/iptables is a decimal number, but that
				// iproute2 uses hexadecimal number.
				// ip ru add fwmark xxx table 3
				va_cmd("/bin/ip", 6, 1, "ru", "add", "fwmark", str_mark, "table", str_rtable);
				// ip ro add default via ipaddr dev vc0 table 3
			}
		}
	}
	if (found) {
		// ip ro add default via ipaddr dev vc0 table 3
		va_cmd("/bin/ip", 9, 1, "ro", "add", "default", "via", ipAddr, "dev", wanif, "table", str_rtable);
		ret = 0;
	}

	return ret;
}
#endif


#ifdef CONFIG_USER_WT_146
#define BFD_SERVER_FIFO_NAME "/tmp/bfd_serv_fifo"
#define BFD_CONF_PREFIX "/var/bfd/bfdconf_"
static void wt146_write_to_bfdmain(struct data_to_pass_st *pmsg)
{
	int bfdmain_fifo_fd=-1;

	bfdmain_fifo_fd = open(BFD_SERVER_FIFO_NAME, O_WRONLY);
	if (bfdmain_fifo_fd == -1)
		fprintf(stderr, "Sorry, no bfdmain server\n");
	else
	{
		write(bfdmain_fifo_fd, pmsg, sizeof(*pmsg));
		close(bfdmain_fifo_fd);
	}
}

#define BFDCFG_DBGLOG		"/var/bfd/bfd_dbg_log"
int wt146_dbglog_get(unsigned char *ifname)
{
	char buff[256];
	FILE *fp;
	unsigned char name[32];
	int dbgflag=0;

	//printf( "%s> enter\n", __FUNCTION__ );
	if(ifname)
	{
		//printf( "%s> open %s, search for %s\n", __FUNCTION__, BFDCFG_DBGLOG, ifname );
		fp = fopen(BFDCFG_DBGLOG, "r");
		if(fp)
		{
			while(fgets(buff, sizeof(buff), fp)!=NULL)
			{
				//printf( "%s> got %s", __FUNCTION__, buff );
				int flag;
				if (sscanf(buff, "%s %d", name, &flag) != 2)
					continue;
				else{
					if( strcmp( name, ifname )==0 )
					{
						dbgflag=flag?1:0;
						break;
					}
				}
			}
			fclose(fp);
		}
	}

	//printf( "%s> exit, dbgflag=%d\n", __FUNCTION__, dbgflag );
	return dbgflag;
}

void wt146_create_wan(MIB_CE_ATM_VC_Tp pEntry, int reset_bfd_only )
{
	if(pEntry)
	{
		char wanif[5], conf_name[32];
		FILE *fp;

		if(pEntry->enable==0)
			return;

		if( (pEntry->cmode!=CHANNEL_MODE_IPOE) &&
			(pEntry->cmode!=CHANNEL_MODE_RT1483) )
			return;

		if( pEntry->bfd_enable==0 ) return 0;

		snprintf(wanif, 5, "vc%d", VC_INDEX(pEntry->ifIndex));
		snprintf(conf_name, 32, "%s%s", BFD_CONF_PREFIX, wanif);
		fp=fopen( conf_name, "w" );
		if(fp)
		{
			int bfddebug;
			if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED)
			{
				fprintf( fp, "LocalIP=%s\n",  inet_ntoa(*((struct in_addr *)pEntry->ipAddr)) );
				fprintf( fp, "RemoteIP=%s\n",  inet_ntoa(*((struct in_addr *)pEntry->remoteIpAddr)) );
			}

			fprintf( fp, "OpMode=%u\n", pEntry->bfd_opmode );
			fprintf( fp, "Role=%u\n", pEntry->bfd_role );
			fprintf( fp, "DetectMult=%u\n", pEntry->bfd_detectmult );
			fprintf( fp, "MinTxInt=%u\n", pEntry->bfd_mintxint );
			fprintf( fp, "MinRxInt=%u\n", pEntry->bfd_minrxint );
			fprintf( fp, "MinEchoRxInt=%u\n", pEntry->bfd_minechorxint );
			fprintf( fp, "AuthType=%u\n", pEntry->bfd_authtype );
			if( pEntry->bfd_authtype!=BFD_AUTH_NONE )
			{
				int authkeylen=0;
				fprintf( fp, "AuthKeyID=%u\n", pEntry->bfd_authkeyid );
				fprintf( fp, "AuthKey=" );
					while( authkeylen<pEntry->bfd_authkeylen  )
					{
						fprintf( fp, "%02x", pEntry->bfd_authkey[authkeylen] );
						authkeylen++;
					}
					fprintf( fp, "\n" );
			}
			fprintf( fp, "DSCP=%u\n", pEntry->bfd_dscp );
			if(pEntry->cmode==CHANNEL_MODE_IPOE)
				fprintf( fp, "EthPrio=%u\n", pEntry->bfd_ethprio );
			bfddebug=wt146_dbglog_get( wanif );
			fprintf( fp, "debug=%d\n", bfddebug );
			fclose(fp);

			if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED)
			{
				struct data_to_pass_st msg;
				snprintf(msg.data, BUF_SIZE,"bfdctl add %s file %s", wanif, conf_name);
				TRACE(STA_SCRIPT, "%s\n", msg.data);
				//printf( "%s> %s\n",  __FUNCTION__, msg.data);
				wt146_write_to_bfdmain(&msg);
			}else{
				//only re-init bfd, not re-init wanconnection
				if(reset_bfd_only)
				{
					int dhcpc_pid;
					dhcpc_pid = read_pid((char*)DHCPC_PID);
					if (dhcpc_pid > 0)
						kill(dhcpc_pid, SIGHUP);
				}
			}
		}

		//printf( "%s> create %s bfd session\n", __FUNCTION__, wanif );
	}
}

void wt146_del_wan(MIB_CE_ATM_VC_Tp pEntry)
{
	if(pEntry)
	{
		if(pEntry->enable==0)
			return;

		if( (pEntry->cmode!=CHANNEL_MODE_IPOE) &&
			(pEntry->cmode!=CHANNEL_MODE_RT1483) )
			return;

		//if ((DHCP_T)pEntry->ipDhcp == DHCP_DISABLED)
		{
				struct data_to_pass_st msg;
				char wanif[5], conf_name[32];

				snprintf(wanif, 5, "vc%d", VC_INDEX(pEntry->ifIndex));
				snprintf(conf_name, 32, "%s%s", BFD_CONF_PREFIX, wanif);
				unlink( conf_name);

				snprintf(msg.data, BUF_SIZE,"bfdctl del %s", wanif);
				TRACE(STA_SCRIPT, "%s\n", msg.data);
				//printf( "%s> %s\n",  __FUNCTION__, msg.data);
				wt146_write_to_bfdmain(&msg);

				//printf( "%s> delete %s bfd session\n", __FUNCTION__, wanif );
		}
	}
}

void wt146_set_default_config(MIB_CE_ATM_VC_Tp pEntry)
{
	if(pEntry)
	{
		if( (pEntry->cmode==CHANNEL_MODE_IPOE) ||
			(pEntry->cmode==CHANNEL_MODE_RT1483) )
			pEntry->bfd_enable=1;
		else
			pEntry->bfd_enable=0;

		pEntry->bfd_opmode=BFD_DEMAND_MODE;
		pEntry->bfd_role=BFD_PASSIVE_ROLE;
		pEntry->bfd_detectmult=3;
		pEntry->bfd_mintxint=1000000;
		pEntry->bfd_minrxint=1000000;
		pEntry->bfd_minechorxint=0;
		pEntry->bfd_authtype=BFD_AUTH_NONE;
		pEntry->bfd_authkeyid=0;
		pEntry->bfd_authkeylen=0;
		memset( pEntry->bfd_authkey, 0, sizeof(pEntry->bfd_authkey) );
		pEntry->bfd_dscp=0;
		pEntry->bfd_ethprio=0;
	}
}

void wt146_copy_config(MIB_CE_ATM_VC_Tp pto, MIB_CE_ATM_VC_Tp pfrom)
{
	if(pto && pfrom)
	{
		//printf( "\n\nwt146_copy_config\n" );
		pto->bfd_enable=pfrom->bfd_enable;
		pto->bfd_opmode=pfrom->bfd_opmode;
		pto->bfd_role=pfrom->bfd_role;
		pto->bfd_detectmult=pfrom->bfd_detectmult;
		pto->bfd_mintxint=pfrom->bfd_mintxint;
		pto->bfd_minrxint=pfrom->bfd_minrxint;
		pto->bfd_minechorxint=pfrom->bfd_minechorxint;
		pto->bfd_authtype=pfrom->bfd_authtype;
		pto->bfd_authkeyid=pfrom->bfd_authkeyid;
		pto->bfd_authkeylen=pfrom->bfd_authkeylen;
		memcpy( pto->bfd_authkey, pfrom->bfd_authkey, sizeof(pto->bfd_authkey) );
		pto->bfd_dscp=pfrom->bfd_dscp;
		pto->bfd_ethprio=pfrom->bfd_ethprio;
	}
}
#endif //CONFIG_USER_WT_146

//Inform kernel the number of routing interface.
// flag = 1 to increase 1
// flag = 0 to decrease 1
static void internetLed_route_if(int flag)
{
	FILE *fp;

	fp = fopen ("/proc/IntnetLED", "w");
	if (fp)
	{
		if (flag)
			fprintf(fp,"+");
		else
			fprintf(fp,"-");
		fclose(fp);
	}
}

static int setup_ethernet_config(MIB_CE_ATM_VC_Tp pEntry, char *wanif)
{
	char *argv[8];
	int status=0;
	unsigned char devAddr[MAC_ADDR_LEN];
	char macaddr[MAC_ADDR_LEN*2+1];

#if defined(CONFIG_LUNA) && defined(GEN_WAN_MAC)
		{
			snprintf(macaddr, 13, "%02x%02x%02x%02x%02x%02x",
				pEntry->MacAddr[0], pEntry->MacAddr[1], pEntry->MacAddr[2], pEntry->MacAddr[3], pEntry->MacAddr[4], pEntry->MacAddr[5]);

			argv[1]=wanif;
			argv[2]="down";
			argv[3]="hw";
			argv[4]="ether";
			argv[5]=macaddr;
			argv[6]=NULL;
			TRACE(STA_SCRIPT, "%s %s %s %s %s\n", IFCONFIG, argv[1], argv[2], argv[3], argv[4]);
			status|=do_cmd(IFCONFIG, argv, 1);
		}
#else	// #if defined(CONFIG_LUNA) && defined(GEN_WAN_MAC)

		if (mib_get(MIB_ELAN_MAC_ADDR, (void *)devAddr) != 0)
		{
			snprintf(macaddr, 13, "%02x%02x%02x%02x%02x%02x",
				devAddr[0], devAddr[1], devAddr[2],
#ifdef CONFIG_USER_IPV6READYLOGO_ROUTER
				//Set vc and nas mac with br0's mac plus 1
				devAddr[3], devAddr[4], devAddr[5]+1);
#else
				devAddr[3], devAddr[4], devAddr[5]);
#endif
			argv[1]=wanif;
			argv[2]="down";
			argv[3]="hw";
			argv[4]="ether";
			argv[5]=macaddr;
			argv[6]=NULL;
			TRACE(STA_SCRIPT, "%s %s %s %s %s\n", IFCONFIG, argv[1], argv[2],
						argv[3], argv[4]);
			status|=do_cmd(IFCONFIG, argv, 1);
		}
#endif

#ifdef CONFIG_RTK_L34_ENABLE

		char sysbuf[128];
		int wanPhyPort;
#if 0
		if(mib_get(MIB_WAN_PHY_PORT,(void *)&wanPhyPort)){
			sprintf( sysbuf, "/bin/echo %d nas0 > /proc/rtl8686gmac/dev_port_mapping",wanPhyPort );
		}
#else
		wanPhyPort = RG_get_wan_phyPortId();
		if(wanPhyPort!=-1){
			sprintf( sysbuf, "/bin/echo %d nas0 > /proc/rtl8686gmac/dev_port_mapping",wanPhyPort );
		}
#endif

		/*
		#ifdef CONFIG_RG_API_RLE0371
		sprintf( sysbuf, "/bin/echo 5 nas0 > /proc/rtl8686gmac/dev_port_mapping" );
		#else
		sprintf( sysbuf, "/bin/echo 3 nas0 > /proc/rtl8686gmac/dev_port_mapping" );
		#endif
		*/
		printf( "system(): %s\n", sysbuf );
		system(sysbuf);

		//Temporary solution for netlink event down/up that will let spppd has ubnormal behavior.
		sleep(1);
#endif
		// ifconfig vc0 txqueuelen 10
		argv[1] = wanif;
		argv[2] = "txqueuelen";
#ifdef NEW_IP_QOS_SUPPORT
		argv[3] = "100";
#else
                argv[3] = "10";
#endif
		argv[4] = NULL;
		TRACE(STA_SCRIPT, "%s %s %s %s\n", IFCONFIG, argv[1], argv[2], argv[3]);
		status|=do_cmd(IFCONFIG, argv, 1);
#ifdef CONFIG_IPV6
		// Disable ipv6 in bridge
		if (pEntry->cmode == CHANNEL_MODE_BRIDGE)
			setup_disable_ipv6(wanif, 1);
		else { // enable ipv6 if applicable
			if (pEntry->IpProtocol & IPVER_IPV6)
				setup_disable_ipv6(wanif, 0);
			else
				setup_disable_ipv6(wanif, 1);
		}
#endif
		// ifconfig vc0 up
		argv[2] = "up";
		argv[3] = NULL;
		TRACE(STA_SCRIPT, "%s %s %s\n", IFCONFIG, argv[1], argv[2]);
		status|=do_cmd(IFCONFIG, argv, 1);

		return status;
}




#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
int Init_RTK_RG_Device(void)
{
	char wanif[IFNAMSIZ];
	int i;

	va_cmd(BRCTL, 2, 1, "addbr", BRIF );

	for(i=1;i<6;i++)
	{
		snprintf( wanif, sizeof(wanif), "eth0.%d", i);
		va_cmd(IFCONFIG, 2, 1, wanif, "down");
	}
	snprintf( wanif, sizeof(wanif), "eth0");
	va_cmd(BRCTL, 3, 1, "addif", BRIF, wanif);

//	snprintf( wanif, sizeof(wanif), "nas0");
//	va_cmd(BRCTL, 3, 1, "delif", BRIF, wanif);

/*
	for(i=1;i<6;i++)
	{
		snprintf( wanif, sizeof(wanif), "eth0.%d", i);
		va_cmd(BRCTL, 3, 1, "delif", BRIF, wanif);
	}
*/
	snprintf( wanif, sizeof(wanif), "eth0");
	va_cmd(IFCONFIG, 2, 1, wanif, "down");

	snprintf( wanif, sizeof(wanif), "nas0");
	va_cmd(IFCONFIG, 2, 1, wanif, "down");

	snprintf( wanif, sizeof(wanif), "br0");
	va_cmd(IFCONFIG, 2, 1, wanif, "down");
}
#endif

void clearRG_Wan_Index(void)
{
	unsigned int entryNum, i=0;
	MIB_CE_ATM_VC_T entry;

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&entry))
		{
			continue;
		}
#ifdef CONFIG_RTK_L34_ENABLE
		if (entry.rg_wan_idx != 0) {
			entry.rg_wan_idx = 0;
			mib_chain_update(MIB_ATM_VC_TBL, &entry, i);
		}
#endif
	}

#ifdef ROUTING	
	MIB_CE_IP_ROUTE_T Entry;
	entryNum = mib_chain_total(MIB_IP_ROUTE_TBL);
	for (i=0; i<entryNum; i++) {
	
		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
		{
			continue;
		}
#ifdef CONFIG_RTK_L34_ENABLE
		if (Entry.rg_staticRoute_idx >= 0) {
			Entry.rg_staticRoute_idx = -1;
			mib_chain_update(MIB_IP_ROUTE_TBL, &Entry, i);
		}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		if (Entry.rg_acl_idx >=0) {
			Entry.rg_acl_idx = -1;
			mib_chain_update(MIB_IP_ROUTE_TBL, &Entry, i);
		}
#endif
#endif
	}
#endif	
}

// return value:
// 0  : successful
// -1 : failed
int startConnection(MIB_CE_ATM_VC_Tp pEntry, int mib_vc_idx)
{
	struct data_to_pass_st msg;
	char *aal5Encap, qosParms[64], wanif[IFNAMSIZ];
	int brpppoe;
	int pcreg, screg;
	int status=0;
	MEDIA_TYPE_T mType;
	char vChar=-1;
#if defined(CONFIG_USER_UPNPD)||defined(CONFIG_USER_MINIUPNPD)
	unsigned char upnpdEnable;
	unsigned int upnpItf;
	char ext_ifname[IFNAMSIZ];
#endif

	if(pEntry == NULL || pEntry->enable == 0)
	{
		return 0;
	}

	mType = MEDIA_INDEX(pEntry->ifIndex);
	if (pEntry->cmode != CHANNEL_MODE_BRIDGE)
		internetLed_route_if(1);//+1

#ifdef NEW_PORTMAPPING
		get_pmap_fgroup(pmap_list, MAX_VC_NUM);
		setup_wan_pmap_lanmember(mType, pEntry->ifIndex);
#endif

	//snprintf(wanif, 5, "vc%d", VC_INDEX(pEntry->ifIndex));
	ifGetName(PHY_INTF(pEntry->ifIndex),wanif,sizeof(wanif));
	//printf("%s true_%s, major dev=%s\n", __func__, MEDIA_INDEX(pEntry->ifIndex)?"ETH":"ATM", wanif);

	if (pEntry->cmode != CHANNEL_MODE_PPPOA)
	{
		setup_ethernet_config(pEntry, wanif);
	}

	printf("[%s@%d] pEntry->ifIndex = %d, pEntry->cmode = %d \n", __FUNCTION__, __LINE__, pEntry->ifIndex, pEntry->cmode);

	if (pEntry->cmode == CHANNEL_MODE_BRIDGE)
	{
  	//shlee turns on DIRECT_BRIDGE_MODE only bridge mode pvc
  	//Avoiding pppoe passthrough will enter direct bridge
		if (mType == MEDIA_ATM) {
			unsigned char ch_no[32];
			sprintf(ch_no,"%d",VC_INDEX(pEntry->ifIndex));
	  		va_cmd("/bin/sarctl",2,1,"direct_bridge",ch_no);	// Turns on direct bridge mode
		}

		// rfc1483-bridged
		// brctl addif br0 vc0
		printf("1483 bridged\n");
		// Mason Yu
		if ( pEntry->brmode != BRIDGE_DISABLE )
		{
			status|=va_cmd(BRCTL, 3, 1, "addif", BRIF, wanif);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
#if defined(CONFIG_EPON_FEATURE) || defined(CONFIG_GPON_FEATURE)
			if(RTK_RG_BridgeType_ACL_Rule_Set(pEntry)<0)
				status = -1;
#endif
#endif
#endif
		}

	}
	else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_IPOE)
	{
		// MAC Encapsulated Routing
		printf("1483 MER\n");

		if (startIP(wanif, pEntry, CHANNEL_MODE_IPOE) == -1)
		{
			printf("start MER failed !\n");
			status=-1;
		}
//forwarding Engine will do it.
#if defined(PPPOE_PASSTHROUGH) && !defined(CONFIG_RTK_L34_ENABLE)
		//if (pEntry->brmode == BRIDGE_PPPOE)	// enable PPPoE pass-through
		if (pEntry->brmode != BRIDGE_DISABLE)	// enable bridge
			// brctl addif br0 vc0
			status|=va_cmd(BRCTL, 3, 1, "addif", BRIF, wanif);
#endif
		if ( pEntry->ipDhcp == DHCP_DISABLED ) {
#ifdef IP_POLICY_ROUTING
			setup_static_PolicyRouting(pEntry->ifIndex);
#endif
		}
	}
	else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOE)
	{
		// PPPoE
		printf("PPPoE\n");

		if (startPPP(wanif, pEntry, 0, CHANNEL_MODE_PPPOE) == -1)
		{
			printf("start PPPoE failed !\n");
			status=-1;
		}
#if defined(CONFIG_USER_PPPOE_PROXY)
		RTK_RG_PPPoE_Proxy_Rule_Set(pEntry);
#endif
//forwarding Engine will do it.
#if defined(PPPOE_PASSTHROUGH) && !defined(CONFIG_RTK_L34_ENABLE)
		//if (pEntry->brmode == BRIDGE_PPPOE)	// enable PPPoE pass-through
		if (pEntry->brmode != BRIDGE_DISABLE)	// enable bridge
			// brctl addif br0 vc0
			status|=va_cmd(BRCTL, 3, 1, "addif", BRIF, wanif);
#endif
	}
#if defined(CONFIG_IPV6) && defined(CONFIG_IPV6_SIT_6RD)
	else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_6RD)
	{
		// 6RD
		printf("6RD\n");
		if (startIP(wanif, pEntry, CHANNEL_MODE_IPOE) == -1)
		{
			printf("start 6RD failed !\n");
			status=-1;
		}
	}
#endif

// Magician: UPnP Daemon Start
#if defined(CONFIG_USER_UPNPD)||defined(CONFIG_USER_MINIUPNPD)
	if(mib_get(MIB_UPNP_DAEMON, (void *)&upnpdEnable) && upnpdEnable)
	{
		if (mib_get(MIB_UPNP_EXT_ITF, (void *)&upnpItf) && upnpItf == pEntry->ifIndex)
		{
			ifGetName(upnpItf, ext_ifname, sizeof(ext_ifname));

			va_cmd("/bin/upnpctrl", 1, 1, "sync");
			va_cmd("/bin/upnpctrl", 3, 1, "up", ext_ifname, BRIF);
		}
	}
#endif
// The end of UPnP Daemon Start

#ifdef CONFIG_USER_WT_146
	wt146_create_wan(pEntry, 0);
#endif //CONFIG_USER_WT_146

#ifdef CONFIG_IPV6
/* Martin zhu add for bridge WAN support ipv4/ipv6 2015.6.29 */
	{
    	unsigned char province_disable_bridge_v4v6_filter;
    	mib_get(PROVINCE_DISABLE_BRIDGE_V4V6_FILTER, (void *)&province_disable_bridge_v4v6_filter);
		if(!province_disable_bridge_v4v6_filter)
		{
				printf("Enable bridge v4v6 filter!!\n");
				setupBridgeIPv4IPv6Filter(pEntry,1);
		}
	}
#endif

	if (status >= 0) {
		generate_ifup_script(pEntry->ifIndex, pEntry);
		generate_ifdown_script(pEntry->ifIndex, pEntry);
	}
#if 0//defined (CONFIG_EPON_FEATURE) && defined(CONFIG_RTK_L34_ENABLE)
	//cxy 2016-6-6: oam need to add iptv wan vid as default multicast vlan
	if(pEntry->applicationtype == X_CT_SRV_OTHER)
	{
		int pon_mode=0;
		int i;
		mib_get(MIB_PON_MODE, &pon_mode);
		if(pon_mode == EPON_MODE)
		{
			char cmdstr[128];
			for(i=0; i<SW_LAN_PORT_NUM; i++)
			{
				if((pEntry->itfGroup)&(1<<i))
				{
					snprintf(cmdstr, sizeof(cmdstr), "oamcli set igmp mcvlan %d %d 1", i, pEntry->vid);
					system(cmdstr);
				}
			}
		}
	}
#endif
	return status;
}

#if defined(CONFIG_RTL_MULTI_ETH_WAN)
static void addEthWANdev(MIB_CE_ATM_VC_Tp pEntry)
{
	MEDIA_TYPE_T mType;
	char ifname[IFNAMSIZ];
	int flag=0;

	ifGetName(PHY_INTF(pEntry->ifIndex), ifname, sizeof(ifname));
	mType = MEDIA_INDEX(pEntry->ifIndex);

	//add new ethwan dev here.
	if( (mType == MEDIA_ETH) && (WAN_MODE & MODE_Ethernet)){
		int tmp_group;
		const char smux_brg_cmd[]="/bin/ethctl addsmux bridge %s %s";
		const char smux_ipoe_cmd[]="/bin/ethctl addsmux ipoe %s %s";
		const char smux_pppoe_cmd[]="/bin/ethctl addsmux pppoe %s %s";

		char cmd_str[128]={0};
		unsigned char *rootdev=NULL;

		rootdev=ALIASNAME_NAS0;

		va_cmd(IFCONFIG, 2, 1, rootdev, "up");
		if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_BRIDGE)
			snprintf(cmd_str, 100, smux_brg_cmd, rootdev, ifname);
		else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_IPOE || (CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_6RD)
			snprintf(cmd_str, 100, smux_ipoe_cmd, rootdev, ifname);
		else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOE)
			snprintf(cmd_str, 100, smux_pppoe_cmd, rootdev, ifname);

		if (pEntry->napt)
			strncat(cmd_str, " napt", strlen(" napt"));

		if(pEntry->brmode != BRIDGE_DISABLE)
			strncat(cmd_str, " brpppoe", strlen(" brpppoe"));

		if (pEntry->vlan) {
			unsigned int vlantag;
			vlantag = (pEntry->vid|((pEntry->vprio) << 13));
			snprintf(cmd_str, 100, "%s vlan %d", cmd_str, vlantag );
		}
		printf("TRACE: %s\n", cmd_str);
		system(cmd_str);

		while(getInFlags(ifname, &flag)==0) { //wait the device created successly, Iulian Wu
			printf("Ethernet WAN not ready!\n");
			sleep(2);
		}
	}
}
#endif


void stopConnection(MIB_CE_ATM_VC_Tp pEntry)
{
	struct data_to_pass_st msg;
	char wandev[IFNAMSIZ];
	char wanif[IFNAMSIZ];
	char myip[16];
	int i;
	char ifname[IFNAMSIZ];   // major vc device name

#ifdef CONFIG_USER_MINIUPNPD
	unsigned char upnpdEnable;
	unsigned int upnpItf;
	char ext_ifname[IFNAMSIZ];
#endif
	char file[128]={0};


#ifdef CONFIG_RTK_L34_ENABLE
	/* When delete the RG wan entry , burst pkts will trap into CPU causing system hang, limit the CPU bandwidth */
	RG_set_CPU_port_egress_bandwidth_control(1024);
#endif
	clean_SourceRoute(pEntry);

#ifdef CONFIG_USER_WT_146
	wt146_del_wan(pEntry);
#endif //CONFIG_USER_WT_146

// Magician: UPnP Daemon Stop
#ifdef CONFIG_USER_MINIUPNPD
	if (mib_get(MIB_UPNP_DAEMON, &upnpdEnable) && upnpdEnable) {
		if (mib_get(MIB_UPNP_EXT_ITF, &upnpItf)
		    && upnpItf == pEntry->ifIndex) {
			ifGetName(upnpItf, ext_ifname, sizeof(ext_ifname));

			va_cmd("/bin/upnpctrl", 3, 1, "down", ext_ifname, BRIF);
		}
	}
#endif
// The end of UPnP Daemon Stop

	// delete this vc
	if (pEntry->cmode == CHANNEL_MODE_PPPOE || pEntry->cmode == CHANNEL_MODE_PPPOA)
	{
		int i,entryNum;
		MIB_CE_ATM_VC_T Entry;
		
		// spppctl del 0
		snprintf(msg.data, BUF_SIZE,
			"spppctl del %u", PPP_INDEX(pEntry->ifIndex));
		snprintf(wanif, 6, "ppp%u", PPP_INDEX(pEntry->ifIndex));
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
		printf("send command [%s]\n",msg.data);

		/* Andrew, need to remove all PPP using the same underlying VC or kernel will have NULL references */
		entryNum =  mib_chain_total(MIB_ATM_VC_TBL);
		for (i = 0; i < entryNum; i++) {
			/* Retrieve entry */
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				continue;

			if ((Entry.cmode != CHANNEL_MODE_PPPOE) && (Entry.cmode != CHANNEL_MODE_PPPOA))
				continue;
			if (VC_INDEX(Entry.ifIndex) != VC_INDEX(pEntry->ifIndex))
				continue;
			if (MEDIA_INDEX(pEntry->ifIndex) != MEDIA_INDEX(Entry.ifIndex))
				continue;

			snprintf(msg.data, BUF_SIZE, "spppctl del %u", PPP_INDEX(Entry.ifIndex));
			TRACE(STA_SCRIPT, "%s\n", msg.data);
			write_to_pppd(&msg);
		}
#if defined(CONFIG_USER_PPPOE_PROXY)
		RTK_RG_PPPoE_Proxy_Rule_Delete(pEntry);
#endif
	}
	else{
		//snprintf(wanif, 6, "vc%u", VC_INDEX(pEntry->ifIndex));
		ifGetName( PHY_INTF(pEntry->ifIndex), wanif, sizeof(wanif));
	}

	ifGetName( PHY_INTF(pEntry->ifIndex), wandev, sizeof(wandev));

#ifdef CONFIG_USER_PPPOE_PROXY
		if (pEntry->PPPoEProxyEnable==1)
		{
			char tp[10];
			for (i=9; i<=13; i++)	//maximum pppoe session count is 5
			{
				sprintf(tp, "ppp%d", i);
				if (find_ppp_from_conf(tp)) {
					snprintf(msg.data, BUF_SIZE, "spppctl delproxyunit %d", i);
					TRACE(STA_SCRIPT, "%s\n", msg.data);
					write_to_pppd(&msg);
					printf("send command [%s]\n",msg.data);
				}
			}

#ifdef CONFIG_RTK_L34_ENABLE
			printf("Flush PPPoE proxy ACL rule.\n");
			RTK_RG_PPPoEProxy_ACL_Rule_Flush();
#endif
		}
#endif

#ifdef CONFIG_IPV6
	stopIP_PPP_for_V6(pEntry);
#endif

#ifdef CONFIG_IPV6
	/* Martin zhu add for bridge WAN support ipv4/ipv6 Filter 2015.6.29 */
	{
    	unsigned char province_disable_bridge_v4v6_filter;
    	mib_get(PROVINCE_DISABLE_BRIDGE_V4V6_FILTER, (void *)&province_disable_bridge_v4v6_filter);
		if(!province_disable_bridge_v4v6_filter)
		{
				printf("Enable bridge v4v6 filter!!\n");
				setupBridgeIPv4IPv6Filter(pEntry,0);
		}
	}
#endif

	/******************************************************************************************************************/
	/* Ruby Note: WAN pppx must be deleted first, then  WAN Interface cound down, or it may happen that like ptm0_0   */
	/*       is disappeared , and the socket in pppx will access incorrect data in kernel pppoe_flush_dev.            */
	/******************************************************************************************************************/
	sleep(2);
	va_cmd(BRCTL, 3, 1, "delif", BRIF, wandev);

	if (pEntry->cmode != CHANNEL_MODE_BRIDGE)
		internetLed_route_if(0);//-1

	/* Kevin, stop root Qdisc before ifdown interface, for 0412 hw closing IPQoS */
	va_cmd(TC, 5, 1, "qdisc", (char *)ARG_DEL, "dev", wandev, "root");

	if (pEntry->cmode != CHANNEL_MODE_PPPOA) {
		//ifconfig vc0 0.0.0.0
		va_cmd(IFCONFIG, 2, 1, wanif, "0.0.0.0");
		// ifconfig vc0 down
		va_cmd(IFCONFIG, 2, 1, wanif, "down");
		// wait for sar to process the queueing packets
		//usleep(1000);
		for (i=0; i<10000000; i++);

#if defined(CONFIG_RTL_MULTI_ETH_WAN)
		//del ethwan dev here.
		if( MEDIA_INDEX(pEntry->ifIndex) == MEDIA_ETH)
		{
			unsigned char *rootdev;
			rootdev=ALIASNAME_NAS0;

#ifdef CONFIG_IPV6
			if (pEntry->IpProtocol & IPVER_IPV4 && (DHCP_T)pEntry->ipDhcp != DHCP_DISABLED)
			{
				int dhcpc_pid = 0;
				char filename[100] = {0};

				sprintf(filename, "%s.%s", (char*)DHCPC_PID, wandev);
				dhcpc_pid = read_pid(filename);
				if (dhcpc_pid > 0)
					kill(dhcpc_pid, SIGHUP);
			}
#endif

			printf("%s remove smux device %s\n", __func__, wandev);
			if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_BRIDGE)
			{
				va_cmd("/bin/ethctl", 4, 1, "remsmux", "bridge", rootdev, wandev);
			}
			else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_IPOE)
			{
				va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", rootdev, wandev);
			}
			else if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOE)
			{
				va_cmd("/bin/ethctl", 4, 1, "remsmux", "pppoe", rootdev, wandev);
			}
		}
#endif
	}
	// delete one NAT rule for the specific interface
	stopAddressMap(pEntry);

#ifdef CONFIG_RTK_L34_ENABLE
	{
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE) || defined(CONFIG_FIBER_FEATURE)
		int pon_mode=0, acl_default=0;
		if (mib_get(MIB_PON_MODE, (void *)&pon_mode) != 0)
		{
#ifdef CONFIG_RTL9602C_SERIES
			acl_default = 1;
#endif
			if ((pon_mode != GPON_MODE) || acl_default == 1)
			{
				RG_del_All_Acl_Rules();
			}
		}
#else
		/*use for 8696*/
		RG_del_All_Acl_Rules();
#endif
	}
	{
		char cmdStr[64];
		if(pEntry->cmode > 0)
		{
			snprintf(cmdStr, sizeof(cmdStr),"echo %d %d > %s",pEntry->rg_wan_idx,0,"/proc/rg/wanIntf_disable_ipv6_linkLocal_rsvACL");
			printf("%s-%d cmd:%s\n",__func__,__LINE__,cmdStr);
			system(cmdStr);
		}		
	}
	RG_flush_vlanBinding_by_WanVID(pEntry->vid);	
	Flush_RG_static_route_per_WAN(pEntry->ifIndex);
	RTK_RG_ACL_Del_DHCP_WAN_IPV6(pEntry->rg_wan_idx);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	Flush_RG_policy_route_on_static();
	Set_RG_policy_route_on_static();
	if ( ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_BRIDGE) && (pEntry->brmode != BRIDGE_DISABLE)) 
		RTK_RG_BridgeType_ACL_Rule_Flush(pEntry->rg_wan_idx);
	
#endif
	RG_WAN_Interface_Del(pEntry->rg_wan_idx);
#endif
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
#if defined(CONFIG_EPON_FEATURE) || defined(CONFIG_GPON_FEATURE)
#ifdef CONFIG_RTL9600_SERIES
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	if ((CHANNEL_MODE_T)pEntry->cmode == CHANNEL_MODE_PPPOE) 
#endif
	RG_del_route_pppoe_multicast_permit(pEntry);
#endif
#endif
#endif
#ifdef CONFIG_IPV6
	if ((CHANNEL_MODE_T)pEntry->cmode != CHANNEL_MODE_BRIDGE){
		ifGetName(pEntry->ifIndex, ifname, sizeof(ifname));
		if(pEntry->dnsv6Mode==REQUEST_DNS_NONE || pEntry->AddrMode == IPV6_WAN_STATIC){//dnsv6 server setting from user
			snprintf(file, 64, "%s.%s_static", (char *)DNS6_RESOLV, ifname);
		}
		else{ //dnsv6 server setting from dhcpv6 server
			snprintf(file, 64, "%s.%s", (char *)DNS6_RESOLV, ifname);
		}
		unlink(file);
	}
#endif

}

#ifdef PORT_FORWARD_ADVANCE
int config_PFWAdvance( int action_type )
{
	switch( action_type )
	{
	case ACT_START:
		startPFWAdvance();
		break;

	case ACT_RESTART:
		stopPFWAdvance();
		startPFWAdvance();
		break;

	case ACT_STOP:
		stopPFWAdvance();
		break;

	default:
		return -1;
	}
	return 0;
}
#endif

#ifdef CONFIG_USER_RTK_SYSLOG
char *log_severity[] =
{
	"Emergency",
	"Alert",
	"Critical",
	"Error",
	"Warning",
	"Notice",
	"Informational",
	"Debug"
};

#define SLOGDPID  "/var/run/syslogd.pid"
#define KLOGDPID  "/var/run/klogd.pid"
#define SLOGDLINK1 "/var/tmp/messages"
#define SLOGDLINK2 "/var/tmp/messages.old"

static int stopSlogD(void)
{
	int slogDid=0;
	int status=0;

	slogDid = read_pid((char*)SLOGDPID);
	if(slogDid > 0) {
		kill(slogDid, 9);
		unlink(SLOGDPID);
		unlink(SLOGDLINK1);
		unlink(SLOGDLINK2);
	}
	return 1;

}

static int stopKlogD(void)
{
	int klogDid=0;
	int status=0;

	klogDid = read_pid((char*)KLOGDPID);
	if(klogDid > 0) {
		kill(klogDid, 9);
		unlink(KLOGDPID);
	}
	return 1;

}

int stopLog(void)
{

	// Kill SlogD
	stopSlogD();
#ifdef USE_BUSYBOX_KLOGD
	// Kill KlogD
	stopKlogD();
#endif

	return 1;
}

int startLog(void)
{
	unsigned char vChar;
	unsigned int vInt;
	char *argv[30], loglen[8], loglevel[2];
#ifdef CONFIG_USER_RTK_SYSLOG_REMOTE
	char serverip[30], serverport[6];
#endif
	int idx;

	mib_get(MIB_MAXLOGLEN, &vInt);
	snprintf(loglen, sizeof(loglen), "%u", vInt);
	mib_get(MIB_SYSLOG_LOG_LEVEL, &vChar);
	snprintf(loglevel, sizeof(loglevel), "%hhu", vChar);
#ifdef CONFIG_USER_RTK_SYSLOG_REMOTE
	mib_get(MIB_SYSLOG_MODE, &vChar);
#endif
	argv[1] = "-n";
	argv[2] = "-s";
	argv[3] = loglen;
	argv[4] = "-l";
	argv[5] = loglevel;
	idx = 6;
#ifdef CONFIG_USER_RTK_SYSLOG_REMOTE
	/* 1: Local, 2: Remote, 3: Both */
	/* Local or Both */
	if (vChar & 1)
		argv[idx++] = "-L";
	/* Remote or Both */
	if (vChar & 2) {
		getMIB2Str(MIB_SYSLOG_SERVER_IP, serverip);
		getMIB2Str(MIB_SYSLOG_SERVER_PORT, serverport);
		snprintf(serverip, sizeof(serverip), "%s:%s", serverip, serverport);
		argv[idx++] = "-R";
		argv[idx++] = serverip;
	}
#endif
#ifdef BB_FEATURE_SAVE_LOG
	argv[idx++] = "-w";
#endif
	argv[idx] = NULL;

	mib_get(MIB_SYSLOG, (void *)&vChar);
	if(vChar!=0){
		TRACE(STA_SCRIPT, "/bin/slogd %s %s %s %s %s ...\n", argv[1], argv[2], argv[3], argv[4], argv[5]);
		printf("/bin/slogd %s %s %s %s %s ...\n", argv[1], argv[2], argv[3], argv[4], argv[5]);
		do_nice_cmd("/bin/slogd", argv, 0);
#if defined(USE_BUSYBOX_KLOGD) && !defined(CONFIG_CMCC) && !defined(CONFIG_CU)
		va_niced_cmd("/bin/klogd",1,0,"-n");
#endif
	}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	if(vChar == 2)
		va_niced_cmd("/bin/klogd",1,0,"-n");
#endif


	return 1;
}
#endif
#if defined(BB_FEATURE_SAVE_LOG) || defined(CONFIG_USER_RTK_SYSLOG)
void writeLogFileHeader(FILE * fp)
{
	unsigned char dev_id_buf[256], log_ip[INET_ADDRSTRLEN];
	unsigned char *bufptr;
	char manufacturer[64] =  {0};
	char model[64] =  {0};
	char hw_ver[64] =  {0};
	char sw_ver[64]=  {0};

/*star:20081017 modify for some macro is changed to mib entry*/
#ifdef _CWMP_MIB_
	unsigned char ipAddr[IP_ADDR_LEN];
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	mib_get(MIB_HW_SERIAL_NUMBER, (void*)dev_id_buf);
#else
	getOUIfromMAC(dev_id_buf);
	bufptr = dev_id_buf + strlen(dev_id_buf);
	*bufptr = '-';
	bufptr++;
	mib_get(MIB_HW_SERIAL_NUMBER, bufptr);
#endif
	mib_get(MIB_ADSL_LAN_IP, ipAddr);
	strcpy(log_ip, inet_ntoa(*(struct in_addr *)ipAddr));
#else
	strcpy(dev_id_buf, "devId");
	strcpy(log_ip, "192.168.1.1");
#endif

	getMIB2Str(MIB_HW_CWMP_MANUFACTURER, manufacturer);
	getMIB2Str(MIB_HW_CWMP_PRODUCTCLASS, model);
	getMIB2Str(MIB_HW_HWVER, hw_ver);
	getSYS2Str(SYS_FWVERSION, sw_ver);
	fprintf(fp,
		"Manufacturer:%s;\nProductClass:%s;\nSerialNumber:%s;\nIP:%s;\nHWVer:%s;\nSWVer:%s;\n\n",
		manufacturer, model, dev_id_buf, log_ip,
		hw_ver, sw_ver);
}
#endif

#ifdef DEFAULT_GATEWAY_V2
int ifExistedDGW(void)
{
	char buff[256];
	int flgs;
	struct in_addr dest, mask;
	FILE *fp;
	if (!(fp = fopen("/proc/net/route", "r"))) {
		printf("Error: cannot open /proc/net/route - continuing...\n");
		return -1;
	}
	fgets(buff, sizeof(buff), fp);
	while (fgets(buff, sizeof(buff), fp) != NULL) {
		if (sscanf(buff, "%*s%x%*x%x%*d%*d%*d%x", &dest, &flgs, &mask) != 3) {
			printf("Unsuported kernel route format\n");
			fclose(fp);
			return -1;
		}
		if ((flgs & RTF_UP) && dest.s_addr == 0 && mask.s_addr == 0) {
			fclose(fp);
			return 1;
		}
	}
	fclose(fp);
	return 0;
}
#endif

// Mason Yu. MLD Proxy
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_ECMH
// MLD proxy configuration
// return value:
// 1  : successful
// 0  : function not enable
// -1 : startup failed
int startMLDproxy()
{
	unsigned char mldproxyEnable=0;
	unsigned int mldproxyItf;
	char ifname[IFNAMSIZ];
	int mldproxy_pid;
	MIB_CE_ATM_VC_T Entry;
	unsigned int entryNum, i;

	// Kill old IGMP proxy
	mldproxy_pid = read_pid((char *)MLDPROXY_PID);
	if (mldproxy_pid >= 1) {
		// kill it
		if (kill(mldproxy_pid, SIGTERM) != 0) {
			printf("Could not kill pid '%d'", mldproxy_pid);
		}
	}

	if (mib_get(MIB_MLD_PROXY_EXT_ITF, (void *)&mldproxyItf) != 0)
	{
		if (!ifGetName(mldproxyItf, ifname, sizeof(ifname)))
		{
			//printf("Error: MLD proxy interface not set !\n");
			//return 0;
			entryNum = mib_chain_total(MIB_ATM_VC_TBL);
			for (i=entryNum; i>0; i--)
			{
				if (!mib_chain_get(MIB_ATM_VC_TBL, i-1, (void *)&Entry))
				{
					printf("error get atm vc entry\n");
					return -1;
				}
				if ((Entry.IpProtocol & IPVER_IPV6) && (Entry.cmode != CHANNEL_MODE_BRIDGE) && ( Entry.applicationtype & X_CT_SRV_INTERNET)){
					mldproxyEnable = 1;
					mib_set(MIB_MLD_PROXY_DAEMON, (void *)&mldproxyEnable);
					mldproxyItf = Entry.ifIndex;
					mib_set(MIB_MLD_PROXY_EXT_ITF, (void *)&mldproxyItf);
					ifGetName(mldproxyItf, ifname, sizeof(ifname));
					mib_update(CURRENT_SETTING, CONFIG_MIB_TABLE);
					break;
				}
			}
		}
	}

#if defined(CONFIG_RTK_L34_ENABLE)
#if defined(CONFIG_MCAST_VLAN)
	RTK_RG_ACL_Flush_mVlan();
	RTK_RG_ACL_Add_mVlan();
#endif
#ifdef CONFIG_USER_ECMH
	RTK_RG_Flush_MLD_proxy_ACL_rule();
	RTK_RG_set_MLD_proxy_ACL_rule();
	RTK_RG_Ipv6_multicastFlow_reset();
	checkIGMPMLDProxySnooping(isIGMPSnoopingEnabled(), isMLDSnoopingEnabled(), isIgmproxyEnabled(), isMLDProxyEnabled());
#endif
#endif

	// check if MLD proxy enabled ?
	if (mib_get(MIB_MLD_PROXY_DAEMON, (void *)&mldproxyEnable) != 0)
	{
		if (mldproxyEnable != 1){
			printf("%s(%d) MLD proxy not enable\n",__func__,__LINE__);
			system("/bin/echo 0 > /proc/br_mldproxy");
			return 0;	// MLD proxy not enable
		}
	}
	if(mldproxyEnable)
	{
		printf("%s(%d) MLD proxy enable\n",__func__,__LINE__);
		system("/bin/echo 1 > /proc/br_mldproxy");
	}

	// check for bridge&IPv4 WAN should not start ecmh process
	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
			printf("error get atm vc entry\n");
			return -1;
		}
		if (mldproxyItf == Entry.ifIndex ) break;
	}

	if (Entry.IpProtocol == IPVER_IPV4 || Entry.cmode == CHANNEL_MODE_BRIDGE )
	{
		printf("Error: MLD proxy interface is invalid, stop the %s !\n",MLDPROXY);
	} else {
		va_niced_cmd(MLDPROXY, 4, 0, "-i", ifname, "-o", (char *)LANIF);
	}
	return 1;
}

int isMLDProxyEnabled(void)
{
	unsigned int mldproxyItf;
	unsigned int entryNum;
	char ifname[IFNAMSIZ];
	MIB_CE_ATM_VC_T Entry;
	int i;
	unsigned char is_enabled;
	int found = 0;

	if(!mib_get(MIB_MLD_PROXY_DAEMON, (void *)&is_enabled))
	{
		return 0;
	}

	if (mib_get(MIB_MLD_PROXY_EXT_ITF, (void *)&mldproxyItf) != 0)
	{	
		entryNum = mib_chain_total(MIB_ATM_VC_TBL);
		for (i=entryNum; i>0; i--)
		{
			if (!mib_chain_get(MIB_ATM_VC_TBL, i-1, (void *)&Entry))
			{
				printf("error get atm vc entry\n");
				return 0;
			}
			
			if (!(Entry.IpProtocol & IPVER_IPV6) || (Entry.cmode == CHANNEL_MODE_BRIDGE))
				continue;

			if (ifGetName(mldproxyItf, ifname, sizeof(ifname)))
			{
				if(Entry.ifIndex == mldproxyItf && is_enabled)
					found = 1;
			}
		}
	}

	return found;
}
#endif
#endif

#ifdef CONFIG_USER_IGMPPROXY
// IGMP proxy configuration
// return value:
// 1  : successful
// 0  : function not enable
// -1 : startup failed
int startIgmproxy(void)
{
	unsigned char igmpEnable;
	unsigned int igmpItf;
	char ifname[IFNAMSIZ];
	int igmpproxy_pid;

	// Kill old IGMP proxy
	igmpproxy_pid = read_pid((char *)IGMPPROXY_PID);
	if (igmpproxy_pid >= 1) {
		// kill it
		if (kill(igmpproxy_pid, SIGTERM) != 0) {
			printf("Could not kill pid '%d'", igmpproxy_pid);
		}
	}

	// check if IGMP proxy enabled ?
	if (mib_get(MIB_IGMP_PROXY, (void *)&igmpEnable) != 0)
	{
		if (igmpEnable != 1)
			return 0;	// IGMP proxy not enable
	}
	if (mib_get(MIB_IGMP_PROXY_ITF, (void *)&igmpItf) != 0)
	{
		if (!ifGetName(igmpItf, ifname, sizeof(ifname)))
		{
			printf("Error: IGMP proxy interface not set !\n");
			return 0;
		}
	}


	va_niced_cmd(IGMPROXY, 6, 0, "-c","1","-d", (char *)LANIF,"-u",ifname);
	return 1;
}

#ifdef CONFIG_IGMPPROXY_MULTIWAN
int setting_Igmproxy(void)
{
	unsigned char igmpProxyEnable;
	int igmpproxy_pid;
	MIB_CE_ATM_VC_T Entry;
	unsigned int entryNum, i;
	char igmpproxy_wan[100];
	char igmpproxy_cmd[120];
	int igmpenable =0;
	char ifname[IFNAMSIZ];

	// Kill old IGMP proxy
	igmpproxy_pid = read_pid((char *)IGMPPROXY_PID);
	if (igmpproxy_pid >= 1) {
		// kill it
		if (kill(igmpproxy_pid, SIGTERM) != 0) {
			printf("Could not kill pid '%d'", igmpproxy_pid);
		}
	}
	igmpproxy_wan[0]='\0';

	mib_get(MIB_IGMP_PROXY, (void *)&igmpProxyEnable);
	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++)
	{
		 if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		 {
  			printf("error get atm vc entry\n");
			return -1;
		 }

		// check if IGMP proxy enabled ?
		if(Entry.enable && Entry.enableIGMP && igmpProxyEnable)
		{
			char iptv_intf_str[10];
			igmpenable =1;
			if (ifGetName(Entry.ifIndex, ifname, sizeof(ifname))) {

				//multiple WAN interfaces, seperated by ','
               if(igmpproxy_wan[0]=='\0')
					snprintf(igmpproxy_wan, 100, "%s",ifname);
               else
					snprintf(igmpproxy_wan, 100, "%s,%s", igmpproxy_wan, ifname);
			}
			else
			{
				printf("Error: IGMP proxy interface not set !\n");
				return 0;
			}
		}
	}
#ifdef CONFIG_YUEME
	unsigned char fw_mode = 0;
	mib_get(CWMP_CT_IP_FORWARD_MODE_ENABLED, &fw_mode);
	if(!igmpenable && fw_mode)
	{
		// No X_CT-COM_UpstreamWAN is set, use INTERNET WAN as IPTV WAN
		for (i=0; i<entryNum; i++)
		{
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			{
	  			printf("error get atm vc entry\n");
				return -1;
			}

			if(Entry.enable && Entry.applicationtype & X_CT_SRV_INTERNET)
			{
				ifGetName(Entry.ifIndex, igmpproxy_wan, sizeof(igmpproxy_wan));
				igmpenable =1;
				fprintf(stderr, "<%s:%d> Select %s as X_CT-COM_UpstreamWAN\n", __FUNCTION__, __LINE__, igmpproxy_wan);
				break;
			}
		}
	}
#endif

	if(igmpenable){
		va_niced_cmd(IGMPROXY, 6, 1, "-c", "1", "-d", "br0", "-u", igmpproxy_wan);
	}


#ifdef CONFIG_IP_NF_UDP
	va_cmd(IFCONFIG, 2, 1, ELANIF, "down");
	va_cmd(IFCONFIG, 2, 1, BRIF, "down");
	va_cmd("/bin/ethctl", 2, 1, "conntrack", "killall");
	va_cmd(IFCONFIG, 2, 1, ELANIF, "up");
	va_cmd(IFCONFIG, 2, 1, BRIF, "up");
	itfcfg("sar", 1);

#endif
#if defined(CONFIG_RTK_L34_ENABLE)
#if defined(CONFIG_MCAST_VLAN)
	RTK_RG_ACL_Flush_mVlan();
	RTK_RG_ACL_Add_mVlan();
#endif
	RTK_RG_Flush_IGMP_proxy_ACL_rule();
	RTK_RG_set_IGMP_proxy_ACL_rule();	
	RTK_RG_multicastFlow_reset();
	checkIGMPMLDProxySnooping(isIGMPSnoopingEnabled(), isMLDSnoopingEnabled(), isIgmproxyEnabled(), isMLDProxyEnabled());
#endif

	return 1;
}
#endif

#ifdef CONFIG_IGMPPROXY_MULTIWAN
int isIgmproxyEnabled(void)
{
	MIB_CE_ATM_VC_T Entry;
	unsigned int entryNum, i;
	int igmpenable =0;
	char ifname[IFNAMSIZ];
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	unsigned char igmpProxyEnable=0;
#endif

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	mib_get(MIB_IGMP_PROXY, (void *)&igmpProxyEnable);
#endif
	entryNum = mib_chain_total(MIB_ATM_VC_TBL);

	for (i=0; i<entryNum; i++)
	{
		 if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		 {
  			printf("error get atm vc entry\n");
			return 0;
		 }
		
		// check if IGMP proxy enabled ?
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		if(Entry.cmode == CHANNEL_MODE_BRIDGE 
#ifdef CONFIG_IPV6
				|| Entry.IpProtocol == IPVER_IPV6 
#endif
				)	continue;

		if(Entry.enable && Entry.enableIGMP && igmpProxyEnable)
#else
		if(Entry.enable && Entry.enableIGMP)
#endif
		{
			igmpenable=1;
		}
	}

#ifdef CONFIG_YUEME
	unsigned char fw_mode = 0;
	mib_get(CWMP_CT_IP_FORWARD_MODE_ENABLED, &fw_mode);
	if(!igmpenable && fw_mode)
	{
		// No X_CT-COM_UpstreamWAN is set, use INTERNET WAN as IPTV WAN
		for (i=0; i<entryNum; i++)
		{
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			{
				printf("error get atm vc entry\n");
				return -1;
			}

			if(Entry.enable && Entry.applicationtype & X_CT_SRV_INTERNET)
			{
				igmpenable=1;
			}
		}
	}
#endif
	
	if(igmpenable)
		return 1;

	return 0;
}
#else
int isIgmproxyEnabled(void)
{
	unsigned char igmpEnable;
	unsigned int igmpItf;
	char ifname[IFNAMSIZ];
	
	// check if IGMP proxy enabled ?
	if (mib_get(MIB_IGMP_PROXY, (void *)&igmpEnable) != 0)
	{
		if (igmpEnable != 1)
			return 0;	// IGMP proxy not enable
	}
	if (mib_get(MIB_IGMP_PROXY_ITF, (void *)&igmpItf) != 0)
	{
		if (!ifGetName(igmpItf, ifname, sizeof(ifname)))
		{
			printf("Error: IGMP proxy interface not set !\n");
			return 0;
		}
	}

	return 1;
}
#endif
#endif // of CONFIG_USER_IGMPPROXY

void addStaticRoute_per_wan(unsigned int ifIndex)
{
	unsigned int entryNum, i;
	MIB_CE_IP_ROUTE_T Entry;
	//struct rtentry rt;
	//struct sockaddr_in *inaddr;
	//char	ifname[17];

	/* Clean out the RTREQ structure. */
	//memset((char *) &rt, 0, sizeof(struct rtentry));
	entryNum = mib_chain_total(MIB_IP_ROUTE_TBL);

	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
		{
			return;
		}
#if !defined(CONFIG_LUNA) && !defined(CONFIG_RTK_L34_ENABLE)
		if (ifIndex == Entry.ifIndex )
			route_cfg_modify(&Entry, 0, i);
#endif
	}
}

void addStaticRoute(void)
{
	unsigned int entryNum, i;
	MIB_CE_IP_ROUTE_T Entry;
	//struct rtentry rt;
	//struct sockaddr_in *inaddr;
	//char	ifname[17];

	/* Clean out the RTREQ structure. */
	//memset((char *) &rt, 0, sizeof(struct rtentry));
	entryNum = mib_chain_total(MIB_IP_ROUTE_TBL);

	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
		{
			return;
		}
#if !defined(CONFIG_LUNA) && !defined(CONFIG_RTK_L34_ENABLE)
		route_cfg_modify(&Entry, 0, i);
#endif
	}
}

void deleteStaticRoute_per_wan(unsigned int ifIndex)
{
	unsigned int entryNum, i;
	MIB_CE_IP_ROUTE_T Entry;
	//struct rtentry rt;
	//struct sockaddr_in *inaddr;
	//char	ifname[17];

	/* Clean out the RTREQ structure. */
	//memset((char *) &rt, 0, sizeof(struct rtentry));
	entryNum = mib_chain_total(MIB_IP_ROUTE_TBL);

	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
		{
			return;
		}
		if (ifIndex == Entry.ifIndex )
			route_cfg_modify(&Entry, 1, i);
	}
}

void deleteStaticRoute(void)
{
	unsigned int entryNum, i;
	MIB_CE_IP_ROUTE_T Entry;
	//struct rtentry rt;
	//struct sockaddr_in *inaddr;
	//char	ifname[17];

	/* Clean out the RTREQ structure. */
	//memset((char *) &rt, 0, sizeof(struct rtentry));
	entryNum = mib_chain_total(MIB_IP_ROUTE_TBL);

	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
		{
			return;
		}
		route_cfg_modify(&Entry, 1, i);
	}
}

#ifdef CONFIG_IPV6
static void addStaticV6Route()
{
	unsigned int entryNum, i;
	MIB_CE_IPV6_ROUTE_T Entry;

	entryNum = mib_chain_total(MIB_IPV6_ROUTE_TBL);

	for (i=0; i<entryNum; i++)
	{
		if (!mib_chain_get(MIB_IPV6_ROUTE_TBL, i, (void *)&Entry))
			return;
		route_v6_cfg_modify(&Entry, 0, i);
	}
}

static void deleteV6StaticRoute()
{
	unsigned int entryNum, i;
	MIB_CE_IPV6_ROUTE_T Entry;
	entryNum = mib_chain_total(MIB_IPV6_ROUTE_TBL);

	for (i=0; i<entryNum; i++)
	{
		if (!mib_chain_get(MIB_IPV6_ROUTE_TBL, i, (void *)&Entry))
			return;
		route_v6_cfg_modify(&Entry, 1, i);
	}
}
#endif

#ifdef CONFIG_USER_PPPOMODEM
static void _wan3g_start_each( MIB_WAN_3G_T *p, unsigned char pppidx)
{
    //printf( "%s: enter\n", __FUNCTION__ );
    //DEBUGMODE(STA_INFO|STA_SCRIPT|STA_WARNING|STA_ERR);

    if(p && p->enable)
    {
	struct data_to_pass_st msg;
	int pppdbg;
	char ifIdx[3], pppif[6];

	snprintf(ifIdx, 3, "%u", pppidx);
	snprintf(pppif, 6, "ppp%u", pppidx);

	if(p->ctype!=MANUAL)
		snprintf(msg.data, BUF_SIZE, "spppctl add %s", ifIdx);
	else
		snprintf(msg.data, BUF_SIZE, "spppctl new %s", ifIdx);

	//set device
	//snprintf(msg.data, BUF_SIZE, "%s pppomodem /dev/ttyUSB0", msg.data);
	snprintf(msg.data, BUF_SIZE, "%s pppomodem auto", msg.data);

	//set pin code
	if( p->pin!=NO_PINCODE )
		snprintf(msg.data, BUF_SIZE, "%s simpin %04u", msg.data, p->pin);

	//set apn
	if( strlen(p->apn) )
		snprintf(msg.data, BUF_SIZE, "%s apn %s", msg.data, p->apn);

	//set dial
	snprintf(msg.data, BUF_SIZE, "%s dial %s", msg.data, p->dial);

	// Set Authentication Method
	//printf( "p->auth=%d, %d, %d\n", p->auth, PPP_AUTH_NONE, p->auth==PPP_AUTH_NONE );
	if(p->auth==PPP_AUTH_NONE)
	{
		//skip or???
	}else{
		snprintf(msg.data, BUF_SIZE, "%s auth %s", msg.data, ppp_auth[p->auth]);
		snprintf(msg.data, BUF_SIZE, "%s username %s password %s", msg.data, p->username, p->password);
	}

	//set default gateway/ mtu
	snprintf(msg.data, BUF_SIZE, "%s gw %d mru %u",	msg.data, p->dgw, p->mtu);

	// set PPP debug
	pppdbg = pppdbg_get(pppidx);
	snprintf(msg.data, BUF_SIZE, "%s debug %d", msg.data, pppdbg);
	//snprintf(msg.data, BUF_SIZE, "%s debug 1", msg.data);

	//paula, set 3g backup PPP
	snprintf(msg.data, BUF_SIZE, "%s backup %d", msg.data, p->backup);

	if(p->backup)
		snprintf(msg.data, BUF_SIZE, "%s backup_timer %d", msg.data, p->backup_timer);

	if(p->ctype == CONTINUOUS) // Continuous
	{
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		//printf("\ncmd=%s\n",msg.data);
		write_to_pppd(&msg);

		// set the ppp keepalive timeout
		snprintf(msg.data, BUF_SIZE,"spppctl katimer 100");
		TRACE(STA_SCRIPT, "%s\n", msg.data);

		write_to_pppd(&msg);
		printf("PPP Connection (Continuous)...\n");
	}else if(p->ctype==CONNECT_ON_DEMAND) // On-demand
	{
		snprintf(msg.data, BUF_SIZE, "%s timeout %u", msg.data, p->idletime);
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
		printf("PPP Connection (On-demand)...\n");
	}
	else if(p->ctype==MANUAL) // Manual
	{
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
		printf("PPP Connection (Manual)...\n");
	}

	if(p->napt)
	{	// Enable NAPT
		va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_ADD, "POSTROUTING",
			"-o", pppif, "-j", "MASQUERADE");
	}

    }

    return;
}

static void _wan3g_stop_each( MIB_WAN_3G_T *p, unsigned char pppidx)
{
    //printf( "%s: enter\n", __FUNCTION__ );
    //DEBUGMODE(STA_INFO|STA_SCRIPT|STA_WARNING|STA_ERR);

    if(p && p->enable)
    {
	struct data_to_pass_st msg;
    	char pppif[6];

	snprintf(pppif, 6, "ppp%u", pppidx);
	// spppctl del 0
	snprintf(msg.data, BUF_SIZE, "spppctl del %u", pppidx);
	TRACE(STA_SCRIPT, "%s\n", msg.data);
	write_to_pppd(&msg);

	//down interface
	va_cmd(IFCONFIG, 2, 1, pppif, "down");

	if(p->napt==1)
	{	// Disable NAPT
		va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_DEL, "POSTROUTING",
			"-o", pppif, "-j", "MASQUERADE");
	}
    }

    return;
}

static MIB_WAN_3G_T mib_wan_3g_default_table[] = {
	{
	 /*enable */ 0,
	 /*auth */ PPP_AUTH_NONE,
	 /*ctype */ CONTINUOUS,
	 /*napt */ 1,
	 /*pin */ NO_PINCODE,
	 /*idletime */ 60,
	 /*mtu */ 1500,
	 /*dgw */ 1,
	 /*apn */ "internet",
	 /*dial */ "*99#",
	 /*username */ "",
	 /*password */ "",
	 //paula, 3g backup PPP
	 /*backup */ 0,
	 /*backup timer */ 60
	 }
};

/*
 *	Return value:
 *		0: disabled
 *		1: enabled
 */

int wan3g_start(void)
{
	unsigned char pppidx;
	MIB_WAN_3G_T entry, *p = &entry;

	pppidx = 0;
	if (!mib_chain_get(MIB_WAN_3G_TBL, pppidx, (void *)p)) {
		//printf("No entry in MIB_WAN_3G, add one\n");
		p = &mib_wan_3g_default_table[0];
		mib_chain_add(MIB_WAN_3G_TBL, (void *)p);
	}

	_wan3g_start_each(p, MODEM_PPPIDX_FROM + pppidx);

	if (p->enable) {
		//setup_ipforwarding(1);
		return 1;
	}

	return 0;
}

/*
 *	Return value:
 *		0: disabled
 *		1: enabled
 */
int wan3g_enable(void)
{
	unsigned char pppidx;
	MIB_WAN_3G_T entry, *p = &entry;

	pppidx = 0;
	if (!mib_chain_get(MIB_WAN_3G_TBL, pppidx, (void *)p)) {
		//printf("No entry in MIB_WAN_3G, add one\n");
		p = &mib_wan_3g_default_table[0];
		mib_chain_add(MIB_WAN_3G_TBL, (void *)p);
	}

	if (p->enable) {
		//setup_ipforwarding(1);
		return 1;
	}

	return 0;
}

void wan3g_stop(void)
{
	unsigned char pppidx;
	MIB_WAN_3G_T entry, *p = &entry;

	pppidx = 0;
	if (!mib_chain_get(MIB_WAN_3G_TBL, pppidx, p)) {
		mib_chain_add(MIB_WAN_3G_TBL, mib_wan_3g_default_table);
	}

	_wan3g_stop_each(p, MODEM_PPPIDX_FROM + pppidx);

	return;
}
#endif //CONFIG_USER_PPPOMODEM

char* config_WAN_action_type_to_str( int configAll, MIB_CE_ATM_VC_Tp pEntry, int isStart, char* ret )
{
	char action_type_str[128] = {0};
	char wan_info_str[128] = {0};

	sprintf(action_type_str, "%s", isStart?"Start":"Stop");
	
	switch( configAll )
	{
		case CONFIGONE:
			if(pEntry) sprintf(wan_info_str, "%s WAN VID=%d", (pEntry->cmode==CHANNEL_MODE_BRIDGE)?"BRIDGE":((pEntry->cmode==CHANNEL_MODE_IPOE)?"IPoE":"PPPoE"), pEntry->vid);
			else sprintf(wan_info_str, "WAN");
			break;
		case CONFIGALL:
			sprintf(wan_info_str, "all WAN");
			break;
		case CONFIGCWMP:
			if(pEntry) sprintf(wan_info_str, "CWMP Config %s WAN VID=%d", (pEntry->cmode==CHANNEL_MODE_BRIDGE)?"BRIDGE":((pEntry->cmode==CHANNEL_MODE_IPOE)?"IPoE":"PPPoE"), pEntry->vid);
			else sprintf(wan_info_str, "CWMP Config WAN");
			break;
		default:
			sprintf(ret, "Invalid action_type !");
			return ret;
	}

	sprintf(ret, "%s %s", action_type_str, wan_info_str);
	return ret;
	
}

// Added by Mason Yu
// configAll = CONFIGALL,  pEntry = NULL  : delete all WAN connections(include VC, ETHWAN, PTMWAN, VPN, 3g).
//									  It means that we want to restart all WAN channel.
// configAll = CONFIGONE, pEntry != NULL : delete specified VC, ETHWAN, PTMWAN connection and VPN, 3g connections.
// 									  It means that we delete or modify an old VC, ETHWAN, PTMWAN channel.
// configAll = CONFIGONE, pEntry = NULL  : delete VPN, 3g connections. It means that we add a new VC, ETHWAN, PTMWAN channel.
int deleteConnection(int configAll, MIB_CE_ATM_VC_Tp pEntry)
{
	char action_type_str[128] = {0};
	unsigned int entryNum, i, idx;
	MIB_CE_ATM_VC_T Entry;
	
	AUG_PRT("%s %s\n", __func__, config_WAN_action_type_to_str(configAll, pEntry, 0, action_type_str));
	syslog(LOG_INFO, "%s", config_WAN_action_type_to_str(configAll, pEntry, 0, action_type_str));

	//close all tunnel before delete wan interface.
#ifdef CONFIG_USER_PPTP_CLIENT_PPTP
	MIB_PPTP_T pptp;

	entryNum = mib_chain_total(MIB_PPTP_TBL);
	for (i=0; i<entryNum; i++)
	{
		if ( !mib_chain_get(MIB_PPTP_TBL, i, (void *)&pptp) )
			return -1;

		if(configAll == CONFIGALL)
		{
			applyPPtP(&pptp, 0, i);
		}
		else if(configAll == CONFIGONE)
		{
			 if(pEntry && pptp.ifIndex == pEntry->ifIndex)
			 {
				applyPPtP(&pptp, 0, i);
				break;
			 }
		}
	}
#endif
#ifdef CONFIG_USER_L2TPD_L2TPD
	MIB_L2TP_T l2tp;
	entryNum = mib_chain_total(MIB_L2TP_TBL);
	for (i=0; i<entryNum; i++)
	{
		if ( !mib_chain_get(MIB_L2TP_TBL, i, (void *)&l2tp) )
			return -1;

		if(configAll == CONFIGALL)
		{
			applyL2TP(&l2tp, 0, i);
		}
		else if(configAll == CONFIGONE)
		{
			 if(pEntry && l2tp.ifIndex == pEntry->ifIndex)
			 {
				applyL2TP(&l2tp, 0, i);
				break;
			 }
		}
	}
#endif

		entryNum = mib_chain_total(MIB_ATM_VC_TBL);
		for (i = 0; i < entryNum; i++) {
			/* Retrieve entry */
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
				printf("deleteConnection: cannot get ATM_VC_TBL(ch=%d) entry\n", i);
				return 0;
			}

		if (configAll == CONFIGALL)
		{
			if(Entry.enable) {
				/* clear IPv6 address when stop connection */
				if (((Entry.cmode == CHANNEL_MODE_IPOE) && ((DHCP_T)Entry.ipDhcp == DHCP_CLIENT)) ||
						(Entry.cmode == CHANNEL_MODE_PPPOE)) {
					memset(Entry.Ipv6Addr, 0, sizeof(Entry.Ipv6Addr));
					mib_chain_update(MIB_ATM_VC_TBL, &Entry, i);
				}
#ifdef CONFIG_RTL9600_SERIES
				if(Entry.cmode == CHANNEL_MODE_BRIDGE)
				{
					//reset acl_force_mc_cvid_when_rearrange, when delete bridge wan
					system("echo -1 > /proc/rg/acl_force_mc_cvid_when_rearrange");
				}					
#endif
				/* remove connection on driver*/
				stopConnection(&Entry);
			}
		}
	}

	if (configAll == CONFIGONE)
	{
		if (pEntry)
		{
			for (i = 0; i < entryNum; i++)
			{
				if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
					continue;

				if (Entry.ifIndex == pEntry->ifIndex && pEntry->enable) {
					/* clear IPv6 address when stop connection */
					if (((pEntry->cmode == CHANNEL_MODE_IPOE) && ((DHCP_T)pEntry->ipDhcp == DHCP_CLIENT)) ||
						(pEntry->cmode == CHANNEL_MODE_PPPOE)) {
						memset(Entry.Ipv6Addr, 0, sizeof(Entry.Ipv6Addr));
						mib_chain_update(MIB_ATM_VC_TBL, &Entry, i);
						break;
					}
				}
			}
			printf("(CONFIGONE) stopConnection: %d\n", pEntry->ifIndex);
#ifdef CONFIG_RTL9600_SERIES
			if(pEntry->cmode == CHANNEL_MODE_BRIDGE)
			{
				//reset acl_force_mc_cvid_when_rearrange, when delete bridge wan
				system("echo -1 > /proc/rg/acl_force_mc_cvid_when_rearrange");
			}					
#endif	

			/* remove connection on driver*/
			stopConnection(pEntry);
		}
	}

#ifdef CONFIG_USER_PPPOMODEM
	if((configAll == CONFIGALL) || (pEntry && (TO_IFINDEX(MEDIA_3G,  MODEM_PPPIDX_FROM, 0) == pEntry->ifIndex)))
	{
	wan3g_stop();
	}
#endif //CONFIG_USER_PPPOMODEM
#if defined(CONFIG_CT_AWIFI_JITUAN_SMARTWIFI)
    unsigned char functype=0;
    mib_get(AWIFI_PROVINCE_CODE, &functype);
    if(functype == AWIFI_ZJ){
	g_wan_modify=1;
    }
#endif
}

void cleanAllFirewallRule(void)
{
	//set INPUT policy to ACCEPT to avoid input packet drop
	va_cmd(IPTABLES, 3, 1, "-P", (char *)FW_INPUT, (char *)FW_ACCEPT);

	// Added by Mason Yu. Clean all Firewall rules.
	va_cmd(IPTABLES, 1, 1, "-F");
#ifdef CONFIG_YUEME
	va_cmd(EBTABLES, 2, 1, "-F", "INPUT");
	va_cmd(EBTABLES, 2, 1, "-F", "FORWARD");
	va_cmd(EBTABLES, 2, 1, "-F", "OUTPUT");
#else
	va_cmd(EBTABLES, 1, 1, "-F");
#endif
	va_cmd(IPTABLES, 3, 1, "-t", "nat", "-F");
#ifdef CONFIG_IPV6
	va_cmd(IP6TABLES, 1, 1, "-F");
#endif
#ifdef IP_ACL
	va_cmd(IPTABLES, 2, 1, "-X", "aclblock");
#endif
#if defined(NAT_CONN_LIMIT) || defined(TCP_UDP_CONN_LIMIT)
	va_cmd(IPTABLES, 2, 1, "-X", "connlimit");
#endif

	va_cmd(EBTABLES, 2, 1, "-X", (char *)FW_BR_WAN);
	va_cmd(EBTABLES, 2, 1, "-X", (char *)FW_BR_WAN_OUT);

#ifdef PPPOE_PASSTHROUGH
	va_cmd(EBTABLES, 6, 1, "-t", "broute", "-D", "BROUTING", "-j", (char *)FW_BR_PPPOE);
	va_cmd(EBTABLES, 4, 1, "-t", "broute", "-X", (char *)FW_BR_PPPOE);
	va_cmd(EBTABLES, 2, 1, "-X", (char *)FW_BR_PPPOE);
#endif

#ifdef DOMAIN_BLOCKING_SUPPORT
	va_cmd(IPTABLES, 2, 1, "-X", "domainblk");
#endif
#ifdef PORT_FORWARD_GENERAL
	va_cmd(IPTABLES, 2, 1, "-X", (char *)PORT_FW);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)PORT_FW);
#endif

	va_cmd(IPTABLES, 2, 1, "-X", (char *)IPTABLE_DMZ);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)IPTABLE_DMZ);

#ifdef NATIP_FORWARDING
	va_cmd(IPTABLES, 2, 1, "-X", (char *)IPTABLE_IPFW);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)IPTABLE_IPFW);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)IPTABLE_IPFW2);
#endif

#ifdef PORT_FORWARD_ADVANCE
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_PPTP);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)FW_PPTP);
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_L2TP);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)FW_L2TP);
#endif

#ifdef PORT_TRIGGERING
	va_cmd(IPTABLES, 2, 1, "-X", (char *)IPTABLES_PORTTRIGGER);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)IPTABLES_PORTTRIGGER);
#endif

#ifdef REMOTE_ACCESS_CTL
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_INACC);
#ifdef CONFIG_YUEME
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_IN_COMMING);
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_FTP_ACCOUNT);
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_SAMBA_ACCOUNT);
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_TELNET_ACCOUNT);
#ifdef CONFIG_IPV6
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_IN_COMMING);
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_FTP_ACCOUNT);
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_SAMBA_ACCOUNT);
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_TELNET_ACCOUNT);
#endif
#endif
#endif
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_IPFILTER_IN);
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_IPFILTER_OUT);
#else
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_IPFILTER);
#endif
#ifdef CONFIG_IPV6
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_IPV6FILTER_IN);
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_IPV6FILTER_OUT);
#else
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_IPV6FILTER);
#endif
	va_cmd(IP6TABLES, 2, 1, "-X", (char *)FW_IPV6REMOTEACC);
#endif

#ifdef CONFIG_USER_IGMPPROXY
	// ebtables -X portmapping_igmp
	va_cmd(EBTABLES, 2, 1, "-X", (char *)PORTMAP_IGMP);
#endif

#if defined(CONFIG_USER_PPTP_CLIENT_PPTP) && defined(CONFIG_USER_L2TPD_L2TPD)
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_VPNGRE);
#endif

#ifdef MAC_FILTER
	//va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_MACFILTER);
#ifndef MAC_FILTER_SRC_ONLY
	va_cmd(EBTABLES, 2, 1, "-X", (char *)FW_MACFILTER);
#else
	va_cmd(EBTABLES, 2, 1, "-X", (char *)FW_MACFILTER_ROUTER);
#endif
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)FW_MACFILTER_ROUTER);
#endif

#ifdef URL_BLOCKING_SUPPORT
	va_cmd(IPTABLES, 2, 1, "-X", "urlblock");
#endif

#ifdef URL_ALLOWING_SUPPORT
	va_cmd(IPTABLES, 2, 1, "-X", "urlallow");
#endif

#ifdef WEB_REDIRECT_BY_MAC
	va_cmd(IPTABLES, 2, 1, "-t", "nat", "-X", "WebRedirectByMAC");
#endif

#ifdef VIRTUAL_SERVER_SUPPORT
	va_cmd(IPTABLES, 2, 1, "-X", (char *)IPTABLE_VTLSUR);
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-X", (char *)IPTABLE_VTLSUR);
#endif

#if 0
#ifdef _SUPPORT_CAPTIVEPORTAL_PROFILE_
	va_cmd(IPTABLES, 2, 1, "-t", "nat", "-X", "CaptivePortal");
#endif
#endif

#ifdef CONFIG_USER_CWMP_TR069
	va_cmd(IPTABLES, 2, 1, "-X", IPTABLE_TR069);
#endif
	filter_set_remote_access(0);


#ifdef SUPPORT_ACCESS_RIGHT
	apply_accessRight(0);
#endif
}

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
static int setupIPFilter()
{
	char *argv[32]={0};
	unsigned char value[32], byte;
	int vInt, i, total;
	MIB_CE_IP_PORT_FILTER_T IpEntry;
	char *policy, *filterSIP = NULL, *filterDIP = NULL, srcPortRange[12], dstPortRange[12];
	char  srcip[20], dstip[20], old_srcip[20], old_dstip[20];
	// jim support ip range options " iptables -m iprange --src-range xx.xx.xx.xx-yy.yy.yy.yy --dst-range a.a.a.a-b.b.b.b ..."
	char srcip2[55]={0}, dstip2[55]={0};
	char SIPRange[110]={0};
	char DIPRange[110]={0};
	char *filterSIPRange=NULL;
	char *filterDIPRange=NULL;
	filterSIP=filterDIP=NULL;
	unsigned char in_enable = 0, out_enable = 0;
	unsigned char in_action = 1, out_action = 1;	//0: white list, 1: black list

	// Delete ipfilter rules
	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_IPFILTER_IN);
	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_IPFILTER_OUT);

#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_ACL_Filters();
	RTK_RG_ACL_IPPort_Filter_Allow_LAN_to_GW();
#endif

	mib_get(MIB_IPFILTER_IN_ENABLE, (void*)&in_enable);
	mib_get(MIB_IPFILTER_OUT_ENABLE, (void*)&out_enable);
	mib_get(MIB_IPF_IN_ACTION, (void*)&in_action);
	mib_get(MIB_IPF_OUT_ACTION, (void*)&out_action);

	// drop wan to wan forward packets
	// ex: (before interface route is created) dhcp offers from wan will be frowarded to pppoe wan (default route)
	// iptables -A ipfilter ! -i br0 ! -o br0 -j DROP
	va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_IPFILTER_IN, "!", ARG_I, "br+"
		,"!", ARG_O, "br+", "-j", (char *)FW_DROP);

	// accept related
	// iptables -A ipfilter_in -m state --state ESTABLISHED,RELATED -j RETURN
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_IPFILTER_IN, "-m", "state",
		"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_RETURN);
	// iptables -A ipfilter_in -d 224.0.0.0/4 -j RETURN
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_IPFILTER_IN, "-d",
		"224.0.0.0/4", "-j", (char *)FW_RETURN);

	// iptables -A ipfilter_out -m state --state ESTABLISHED,RELATED -j RETURN
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_IPFILTER_OUT, "-m", "state",
		"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_RETURN);
	// iptables -A ipfilter_out -d 224.0.0.0/4 -j RETURN
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_IPFILTER_OUT, "-d",
		"224.0.0.0/4", "-j", (char *)FW_RETURN);

	total = mib_chain_total(MIB_IP_PORT_FILTER_TBL);
	for (i = 0; i < total; i++)
	{
		int idx = 0;
		int udp_tcp_idx=-1;

		if (!mib_chain_get(MIB_IP_PORT_FILTER_TBL, i, (void *)&IpEntry))
			continue;

		if(IpEntry.enable == 0)
			continue;

		if(IpEntry.dir == DIR_IN && !in_enable)
			continue;

		if(IpEntry.dir == DIR_OUT && !out_enable)
			continue;
		
#ifdef CONFIG_IPV6
		if(IpEntry.IpProtocol == IPVER_IPV6)
			continue;
#endif

#ifdef CONFIG_RTK_L34_ENABLE
		if(IpEntry.IpProtocol == IPVER_IPV4) //ipv4
			AddRTK_RG_ACL_IPPort_Filter(&IpEntry, in_action, out_action);
#endif

		if ((IpEntry.dir == DIR_IN && in_action == 1) || (IpEntry.dir == DIR_OUT && out_action == 1))
			policy = (char *)FW_DROP;
		else
			policy = (char *)FW_RETURN;

		// source port
		if (IpEntry.srcPortFrom == 0)
			srcPortRange[0]='\0';
		else if (IpEntry.srcPortTo == 0)
			snprintf(srcPortRange, 12, "%u", IpEntry.srcPortFrom);
		else
			snprintf(srcPortRange, 12, "%u:%u",
				IpEntry.srcPortFrom, IpEntry.srcPortTo);

		// destination port
		if (IpEntry.dstPortFrom == 0)
			dstPortRange[0]='\0';
		else if (IpEntry.dstPortTo == 0)
			snprintf(dstPortRange, 12, "%u", IpEntry.dstPortFrom);
		else
			snprintf(dstPortRange, 12, "%u:%u",
				IpEntry.dstPortFrom, IpEntry.dstPortTo);

		// source ip, mask
		if(IpEntry.srcIp2[0] == 0)    // normal ip filter, no iprange supported
		{
			strncpy(srcip, inet_ntoa(*((struct in_addr *)IpEntry.srcIp)), 16);
			if (strcmp(srcip, ARG_0x4) == 0)
				filterSIP = 0;
			else {
				if (IpEntry.smaskbit!=0) {
					strncpy( old_srcip, srcip, sizeof(srcip));
					snprintf(srcip, 20, "%s/%d", old_srcip, IpEntry.smaskbit);
				}
				filterSIP = srcip;
			}
		}
		else
		{
			strncpy(srcip, inet_ntoa(*((struct in_addr *)IpEntry.srcIp)), 16);
			strncpy(srcip2, inet_ntoa(*((struct in_addr *)IpEntry.srcIp2)),16);

			if(strcmp(srcip, ARG_0x4) ==0 || strcmp(srcip2, ARG_0x4) ==0)
				filterSIPRange=0;
			else
			{
				snprintf(SIPRange, 40, "%s-%s", srcip, srcip2);
				filterSIPRange=SIPRange;
			}
		}

		// destination ip, mask
		if(IpEntry.dstIp2[0] == 0)    // normal ip filter, no iprange supported
		{
			strncpy(dstip, inet_ntoa(*((struct in_addr *)IpEntry.dstIp)), 16);
			if (strcmp(dstip, ARG_0x4) == 0)
				filterDIP = 0;
			else {
				if (IpEntry.dmaskbit!=0) {
					strncpy( old_dstip, dstip, sizeof(dstip));
					snprintf(dstip, 20, "%s/%d", old_dstip, IpEntry.dmaskbit);
				}
				filterDIP = dstip;
			}
		}
		else
		{
			strncpy(dstip, inet_ntoa(*((struct in_addr *)IpEntry.dstIp)), 16);
			strncpy(dstip2, inet_ntoa(*((struct in_addr *)IpEntry.dstIp2)),16);

			if(strcmp(dstip, ARG_0x4) ==0 || strcmp(dstip2, ARG_0x4) ==0)
				filterDIPRange=0;
			else
			{
				snprintf(DIPRange, 40, "%s-%s", dstip, dstip2);
				filterDIPRange=DIPRange;
			}
		}

		argv[idx++] = (char *)IPTABLES;
		argv[idx++] = (char *)FW_ADD;
		if(IpEntry.dir == DIR_IN)
			argv[idx++] = (char *)FW_IPFILTER_IN;
		else
			argv[idx++] = (char *)FW_IPFILTER_OUT;
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		if(IpEntry.dir == DIR_IN){
			argv[idx++] = "-i";
			argv[idx++] = IpEntry.WanPath;
		}
#endif
		// protocol
		if (IpEntry.protoType != PROTO_NONE) {
			argv[idx++] = "-p";
			if (IpEntry.protoType == PROTO_TCP)
				argv[idx++] = (char *)ARG_TCP;
			else if (IpEntry.protoType == PROTO_UDP)
				argv[idx++] = (char *)ARG_UDP;
			else if (IpEntry.protoType == PROTO_ICMP)
				argv[idx++] = (char *)ARG_ICMP;
			else if(IpEntry.protoType == PROTO_UDPTCP){
				//add udp rule first for udp/tcp protocol
				udp_tcp_idx = idx;
				argv[idx++] = (char *)ARG_UDP;
			}
		}

		// src ip
		if (filterSIP != 0)
		{
			argv[idx++] = "-s";
			argv[idx++] = filterSIP;
		}

		// src port
		if ((IpEntry.protoType==PROTO_TCP ||
			IpEntry.protoType==PROTO_UDP ||
			IpEntry.protoType==PROTO_UDPTCP) &&
			srcPortRange[0] != 0) {
			argv[idx++] = (char *)FW_SPORT;
			argv[idx++] = srcPortRange;
		}

		// dst ip
		if (filterDIP != 0)
		{
			argv[idx++] = "-d";
			argv[idx++] = filterDIP;
		}
		// dst port
		if ((IpEntry.protoType==PROTO_TCP ||
			IpEntry.protoType==PROTO_UDP ||
			IpEntry.protoType==PROTO_UDPTCP) &&
			dstPortRange[0] != 0) {
			argv[idx++] = (char *)FW_DPORT;
			argv[idx++] = dstPortRange;
		}

		if(filterSIPRange || filterDIPRange)
		{
			argv[idx++] = strdup("-m");
			argv[idx++] = strdup("iprange");
			if(filterSIPRange)
			{
				argv[idx++] = strdup("--src-range");
				argv[idx++] = strdup(filterSIPRange);
			}
			if(filterDIPRange)
			{
				argv[idx++] = strdup("--dst-range");
				argv[idx++] = strdup(filterDIPRange);
			}
		}

		// target/jump
		argv[idx++] = "-j";
		argv[idx++] = policy;
		argv[idx++] = NULL;

		do_cmd(IPTABLES, argv, 1);
		if(udp_tcp_idx!=-1){
			//add tcp rule for udp/tcp protocol
			argv[udp_tcp_idx] = (char *)ARG_TCP;
			do_cmd(IPTABLES, argv, 1);
		}
	}
#ifdef _PRMT_C_CU_USERACCOUNT_
	int k = 0, user_account_ipfilter_cnt = 0;
	USER_ACCOUNT_IP_T ipEntry;
	//iptables -t filter -A ipfilter_in -s 172.29.38.5 -j DROP
	char *argv_in[8] = {0};
	char *argv_out[8]={0};
	argv_in[0] = argv_out[0] =  (char *)IPTABLES;
	argv_in[1] = argv_out[1] =  (char *)FW_ADD;
	argv_in[2] = strdup("ipfilter_in");
	argv_in[3] = strdup("-s");
	argv_out[2] = strdup("ipfilter_out");
	argv_out[3] = strdup("-d");
	argv_in[5] = argv_out[5] =  strdup("-j");
	argv_in[6] = argv_out[6] =  strdup("DROP");
	argv_in[7] = argv_out[7] = NULL;
	
	user_account_ipfilter_cnt = mib_chain_total(CONFIG_USER_ACCOUNT_IP);
	for(k = 0; k < user_account_ipfilter_cnt; k++)
	{
		if(!mib_chain_get(CONFIG_USER_ACCOUNT_IP,k,&ipEntry))
			continue;	
		if(ipEntry.ipaddr == 0)
			continue;
		argv_in[4] = argv_out[4] = strdup(inet_ntoa(*(struct in_addr*)&ipEntry.ipaddr));

		do_cmd(IPTABLES, argv_in, 1);
		do_cmd(IPTABLES, argv_out, 1);		
	}
#endif
	// Kill all conntrack (to kill the established conntrack when change iptables rules)
	va_cmd("/bin/ethctl", 2, 1, "conntrack", "killall");
}

#else
static int setupIPFilter()
{
	char *argv[20];
	unsigned char value[32], byte;
	int vInt, i, total;
	MIB_CE_IP_PORT_FILTER_T IpEntry;
	char *policy, *filterSIP, *filterDIP, srcPortRange[12], dstPortRange[12];
	char  srcip[20], dstip[20];
#ifdef IP_RANGE_FILTER_SUPPORT
	// jim support ip range options " iptables -m iprange --src-range xx.xx.xx.xx-yy.yy.yy.yy --dst-range a.a.a.a-b.b.b.b ..."
	//char srcip2[20]={0}, dstip2[20]={0};
	char srcip2[55]={0}, dstip2[55]={0};
	//char SIPRange[40]={0};
	char SIPRange[110]={0};
	//char DIPRange[40]={0};
	char DIPRange[110]={0};
	char *filterSIPRange=NULL;
	char *filterDIPRange=NULL;
	filterSIP=filterDIP=NULL;
#endif
	unsigned char ipportfilter_state;

	// Delete ipfilter rule
	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_IPFILTER);

#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_ACL_Filters();
	RTK_RG_ACL_IPPort_Filter_Allow_LAN_to_GW();
#endif

	// packet filtering
	// ip filtering
	// Add chain for ip filtering
	// iptables -N ipfilter
	//va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_IPFILTER);

	// drop wan to wan forward packets
	// ex: (before interface route is created) dhcp offers from wan will be frowarded to pppoe wan (default route)
	// iptables -A ipfilter ! -i br0 ! -o br0 -j DROP
	va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_IPFILTER, "!", ARG_I, LANIF
		,"!", ARG_O, LANIF, "-j", (char *)FW_DROP);
	// accept related
	// iptables -A ipfilter -m state --state ESTABLISHED,RELATED -j RETURN
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_IPFILTER, "-m", "state",
		"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_RETURN);
	// iptables -A ipfilter -d 224.0.0.0/4 -j RETURN
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_IPFILTER, "-d",
		"224.0.0.0/4", "-j", (char *)FW_RETURN);

	mib_get(MIB_IPFILTER_ON_OFF, (void*)&ipportfilter_state);

	if(ipportfilter_state == 0) return 0;

	total = mib_chain_total(MIB_IP_PORT_FILTER_TBL);
	for (i = 0; i < total; i++)
	{
		int idx=0;
		int udp_tcp_idx=-1;
		/*
		 *	srcPortRange: src port
		 *	dstPortRange: dst port
		 */
		if (!mib_chain_get(MIB_IP_PORT_FILTER_TBL, i, (void *)&IpEntry))
			return -1;

#ifdef CONFIG_RTK_L34_ENABLE
#ifdef CONFIG_IPV6
		if(IpEntry.IpProtocol == IPVER_IPV4) //ipv4
#endif
		AddRTK_RG_ACL_IPPort_Filter(&IpEntry);
#endif

		if (IpEntry.action == 0)
			policy = (char *)FW_DROP;
		else
			policy = (char *)FW_RETURN;

		// source port
		if (IpEntry.srcPortFrom == 0)
			srcPortRange[0]='\0';
		else if (IpEntry.srcPortTo == 0)
			snprintf(srcPortRange, 12, "%u", IpEntry.srcPortFrom);
		else
			snprintf(srcPortRange, 12, "%u:%u",
				IpEntry.srcPortFrom, IpEntry.srcPortTo);

		// destination port
		if (IpEntry.dstPortFrom == 0)
			dstPortRange[0]='\0';
		else if (IpEntry.dstPortTo == 0)
			snprintf(dstPortRange, 12, "%u", IpEntry.dstPortFrom);
		else
			snprintf(dstPortRange, 12, "%u:%u",
				IpEntry.dstPortFrom, IpEntry.dstPortTo);

		// source ip, mask
	#ifdef IP_RANGE_FILTER_SUPPORT
		if(IpEntry.srcIp2[0] == 0)    // normal ip filter, no iprange supported
		{
	#endif
			strncpy(srcip, inet_ntoa(*((struct in_addr *)IpEntry.srcIp)), 16);
			if (strcmp(srcip, ARG_0x4) == 0)
				filterSIP = 0;
			else {
				if (IpEntry.smaskbit!=0)
					snprintf(srcip, 20, "%s/%d", srcip, IpEntry.smaskbit);
				filterSIP = srcip;
			}
	#ifdef IP_RANGE_FILTER_SUPPORT
		}
		else
		{
			strncpy(srcip, inet_ntoa(*((struct in_addr *)IpEntry.srcIp)), 16);
			strncpy(srcip2, inet_ntoa(*((struct in_addr *)IpEntry.srcIp2)),16);

			if(strcmp(srcip, ARG_0x4) ==0 || strcmp(srcip2, ARG_0x4) ==0)
				filterSIPRange=0;
			else
			{
				snprintf(SIPRange, 40, "%s-%s", srcip, srcip2);
				filterSIPRange=SIPRange;
			}
		}
	#endif

		// destination ip, mask
	#ifdef IP_RANGE_FILTER_SUPPORT
		if(IpEntry.dstIp2[0] == 0)    // normal ip filter, no iprange supported
		{
	#endif
			strncpy(dstip, inet_ntoa(*((struct in_addr *)IpEntry.dstIp)), 16);
			if (strcmp(dstip, ARG_0x4) == 0)
				filterDIP = 0;
			else {
				if (IpEntry.dmaskbit!=0)
					snprintf(dstip, 20, "%s/%d", dstip, IpEntry.dmaskbit);
				filterDIP = dstip;
			}
	#ifdef IP_RANGE_FILTER_SUPPORT
		}
		else
		{
			strncpy(dstip, inet_ntoa(*((struct in_addr *)IpEntry.dstIp)), 16);
			strncpy(dstip2, inet_ntoa(*((struct in_addr *)IpEntry.dstIp2)),16);

			if(strcmp(dstip, ARG_0x4) ==0 || strcmp(dstip2, ARG_0x4) ==0)
				filterDIPRange=0;
			else
			{
				snprintf(DIPRange, 40, "%s-%s", dstip, dstip2);
				filterDIPRange=DIPRange;
			}
		}
	#endif

		// interface
		argv[1] = (char *)FW_ADD;
		argv[2] = (char *)FW_IPFILTER;
		argv[3] = (char *)ARG_I;

		if (IpEntry.dir == DIR_OUT) {
			argv[4] = (char *)LANIF;
			idx = 5;
		}
		else {
			argv[4] = "!";
			argv[5] = (char *)LANIF;
			idx = 6;
		}

		// protocol
		if (IpEntry.protoType != PROTO_NONE) {
			argv[idx++] = "-p";
			if (IpEntry.protoType == PROTO_TCP)
				argv[idx++] = (char *)ARG_TCP;
			else if (IpEntry.protoType == PROTO_UDP)
				argv[idx++] = (char *)ARG_UDP;
			else if (IpEntry.protoType == PROTO_ICMP)
				argv[idx++] = (char *)ARG_ICMP;
			else if(IpEntry.protoType == PROTO_UDPTCP){
				//add udp rule first for udp/tcp protocol
				udp_tcp_idx = idx;
				argv[idx++] = (char *)ARG_UDP;
			}
		}

		// src ip
		if (filterSIP != 0)
		{
			argv[idx++] = "-s";
			argv[idx++] = filterSIP;
		}

		// src port
		if ((IpEntry.protoType==PROTO_TCP ||
			IpEntry.protoType==PROTO_UDP ||
			IpEntry.protoType==PROTO_UDPTCP) &&
			srcPortRange[0] != 0) {
			argv[idx++] = (char *)FW_SPORT;
			argv[idx++] = srcPortRange;
		}

		// dst ip
		if (filterDIP != 0)
		{
			argv[idx++] = "-d";
			argv[idx++] = filterDIP;
		}
		// dst port
		if ((IpEntry.protoType==PROTO_TCP ||
			IpEntry.protoType==PROTO_UDP ||
			IpEntry.protoType==PROTO_UDPTCP) &&
			dstPortRange[0] != 0) {
			argv[idx++] = (char *)FW_DPORT;
			argv[idx++] = dstPortRange;
		}

#ifdef IP_RANGE_FILTER_SUPPORT
	if(filterSIPRange || filterDIPRange)
	{
		argv[idx++] = strdup("-m");
		argv[idx++] = strdup("iprange");
		if(filterSIPRange)
		{
			argv[idx++] = strdup("--src-range");
			argv[idx++] = strdup(filterSIPRange);
		}
		if(filterDIPRange)
		{
			argv[idx++] = strdup("--dst-range");
			argv[idx++] = strdup(filterDIPRange);
		}
	}
#endif

		// target/jump
		argv[idx++] = "-j";
		argv[idx++] = policy;
		argv[idx++] = NULL;

		/* Debug printing.
		idx = 1;
		printf("iptables ");
		while(argv[idx])
		{
			printf("%s ", argv[idx++]);
		}
		putchar(10);
		/* End debug printing. */

		do_cmd(IPTABLES, argv, 1);
		if(udp_tcp_idx!=-1){
			//add tcp rule for udp/tcp protocol
			argv[udp_tcp_idx] = (char *)ARG_TCP;
			do_cmd(IPTABLES, argv, 1);
		}
	}

	// iptables -A FORWARD -j ipfilter
	//va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_IPFILTER);

	// Kill all conntrack (to kill the established conntrack when change iptables rules)
	va_cmd("/bin/ethctl", 2, 1, "conntrack", "killall");
}
#endif

static int block_br_wan()
{
	int total;
	int i;
	MIB_CE_ATM_VC_T Entry;
	char ifname[IFNAMSIZ] = {0};

	// INPUT
	va_cmd(EBTABLES, 2, 1, "-N", FW_BR_WAN);
	va_cmd(EBTABLES, 3, 1, "-P", FW_BR_WAN, "RETURN");
	// OUTPUT
	va_cmd(EBTABLES, 2, 1, "-N", FW_BR_WAN_OUT);
	va_cmd(EBTABLES, 3, 1, "-P", FW_BR_WAN_OUT, "RETURN");

	// check all wan interfaces
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;

		if(!Entry.enable)
			continue;

		ifGetName(PHY_INTF(Entry.ifIndex), ifname, sizeof(ifname));

		if(Entry.cmode == CHANNEL_MODE_BRIDGE)
		{
			va_cmd(EBTABLES, 6, 1, "-A", FW_BR_WAN, "-i", ifname, "-j", "DROP");
			va_cmd(EBTABLES, 6, 1, "-A", FW_BR_WAN_OUT, "-o", ifname, "-j", "DROP");
		}
	}
#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
	//cxy 2018-1-19: add for ip6sec get bridge wan ra packet 
	va_cmd(EBTABLES, 10, 1, (char *)FW_INSERT, FW_BR_WAN, "-p", "IPv6", "--ip6-proto","58","--ip6-icmp-type", "134", "-j", FW_RETURN);
#endif
	// add to INPUT chain
	va_cmd(EBTABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", FW_BR_WAN);
	// add to OUTPUT chain
	va_cmd(EBTABLES, 4, 1, (char *)FW_ADD, (char *)FW_OUTPUT, "-j", FW_BR_WAN_OUT);

	return 0;
}

#ifdef PPPOE_PASSTHROUGH
static int setupBrPppoe(void)
{
	int total;
	int i;
	MIB_CE_ATM_VC_T Entry;
	char ifname[IFNAMSIZ] = {0};

	// check all wan interfaces
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;

		if(!Entry.enable)
			continue;

		ifGetName(PHY_INTF(Entry.ifIndex), ifname, sizeof(ifname));

		if (Entry.brmode != BRIDGE_DISABLE)
		{
			struct sockaddr hwaddr;
			char mac_str[20]={0};
			getInAddr(ifname, HW_ADDR, &hwaddr);
			sprintf( mac_str, "%02X:%02X:%02X:%02X:%02X:%02X",
				(unsigned char)hwaddr.sa_data[0], (unsigned char)hwaddr.sa_data[1], (unsigned char)hwaddr.sa_data[2],
				(unsigned char)hwaddr.sa_data[3], (unsigned char)hwaddr.sa_data[4], (unsigned char)hwaddr.sa_data[5] );

			// route packets if the packet is from WAN and the destination is for myself
			//eg.: ebtables -t broute -A BROUTING -i vc0 -d 00:E0:4C:86:70:02 -j DROP
			va_cmd(EBTABLES, 10, 1, "-t", "broute", "-A", FW_BR_PPPOE, "-i", ifname,
				"-d", mac_str, "-j", "DROP");
		}

		if (Entry.brmode == BRIDGE_PPPOE)
		{
			char vid[10] = {0};

#if defined(CONFIG_RTL_MULTI_WAN) || defined(CONFIG_RTL_MULTI_ETH_WAN)
			//bridge PPPoE session/discover packets on this WAN interface
			if(Entry.vlan)
			{
				sprintf(vid, "%u", Entry.vid);

				va_cmd(EBTABLES, 10, 1, "-A", FW_BR_PPPOE, "-i", ifname,
				"--proto", "0x8100", "--vlan-encap", "0x8863", "-j", "RETURN");

				va_cmd(EBTABLES, 10, 1, "-A", FW_BR_PPPOE, "-i", ifname,
				"--proto", "0x8100", "--vlan-encap", "0x8864", "-j", "RETURN");
			}
			else
#endif
			{
				va_cmd(EBTABLES, 8, 1, "-A", FW_BR_PPPOE, "-i", ifname,
				"--proto", "0x8863", "-j", "RETURN");
				va_cmd(EBTABLES, 8, 1, "-A", FW_BR_PPPOE, "-i", ifname,
				"--proto", "0x8864", "-j", "RETURN");
			}

			va_cmd(EBTABLES, 8, 1, "-A", FW_BR_PPPOE, "-o", ifname,
				"--proto", "0x8863", "-j", "RETURN");
			va_cmd(EBTABLES, 8, 1, "-A", FW_BR_PPPOE, "-o", ifname,
				"--proto", "0x8864", "-j", "RETURN");

			//drop other packets on this WAN interface
			va_cmd(EBTABLES, 6, 1, "-A", FW_BR_PPPOE, "-i", ifname,
				"-j", "DROP");
			va_cmd(EBTABLES, 6, 1, "-A", FW_BR_PPPOE, "-o", ifname,
				"-j", "DROP");
		}
	}

	return 0;
}
#endif

int setupMacFilter(void)
{
	int i, total;
	char *policy;
	char srcmacaddr[18], dstmacaddr[18];
	char smacParm[64]={0};
	char dmacParm[64]={0};
#ifdef MAC_FILTER
	MIB_CE_MAC_FILTER_T MacEntry;
	char mac_in_dft, mac_out_dft;
	char eth_mac_ctrl=0, wlan_mac_ctrl=0;
#endif

	DOCMDINIT;


	// Delete all Macfilter rule
	va_cmd(EBTABLES, 2, 1, "-F", (char *)FW_MACFILTER);
#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_MAC_Filters();
#endif
#ifdef PARENTAL_CTRL
	parent_ctrl_table_init();
	parent_ctrl_table_rule_update();
#endif
#ifdef MAC_FILTER
	mib_get(MIB_MACF_OUT_ACTION, (void *)&mac_out_dft);
	mib_get(MIB_MACF_IN_ACTION, (void *)&mac_in_dft);
	mib_get(MIB_ETH_MAC_CTRL, (void *)&eth_mac_ctrl);
	mib_get(MIB_WLAN_MAC_CTRL, (void *)&wlan_mac_ctrl);
#endif

#ifdef MAC_FILTER
	total = mib_chain_total(MIB_MAC_FILTER_TBL);

	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_MAC_FILTER_TBL, i, (void *)&MacEntry))
			return -1;

#ifdef CONFIG_RTK_L34_ENABLE
		AddRTK_RG_MAC_Filter(&MacEntry);
		continue;
#endif

		smacParm[0]=dmacParm[0]='\0';

		if (MacEntry.action == 0)
			policy = (char *)FW_DROP;
		else
			policy = (char *)FW_RETURN;

		if(memcmp(MacEntry.srcMac,"\x00\x00\x00\x00\x00\x00",MAC_ADDR_LEN)) {
			snprintf(srcmacaddr, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
				MacEntry.srcMac[0], MacEntry.srcMac[1],
				MacEntry.srcMac[2], MacEntry.srcMac[3],
				MacEntry.srcMac[4], MacEntry.srcMac[5]);
			snprintf(smacParm, sizeof(smacParm),"-s %s", srcmacaddr);
		}

		if(memcmp(MacEntry.dstMac,"\x00\x00\x00\x00\x00\x00",MAC_ADDR_LEN)) {
			snprintf(dstmacaddr, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
				MacEntry.dstMac[0], MacEntry.dstMac[1],
				MacEntry.dstMac[2], MacEntry.dstMac[3],
				MacEntry.dstMac[4], MacEntry.dstMac[5]);
			snprintf(dmacParm, sizeof(dmacParm),"-d %s", dstmacaddr);
		}

		if (MacEntry.dir == DIR_OUT) {
			if (!strlen(dmacParm)) { // compatible with TR069 -- smac outgoing
				if(mac_out_dft) {
					// ebtables -A macfilter -i eth0+  -s 00:xx:..:xx -j ACCEPT/DROP
					DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ %s %s -j %s", (char *)FW_MACFILTER,
						(char *)ELANIF,smacParm,dmacParm,policy);
#ifdef WLAN_SUPPORT
					// ebtables -A macfilter -i wlan0+  -s 00:xx:..:xx -j ACCEPT/DROP
					DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ %s %s -j %s", (char *)FW_MACFILTER,
						(char *)WLANIF[0],smacParm,dmacParm,policy);
#endif
				}
				else {
					if (eth_mac_ctrl) {
						// ebtables -A macfilter -i eth0+  -s 00:xx:..:xx -j ACCEPT/DROP
						DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ %s %s -j %s", (char *)FW_MACFILTER,
							(char *)ELANIF,smacParm,dmacParm,policy);
					}
					if (wlan_mac_ctrl) {
#ifdef WLAN_SUPPORT
						// ebtables -A macfilter -i wlan0+  -s 00:xx:..:xx -j ACCEPT/DROP
						DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ %s %s -j %s", (char *)FW_MACFILTER,
							(char *)WLANIF[0],smacParm,dmacParm,policy);
#endif
					}
				}
			}
			else {
				// ebtables -A macfilter -i eth0+  -s 00:xx:..:xx -j ACCEPT/DROP
				DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ %s %s -j %s", (char *)FW_MACFILTER,
					(char *)ELANIF, smacParm,dmacParm,policy);
#ifdef WLAN_SUPPORT
				// ebtables -A macfilter -i wlan0+  -s 00:xx:..:xx -j ACCEPT/DROP
				DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ %s %s -j %s", (char *)FW_MACFILTER,
					(char *)WLANIF[0],smacParm,dmacParm,policy);
#endif
			}
		}
		else { // DIR_IN
#ifdef CONFIG_ETHWAN
			// ebtables -A macfilter -i nas0+  -s 00:xx:..:xx -j ACCEPT/DROP
			DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ %s %s -j %s", (char *)FW_MACFILTER, ALIASNAME_NAS0,
				smacParm,dmacParm,policy);
#endif
		}
	}

#ifdef CONFIG_RTK_L34_ENABLE
	//RTK_RG_MAC_Filter_Default_Policy(mac_out_dft, mac_in_dft);
	return 0;
#endif

	// default action
	DOCMDARGVS(EBTABLES,DOWAIT,"-P %s RETURN", (char *)FW_MACFILTER);
	if(mac_out_dft == 0) { // DROP
		if (eth_mac_ctrl) {
			// ebtables -A macfilter -i eth0+ -j DROP
			DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ -j DROP", (char *)FW_MACFILTER, (char *)ELANIF);
		}
#ifdef WLAN_SUPPORT
		if (wlan_mac_ctrl) {
			// ebtables -A macfilter -i wlan0+ -j DROP
			DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ -j DROP", (char *)FW_MACFILTER, (char *)WLANIF[0]);
		}
#endif
	}
	if(mac_in_dft == 0) { // DROP
#ifdef CONFIG_ETHWAN
		// ebtables -A macfilter -i nas0+ -j DROP
		DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s+ -j DROP", (char *)FW_MACFILTER, ALIASNAME_NAS0);
#endif
	}

#endif // of MAC_FILTER

	//Kevin, clear bridge fastpath table
	TRACE(STA_SCRIPT,"/bin/echo 2 > /proc/fastbridge\n");
	system("/bin/echo 2 > /proc/fastbridge");

	return 0;
}

#ifdef _PRMT_X_CMCC_LANINTERFACES_
int setupL2Filter(void)
{
	int i, total;
	char *policy;
	char srcmacaddr[18], dstmacaddr[18];
	char smacParm[64]={0};
	char dmacParm[64]={0};
	MIB_CE_L2FILTER_T entry;

#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_l2filter_rules();
#endif

	total = mib_chain_total(MIB_L2FILTER_TBL);

	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_L2FILTER_TBL, i, (void *)&entry))
			continue;

#ifdef CONFIG_RTK_L34_ENABLE
		AddRTK_RG_l2filter_rule(i, &entry);
		continue;
#endif

		//TODO: Add ebtable rules for non-RG platform
	}

#ifdef CONFIG_RTL8672_BRIDGE_FASTPATH
	TRACE(STA_SCRIPT,"/bin/echo 2 > /proc/fastbridge\n");
	system("/bin/echo 2 > /proc/fastbridge");
#endif

	return 0;
}
#endif

#ifdef _PRMT_X_CMCC_LANINTERFACES_
int setupMACLimit(void)
{
#ifdef CONFIG_RTK_L34_ENABLE
	RG_setup_mac_limit();
#endif
}
#endif

#ifdef LAYER7_FILTER_SUPPORT
int setupAppFilter(void)
{
	int entryNum,i;
	LAYER7_FILTER_T Entry;

	// Delete all Appfilter rule
	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_APPFILTER);
	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_APP_P2PFILTER);
	va_cmd(IPTABLES, 4, 1, ARG_T, "mangle", "-F", (char *)FW_APPFILTER);

	entryNum = mib_chain_total(MIB_LAYER7_FILTER_TBL);

	for(i=0;i<entryNum;i++)
	{
		if (!mib_chain_get(MIB_LAYER7_FILTER_TBL, i, (void *)&Entry))
			return -1;

		if(!strcmp("smtp",Entry.appname)){
			//iptables -A appfilter -i br0 -p TCP --dport 25 -j DROP
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_APPFILTER, ARG_I, LANIF,
				"-p", ARG_TCP, FW_DPORT, "25", "-j", (char *)FW_DROP);
			continue;
		}
		else if(!strcmp("pop3",Entry.appname)){
			//iptables -A appfilter -i br0 -p TCP --dport 110 -j DROP
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_APPFILTER, ARG_I, LANIF,
				"-p", ARG_TCP, FW_DPORT, "110", "-j", (char *)FW_DROP);
			continue;
		}
		else if(!strcmp("bittorrent",Entry.appname)){
			//iptables -A appp2pfilter -m ipp2p --bit -j DROP
			va_cmd(IPTABLES, 7, 1, (char *)FW_ADD, (char *)FW_APP_P2PFILTER, "-m", "ipp2p",
				"--bit", "-j", (char *)FW_DROP);
			continue;
		}
		else if(!strcmp("chinagame",Entry.appname)){
			//iptables -A appfilter -i br0 -p TCP --dport 8000 -j DROP
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_APPFILTER, ARG_I, LANIF,
				"-p", ARG_TCP, FW_DPORT, "8000", "-j", (char *)FW_DROP);
			continue;
		}
		else if(!strcmp("gameabc",Entry.appname)){
			//iptables -A appfilter -i br0 -p TCP --dport 5100 -j DROP
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_APPFILTER, ARG_I, LANIF,
				"-p", ARG_TCP, FW_DPORT, "5100", "-j", (char *)FW_DROP);
			continue;
		}
		else if(!strcmp("haofang",Entry.appname)){
			//iptables -A appfilter -i br0 -p TCP --dport 1201 -j DROP
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_APPFILTER, ARG_I, LANIF,
				"-p", ARG_TCP, FW_DPORT, "1201", "-j", (char *)FW_DROP);
			continue;
		}
		else if(!strcmp("ourgame",Entry.appname)){
			//iptables -A appfilter -i br0 -p TCP --dport 2000 -j DROP
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_APPFILTER, ARG_I, LANIF,
				"-p", ARG_TCP, FW_DPORT, "2000", "-j", (char *)FW_DROP);
		}


		// iptables -t mangle -A appfilter -m layer7 --l7proto qq -j DROP
		va_cmd(IPTABLES, 10, 1, ARG_T, "mangle", (char *)FW_ADD, (char *)FW_APPFILTER, "-m", "layer7",
			"--l7proto", Entry.appname, "-j", (char *)FW_DROP);

	}

	return 0;
}
#endif
#ifdef PARENTAL_CTRL
//Uses Global variable for keep watching timeout
static MIB_PARENT_CTRL_T parentctrltable[MAX_PARENTCTRL_USER_NUM] = {0};
/********************************
 *
 *	Initialization. load from flash
 *
 ********************************/
//return if this mac should be filtered now!
static int parent_ctrl_check(MIB_PARENT_CTRL_T *entry)
{
	time_t tm;
	struct tm the_tm;
	int		tmp1,tmp2,tmp3;;

	time(&tm);
	memcpy(&the_tm, localtime(&tm), sizeof(the_tm));

	if (((entry->controlled_day) & (1 << the_tm.tm_wday))!=0)
	{
		tmp1 = entry->start_hr * 60 +  entry->start_min;
		tmp2 = entry->end_hr * 60 +  entry->end_min;
		tmp3 = the_tm.tm_hour *60 + the_tm.tm_min;
		if ((tmp3 >= tmp1) && (tmp3 <= tmp2) )
			return 1;
	}

		return 0;

}

int parent_ctrl_table_init(void)
{
	int total,i;
	MIB_PARENT_CTRL_T	entry;

	memset(&parentctrltable[0],0, sizeof(MIB_PARENT_CTRL_T)*MAX_PARENTCTRL_USER_NUM);
	total = mib_chain_total(MIB_PARENTAL_CTRL_TBL);
	if (total >= MAX_PARENTCTRL_USER_NUM)
	{
		total = MAX_PARENTCTRL_USER_NUM -1;
		printf("ERROR, CHECK!");
	}
	 for ( i=0; i<total; i++)
	 {
		mib_chain_get(MIB_PARENTAL_CTRL_TBL, i, &parentctrltable[i]);
	 }
}

int parent_ctrl_table_add(MIB_PARENT_CTRL_T *addedEntry)
{
	int	i;

	for (i = 0; i < MAX_PARENTCTRL_USER_NUM; i++)
	{
		if (strlen(parentctrltable[i].username) == 0)
		{
			break;
		}
	}
	addedEntry->cur_state = 0;
	memcpy (&parentctrltable[i],addedEntry, sizeof(MIB_PARENT_CTRL_T));

	parent_ctrl_table_rule_update();
}

int parent_ctrl_table_del(MIB_PARENT_CTRL_T *addedEntry)
{
	int	i;
	char macaddr[20];

	for (i = 0; i < MAX_PARENTCTRL_USER_NUM; i++)
	{
		if ( !strcmp(parentctrltable[i].username, addedEntry->username))
		{
			if (parentctrltable[i].cur_state == 1)
			{
				//del the entry
					snprintf(macaddr, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
					parentctrltable[i].mac[0], parentctrltable[i].mac[1],
					parentctrltable[i].mac[2], parentctrltable[i].mac[3],
					parentctrltable[i].mac[4], parentctrltable[i].mac[5]);
				va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, (char *)FW_MACFILTER,
						(char *)ARG_I, (char *)getWlanIfName(), "-m", "mac",
						"--mac-source",  macaddr, "-j", "DROP");
				va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, (char *)FW_MACFILTER,
						(char *)ARG_I, (char *)ELANIF, "-m", "mac",
						"--mac-source",  macaddr, "-j", "DROP");
			}
			//remove the iptable here if it exists
			memset(&parentctrltable[i],0, sizeof(MIB_PARENT_CTRL_T));
			break;
		}
	}
}

int parent_ctrl_table_delall(void)
{
	int	i;
	char macaddr[20];

	for (i = 0; i < MAX_PARENTCTRL_USER_NUM; i++)
	{
		if (parentctrltable[i].cur_state == 1)
		{
			//del the entry
			snprintf(macaddr, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
				parentctrltable[i].mac[0], parentctrltable[i].mac[1],
				parentctrltable[i].mac[2], parentctrltable[i].mac[3],
				parentctrltable[i].mac[4], parentctrltable[i].mac[5]);
			va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, (char *)FW_MACFILTER,
					(char *)ARG_I, (char *)getWlanIfName(), "-m", "mac",
					"--mac-source",  macaddr, "-j", "DROP");
			va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, (char *)FW_MACFILTER,
					(char *)ARG_I, (char *)ELANIF, "-m", "mac",
					"--mac-source",  macaddr, "-j", "DROP");
		}

	}
	memset(&parentctrltable[0],0, sizeof(MIB_PARENT_CTRL_T)*MAX_PARENTCTRL_USER_NUM);
}

// update the rules to iptables according to current time
int parent_ctrl_table_rule_update(void)
{
	int i, check;
	char macaddr[20];

	for (i = 0; i < MAX_PARENTCTRL_USER_NUM; i++)
	{
		if (strlen(parentctrltable[i].username) > 0)
		{

			check = parent_ctrl_check(&parentctrltable[i]);

			if (( check == 1) &&
				(parentctrltable[i].cur_state == 0))
			{
				parentctrltable[i].cur_state = 1;

				//add the entry
				snprintf(macaddr, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
				parentctrltable[i].mac[0], parentctrltable[i].mac[1],
				parentctrltable[i].mac[2], parentctrltable[i].mac[3],
				parentctrltable[i].mac[4], parentctrltable[i].mac[5]);

				//for debug
				va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_MACFILTER,
						(char *)ARG_I, (char *)getWlanIfName(), "-m", "mac",
						"--mac-source",  macaddr, "-j", "DROP");
				va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_MACFILTER,
						(char *)ARG_I, (char *)ELANIF, "-m", "mac",
						"--mac-source",  macaddr, "-j", "DROP");
			}
			else if ((check == 0) &&
				(parentctrltable[i].cur_state == 1))
			{
				parentctrltable[i].cur_state = 0;
				//del the entry
				snprintf(macaddr, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
				parentctrltable[i].mac[0], parentctrltable[i].mac[1],
				parentctrltable[i].mac[2], parentctrltable[i].mac[3],
				parentctrltable[i].mac[4], parentctrltable[i].mac[5]);

				va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, (char *)FW_MACFILTER,
						(char *)ARG_I, (char *)getWlanIfName(), "-m", "mac",
						"--mac-source",  macaddr, "-j", "DROP");
				va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, (char *)FW_MACFILTER,
						(char *)ARG_I, (char *)ELANIF, "-m", "mac",
						"--mac-source",  macaddr, "-j", "DROP");
			}

		}
	}
}
#endif

#ifdef _PRMT_X_CMCC_SECURITY_
struct ParentalCtrl_info
{
	unsigned char MACAddress[MAC_ADDR_LEN];
	unsigned char UrlFilterPolicy;
	unsigned char UrlFilterRight;
	unsigned char DurationPolicy;
	unsigned char DurationRight;
	unsigned char StartTime_hr;
	unsigned char StartTime_min;
	unsigned char EndTime_hr;
	unsigned char EndTime_min;
	unsigned int RepeatDay;
	char UrlAddress[64];
	unsigned char cur_state;
	struct ParentalCtrl_info *next;
};
struct ParentalCtrl_info *ParentalCtrl_list = NULL;
int is_rule_ready = 0;

int get_Templates_entry_by_inst_num(unsigned int num, MIB_PARENTALCTRL_TEMPLATES_Tp pEntry, int *idx)
{
	int i = 0, total = mib_chain_total(MIB_PARENTALCTRL_TEMPLATES_TBL);

	if (pEntry == NULL || idx == NULL || num == 0)
		return -1;

	*idx = -1;
	for (i = 0; i < total; i++)
	{
		if (mib_chain_get(MIB_PARENTALCTRL_TEMPLATES_TBL, i, pEntry) == 0)
			continue;

		if (pEntry->inst_num == num)
		{
			*idx = i;
			return 0;
		}
	}
	return -1;
}

void ParentalCtrl_rule_free(void)
{
	if (ParentalCtrl_list)
	{
		struct ParentalCtrl_info *node = ParentalCtrl_list, *tmp = NULL;
		while (node != NULL)
		{
#ifdef CONFIG_RTK_L34_ENABLE
			//set MAC Policy to RG_FILTER_NONE
			RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_NONE, NULL);
#endif
			tmp = node;
			node = node->next;
			free(tmp);
		}
	}

	ParentalCtrl_list = NULL;
	return;
}

void ParentalCtrl_rule_dump(void)
{
	if (ParentalCtrl_list)
	{
		struct ParentalCtrl_info *node = ParentalCtrl_list;
		while (node != NULL)
		{
			fprintf(stderr, "--------------------\n");
			fprintf(stderr, "MACAddress = %02x:%02x:%02x:%02x:%02x:%02x\n", node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
																								node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
			fprintf(stderr, "UrlFilterPolicy = %d\n", node->UrlFilterPolicy);
			fprintf(stderr, "UrlFilterRight = %d\n", node->UrlFilterRight);
			fprintf(stderr, "DurationPolicy = %d\n", node->DurationPolicy);
			fprintf(stderr, "DurationRight = %d\n", node->DurationRight);
			fprintf(stderr, "StartTime_hr = %d\n", node->StartTime_hr);
			fprintf(stderr, "StartTime_min = %d\n", node->StartTime_min);
			fprintf(stderr, "EndTime_hr = %d\n", node->EndTime_hr);
			fprintf(stderr, "EndTime_min = %d\n", node->EndTime_min);
			fprintf(stderr, "RepeatDay = %u\n", node->RepeatDay);
			fprintf(stderr, "UrlAddress = %s\n", (strlen(node->UrlAddress) == 0) ? "":node->UrlAddress);
			fprintf(stderr, "cur_state = %u\n\n", node->cur_state);
			node = node->next;
		}
	}
	return;
}

void ParentalCtrl_rule_init(void)
{
	int i = 0, j = 0, k = 0;
	struct ParentalCtrl_info *new_info;

	is_rule_ready = 0;

	ParentalCtrl_rule_free();

	MIB_PARENTALCTRL_MAC_T mac_entry;
	int mac_total = mib_chain_total(MIB_PARENTALCTRL_MAC_TBL);
	for (i = 0; i < mac_total; i++)
	{
		if (!mib_chain_get(MIB_PARENTALCTRL_MAC_TBL, i, (void*)&mac_entry))
			continue;

		MIB_PARENTALCTRL_TEMPLATES_T templates_entry;
		int templates_idx = -1;
		if (get_Templates_entry_by_inst_num(mac_entry.TemplateInst, &templates_entry, &templates_idx) == 0)
		{
			MIB_PARENTALCTRL_TEMPLATES_URLFILTER_T url_entry;
			MIB_PARENTALCTRL_TEMPLATES_DURATION_T duration_entry;
			int url_total = mib_chain_total(MIB_PARENTALCTRL_TEMPLATES_URLFILTER_TBL);
			int duration_total = mib_chain_total(MIB_PARENTALCTRL_TEMPLATES_DURATION_TBL);

			if ((templates_entry.UrlFilterRight == 1 && templates_entry.DurationRight == 0 && url_total > 0) ||
				(templates_entry.UrlFilterRight == 1 && templates_entry.DurationRight == 1 && (url_total > 0 && duration_total == 0)))
			{
				// check URL only
				for (j = 0; j < url_total; j++)
				{
					if (!mib_chain_get(MIB_PARENTALCTRL_TEMPLATES_URLFILTER_TBL, j, (void*)&url_entry))
						continue;

					if (url_entry.TemplateInst == templates_entry.inst_num)
					{
						if (strlen(url_entry.UrlAddress) > 0)
						{
							fprintf(stderr, "MAC %d, URLFILTER %d\n", i, j);
							new_info = malloc(sizeof(struct ParentalCtrl_info));
							memset(new_info, 0, sizeof(struct ParentalCtrl_info));
							memcpy(new_info->MACAddress, mac_entry.MACAddress, 6);
							new_info->UrlFilterPolicy = templates_entry.UrlFilterPolicy;
							new_info->UrlFilterRight = templates_entry.UrlFilterRight;
							new_info->DurationPolicy = templates_entry.DurationPolicy;
							new_info->DurationRight = templates_entry.DurationRight;
							new_info->cur_state = 2;

							strncpy(new_info->UrlAddress, url_entry.UrlAddress, sizeof(url_entry.UrlAddress));

							new_info->next = ParentalCtrl_list;
							ParentalCtrl_list = new_info;
						}
					}
				}
			}
			else if ((templates_entry.UrlFilterRight == 0 && templates_entry.DurationRight == 1 && duration_total > 0) ||
						(templates_entry.UrlFilterRight == 1 && templates_entry.DurationRight == 1 && (url_total == 0 && duration_total > 0)))
			{
				// check duration only
				for (k = 0; k < duration_total; k++)
				{
					if (!mib_chain_get(MIB_PARENTALCTRL_TEMPLATES_DURATION_TBL, k, (void*)&duration_entry))
						continue;

					if (duration_entry.TemplateInst == templates_entry.inst_num)
					{
						int t1 = (duration_entry.StartTime_hr * 60) + duration_entry.StartTime_min;
						int t2 = (duration_entry.EndTime_hr * 60) + duration_entry.EndTime_min;
						if (t1 > 0 && t2 > 0 && t2 >= t1 && duration_entry.RepeatDay > 0)
						{
							fprintf(stderr, "MAC %d, DURATION %d\n", i, k);
							new_info = malloc(sizeof(struct ParentalCtrl_info));
							memset(new_info, 0, sizeof(struct ParentalCtrl_info));
							memcpy(new_info->MACAddress, mac_entry.MACAddress, 6);
							new_info->UrlFilterPolicy = templates_entry.UrlFilterPolicy;
							new_info->UrlFilterRight = templates_entry.UrlFilterRight;
							new_info->DurationPolicy = templates_entry.DurationPolicy;
							new_info->DurationRight = templates_entry.DurationRight;

							new_info->StartTime_hr = duration_entry.StartTime_hr;
							new_info->StartTime_min = duration_entry.StartTime_min;
							new_info->EndTime_hr = duration_entry.EndTime_hr;
							new_info->EndTime_min = duration_entry.EndTime_min;
							new_info->RepeatDay = duration_entry.RepeatDay;
							new_info->cur_state = 2;

							new_info->next = ParentalCtrl_list;
							ParentalCtrl_list = new_info;
						}
					}
				}
			}
			else if (templates_entry.UrlFilterRight == 1 && templates_entry.DurationRight == 1 && (url_total > 0 && duration_total > 0))
			{
				// check URL and duration
				for (j = 0; j < url_total; j++)
				{
					if (!mib_chain_get(MIB_PARENTALCTRL_TEMPLATES_URLFILTER_TBL, j, (void*)&url_entry))
						continue;

					if (url_entry.TemplateInst == templates_entry.inst_num)
					{
						for (k = 0; k < duration_total; k++)
						{
							if (!mib_chain_get(MIB_PARENTALCTRL_TEMPLATES_DURATION_TBL, k, (void*)&duration_entry))
								continue;

							if (duration_entry.TemplateInst == templates_entry.inst_num)
							{
								int t1 = (duration_entry.StartTime_hr * 60) + duration_entry.StartTime_min;
								int t2 = (duration_entry.EndTime_hr * 60) + duration_entry.EndTime_min;
								if ((strlen(url_entry.UrlAddress) > 0) && (t1 > 0 && t2 > 0 && t2 >= t1 && duration_entry.RepeatDay > 0))
								{
									fprintf(stderr, "MAC %d, URLFILTER %d, DURATION %d\n", i, j, k);
									new_info = malloc(sizeof(struct ParentalCtrl_info));
									memset(new_info, 0, sizeof(struct ParentalCtrl_info));
									memcpy(new_info->MACAddress, mac_entry.MACAddress, 6);
									new_info->UrlFilterPolicy = templates_entry.UrlFilterPolicy;
									new_info->UrlFilterRight = templates_entry.UrlFilterRight;
									new_info->DurationPolicy = templates_entry.DurationPolicy;
									new_info->DurationRight = templates_entry.DurationRight;

									strncpy(new_info->UrlAddress, url_entry.UrlAddress, sizeof(url_entry.UrlAddress));

									new_info->StartTime_hr = duration_entry.StartTime_hr;
									new_info->StartTime_min = duration_entry.StartTime_min;
									new_info->EndTime_hr = duration_entry.EndTime_hr;
									new_info->EndTime_min = duration_entry.EndTime_min;
									new_info->RepeatDay = duration_entry.RepeatDay;
									new_info->cur_state = 2;

									new_info->next = ParentalCtrl_list;
									ParentalCtrl_list = new_info;
								}
							}
						}
					}
				}
			}
		}
	}

	ParentalCtrl_rule_dump();
	is_rule_ready = 1;
	return;
}

int ParentalCtrl_time_check(int StartTime, int EndTime, unsigned int RepeatDay)
{
	time_t tm;
	struct tm the_tm;
	time(&tm);
	memcpy(&the_tm, localtime(&tm), sizeof(the_tm));
	int t_now = 0;
	//printf("day of the week:%d, RepeatDay:%d\r\n", (1 << the_tm.tm_wday), RepeatDay);

	if ((RepeatDay & (1 << the_tm.tm_wday)) != 0)
	{
		t_now = (the_tm.tm_hour * 60) + the_tm.tm_min;
		//printf("t_now(%d), StartTime(%d), EndTime(%d)\r\n", t_now, StartTime, EndTime);
		if ((t_now >= StartTime) && (t_now <= EndTime))
			return 1;
	}
	return 0;
}

int ParentalCtrl_rule_set(void)
{
	if (is_rule_ready)
	{
		int i = 0, j = 0, k = 0;
		if (ParentalCtrl_list)
		{
			struct ParentalCtrl_info *node = ParentalCtrl_list;
			while (node != NULL)
			{
				if (0)
				{
					fprintf(stderr, "--------------------\n");
					fprintf(stderr, "MACAddress = %02x:%02x:%02x:%02x:%02x:%02x\n", node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
																										node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
					fprintf(stderr, "UrlFilterPolicy = %d\n", node->UrlFilterPolicy);
					fprintf(stderr, "UrlFilterRight = %d\n", node->UrlFilterRight);
					fprintf(stderr, "DurationPolicy = %d\n", node->DurationPolicy);
					fprintf(stderr, "DurationRight = %d\n", node->DurationRight);
					fprintf(stderr, "StartTime_hr = %d\n", node->StartTime_hr);
					fprintf(stderr, "StartTime_min = %d\n", node->StartTime_min);
					fprintf(stderr, "EndTime_hr = %d\n", node->EndTime_hr);
					fprintf(stderr, "EndTime_min = %d\n", node->EndTime_min);
					fprintf(stderr, "RepeatDay = %u\n", node->RepeatDay);
					fprintf(stderr, "UrlAddress = %s\n", (strlen(node->UrlAddress) == 0) ? "":node->UrlAddress);
					fprintf(stderr, "cur_state = %u\n\n", node->cur_state);
				}

				if (node->UrlFilterRight == 1 && node->DurationRight == 0 && (node->cur_state == 0 || node->cur_state == 2))
				{
					if (strlen(node->UrlAddress) > 0)
					{
						fprintf(stderr, "(URL 1) Set %02x:%02x:%02x:%02x:%02x:%02x (Mode: %s) (URL: %s)\n\n",
												node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
												node->MACAddress[3], node->MACAddress[4], node->MACAddress[5],
												(node->UrlFilterPolicy == 0) ? "BLACK":"WHITE",
												node->UrlAddress);
#ifdef CONFIG_RTK_L34_ENABLE
						//set MAC Policy
						RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, (node->UrlFilterPolicy == 0) ? (RG_FILTER_BLACK):(RG_FILTER_WHITE), node->UrlAddress);
#endif
					}
					node->cur_state = 1;
				}
				else if (node->UrlFilterRight == 0 && node->DurationRight == 1)
				{
					int timecheck = 0, t1 = 0, t2 = 0;
					t1 = (node->StartTime_hr * 60) + node->StartTime_min;
					t2 = (node->EndTime_hr * 60) + node->EndTime_min;
					timecheck = ParentalCtrl_time_check(t1, t2, node->RepeatDay);

					if (node->DurationPolicy == 0 && timecheck == 1 && (node->cur_state == 0 || node->cur_state == 2))
					{
						fprintf(stderr, "(Duration 1) Block all URLs of %02x:%02x:%02x:%02x:%02x:%02x\n\n",
												node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
												node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
#ifdef CONFIG_RTK_L34_ENABLE
						//block MAC: MAC Policy = white and URL list is empty
						RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_WHITE, NULL);
#endif
						node->cur_state = 1;
					}
					else if (node->DurationPolicy == 0 && timecheck == 0 && (node->cur_state == 1 || node->cur_state == 2))
					{
						fprintf(stderr, "(Duration 2) Remove blocked MAC %02x:%02x:%02x:%02x:%02x:%02x\n\n",
												node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
												node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
#ifdef CONFIG_RTK_L34_ENABLE
						//Remove blocked MAC
						RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_NONE, NULL);
#endif
						node->cur_state = 0;
					}
					else if (node->DurationPolicy == 1 && timecheck == 1 && (node->cur_state == 1 || node->cur_state == 2))
					{
						fprintf(stderr, "(Duration 3) Remove blocked MAC %02x:%02x:%02x:%02x:%02x:%02x\n\n",
												node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
												node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
#ifdef CONFIG_RTK_L34_ENABLE
						//Remove blocked MAC
						RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_NONE, NULL);
#endif
						node->cur_state = 0;
					}
					else if (node->DurationPolicy == 1 && timecheck == 0 && (node->cur_state == 0 || node->cur_state == 2))
					{
						fprintf(stderr, "(Duration 4) Block all URLs of %02x:%02x:%02x:%02x:%02x:%02x\n\n",
												node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
												node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
#ifdef CONFIG_RTK_L34_ENABLE
						//block MAC: MAC Policy = white and URL list is empty
						RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_WHITE, NULL);
#endif
						node->cur_state = 1;
					}
				}
				else if (node->UrlFilterRight == 1 && node->DurationRight == 1)
				{
					int timecheck = 0, t1 = 0, t2 = 0;
					t1 = (node->StartTime_hr * 60) + node->StartTime_min;
					t2 = (node->EndTime_hr * 60) + node->EndTime_min;
					timecheck = ParentalCtrl_time_check(t1, t2, node->RepeatDay);

					if (node->UrlFilterPolicy == 0)
					{
						if (((node->DurationPolicy == 0 && timecheck == 1) || (node->DurationPolicy == 1 && timecheck == 0)) && (node->cur_state == 1 || node->cur_state == 2))
						{
							fprintf(stderr, "(Both 1) Block all URLs of %02x:%02x:%02x:%02x:%02x:%02x\n\n",
													node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
													node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
#ifdef CONFIG_RTK_L34_ENABLE
							//block MAC: MAC Policy = white and URL list is empty
							RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_NONE, NULL); // clean URLs of this MAC
							RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_WHITE, NULL);
#endif
							node->cur_state = 0;
						}
						else if (((node->DurationPolicy == 0 && timecheck == 0) || (node->DurationPolicy == 1 && timecheck == 1)) && (node->cur_state == 0 || node->cur_state == 2))
						{
							if (strlen(node->UrlAddress) > 0)
							{
								fprintf(stderr, "(Both 2) Set %02x:%02x:%02x:%02x:%02x:%02x (Mode: %s) (URL: %s)\n\n",
														node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
														node->MACAddress[3], node->MACAddress[4], node->MACAddress[5],
														(node->UrlFilterPolicy == 0) ? "BLACK":"WHITE",
														node->UrlAddress);
#ifdef CONFIG_RTK_L34_ENABLE
								//set MAC Policy
								RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, (node->UrlFilterPolicy == 0) ? (RG_FILTER_BLACK):(RG_FILTER_WHITE), node->UrlAddress);
#endif
							}
							node->cur_state = 1;
						}
					}
					else if (node->UrlFilterPolicy == 1)
					{
						if (((node->DurationPolicy == 0 && timecheck == 0) || (node->DurationPolicy == 1 && timecheck == 1)) && (node->cur_state == 1 || node->cur_state == 2))
						{
							fprintf(stderr, "(Both 3) Remove blocked MAC %02x:%02x:%02x:%02x:%02x:%02x\n\n",
													node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
													node->MACAddress[3], node->MACAddress[4], node->MACAddress[5]);
#ifdef CONFIG_RTK_L34_ENABLE
							//Remove blocked MAC
							RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, RG_FILTER_NONE, NULL);
#endif
							node->cur_state = 0;
						}
						else if (((node->DurationPolicy == 0 && timecheck == 1) || (node->DurationPolicy == 1 && timecheck == 0)) && (node->cur_state == 0 || node->cur_state == 2))
						{
							if (strlen(node->UrlAddress) > 0)
							{
								fprintf(stderr, "(Both 4) Set %02x:%02x:%02x:%02x:%02x:%02x (Mode: %s) (URL: %s)\n\n",
														node->MACAddress[0], node->MACAddress[1], node->MACAddress[2],
														node->MACAddress[3], node->MACAddress[4], node->MACAddress[5],
														(node->UrlFilterPolicy == 0) ? "BLACK":"WHITE",
														node->UrlAddress);
#ifdef CONFIG_RTK_L34_ENABLE
								//set MAC Policy
								RTK_RG_ParentalCtrl_MAC_Policy_Set(node->MACAddress, (node->UrlFilterPolicy == 0) ? (RG_FILTER_BLACK):(RG_FILTER_WHITE), node->UrlAddress);
#endif
							}
							node->cur_state = 1;
						}
					}
				}
				node = node->next;
			}
		}
	}
	return 0;
}
#endif

#ifdef CONFIG_USER_RTK_VOIP
#include "web_voip.h"
/*----------------------------------------------------------------------------
 * Name:
 *      voip_setup_iptable
 * Descriptions:
 *      Creat an iptable rule to allow incoming VoIP calls.
 * return:              none
 *---------------------------------------------------------------------------*/
static void voip_setup_iptable(void)
{
        char portbuff[10];
	voipCfgParam_t VoipEntry;
	voipCfgParam_t *pCfg = NULL;
	voipCfgPortParam_t *VoIPport;
	
	int i,val;
	unsigned int totalEntry = 0;

	totalEntry = mib_chain_total(MIB_VOIP_CFG_TBL);
	if( totalEntry > 0 ){
		if(mib_chain_get(MIB_VOIP_CFG_TBL, 0, (void*)&VoipEntry)){
			pCfg = &VoipEntry;
		}else{
			fprintf(stderr, "[%s %d]read voip config fail.\n",__FUNCTION__,__LINE__);
		}
	}else{
		fprintf(stderr, "[%s %d]flash do no have voip configuration.\n",__FUNCTION__,__LINE__);
	}

	if (!pCfg)
	{
		for ( i=5060; i<=5061; i++)	//default value
		{
			sprintf(portbuff, "%d",i);
  			va_cmd(IPTABLES, 11, 1, "-I", (char *)FW_INPUT,
             	   "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
	                (char *)FW_DPORT,portbuff, "-j", (char* ) "ACCEPT");
		}
#ifdef CONFIG_USER_RTK_H248
        /* for h.248 */
        sprintf(portbuff, "%d",pCfg->mg_port);
		va_cmd(IPTABLES, 11, 1, "-I", (char *)FW_INPUT, "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP, (char *)FW_DPORT,portbuff,
			"-j", (char* ) "ACCEPT");
#endif
	}
	else
	{
        for ( i=0; i<VOIP_PORTS; i++)
        {
                VoIPport = &pCfg->ports[i];
	        sprintf(portbuff, "%d",VoIPport->sip_port);
      		  va_cmd(IPTABLES, 11, 1, "-I", (char *)FW_INPUT,
                "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
                (char *)FW_DPORT,portbuff, "-j", (char* ) "ACCEPT");
        }
#ifdef CONFIG_USER_RTK_H248
        /* for h.248 */
        sprintf(portbuff, "%d",pCfg->mg_port);
		va_cmd(IPTABLES, 11, 1, "-I", (char *)FW_INPUT, "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP, (char *)FW_DPORT,portbuff,
			"-j", (char* ) "ACCEPT");
#endif
	}
}

#ifdef _PRMT_X_CT_COM_DHCP_
#define DEBUG_CHN_TEL(format, ...)
//#define DEBUG_CHN_TEL  printf

#include <openssl/des.h>
#include <openssl/md5.h>
#include <voip_flash.h>

void output_hex(const char *prefix, const unsigned char *data, size_t size)
{
	int i;

	DEBUG_CHN_TEL("%s", prefix);
	for(i=0 ; i < size ; i++)
	{
		DEBUG_CHN_TEL("%02X ", data[i]);
	}
	DEBUG_CHN_TEL("\n");
}

/** Utilities to encrypt VoIP username/password **/
/** For DHCP option 60 & DHCPv6 option 16 **/
static void get_key(const unsigned char *in, const unsigned char *R, const unsigned char *TS, unsigned char *out)
{
	unsigned char tmp[80];
	unsigned char *cur = tmp;

	memcpy(cur, R, 8);
	cur += 8;

	memcpy(cur, in, strlen(in));
	cur += strlen(in);

	memcpy(cur, TS, 8);
	cur += 8;

	MD5(tmp, strlen(in)+16, out);
}

static void do_3des(const unsigned char *key, const unsigned char *in, unsigned char *out, size_t len)
{
	DES_key_schedule ks1, ks2, ks3;
	DES_cblock block_key;
	DES_cblock tmp1, tmp2;
	int cnt, i;

	memcpy(&block_key, key, 8);
	DES_set_key_unchecked(&block_key, &ks1);

	memcpy(&block_key, key + 8, 8);
    DES_set_key_unchecked(&block_key, &ks2);

	memcpy(&block_key, key + 16, 8);
    DES_set_key_unchecked(&block_key, &ks3);

	cnt = len / 8;

	for(i = 0; i < cnt ; i++)
	{
		memcpy(tmp1, in + 8*i, 8);
		DES_ecb3_encrypt(&tmp1, &tmp2, &ks1, &ks2, &ks3, DES_ENCRYPT);
		memcpy(out + 8*i, &tmp2, 8);
	}
}

static int get_encrypt_text(char *user, char *R, char *TS, char *buf)
{
	char des3_key[24] = {0};
	int user_len = strlen(user);
	int i;
	char *plain_text;
	int plain_len;
	unsigned char pkcs7;


	output_hex("R = ", R, 8);
	output_hex("TS = ", TS, 8);

	// key for 3DES
	memcpy(des3_key, R, 8);
	memcpy(des3_key + 8, TS, 8);
	//output_hex("3des_key = ", des3_key, 24);

	// Prepare plain text for 3DES
	pkcs7 = (user_len % 8 == 0) ? 8 : 8 - (user_len % 8);
	plain_len = user_len + pkcs7;
	plain_text = malloc(plain_len);
	strcpy(plain_text, user);
	for( i = 0 ; i < pkcs7 ; i++)
		*(plain_text + user_len + i) = pkcs7;

	//output_hex("plain_text = ", plain_text, plain_len);

	//clear output buffer
	memset(buf, 0, plain_len);

	do_3des(des3_key, plain_text, buf, plain_len);

	output_hex("encrypted text = ", buf, plain_len);
	free(plain_text);

	return plain_len;
}

/*----------------------------------------------------------------------------
 * Name:
 *      get_ctc_voip_encrypted_data
 * Descriptions:
 *      Generate DHCP option 60 or DHCPv6 option 16 field type 34 values.
 * return:
 *      Length of encrypted data.
 *---------------------------------------------------------------------------*/
static int get_ctc_voip_encrypted_data(char *out, int len)
{
	char buf[100];
	char *cur = out;
	int buf_len;
	char serial[64] = {0};
	char oui[32] = {0};

#if 0	//test data 1
	// Result of C: A4 ED BA BF 98 50 1E D1 6C BF DE 0D 0E A5 0F F9
	// Result of Key: 53 BE 31 31 0F 1F 5F C8 53 8E 67 70 77 32 19 DE
	char user[] = "ad66133512@iptv";
	char pass[] = "123456";
	char R[8] = {0x0A, 0xDA, 0xA1, 0x3C, 0x13, 0x0D, 0x33, 0x6A};
	char TS[8] = {0x0E, 0};
#endif

#if 0	//test data 2
	// Result of C: 1A B2 45 FF B0 CF B4 47 52 29 C8 67 10 6B E0 E3
	// Result of Key: 26 57 07 02 2B 15 B6 BC 3A C6 50 1B 69 46 29 FA
	char user[] = "ad66133512@iptv";
	char pass[] = "123456";
	char R[8] = {0x3E, 0x1C, 0x2D, 0x45, 0x13, 0xDB, 0x38, 0x15};
	char TS[8] = {0xFB, 0x16, 0x57, 0x4E, 0};
#endif

#if 1	//disable this code block and enable above test data for testing
	char username[DNS_LEN] = {0};
	char password[DNS_LEN] = {0};
	char R[8] = {0};	//8 bytes random number
	char TS[8] = {0};	//8 bytes time stamp with leading zero
	long temp;
	voipCfgParam_t * pCfg;
	voipCfgPortParam_t *VoIPport;
	int i,val;

	if(voip_flash_get( &pCfg) == 0)
	{
		unsigned char type = 0;
		char *login_id = pCfg->ports[0].proxies[0].login_id;

		mib_get(PROVINCE_DHCP_OPT60_TYPE, &type);

		if(type == DHCP_OPT60_TYPE_JSU && strchr(login_id, '@') == NULL)
		{
			DEBUG_CHN_TEL("Appdneding hostname %s\n", pCfg->ports[0].proxies[0].addr);
			snprintf(username, sizeof(username), "%s@%s", login_id, pCfg->ports[0].proxies[0].addr);
		}
		else
			strcpy(username, login_id);

		strcpy(password, pCfg->ports[0].proxies[0].password);
	}

	temp = time(NULL);
	memcpy(TS, &temp, 4);

	srandom(temp);
	temp = random();
	memcpy(R, &temp, 4);
	temp = random();
	memcpy(R+4, &temp, 4);
#endif

	mib_get(MIB_HW_SERIAL_NUMBER, serial);
	mib_set(RTK_DEVID_OUI, "");
	getOUIfromMAC(oui);

	DEBUG_CHN_TEL("Username: %s\n", username);
	DEBUG_CHN_TEL("Password: %s\n", password);
	DEBUG_CHN_TEL("OUI: %s\n", oui);
	DEBUG_CHN_TEL("Serial Number: %s\n", serial);

	buf_len = strlen(oui);
	memcpy(cur, oui, buf_len);
	cur += buf_len;

	memcpy(cur, "-", 1);
	cur += 1;

	buf_len = strlen(serial);
	memcpy(cur, serial, buf_len);
	cur += buf_len;


	if(strlen(username) == 0 || strlen(password) == 0)
	{
		printf("Use default: admin/admin\n");
		strcpy(cur, "admin/admin");
		cur += strlen("admin/admin");
		return (cur-out);
	}

	// First byte is encryption type;
	*cur = 1;
	cur += 1;

	// concat random number
	memcpy(cur, R, 8);
	cur += 8;

	// concat time stamp
	memcpy(cur, TS, 8);
	cur += 8;

	// length of MD5 result is 16
	get_key(password, R, TS, buf);
	output_hex("Key = ", buf, 16);
	memcpy(cur, buf, 16);
	cur += 16;

	buf_len = get_encrypt_text(username, R, TS, buf);
	memcpy(cur, buf, buf_len);
	cur += buf_len;

	output_hex("Result: ", out, cur - out);

	return (cur - out);
}
#endif //_PRMT_X_CT_COM_DHCP_
#endif //CONFIG_USER_RTK_VOIP

#ifdef _PRMT_X_CT_COM_DHCP_
int gen_ctcom_dhcp_opt(unsigned char type, char *output, int out_len)
{
	int len;
	char buf[256] = {0};

	if(output == NULL)
		return 0;

	switch(type)
	{
	case 1:
		mib_get(MIB_HW_CWMP_MANUFACTURER, output);
		return strlen(output);
	case 2:
		strncpy(output, "HGW", out_len);
		return strlen(output);
	case 3:
		mib_get(MIB_HW_CWMP_PRODUCTCLASS, output);
		return strlen(output);
	case 4:
		{
			char hw[64] = {0}, sw[64] = {0};
			mib_get(MIB_HW_HWVER, hw);
			getSYS2Str(SYS_FWVERSION, sw);
			snprintf(output, out_len, "%s/%s", hw, sw);
		return strlen(output);
		}
	case 32:
		strncpy(output, "CTCDHCP0001", out_len);
		return strlen(output);
		break;
#ifdef CONFIG_USER_RTK_VOIP
	case 34:
		return get_ctc_voip_encrypted_data(output, out_len);
#endif
	default:
		return -1;
	}
}
#endif //_PRMT_X_CT_COM_DHCP_


#ifdef VIRTUAL_SERVER_SUPPORT
int setupVtlsvr(int type)
{

	int i, total;
	struct vtlsvr_entryx Entry;
	char remoteHost[32];
	total = mib_chain_total(MIB_VIRTUAL_SVR_TBL);
	DOCMDINIT;
/*
#ifdef IP_FILTER_PRIORITY_HIGHEST
	int position=mib_chain_total(MIB_IP_PORT_FILTER_TBL)+3;
#else
	int position=3;
#endif
*/
	//clear the IPTABLE_VTLSUR rules in the filter tables
	DOCMDARGVS(IPTABLES, DOWAIT, "-F %s", IPTABLE_VTLSUR);

	//clear the IPTABLE_VTLSUR rules in the nat tables
	DOCMDARGVS(IPTABLES, DOWAIT, "-t nat -F %s", IPTABLE_VTLSUR);

#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_Virtual_Server();
#endif

	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_VIRTUAL_SVR_TBL, i, (void *)&Entry))
			return -1;

		if(Entry.enable == 0)
			continue;

		if(Entry.remotehost[0])
		{
			sprintf(remoteHost, "-s %s", inet_ntoa(*((struct in_addr *)&(Entry.remotehost))));
		}
		else
		{
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			continue;
#else
			remoteHost[0] = '\0';
#endif
		}
#ifdef CONFIG_RTK_L34_ENABLE
		if(type == VIRTUAL_SERVER_ADD){
			//printf("Entry.ifIndex %u\n", Entry.ifIndex);
			RTK_RG_Virtual_Server_Set(&Entry);
		}
#endif
		if (Entry.protoType == PROTO_TCP || Entry.protoType == 0)//0--TCP/UDP
		{
		/*ping_zhang:20080809 START:replace 'br0' with 'br+' in order to involve pppoe proxy connection*/
	 	#ifdef CONFIG_PPPOE_PROXY_IF_NAME
			// iptables -t nat -A virtual_server -i ! $LAN_IF -p TCP --dport srcPortRange -j DNAT --to-destination ipaddr --to-ports 8080
			DOCMDARGVS(IPTABLES, DOWAIT, "-t nat %s %s -i !br+ -p TCP %s --dport %u:%u -j DNAT --to-destination %s:%u ",VIRTUAL_SERVER_ACTION_APPEND(type),IPTABLE_VTLSUR,
				remoteHost, Entry.wanStartPort, Entry.wanEndPort,	inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
			// iptables -A virtual_server 3 -i ! $LAN_IF -o $LAN_IF -p TCP --dport dstPortRange -j ACCEPT
			DOCMDARGVS(IPTABLES, DOWAIT, "%s %s -i !br+ -o br+ -p TCP -d %s --dport %u -j ACCEPT",VIRTUAL_SERVER_ACTION_INSERT(type),IPTABLE_VTLSUR,inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
		#else
			// iptables -t nat -A virtual_server -i ! $LAN_IF -p TCP --dport srcPortRange -j DNAT --to-destination ipaddr --to-ports 8080
			DOCMDARGVS(IPTABLES, DOWAIT, "-t nat %s %s -i !br0 -p TCP %s --dport %u:%u -j DNAT --to-destination %s:%u ",VIRTUAL_SERVER_ACTION_APPEND(type),IPTABLE_VTLSUR,
				remoteHost, Entry.wanStartPort, Entry.wanEndPort,	inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
			// iptables -A virtual_server -i ! $LAN_IF -o $LAN_IF -p TCP --dport dstPortRange -j ACCEPT
			DOCMDARGVS(IPTABLES, DOWAIT, "%s %s -i !br0 -o br0 -p TCP -d %s --dport %u -j ACCEPT",VIRTUAL_SERVER_ACTION_INSERT(type),IPTABLE_VTLSUR,inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
		#endif
	 	/*ping_zhang:20080809 END*/
		}

		if (Entry.protoType == PROTO_UDP || Entry.protoType == 0)
		{
	 	/*ping_zhang:20080809 START:replace 'br0' with 'br+' in order to involve pppoe proxy connection*/
	 	#ifdef CONFIG_PPPOE_PROXY_IF_NAME
			// iptables -t nat -A virtual_server -i ! $LAN_IF -p TCP --dport srcPortRange -j DNAT --to-destination ipaddr --to-ports 8080
			DOCMDARGVS(IPTABLES, DOWAIT, "-t nat %s %s -i !br+ -p UDP %s --dport %u:%u -j DNAT --to-destination %s:%u ",VIRTUAL_SERVER_ACTION_APPEND(type),IPTABLE_VTLSUR,
				remoteHost, Entry.wanStartPort, Entry.wanEndPort,	inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
			// iptables -A virtual_server -i ! $LAN_IF -o $LAN_IF -p TCP --dport dstPortRange -j ACCEPT
			DOCMDARGVS(IPTABLES, DOWAIT, "%s %s  -i !br+ -o br+ -p UDP -d %s --dport %u -j ACCEPT",VIRTUAL_SERVER_ACTION_INSERT(type),IPTABLE_VTLSUR,inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
	 	#else
			// iptables -t nat -A virtual_server -i ! $LAN_IF -p TCP --dport srcPortRange -j DNAT --to-destination ipaddr --to-ports 8080
			DOCMDARGVS(IPTABLES, DOWAIT, "-t nat %s %s -i !br0 -p UDP %s --dport %u:%u -j DNAT --to-destination %s:%u ",VIRTUAL_SERVER_ACTION_APPEND(type),IPTABLE_VTLSUR,
				remoteHost, Entry.wanStartPort, Entry.wanEndPort,	inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
			// iptables -A virtual_server -i ! $LAN_IF -o $LAN_IF -p TCP --dport dstPortRange -j ACCEPT
			DOCMDARGVS(IPTABLES, DOWAIT, "%s %s  -i !br0 -o br0 -p UDP -d %s --dport %u -j ACCEPT", VIRTUAL_SERVER_ACTION_INSERT(type), IPTABLE_VTLSUR, inet_ntoa(*((struct in_addr *)&(Entry.serverIp))),Entry.lanPort);
	 	#endif
	 	/*ping_zhang:20080809 END*/
		}
	}

#ifdef CONFIG_RTK_L34_ENABLE
	if(type == VIRTUAL_SERVER_ADD)
		RTK_RG_ALG_SRV_in_Lan_Set();
#endif

	return 1;
}
#endif

int getIpRange(char *src, char* start, char*end)
{
	struct in6_addr address6;
	struct in_addr address;
	int iptype=0;
	int ip_addr1, ip_addr2, ip_addr3;

	if(!strcmp(src, "") || !strcmp(src, "0")){
	    iptype = 0;
	}
	else if(inet_pton(AF_INET, src, &address) == 1){
	    iptype = IPVER_IPV4;
	}
	else if(inet_pton(AF_INET6, src, &address6) == 1){
	    iptype = IPVER_IPV6;
	}
	else{
	    iptype = 0;
	}

	if(iptype==IPVER_IPV4){
			address.s_addr = ntohl(address.s_addr);		
			if(address.s_addr & 0x00000FF){//single ip
			sprintf(start, "%s", src);
			sprintf(end, "%s", src);
			return 1;
	        }
        	else{//range
			sscanf(src, "%d.%d.%d.*%d", &ip_addr1, &ip_addr2, &ip_addr3);
			sprintf(start, "%d.%d.%d.1", ip_addr1, ip_addr2, ip_addr3);
			sprintf(end, "%d.%d.%d.255", ip_addr1, ip_addr2, ip_addr3);				
			return 2;
		}
	}
	else if(iptype==IPVER_IPV6){
		if(address6.s6_addr32[3]==0){//range
			strcpy(start, src);
			address6.s6_addr32[3]=0xffffffff;
			inet_ntop(AF_INET6, &address6, end, 64);
			return 2;
		}
		else{
			sprintf(start, "%s", src);
			sprintf(end, "%s", src);
			return 1;
		}
	}
	return -1;
}

#ifdef CONFIG_CMCC_FORWARD_RULE_SUPPORT
char* trimSpaces(char* source)
{
	char* i = source;
	char* j = source;
	while(*j != 0)
	{
		*i = *j++;
		if(*i != ' ')
			i++;
	}
	*i = 0;
	return source;
}

// parse format  x-y/!x/x
// type 0: x-y
// type 1: !x
// type 2: x
// type 3: 0
int parseRemotePort(char* source, int*start, int*end)
{
	char *pch;
	int i = 0;
	char tmp[128] = {0};

	strcpy(tmp, source);

	if(tmp[0] == '!'){
		*start = atoi(&tmp[1]);
		*end = atoi(&tmp[1]);
		return 1;
	}
	else if(!strstr(tmp, "-")){//format x
		*start = atoi(tmp);
		*end = atoi(tmp);
		if(*start == 0 && *end == 0)
			return 3;
		else
			return 2;
	}
	else{//format x-y
		for(i=0; i < strlen(tmp); i++){
			if(tmp[i] == '-'){
				break;
			}
		}
		tmp[i] = 0;
		*start = atoi(tmp);
		*end = atoi(&tmp[i+1]);

		return 0;
	}
	return -1;
}

char* replaceChar(char*source, char found, char c)
{
	int i = 0;
	for(i=0; i < strlen(source); i++){
		if(source[i] == found){
			source[i] = c;
		}
	}
	return source;
}

/*
remote: any, forward: any   ==> 0 (ipv4+ipv6)
remote: any, forward: ipv4   ==> 1 (ipv4)
remote: any, forward: ipv6   ==> 2 (ipv6)
remote: ipv4, forward: any   ==> 3   (ipv4)
remote: ipv4, forward: ipv4   ==> 4   (ipv4)
remote: ipv4, forward: ipv6   ==> 5   (error)
remote: ipv6, forward: any   ==> 6   (ipv6)
remote: ipv6, forward: ipv4   ==> 7   (error)
remote: ipv6, forward: ipv6   ==> 8   (ipv6)
*/
int checkIPv4OrIPv6(char *remote, char* forward)
{
	struct in6_addr address6;
	struct in_addr address;
	int iremote = 0, iforward = 0;  //0: any, 1:ipv4, 2:ipv6

	if(!strcmp(remote, "") || !strcmp(remote, "0")){
		iremote = 0;
	}
	else if(inet_pton(AF_INET, remote, &address) == 1){
		iremote = 1;
	}
	else if(inet_pton(AF_INET6, remote, &address6) == 1){
		iremote = 2;
	}
	else{
		iremote = 0;
	}
	
	if(!strcmp(forward, "") || !strcmp(forward, "0")){
		iforward = 0;
	}
	else if(inet_pton(AF_INET, forward, &address) == 1){
		iforward = 1;
	}
	else if(inet_pton(AF_INET6, forward, &address6) == 1){
		iforward = 2;
	}
	else{
		iforward = 0;
	}

	if(iremote == 0 && iforward == 0){
		return 0;
	}
	else if(iremote == 0 && iforward == 1){
		return 1;
	}
	else if(iremote == 0 && iforward == 2){
		return 2;
	}
	else if(iremote == 1 && iforward == 0){
		return 3;
	}
	else if(iremote == 1 && iforward == 1){
		return 4;
	}
	else if(iremote == 1 && iforward == 2){
		return 5;
	}
	else if(iremote == 2 && iforward == 0){
		return 6;
	}
	else if(iremote == 2 && iforward == 1){
		return 7;
	}
	else if(iremote == 2 && iforward == 2){
		return 8;
	}
}

void setCmccForwardRuleIptables(MIB_CMCC_FORWARD_RULE_T *Entry, int type)
{
	int remoteporttype = -1, startport = 0, endport = 0;
	char cmd[512] = {0};
	char cmd1[512] = {0};
	char cmd2[512] = {0};
	char tmp[128] = {0};
	char tmp1[128] = {0};
	int iptype = 0;
	int iprangetype=0;
	char ipaddr1[64]={0}, ipaddr2[64] ={0};
	
	DOCMDINIT;

	printf("%s:%d type %d\n", __FUNCTION__, __LINE__, type);
	printf("%s:%d remoteAddress %s, realremoteAddress %s, remotePort %s, protocol %d, hostMAC %s, forwardToIP %s, forwardToPort %d\n", __FUNCTION__, __LINE__, 
		Entry->remoteAddress, 
		Entry->realremoteAddress, 
		Entry->remotePort,
		Entry->protocol,
		Entry->hostMAC,
		Entry->forwardToIP,
		Entry->forwardToPort);

	iptype = checkIPv4OrIPv6(Entry->realremoteAddress, Entry->forwardToIP);
	iprangetype = getIpRange(Entry->realremoteAddress, ipaddr1, ipaddr2);
	printf("%s:%d iptype %d iprangetype %d\n", __FUNCTION__, __LINE__, iptype, iprangetype);
	
	//protocol, remoteAddress
	memset(tmp, 0, 128);
	if(Entry->protocol == PROTO_TCP){
		sprintf(tmp, "%s %s -p TCP", CMCC_FORWARDRULE_ACTION_APPEND(type),CMCC_FORWARDRULE);
	}
	else{
		sprintf(tmp, "%s %s -p UDP", CMCC_FORWARDRULE_ACTION_APPEND(type),CMCC_FORWARDRULE);
	}
	strcat(cmd, tmp);

	//remoteAddress
	memset(tmp, 0, 128);
	if(!strcmp(Entry->remoteAddress, "") || !strcmp(Entry->remoteAddress, "0")){
		strcpy(tmp, "");
	}
	else{
		if(iprangetype==1)
			sprintf(tmp, " -d %s", Entry->realremoteAddress);
		else if(iprangetype==2)
			sprintf(tmp, " -m iprange --dst-range %s-%s", ipaddr1, ipaddr2);
	}
	strcat(cmd, tmp);

	//remote port
	memset(tmp, 0, 128);
	remoteporttype = parseRemotePort(Entry->remotePort, &startport, &endport);
	if(remoteporttype == 3){//remote port == 0, don't card
		strcpy(tmp, "");
	}
	else if(remoteporttype == 1){ //format !x
		sprintf(tmp, " ! --dport %d", startport);
	}
	else{
		strcpy(tmp1, Entry->remotePort);
		sprintf(tmp, " --dport %s", replaceChar(tmp1, '-', ':'));
	}
	strcat(cmd, tmp);

	//hostMAC
	memset(tmp, 0, 128);
	if(!strcmp(Entry->hostMAC, "") || !strcmp(Entry->hostMAC, "0")){
		strcpy(tmp, "");
	}
	else{
		sprintf(tmp, " -m mac --mac-source %s", Entry->hostMAC);
	}
	strcat(cmd, tmp);

	//action
	memset(tmp, 0, 128);
	if(Entry->forwardToPort == 0){ //drop
		//action
		sprintf(tmp, " -j DROP");
		strcat(cmd, tmp);	
	}
	else {
		//action
		sprintf(tmp, " -j ACCEPT");
		strcat(cmd, tmp);
			
		if(!strcmp(Entry->forwardToIP, "") || !strcmp(Entry->forwardToIP, "0")){
			//do nothing, let packet handle by kernel stack
		}
		else{ //forward to destination IP/port
			//protocol, remoteAddress
			memset(tmp, 0, 128);
			if(Entry->protocol == PROTO_TCP){
				sprintf(tmp, "-t nat %s %s -p TCP", CMCC_FORWARDRULE_ACTION_APPEND(type),CMCC_FORWARDRULE);
				sprintf(tmp1, "-t nat %s %s -p TCP", CMCC_FORWARDRULE_ACTION_APPEND(type),CMCC_FORWARDRULE_POST);
			}
			else{
				sprintf(tmp, "-t nat %s %s -p UDP", CMCC_FORWARDRULE_ACTION_APPEND(type),CMCC_FORWARDRULE);
				sprintf(tmp1, "-t nat %s %s -p UDP", CMCC_FORWARDRULE_ACTION_APPEND(type),CMCC_FORWARDRULE_POST);
			}
			strcat(cmd1, tmp);
			strcat(cmd2, tmp1);

			//remoteAddress
			memset(tmp, 0, 128);
			if(!strcmp(Entry->remoteAddress, "") || !strcmp(Entry->remoteAddress, "0")){
				strcpy(tmp, "");
			}
			else{
				if(iprangetype==1)
					sprintf(tmp, " -d %s", Entry->realremoteAddress);
				else if(iprangetype==2)
					sprintf(tmp, " -m iprange --dst-range %s-%s", ipaddr1, ipaddr2);
			}
			strcat(cmd1, tmp);

			//remote port
			memset(tmp, 0, 128);
			remoteporttype = parseRemotePort(Entry->remotePort, &startport, &endport);
			if(remoteporttype == 3){//remote port == 0, don't card
				strcpy(tmp, "");
			}
			else if(remoteporttype == 1){ //format !x
				sprintf(tmp, " ! --dport %d", startport);
			}
			else{
				strcpy(tmp1, Entry->remotePort);
				sprintf(tmp, " --dport %s", replaceChar(tmp1, '-', ':'));
			}
			strcat(cmd1, tmp);

			//hostMAC
			memset(tmp, 0, 128);
			if(!strcmp(Entry->hostMAC, "") || !strcmp(Entry->hostMAC, "0")){
				strcpy(tmp, "");
			}
			else{
				sprintf(tmp, " -m mac --mac-source %s", Entry->hostMAC);
			}
			strcat(cmd1, tmp);

			//forwardToIP, forwardToPort
			memset(tmp, 0, 128);
			
			printf("%s:%d iptype %d\n", __FUNCTION__, __LINE__, iptype);
			if(iptype == 0 || iptype == 1 || iptype == 3 || iptype == 4){
				sprintf(tmp, " -j DNAT --to-destination %s:%d", Entry->forwardToIP, Entry->forwardToPort);
				strcat(cmd1, tmp);
				printf("%s:%d cmd1 %s\n", __FUNCTION__, __LINE__, cmd1);
				DOCMDARGVS(IPTABLES, DOWAIT, cmd1);
			}
			if(iptype == 0 || iptype == 2 || iptype == 6 || iptype == 8){
				sprintf(tmp, " -j DNAT --to-destination [%s]:%d", Entry->forwardToIP, Entry->forwardToPort);
				strcat(cmd1, tmp);
				printf("%s:%d cmd1 %s\n", __FUNCTION__, __LINE__, cmd1);
				DOCMDARGVS(IP6TABLES, DOWAIT, cmd1);

				//ip6tables -t nat -A POSTROUTING -d 2004::1 -j MASQUERADE
				sprintf(tmp, " -d %s --dport %d -j MASQUERADE", Entry->forwardToIP, Entry->forwardToPort);
				strcat(cmd2, tmp);
				
				printf("%s:%d cmd2 %s\n", __FUNCTION__, __LINE__, cmd2);
				DOCMDARGVS(IP6TABLES, DOWAIT, cmd2);
			}
		}
	}
	printf("%s:%d cmd %s\n", __FUNCTION__, __LINE__, cmd);
	printf("%s:%d iptype %d\n", __FUNCTION__, __LINE__, iptype);
	if(iptype == 0 || iptype == 1 || iptype == 3 || iptype == 4){
		DOCMDARGVS(IPTABLES, DOWAIT, cmd);
	}
	if(iptype == 0 || iptype == 2 || iptype == 6 || iptype == 8){
		DOCMDARGVS(IP6TABLES, DOWAIT, cmd);
	}
}

int AddCmccForwardRule(MIB_CMCC_FORWARD_RULE_T *Entry, int type)
{
	int ret = 0;

	printf("%s:%d\n", __FUNCTION__, __LINE__);
	
#ifdef CONFIG_RTK_L34_ENABLE
	if(type == CMCC_FORWARDRULE_ADD)
		ret = AddRTK_RG_ACL_CmccForwardRule(Entry, type);
#endif
	if(type == CMCC_FORWARDRULE_MOD){
		setCmccForwardRuleIptables(Entry, CMCC_FORWARDRULE_DELETE);
	}
	setCmccForwardRuleIptables(Entry, CMCC_FORWARDRULE_ADD);

	return ret;
}

int DelCmccForwardRule(MIB_CMCC_FORWARD_RULE_T *Entry)
{
	int ret = 0;

	printf("%s:%d\n", __FUNCTION__, __LINE__);
	
#ifdef CONFIG_RTK_L34_ENABLE
		ret = delRTK_RG_ACL_CmccForwardRule(Entry->aclIdx);
		if(Entry->aclIdx1 > 0){
			ret = delRTK_RG_ACL_CmccForwardRule(Entry->aclIdx1);
		}
#endif
		setCmccForwardRuleIptables(Entry, CMCC_FORWARDRULE_DELETE);

	return ret;
}

int DelAllCmccForwardRule()
{
	int i, total;
	MIB_CMCC_FORWARD_RULE_T Entry;
	
	total = mib_chain_total(MIB_CMCC_FORDWARD_RULE_TBL);
	DOCMDINIT;

	//clear the IPTABLE_VTLSUR rules in the filter tables
	DOCMDARGVS(IPTABLES, DOWAIT, "-F %s", CMCC_FORWARDRULE);
	DOCMDARGVS(IP6TABLES, DOWAIT, "-F %s", CMCC_FORWARDRULE);

	//clear the IPTABLE_VTLSUR rules in the nat tables
	DOCMDARGVS(IPTABLES, DOWAIT, "-t nat -F %s", CMCC_FORWARDRULE);
	DOCMDARGVS(IP6TABLES, DOWAIT, "-t nat -F %s", CMCC_FORWARDRULE);
	DOCMDARGVS(IP6TABLES, DOWAIT, "-t nat -F %s", CMCC_FORWARDRULE_POST);

#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_CmccForwardRule();
#endif

	return 0;
}

int setupCmccForwardRule(int type)
{

	int i, total;
	MIB_CMCC_FORWARD_RULE_T Entry;
	
	total = mib_chain_total(MIB_CMCC_FORDWARD_RULE_TBL);
	DOCMDINIT;

	//clear the IPTABLE_VTLSUR rules in the filter tables
	DOCMDARGVS(IPTABLES, DOWAIT, "-F %s", CMCC_FORWARDRULE);
	DOCMDARGVS(IP6TABLES, DOWAIT, "-F %s", CMCC_FORWARDRULE);

	//clear the IPTABLE_VTLSUR rules in the nat tables
	DOCMDARGVS(IPTABLES, DOWAIT, "-t nat -F %s", CMCC_FORWARDRULE);
	DOCMDARGVS(IP6TABLES, DOWAIT, "-t nat -F %s", CMCC_FORWARDRULE);
	DOCMDARGVS(IP6TABLES, DOWAIT, "-t nat -F %s", CMCC_FORWARDRULE_POST);

#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_CmccForwardRule();
#endif

	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_CMCC_FORDWARD_RULE_TBL, i, (void *)&Entry))
			return -1;

		if(type == CMCC_FORWARDRULE_ADD){
			AddCmccForwardRule(&Entry, CMCC_FORWARDRULE_ADD);
		}
	}
	return 1;
}
#endif

#ifdef PORT_FORWARD_GENERAL
void clear_dynamic_port_fw(int (*upnp_delete_redirection)(unsigned short eport, const char * protocol))
{
	int i, total;
	MIB_CE_PORT_FW_T port_entity;

	total = mib_chain_total(MIB_PORT_FW_TBL);

	for (i = total - 1; i >= 0; i--) {
		if (!mib_chain_get(MIB_PORT_FW_TBL, i, &port_entity))
			continue;

		if (port_entity.dynamic) {
			/* created by UPnP */
			mib_chain_delete(MIB_PORT_FW_TBL, i);

			if (upnp_delete_redirection)
				upnp_delete_redirection(port_entity.externalfromport,
					port_entity.protoType == PROTO_UDP ? "UDP" : "TCP");
		}
	}
}

// Mason Yu
int setupPortFW(void)
{
	int vInt, i, total;
	unsigned char value[32];
	MIB_CE_PORT_FW_T PfEntry;

	// Clean all rules
	// iptables -F portfw
	va_cmd(IPTABLES, 2, 1, "-F", (char *)PORT_FW);
	// iptables -t nat -F portfw
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-F", (char *)PORT_FW);

#ifdef CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_Vertual_Server();
#endif

	vInt = 0;
	if (mib_get(MIB_PORT_FW_ENABLE, (void *)value) != 0)
		vInt = (int)(*(unsigned char *)value);

	if (vInt == 1)
	{
		int negate=0, hasRemote=0;
		char * proto = 0;
		char intPort[32], extPort[32];

		total = mib_chain_total(MIB_PORT_FW_TBL);

		for (i = 0; i < total; i++)
		{
			if (!mib_chain_get(MIB_PORT_FW_TBL, i, (void *)&PfEntry))
				return -1;
			if (PfEntry.dynamic == 1)
				continue;
#ifdef CONFIG_RTK_L34_ENABLE
			RTK_RG_Vertual_Server_Set(&PfEntry);
#endif
			portfw_modify( &PfEntry, 0 );
		}
	}//if (vInt == 1)

	return 1;
}
#endif

#ifdef PORT_FORWARD_ADVANCE
static int setupPFWAdvance(void)
{
	// iptables -N pptp
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_PPTP);
	// iptables -A FORWARD -j pptp
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_PPTP);
	// iptables -t nat -N pptp
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)FW_PPTP);
	// iptables -t nat -A PREROUTING -j pptp
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)FW_PPTP);


	// iptables -N l2tp
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_L2TP);
	// iptables -A FORWARD -j l2tp
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_L2TP);
	// iptables -t nat -N l2tp
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)FW_L2TP);
	// iptables -t nat -A PREROUTING -j l2tp
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)FW_L2TP);

	config_PFWAdvance(ACT_START);

	return 0;
}

static int stopPFWAdvance(void)
{
	unsigned int entryNum, i;
	MIB_CE_PORT_FW_ADVANCE_T Entry;
	int pptp_enable=1;
	int l2tp_enable=1;

	entryNum = mib_chain_total(MIB_PFW_ADVANCE_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_PFW_ADVANCE_TBL, i, (void *)&Entry))
		{
  			printf("stopPFWAdvance: Get chain record error!\n");
			return 1;
		}

		if ( strcmp("PPTP", PFW_Rule[(PFW_RULE_T)Entry.rule]) == 0 && pptp_enable == 1) {
			// iptables -F pptp
			va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_PPTP);
			// iptables -t nat -F pptp
			va_cmd(IPTABLES, 4, 1, "-t", "nat", "-F", (char *)FW_PPTP);
			pptp_enable = 0;
		}

		if ( strcmp("L2TP", PFW_Rule[(PFW_RULE_T)Entry.rule]) == 0 && l2tp_enable == 1) {
			// iptables -F l2tp
			va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_L2TP);
			// iptables -t nat -F l2tp
			va_cmd(IPTABLES, 4, 1, "-t", "nat", "-F", (char *)FW_L2TP);
			l2tp_enable = 0;
		}
	}
	return 0;
}

static int startPFWAdvance(void)
{
	unsigned int entryNum, i;
	MIB_CE_PORT_FW_ADVANCE_T Entry;
	char interface_name[IFNAMSIZ], lanIP[16], ip_port[32];
	struct in_addr dest;
	int pf_enable;
	unsigned char value[32];
	int pptp_enable=0;
	int l2tp_enable=0;

	entryNum = mib_chain_total(MIB_PFW_ADVANCE_TBL);


	pf_enable = 0;
	if (mib_get(MIB_PORT_FW_ENABLE, (void *)value) != 0)
		pf_enable = (int)(*(unsigned char *)value);

	if ( pf_enable != 1 ) {
		printf("Port Forwarding is disable and stop to setup Port Forwarding Advance!\n");
		return 1;
	}

	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_PFW_ADVANCE_TBL, i, (void *)&Entry))
		{
  			printf("startPFWAdvance: Get chain record error!\n");
			return 1;
		}

		if ( strcmp("PPTP", PFW_Rule[(PFW_RULE_T)Entry.rule]) == 0 && pptp_enable == 0) {
			// LAN IP Address
			dest.s_addr = *(unsigned long *)Entry.ipAddr;
			// inet_ntoa is not reentrant, we have to
			// copy the static memory before reuse it
			strcpy(lanIP, inet_ntoa(dest));
			lanIP[15] = '\0';
			sprintf(ip_port,"%s:%d",lanIP, 1723);

			// interface

			// iptables -A pptp -p tcp --destination-port 1723 --dst $LANIP -j ACCEPT
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_PPTP, "-p", (char *)ARG_TCP, "--destination-port", "1723", "--dst", lanIP, "-j", (char *)FW_ACCEPT);

			// iptables -A pptp -p 47 --dst $LANIP -j ACCEPT
			va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_PPTP, "-p", "47", "--dst", lanIP, "-j", (char *)FW_ACCEPT);


			if (ifGetName(Entry.ifIndex, interface_name, sizeof(interface_name))) {
				// iptables -t nat -A pptp -i ppp0 -p tcp --dport 1723 -j DNAT --to-destination $LANIP:1723
				va_cmd(IPTABLES, 14, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PPTP, "-i", interface_name, "-p", (char *)ARG_TCP, "--dport", "1723", "-j", "DNAT", "--to-destination", ip_port);

				// iptables -t nat -A pptp -i ppp0 -p 47 -j DNAT --to-destination $LANIP
				va_cmd(IPTABLES, 12, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PPTP, "-i", interface_name, "-p", "47", "-j", "DNAT", "--to-destination", lanIP);
			} else {
				// iptables -t nat -A pptp -p tcp --dport 1723 -j DNAT --to-destination $LANIP:1723
				va_cmd(IPTABLES, 12, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PPTP, "-p", (char *)ARG_TCP, "--dport", "1723", "-j", "DNAT", "--to-destination", ip_port);

				// iptables -t nat -A pptp -p 47 -j DNAT --to-destination $LANIP
				va_cmd(IPTABLES, 10, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PPTP, "-p", "47", "-j", "DNAT", "--to-destination", lanIP);
			}
			pptp_enable = 1;
		}

		if ( strcmp("L2TP", PFW_Rule[(PFW_RULE_T)Entry.rule]) == 0 && l2tp_enable == 0) {
			// LAN IP Address
			dest.s_addr = *(unsigned long *)Entry.ipAddr;
			// inet_ntoa is not reentrant, we have to
			// copy the static memory before reuse it
			strcpy(lanIP, inet_ntoa(dest));
			lanIP[15] = '\0';
			sprintf(ip_port,"%s:%d",lanIP, 1701);

			// interface

			// iptables -A l2tp -p udp --destination-port 1701 --dst $LANIP -j ACCEPT
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_L2TP, "-p", (char *)ARG_UDP, "--destination-port", "1701", "--dst", lanIP, "-j", (char *)FW_ACCEPT);

			// iptables -t nat -A l2tp -i ppp0 -p udp --dport 1701 -j DNAT --to-destination $LANIP:1701
			if (!ifGetName(Entry.ifIndex, interface_name, sizeof(interface_name))) {
				va_cmd(IPTABLES, 12, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_L2TP, "-p", (char *)ARG_UDP, "--dport", "1701", "-j", "DNAT", "--to-destination", ip_port);
			} else {
				va_cmd(IPTABLES, 14, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_L2TP, "-i", interface_name, "-p", (char *)ARG_UDP, "--dport", "1701", "-j", "DNAT", "--to-destination", ip_port);
			}
			l2tp_enable = 1;
		}
	}
	return 0;
}
#endif

static void clearDMZ(void)
{
	// iptables -F dmz
	va_cmd(IPTABLES, 2, 1, "-F", (char *)IPTABLE_DMZ);
	// iptables -t nat -F dmz
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-F", (char *)IPTABLE_DMZ);
}

static void setDMZ(char *ip)
{
	//snmp don't forward to DMZ
	// iptables -t nat -A dmz -i ! $LAN_IF -p UDP --dport 161:162 -j ACCEPT
	va_cmd(IPTABLES, 13, 1, "-t", "nat", (char *)FW_ADD, (char *)IPTABLE_DMZ, "!", (char *)ARG_I,
		(char *)LANIF, "-p", (char *)ARG_UDP, (char *)FW_DPORT, "161:162", "-j", (char *)FW_ACCEPT);
	// iptables -t nat -A dmz -i ! $LAN_IF -p UDP --dport 9000:9050 -j ACCEPT
	va_cmd(IPTABLES, 13, 1, "-t", "nat", (char *)FW_ADD, (char *)IPTABLE_DMZ, "!", (char *)ARG_I,
		(char *)LANIF, "-p", (char *)ARG_UDP, (char *)FW_DPORT, "9000:9050", "-j", (char *)FW_ACCEPT);
#ifdef _CWMP_MIB_
	va_cmd(IPTABLES, 13, 1, "-t", "nat", (char *)FW_ADD, (char *)IPTABLE_DMZ, "!", (char *)ARG_I,
		(char *)LANIF, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "9999", "-j", (char *)FW_ACCEPT);
#endif
	// Kaohj -- Multicast not involved
	// iptables -t nat -A dmz -i ! $LAN_IF -d 224.0.0.0/4 -j ACCEPT
	va_cmd(IPTABLES, 11, 1, "-t", "nat", (char *)FW_ADD, (char *)IPTABLE_DMZ, "!", (char *)ARG_I,
		(char *)LANIF, "-d", "224.0.0.0/4", "-j", (char *)FW_ACCEPT);
	// Remote access not go DMZ
	va_cmd(IPTABLES, 13, 1, "-t", "nat", (char *)FW_ADD, (char *)IPTABLE_DMZ, "!", (char *)ARG_I,
		(char *)LANIF, "-m", "mark", "--mark", RMACC_MARK, "-j", FW_RETURN);
#if defined(CONFIG_VIRTUAL_WLAN_DRIVER) && defined(CONFIG_SLAVE_WLAN1_ENABLE)
	va_cmd(IPTABLES, 8, 1, "-t", "nat", (char *)FW_ADD, (char *)IPTABLE_DMZ, (char *)ARG_I,
		"vwlan", "-j", (char *)FW_ACCEPT);
#endif
	// iptables -t nat -A dmz -i ! $LAN_IF -j DNAT --to-destination $DMZ_IP
	va_cmd(IPTABLES, 11, 1, "-t", "nat", (char *)FW_ADD, (char *)IPTABLE_DMZ, "!", (char *)ARG_I,
		(char *)LANIF, "-j", "DNAT", "--to-destination", ip);
	// iptables -A dmz -i ! $LAN_IF -o $LAN_IF -d $DMZ_IP -j ACCEPT
	va_cmd(IPTABLES, 11, 1, (char *)FW_ADD, (char *)IPTABLE_DMZ, "!", (char *)ARG_I,
		(char *)LANIF, (char *)ARG_O, (char *)LANIF, "-d", ip, "-j", (char *)FW_ACCEPT);
}

// Mason Yu
int setupDMZ(int isBoot)
{
	int vInt;
	unsigned char value[32];
	char ipaddr[32];

	clearDMZ();

	vInt = 0;
	if (mib_get(MIB_DMZ_ENABLE, (void *)value) != 0)
		vInt = (int)(*(unsigned char *)value);

	if (mib_get(MIB_DMZ_IP, (void *)value) != 0)
	{
#ifdef CONFIG_RTK_L34_ENABLE
		RTK_RG_DMZ_Set(vInt, *(in_addr_t *)&value, isBoot);
#endif

		if (vInt == 1)
		{
			strncpy(ipaddr, inet_ntoa(*((struct in_addr *)value)), 16);
			ipaddr[15] = '\0';
			setDMZ(ipaddr);
		}
	}
}

#ifdef NATIP_FORWARDING
static void fw_setupIPForwarding(void)
{
	int i, total;
	char local[16], remote[16], enable;
	MIB_CE_IP_FW_T Entry;

	// Add New chain on filter and nat
	// iptables -N ipfw
	va_cmd(IPTABLES, 2, 1, "-N", (char *)IPTABLE_IPFW);
	// iptables -A FORWARD -j ipfw
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)IPTABLE_IPFW);
	// iptables -t nat -N ipfw
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)IPTABLE_IPFW);
	// iptables -t nat -A PREROUTING -j ipfw
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)IPTABLE_IPFW);
	// iptables -t nat -N ipfw2
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)IPTABLE_IPFW2);
	// iptables -t nat -A POSTROUTING -j ipfw2
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_POSTROUTING, "-j", (char *)IPTABLE_IPFW2);


	mib_get(MIB_IP_FW_ENABLE, (void *)&enable);
	if (!enable)
		return;

	total = mib_chain_total(MIB_IP_FW_TBL);
	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_IP_FW_TBL, i, (void *)&Entry))
			continue;
		strncpy(local, inet_ntoa(*((struct in_addr *)Entry.local_ip)), 16);
		strncpy(remote, inet_ntoa(*((struct in_addr *)Entry.remote_ip)), 16);
		// iptables -t nat -A ipfw -d remoteip -i ! $LAN_IF -j DNAT --to-destination localip
		va_cmd(IPTABLES, 13, 1, "-t", "nat",
			(char *)FW_ADD,	(char *)IPTABLE_IPFW, "-d", remote,
			 "!", (char *)ARG_I, (char *)LANIF, "-j",
			"DNAT", "--to-destination", local);
		// iptables -t nat -A ipfw2 -s localip -o ! br0 -j SNAT --to-source remoteip
		va_cmd(IPTABLES, 13, 1, "-t", "nat", FW_ADD, (char *)IPTABLE_IPFW2,

			(char *)ARG_O, "!", (char *)LANIF, "-s", local, "-j", "SNAT", "--to-source", remote);

		// iptables -A ipfw2 -d localip -i ! $LAN_IF -o $LAN_IF -j RETURN
		va_cmd(IPTABLES, 11, 1, (char *)FW_ADD,
			(char *)IPTABLE_IPFW, "-d", local, "!", (char *)ARG_I,
			(char *)LANIF, (char *)ARG_O,
			(char *)LANIF, "-j", (char *)FW_ACCEPT);
	}
}
#endif

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
static int setup_default_IPFilter(void)
{
	// Set default action for ipfilter
	unsigned char action = 1;	//0: drop (white list), 1: return (black list)
	unsigned char in_enable = 0, out_enable = 0;

	mib_get(MIB_IPFILTER_IN_ENABLE, (void*)&in_enable);
	mib_get(MIB_IPFILTER_OUT_ENABLE, (void*)&out_enable);

	mib_get(MIB_IPF_OUT_ACTION, (void *)&action);
	if(out_enable && action == 0)
	{
		// iptables -A ipfilter_out -j DROP
		va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_IPFILTER_OUT, "-j", (char *)FW_DROP);
	}

	mib_get(MIB_IPF_IN_ACTION, (void *)&action);
	if(in_enable && action == 0)
	{
		// iptables -A ipfilter_in -j DROP
		va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_IPFILTER_IN, "-j", (char *)FW_DROP);
	}

	return 1;
}
#else
static int setup_default_IPFilter(void)
{
	// Set default action for ipfilter
	unsigned char value[32];
	int vInt;
	unsigned char ipportfilter_state;

	mib_get(MIB_IPFILTER_ON_OFF, (void*)&ipportfilter_state);

	if(ipportfilter_state == 0) return 0;

	if (mib_get(MIB_IPF_OUT_ACTION, (void *)value) != 0)
	{
		vInt = (int)(*(unsigned char *)value);

		if (vInt == 0)	// DROP
		{
			// iptables -A ipfilter -i $LAN_IF -j DROP
			va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_IPFILTER, (char *)ARG_I, (char *)LANIF, "-j", (char *)FW_DROP);
		}
	}

	if (mib_get(MIB_IPF_IN_ACTION, (void *)value) != 0)
	{
		vInt = (int)(*(unsigned char *)value);

		if (vInt == 0)	// DROP
		{
			// iptables -A ipfilter -i ! $LAN_IF -j DROP
				va_cmd(IPTABLES, 7, 1, (char *)FW_ADD, (char *)FW_IPFILTER, "!", (char *)ARG_I, (char *)LANIF, "-j", (char *)FW_DROP);
		}
	}

	return 1;
}
#endif

#ifdef CONFIG_RTK_L34_ENABLE
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
static int setup_RG_IPPort_Filter_Default_Policy()
{
	unsigned char in_policy = 1, out_policy = 1;
	unsigned char in_enable = 0, out_enable = 0;

	mib_get(MIB_IPFILTER_IN_ENABLE, (void*)&in_enable);
	mib_get(MIB_IPFILTER_OUT_ENABLE, (void*)&out_enable);

	mib_get(MIB_IPF_OUT_ACTION, &out_policy);
	if(!out_enable)
		out_policy = 1;

	mib_get(MIB_IPF_IN_ACTION, &in_policy);
	if(!in_enable)
		in_policy = 1;

	RTK_RG_ACL_IPPort_Filter_Default_Policy(out_policy, in_policy);
}
#else
static int setup_RG_IPPort_Filter_Default_Policy()
{
	char vChar;
	int in_policy=0, out_policy=1;
	unsigned char ipportfilter_state;

	mib_get(MIB_IPFILTER_ON_OFF, (void*)&ipportfilter_state);

	if(ipportfilter_state == 0) return 0;

	if (mib_get(MIB_IPF_OUT_ACTION, &vChar) != 0)
		out_policy = vChar;

	if (mib_get(MIB_IPF_IN_ACTION, &vChar) != 0)
		in_policy = vChar;

	RTK_RG_ACL_IPPort_Filter_Default_Policy(out_policy, in_policy);

	return 1;
}
#endif
#endif

#ifdef CONFIG_LED_INDICATOR_TIMER
/**
 * interface for dbus
 * return:
 *	0:	success
 * 	-1:	failed
 */
int setLedIndicator(unsigned char enable, unsigned char ctlCycle, unsigned char startHour,
	unsigned char startMin, unsigned char endHour, unsigned char endMin)
{
	int i, totalEntry, index;
	MIB_CE_DAY_SCHED_T ledEntry;

	memset(&ledEntry, 0, sizeof(ledEntry));
	ledEntry.enable = enable;
	ledEntry.ctlCycle = ctlCycle;
	ledEntry.startHour = startHour;
	ledEntry.startMin = startMin;
	ledEntry.endHour = endHour;
	ledEntry.endMin = endMin;

	totalEntry = mib_chain_total(MIB_LED_INDICATOR_TIMER_TBL);
	if(0 != totalEntry)
	{
		if (!mib_chain_update(MIB_LED_INDICATOR_TIMER_TBL, (void *)&ledEntry, 0))
		{
			printf("[%s %d]mib_chain_update failed.\n", __func__, __LINE__);
			return -1;
		}
	}
	else
	{
		if(!mib_chain_add(MIB_LED_INDICATOR_TIMER_TBL, (void *)&ledEntry))
		{
			printf("[%s %d]mib_chain_add_failed\n", __func__, __LINE__);
			return -1;
		}
	}

#ifdef COMMIT_IMMEDIATELY
	Commit();
#endif

	updateScheduleCrondFile("/var/spool/cron/crontabs", 0);

	return 0;
}
#endif

#ifdef CONFIG_RG_SLEEPMODE_TIMER
int get_sleepmode_state(void)
{
        unsigned char state = 0;

        if (!mib_get(MIB_RG_SLEEPMODE_ENABLE, (void *)&state))
        {
                printf("ERROR: Get sleepmode_state from MIB database failed.\n");
                return -1;
        }

        return state;
}
#endif


#ifdef CONFIG_LED_INDICATOR_TIMER
int get_ledctrl_state(void)
{
        unsigned char state = 0;

        if (!mib_get(MIB_LED_STATUS, (void *)&state))
        {
                printf("ERROR: Get LED status from MIB database failed.\n");
                return -1;
        }

        return state;
}
#endif

#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_) || defined(_PRMT_X_CT_COM_WirelessTestDiagnostics_)
//#ifdef _PRMT_X_CT_COM_WirelessTestDiagnostics_
enum
{
	eWirelessTest_None=0,
	eWirelessTest_Requested,
	eWirelessTest_Completed,
	
	eWirelessTest_Error_InitConnectionFailed,
	eWirelessTest_Error_NoResponse,
	eWirelessTest_Error_TransferFailed,
	eWirelessTest_Error_Timeout,
	
	eWirelessTest_End /*last one*/
};
//#endif

int getAllWirelessChannelOnce(void)
{
	unsigned char res;
	int wait_time;
	int status;
	char tmpBuf[100];
	int bssdb_idx;
	static SS_STATUS_T Status={0};
	FILE *fp_tmp = NULL;
		
	// issue scan request
	wait_time = 0;
	while (1) 
	{
		if ( getWlSiteSurveyRequest(getWlanIfName(),  &status) < 0 ) 
		{
			printf("Site-survey request failed!");
			return -eWirelessTest_Error_NoResponse;
		}
		if (status != 0)
		{	
			if (wait_time++ > 5) 
			{
				printf("scan request timeout!");
				return -eWirelessTest_Error_Timeout;
			}
			sleep(1);
		}
		else
			break;
	}
	
		// wait until scan completely
	wait_time = 0;
	while (1) 
	{
		Status.number=0;
		if ( getWlSiteSurveyResult(getWlanIfName(), (SS_STATUS_Tp)&Status) < 0 ) 
		{
			strcpy(tmpBuf, "Read site-survey status failed!");
			return -eWirelessTest_Error_TransferFailed;
		}
		if (Status.number == 0xff) 
		{   
			if (wait_time++ > 10) 
			{
				printf("scan timeout!");
				return -eWirelessTest_Error_Timeout;
			}
			sleep(1);
		}
		else
			break;
	}
		
	if(!(fp_tmp = fopen("/var/wireless_neighbor_info", "w+")))
	{
		return -eWirelessTest_Error_TransferFailed;
	}
	
#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_AllWirelessChannelEnable_) || defined(_PRMT_X_CT_COM_WirelessTestDiagnostics_)
	int curChanIndex, chanIndex;
	unsigned int neighborNum[14] = {0};
	for(bssdb_idx=0 ; bssdb_idx<Status.number ; bssdb_idx++)
	{
		curChanIndex = Status.bssdb[bssdb_idx].channel;
		if(curChanIndex > 13)
		{
			continue;
		}
				
			neighborNum[curChanIndex]++;
	}
			
	for(chanIndex=1 ; chanIndex<14 ; chanIndex++)
	{
		if(neighborNum[chanIndex])
		{
			fprintf(fp_tmp, "%d:%d+", chanIndex, neighborNum[chanIndex]);
		}
	}
#endif
#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_BestWirelessChannelEnable_) || defined(_PRMT_X_CT_COM_WirelessTestDiagnostics_)
	fprintf(fp_tmp, "##%d+%d", Status.bssdb[0].channel, Status.bssdb[0].rssi-100);
#endif
	fclose(fp_tmp);			
	return 0;		
}
#endif

#if defined(WIFI_TIMER_SCHEDULE) || defined(CONFIG_LED_INDICATOR_TIMER) || defined(CONFIG_RG_SLEEPMODE_TIMER)
void updateScheduleCrondFile(char *pathname, int startup)
{
	char *strVal;
	int totalnum, i, j, first, crond_pid;
	FILE *fp, *getPIDS;
	char tmpbuf[100], day_string[20], kill_cmd[100], filename[100];
#ifdef WIFI_TIMER_SCHEDULE
	MIB_CE_WIFI_TIMER_EX_T Entry_ex;
	MIB_CE_WIFI_TIMER_T Entry;
	unsigned char startHour, startMinute, endHour, endMinute;
#endif
#ifdef CONFIG_LED_INDICATOR_TIMER
	MIB_CE_DAY_SCHED_T ledEntry;
#endif
#ifdef CONFIG_RG_SLEEPMODE_TIMER
	MIB_CE_RG_SLEEPMODE_SCHED_T sleepEntry;
#endif
	int schedFileExist = 0;
	char site_survey_time; // minute
	char guest_ssid; // ssid_index
	int guest_ssid_duration;
	int guestSSIDExist=0;
	unsigned long guest_ssid_endtime;

	if(startup){
		snprintf(tmpbuf, 100, "mkdir -p %s", pathname);
		system(tmpbuf);
#ifdef WLAN_CLIENT
		getSiteSurveyWlanNeighborAsync(0);
#ifdef WLAN_DUALBAND_CONCURRENT
		getSiteSurveyWlanNeighborAsync(1);
#endif
#endif
	}
	if ( !mib_get(MIB_SUSER_NAME, (void *)tmpbuf) ) {
		printf("ERROR: Get superuser name from MIB database failed.\n");
		return;
	}
	snprintf(filename, 100, "%s/%s", pathname, tmpbuf);

	crond_pid = read_pid("/var/run/crond.pid");
	if(crond_pid > 0){
		kill(crond_pid, 9);
		unlink("/var/run/crond.pid");
	}

	fp = fopen(filename, "w");
    if (fp == NULL)
    {
        printf("ERROR: error to file open %s .\n", filename);
        return;
    }

#ifdef WIFI_TIMER_SCHEDULE
	totalnum = mib_chain_total(MIB_WIFI_TIMER_EX_TBL);
	for(i=0; i<totalnum; i++){
		mib_chain_get(MIB_WIFI_TIMER_EX_TBL, i, &Entry_ex);

		first = 1;
		if(Entry_ex.day & (1<<7)){
			if(first){
				snprintf(day_string, 20, "0");
				first = 0;
			}
			else
				snprintf(day_string, 20,"%s,0", day_string);
		}
		for(j=1;j<7;j++){
			if(Entry_ex.day & (1<<j)){
				if(first){
					snprintf(day_string, 20, "%d", j);
					first = 0;
				}
				else
					snprintf(day_string, 20,"%s,%d", day_string, j);
			}
		}
		if(Entry_ex.enable){
			sscanf(Entry_ex.Time, "%hhu:%hhu", &startHour, &startMinute);
			snprintf(tmpbuf, 100, "%hhu %hhu * * %s /bin/config_wlan %d %u\n", startMinute, startHour, day_string, Entry_ex.onoff, Entry_ex.SSIDMask);
			fputs(tmpbuf,fp);
			if(schedFileExist == 0)
				schedFileExist = 1;
		}
	}

	totalnum = mib_chain_total(MIB_WIFI_TIMER_TBL);
	for(i=0; i<totalnum; i++){
		mib_chain_get(MIB_WIFI_TIMER_TBL, i, &Entry);
		if(Entry.enable){
			sscanf(Entry.startTime, "%hhu:%hhu", &startHour, &startMinute);
			snprintf(tmpbuf, 100, "%hhu %hhu */%hhu * * /bin/config_wlan 1 %u\n", startMinute, startHour, Entry.controlCycle, Entry.SSIDMask);
			fputs(tmpbuf,fp);
			sscanf(Entry.endTime, "%hhu:%hhu", &endHour, &endMinute);
			snprintf(tmpbuf, 100, "%hhu %hhu */%hhu * * /bin/config_wlan 0 %u\n", endMinute, endHour, Entry.controlCycle, Entry.SSIDMask);
			fputs(tmpbuf,fp);
			if(schedFileExist == 0)
				schedFileExist = 1;
		}
	}
#endif

#ifdef CONFIG_LED_INDICATOR_TIMER
	totalnum = mib_chain_total(MIB_LED_INDICATOR_TIMER_TBL);
	for(i=0; i<totalnum; i++)
	{
		mib_chain_get(MIB_LED_INDICATOR_TIMER_TBL, i, &ledEntry);
		if(ledEntry.enable)
		{
			//set initial state.
			time_t curTime;
			struct tm curTm;
			int curState = 0;

			time(&curTime);
			memcpy(&curTm, localtime(&curTime), sizeof(curTm));
			if(ledEntry.startHour == ledEntry.endHour)
			{
				if((curTm.tm_hour == ledEntry.startHour)
					&& (ledEntry.startMin <= curTm.tm_min) && (ledEntry.endMin > curTm.tm_min))
				{
					curState = 1;
				}
			}
			else if((ledEntry.startHour <= curTm.tm_hour) && (ledEntry.endHour >= curTm.tm_hour))
			{
				if((ledEntry.startHour == curTm.tm_hour) && (ledEntry.startMin <= curTm.tm_min))
				{
					curState = 1;
				}
				else if((ledEntry.endHour == curTm.tm_hour) && (ledEntry.endMin > curTm.tm_min))
				{
					curState = 1;
				}
				else if((ledEntry.startHour < curTm.tm_hour) && (ledEntry.endHour > curTm.tm_hour))
				{
					curState = 1;
				}
			}
			if(1 == curState)
			{
				system("/bin/config_led 1");
			}
			else
			{
				system("/bin/config_led 0");
			}
			snprintf(tmpbuf, 100, "%hhu %hhu */%hhu * * /bin/config_led 1\n", ledEntry.startMin, ledEntry.startHour, ledEntry.ctlCycle);
			fputs(tmpbuf,fp);
			snprintf(tmpbuf, 100, "%hhu %hhu */%hhu * * /bin/config_led 0\n", ledEntry.endMin, ledEntry.endHour, ledEntry.ctlCycle);
			fputs(tmpbuf,fp);
			if(schedFileExist == 0)
				schedFileExist = 1;
		}
	}
#endif

#ifdef CONFIG_RG_SLEEPMODE_TIMER
	totalnum = mib_chain_total(MIB_SLEEP_MODE_SCHED_TBL);
	for(i=0; i<totalnum; i++)
	{
		mib_chain_get(MIB_SLEEP_MODE_SCHED_TBL, i, &sleepEntry);
		if(1 == sleepEntry.day)
		{
			if(startup == 0 /*|| (startup==1 && sleepEntry.onoff==1) */)
			{
				//action rightnow!
				snprintf(tmpbuf, 100, "/bin/config_sleepmode %d", sleepEntry.onoff);
				system(tmpbuf);
			}
		}
		else if(sleepEntry.enable)
		{
		#if 0
			if(1 == sleepEntry.day)
			{
				//action rightnow!
				snprintf(tmpbuf, 100, "/bin/config_sleepmode %d", sleepEntry.onoff);
				system(tmpbuf);
			}
			else
		#endif
			{
				first = 1;
				if(sleepEntry.day & (1<<7)){
					if(first){
						snprintf(day_string, 20, "0");
						first = 0;
					}
					else
						snprintf(day_string, 20,"%s,0", day_string);
				}
				for(j=1;j<7;j++){
					if(sleepEntry.day & (1<<j)){
						if(first){
							snprintf(day_string, 20, "%d", j);
							first = 0;
						}
						else
							snprintf(day_string, 20,"%s,%d", day_string, j);
					}
				}
				//printf("[%s %d]day_string=%s\n", __func__, __LINE__, day_string);
				snprintf(tmpbuf, 100, "%hhu %hhu * * %s /bin/config_sleepmode %d\n", sleepEntry.minute, sleepEntry.hour, day_string, sleepEntry.onoff);
				//printf("[%s %d]tmpbuf=%s\n", __func__, __LINE__, tmpbuf);
				fputs(tmpbuf,fp);

				if(schedFileExist == 0)
					schedFileExist = 1;
			}
		}
	}
#endif

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	int wlanIndex;
#ifdef WLAN_CLIENT
	mib_get(MIB_WLAN_SITE_SURVEY_TIME, (void *)&site_survey_time);
	if(site_survey_time)
	{
		snprintf(tmpbuf, 100, "*/%d * * * * /bin/SiteSurveyWLANNeighbor 0\n", site_survey_time);
		fputs(tmpbuf,fp);
#ifdef WLAN_DUALBAND_CONCURRENT
		snprintf(tmpbuf, 100, "*/%d * * * * /bin/SiteSurveyWLANNeighbor 1\n", site_survey_time);
		fputs(tmpbuf,fp);
#endif
		if(schedFileExist == 0)
			schedFileExist = 1;
	}
#endif

	for(i=0 ; i<NUM_WLAN_INTERFACE ; i++)
	{			
		wlanIndex=i;
		mib_local_mapping_get(MIB_WLAN_GUEST_SSID, wlanIndex, (void *)&guest_ssid);
		mib_local_mapping_get(MIB_WLAN_GUEST_SSID_DURATION, wlanIndex, (void *)&guest_ssid_duration);
		mib_local_mapping_get(MIB_WLAN_GUEST_SSID_ENDTIME, wlanIndex, (void *)&guest_ssid_endtime);
		if(guest_ssid && guest_ssid_duration && guest_ssid_endtime) {
			char ifname[16], timeStrBuf[200];
			struct tm tm_time;
			time_t tm;	
			tm = guest_ssid_endtime;
			memcpy(&tm_time, localtime(&tm), sizeof(tm_time));
			strftime(timeStrBuf, 200, "%M %H %d %m %w", &tm_time);	
			get_ifname_by_ssid_index(guest_ssid, ifname);
			snprintf(tmpbuf, 100, "%s /bin/iwpriv %s set_mib func_off=1\n", timeStrBuf, ifname);
			fputs(tmpbuf,fp);
			if(schedFileExist == 0)
				schedFileExist = 1;
		}
	}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_
	unsigned char scWlanScan = 0;
	mib_get(PROVINCE_SICHUAN_WLAN_SURVEY_TIME, &scWlanScan);
	if(scWlanScan)
	{
		snprintf(tmpbuf, 100, "*/%d * * * * /bin/ShowWirelessChannel all\n", scWlanScan);		
		fputs(tmpbuf,fp);
		if(schedFileExist == 0)
		{
			schedFileExist = 1; 	
		}
	}
#endif


    if (fp != NULL)
	fclose(fp);

	if(schedFileExist) {
		// file is not empty
		va_niced_cmd("/bin/crond", 0, 1);
	}
	else
		unlink(filename);
}
#endif



int restart_IPFilter_DMZ_MACFilter(void)
{
	setupIPFilter();
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	// iptables -A filter_in -j dmz
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_IPFILTER_IN, "-j", (char *)IPTABLE_DMZ);
#else
	// iptables -A filter -j dmz
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_IPFILTER, "-j", (char *)IPTABLE_DMZ);
#endif
	setup_default_IPFilter();
	//setupMacFilter();
#ifndef MAC_FILTER_SRC_ONLY
	setupMacFilterEbtables();
#endif
	setupMacFilterTables();
#ifdef CONFIG_IPV6
	restart_IPV6Filter();
#endif
#ifdef CONFIG_RTK_L34_ENABLE
	setup_RG_IPPort_Filter_Default_Policy();
#endif
	return 1;
}

#ifdef PORT_TRIGGERING
static void parse_and_add_triggerPort(char *inRange, PROTO_TYPE_T prot, char *ip)
{
	int parseLen, j;
	char tempStr1[10]={0},tempStr2[10]={0};
	char *p, dstPortRange[32];
	int idx=0,shift=0;

	parseLen = strlen(inRange);
	if (prot == PROTO_TCP)
		p = (char *)ARG_TCP;
	else
		p = (char *)ARG_UDP;

	for(j=0;j<GAMING_MAX_RANGE;j++)
	{
		if(((inRange[j]>='0')&&(inRange[j]<='9')))
		{
			if(shift>=9) continue;
			if(idx==0)
				tempStr1[shift++]=inRange[j];
			else
				tempStr2[shift++]=inRange[j];

		}
		else if((inRange[j]==',')||
				(inRange[j]=='-')||
				(inRange[j]==0))
		{
			if(idx==0)
				tempStr1[shift]=0;
			else
				tempStr2[shift]=0;

			shift=0;
			if((inRange[j]==',')||
				(inRange[j]==0))
			{
				/*
				uint16 inStart,inFinish;
				inStart=atoi(tempStr1);
				if(idx==0)
					inFinish=inStart;
				else
					inFinish=atoi(tempStr2);
				*/
				dstPortRange[0] = '\0';
				if (idx==0) // single port number
					strncpy(dstPortRange, tempStr1, 32);
				else {
					if (strlen(tempStr1)!=0 && strlen(tempStr2)!=0)
						snprintf(dstPortRange, 32, "%s:%s", tempStr1, tempStr2);
				}

				idx=0;

				// iptables -t nat -A PREROUTING -i ! $LAN_IF -p TCP --dport dstPortRange -j DNAT --to-destination ipaddr
				va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)FW_ADD,	(char *)IPTABLES_PORTTRIGGER,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", p,
					(char *)FW_DPORT, dstPortRange, "-j",
					"DNAT", "--to-destination", ip);

				// iptables -I ipfilter 3 -i ! $LAN_IF -o $LAN_IF -p TCP --dport dstPortRange -j RETURN
				va_cmd(IPTABLES, 13, 1, (char *)FW_ADD,
					(char *)IPTABLES_PORTTRIGGER, "!", (char *)ARG_I,
					(char *)LANIF, (char *)ARG_O,
					(char *)LANIF, "-p", p,
					(char *)FW_DPORT, dstPortRange, "-j",
					(char *)FW_ACCEPT);
				/*
				//make inFinish always bigger than inStart
				if(inStart>inFinish)
				{
					uint16 temp;
					temp=inFinish;
					inFinish=inStart;
					inStart=temp;
				}

				if(!((inStart==0)||(inFinish==0)))
				{
					rtl8651a_addTriggerPortRule(
					dsid, //dsid
					inType,inStart,inFinish,
					outType,
					outStart,
					outFinish,localIp);
//					printf("inRange=%d-%d\n inType=%d\n",inStart,inFinish,inType);
				}
				*/
			}
			else
			{
				idx++;
			}
			if(inRange[j]==0)
				break;
		}
	}
}

static void setupPortTriggering(void)
{
	int i, total;
	char ipaddr[16];
	MIB_CE_PORT_TRG_T Entry;

	total = mib_chain_total(MIB_PORT_TRG_TBL);
	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_PORT_TRG_TBL, i, (void *)&Entry))
			continue;
		if(!Entry.enable)
			continue;

		strncpy(ipaddr, inet_ntoa(*((struct in_addr *)Entry.ip)), 16);

		parse_and_add_triggerPort(Entry.tcpRange, PROTO_TCP, ipaddr);
		parse_and_add_triggerPort(Entry.udpRange, PROTO_UDP, ipaddr);
	}
}
#endif // of PORT_TRIGGERING

/*
 *	Setup TCPMSS for ppp in FORWARD chain
 */
static int filter_set_tcpmss(void)
{
	int i, total, min_mtu;
	char mmtu[5]="1492", mmtu_s[11];
	MIB_CE_ATM_VC_T Entry;

	min_mtu=1492;
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<total; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;
		if (Entry.enable == 0)
			continue;
		if(min_mtu > Entry.mtu)
			min_mtu = Entry.mtu;
	}
	sprintf(mmtu, "%d", min_mtu-40);
	// Added by Mason Yu
	sprintf(mmtu_s, "%d:1536", min_mtu-40);

	// for PPPoE Black Hole
	// iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
	{ /* Since we should NOT modify the MSS of the inbound SYN packet, we should add this rule ONLY on PPP interface. */
		va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, (char *)FW_FORWARD,
			"-p", "tcp", "-o", "ppp+", "--tcp-flags", "SYN,RST", "SYN", "-j",
			"TCPMSS", "--clamp-mss-to-pmtu");

		/* Because we don't want to change the br0's MTU, thus, we must patch ISP's MSS on the inbound packet. */
//		va_cmd(IPTABLES, 13, 1, (char *)FW_ADD, (char *)FW_FORWARD,
//			"-p", "tcp", "-i", "ppp+", "--tcp-flags", "SYN,RST", "SYN", "-j",
//			"TCPMSS", "--set-mss", "1452");

		// Mason Yu.
		// When the receive interface is ppp,
		// if the incoming packet's mss is greater than WAN's min mss, the incoming packet's mss must be changed to WAN's min mss,
		// if the incoming packet's mss is smaller than WAN's min mss, the incoming packet's mss need not be changed.
		va_cmd(IPTABLES, 17, 1, (char *)FW_ADD, (char *)FW_FORWARD,
			"-p", "tcp", "-i", "ppp+", "--tcp-flags", "SYN,RST", "SYN", "-m" , "tcpmss", "--mss", mmtu_s, "-j",
			"TCPMSS", "--set-mss", mmtu);
	}
}

// Execute firewall rules
// return value:
// 1  : successful
int setupFirewall(int isBoot)
{
	char *argv[20];
	unsigned char value[32];
	int vInt, i, total, vcNum;
	MIB_CE_IP_PORT_FILTER_T IpEntry;
#ifdef MAC_FILTER
	MIB_CE_MAC_FILTER_T MacEntry;
	char mac_in_dft, mac_out_dft;
	char eth_mac_ctrl=0, wlan_mac_ctrl=0;
#endif
	MIB_CE_ATM_VC_T Entry;
	char *policy, *filterSIP, *filterDIP, srcPortRange[12], dstPortRange[12];
	char ipaddr[32], srcip[20], dstip[20];
	char ifname[16], extra[32];
	char srcmacaddr[18], dstmacaddr[18];
#ifdef IP_PASSTHROUGH
	unsigned int ippt_itf;
#endif
	int spc_enable, spc_ip;
	// Added by Mason Yu for ACL
	unsigned char aclEnable, domainEnable;
	unsigned char dhcpvalue[32];
	unsigned char vChar;
	int dhcpmode;
	char str_vc[] = "vc0";
	// Added by Mason Yu for URL Blocking
#if defined( URL_BLOCKING_SUPPORT)||defined( URL_ALLOWING_SUPPORT)
	unsigned char urlEnable;
#endif
#ifdef NAT_CONN_LIMIT
	unsigned char connlimitEn;
#endif

#ifdef CONFIG_USER_BEHAVIOR_ANALYSIS
	unsigned char ba_enable = 0;
	mib_get(MIB_BA_ENABLE, &ba_enable);
#endif
#if defined(CONFIG_USER_PPTP_CLIENT_PPTP) && defined(CONFIG_USER_L2TPD_L2TPD)
	MIB_PPTP_T PPTPEntry;
	MIB_L2TP_T L2TPEntry;
#endif

#ifdef CONFIG_RTK_L34_ENABLE
	char sysbuf[128];
	//iptables -F
	//iptables -P INPUT ACCEPT
	sprintf(sysbuf,"/bin/echo 1 > /proc/sys/net/ipv4/ip_forward");
	printf("system(): %s\n",sysbuf);
	system(sysbuf);
#endif

	//-------------------------------------------------
	// Filter table
	//-------------------------------------------------
	//--------------- set policies --------------
	/* Move to end of this function because of ITMS interactive problem in An-Hui */
	// iptables -P INPUT DROP
	//va_cmd(IPTABLES, 3, 1, "-P", (char *)FW_INPUT, (char *)FW_DROP);

	// iptables -P FORWARD ACCEPT
	va_cmd(IPTABLES, 3, 1, "-P", (char *)FW_FORWARD, (char *)FW_ACCEPT);

	// accept related
	// iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-m", "state",
		"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_ACCEPT);

	// It must be in the beginning of FORWARD chain.
	filter_set_tcpmss();
#ifdef CONFIG_LUNA_DUAL_LINUX
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_INPUT, "-i", "vwlan", "-j", (char *)FW_ACCEPT);
#endif
	// Kaohj -- allowing RIP (in case of ACL blocking)
	// iptables -A INPUT -p udp --dport 520 -j ACCEPT
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p",
		"udp", (char *)FW_DPORT, "520", "-j", (char *)FW_ACCEPT);

	// Drop UPnP SSDP from the WAN side
	va_cmd(IPTABLES, 9, 1, (char *)FW_ADD, (char *)FW_INPUT, "!", (char *)ARG_I, (char *)LANIF, "-d", "239.255.255.250", "-j", (char *)FW_DROP);

	// Allowing multicast access, ie. IGMP, RIPv2
	// iptables -A INPUT -d 224.0.0.0/4 -j ACCEPT
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_INPUT, "-d",
		"224.0.0.0/4", "-j", (char *)FW_ACCEPT);
#ifdef IP_ACL
	//  Add Chain(aclblock) for ACL
	va_cmd(IPTABLES, 2, 1, "-N", "aclblock");
	mib_get(MIB_ACL_CAPABILITY, (void *)&aclEnable);
	if (aclEnable == 1)  // ACL Capability is enabled
		filter_set_acl(1);
	//iptables -A INPUT -j aclblock
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", "aclblock");
#endif

#ifdef NAT_CONN_LIMIT
	//Add Chain(connlimit) for NAT conn limit
	va_cmd(IPTABLES, 2, 1, "-N", "connlimit");

	mib_get(MIB_NAT_CONN_LIMIT, (void *)&connlimitEn);
	if (connlimitEn == 1)
		set_conn_limit();

	//iptables -A FORWARD -j connlimit
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", "connlimit");
#endif
#ifdef TCP_UDP_CONN_LIMIT
	//Add Chain(connlimit) for NAT conn limit
	va_cmd(IPTABLES, 2, 1, "-N", "connlimit");

	mib_get(MIB_CONNLIMIT_ENABLE, (void *)&vChar);
	if (vChar == 1)
		set_conn_limit();
	//iptables -A FORWARD -j connlimit
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", "connlimit");
#endif

#ifdef CONFIG_USER_RTK_VOIP
	voip_setup_iptable();
#endif

	// setup chain for wlan blocking
	va_cmd(EBTABLES, 4, 1, "-N", "wlan_block", "-P", "RETURN");
	va_cmd(EBTABLES, 4, 1, "-A", "FORWARD", "-j", "wlan_block");

#ifdef PPPOE_PASSTHROUGH
	//  W.H. Hung: Add Chain br_pppoe for bridged PPPoE
	va_cmd(EBTABLES, 2, 1, "-N", FW_BR_PPPOE);
	va_cmd(EBTABLES, 3, 1, "-P", FW_BR_PPPOE, "RETURN");
	va_cmd(EBTABLES, 4, 1, "-t", "broute", "-N", FW_BR_PPPOE);
	va_cmd(EBTABLES, 5, 1, "-t", "broute", "-P", FW_BR_PPPOE, "RETURN");
#ifdef CONFIG_USER_BEHAVIOR_ANALYSIS
/*
* FIXME: br_pppoe rules cannot work correctly. PPPoE traffic will be dropped if HWNAT is disabled.
* Remove these code if it is fixed.
*/
	if(!ba_enable)
#endif
	setupBrPppoe();
	// and to FORWORD chain
	va_cmd(EBTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", FW_BR_PPPOE);
	va_cmd(EBTABLES, 6, 1, "-t", "broute", (char *)FW_ADD, "BROUTING", "-j", FW_BR_PPPOE);
#endif

#ifdef DOMAIN_BLOCKING_SUPPORT
	//  Add Chain(domainblk) for ACL
	va_cmd(IPTABLES, 2, 1, "-N", "domainblk");
#ifdef CONFIG_IPV6
	va_cmd(IP6TABLES, 2, 1, "-N", "domainblk");
#endif
	mib_get(MIB_DOMAINBLK_CAPABILITY, (void *)&domainEnable);
	if (domainEnable == 1)  // Domain blocking Capability is enabled
		filter_set_domain(1);
	//iptables -A INPUT -j domainblk
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", "domainblk");
#ifdef CONFIG_IPV6
	va_cmd(IP6TABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", "domainblk");
#endif

	//iptables -A FORWARD -j domainblk
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", "domainblk");

	//iptables -A OUTPUT -j domainblk
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, "OUTPUT", "-j", "domainblk");
#endif

#ifdef IP_PASSTHROUGH
	// IP Passthrough, LAN access
	set_IPPT_LAN_access();
#endif

#ifdef CONFIG_USER_CWMP_TR069
	va_cmd(IPTABLES, 2, 1, "-N", (char *)IPTABLE_TR069);
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, "INPUT", "-j", (char *)IPTABLE_TR069);
	set_TR069_Firewall(1);
#endif

#ifdef CONFIG_MIDDLEWARE
	//setMidwareRouteFW(0);
#endif

#ifdef REMOTE_ACCESS_CTL
	// Add chain for remote access
	// iptables -N inacc
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_INACC);

	// iptables -t mangle -A PREROUTING -j inacc
	va_cmd(IPTABLES, 4, 1, ARG_T, "mangle", "-N", (char *)FW_INACC);

	// iptables -t mangle -A PREROUTING -j inacc
	va_cmd(IPTABLES, 6, 1, ARG_T, "mangle", "-A", (char *)FW_PREROUTING, "-j", FW_INACC);

#ifdef CONFIG_YUEME	
	va_cmd(IPTABLES, 11, 1, "-A", (char *)FW_INACC,
		 "!", (char *)ARG_I, LANIF, "-m", "mark", "--mark", RMACC_MARK, "-j", FW_ACCEPT);

	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_IN_COMMING);
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_INACC, "-j", (char *)FW_IN_COMMING);

	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_FTP_ACCOUNT);
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_INACC, "-j", (char *)FW_FTP_ACCOUNT);

	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_SAMBA_ACCOUNT);
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_INACC, "-j", (char *)FW_SAMBA_ACCOUNT);

	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_TELNET_ACCOUNT);
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_INACC, "-j", (char *)FW_TELNET_ACCOUNT);
#endif
#ifdef CONFIG_IPV6
	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_IPV6REMOTEACC);
#ifdef CONFIG_YUEME	
	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_IPV6REMOTEACC);

	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_IN_COMMING);
	va_cmd(IP6TABLES, 4, 1, "-A", (char *)FW_INPUT, "-j", (char *)FW_IN_COMMING);

	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_FTP_ACCOUNT);
	va_cmd(IP6TABLES, 4, 1, "-A", (char *)FW_INPUT, "-j", (char *)FW_FTP_ACCOUNT);

	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_SAMBA_ACCOUNT);
	va_cmd(IP6TABLES, 4, 1, "-A", (char *)FW_INPUT, "-j", (char *)FW_SAMBA_ACCOUNT);

	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_TELNET_ACCOUNT_V6);
	va_cmd(IP6TABLES, 4, 1, "-A", (char *)FW_INPUT, "-j", (char *)FW_TELNET_ACCOUNT_V6);

#endif
#endif

	filter_set_remote_access(1);

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	//disable VoIP debug port, if voip need to debug, please remove this iptables rule
	//iptables -A INPUT -p tcp --dport 5432 -j DROP
	va_cmd(IPTABLES, 8, 1, FW_ADD, (char *)FW_INPUT,
			"-p", (char *)ARG_TCP, (char *)FW_DPORT, "5432", "-j", (char *)FW_DROP);
	va_cmd(IPTABLES, 8, 1, FW_ADD, (char *)FW_INPUT,
			"-p", (char *)ARG_UDP, (char *)FW_DPORT, "5432", "-j", (char *)FW_DROP);
		
	//disable all interface except wifi interface osgiManage port 17998
	va_cmd(IPTABLES, 12, 1, FW_ADD, (char *)FW_INPUT, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "17998", "-m", "physdev", "--physdev-in", "wlan+", "-j", (char *)FW_ACCEPT);
	//va_cmd(IPTABLES, 10, 1, FW_ADD, (char *)FW_INPUT,
	//		(char *)ARG_I, "nas+", "-p", (char *)ARG_TCP, (char *)FW_DPORT, "17998", "-j", (char *)FW_ACCEPT);
	//va_cmd(IPTABLES, 10, 1, FW_ADD, (char *)FW_INPUT,
	//		(char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP, (char *)FW_DPORT, "17998", "-j", (char *)FW_ACCEPT);
	va_cmd(IPTABLES, 8, 1, FW_ADD, (char *)FW_INPUT,
			"-p", (char *)ARG_TCP, (char *)FW_DPORT, "17998", "-j", (char *)FW_DROP);
#endif

	// iptables -A INPUT -j inacc
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", (char *)FW_INACC);
#endif // of REMOTE_ACCESS_CTL

#if defined(CONFIG_USER_PPTP_CLIENT_PPTP) && defined(CONFIG_USER_L2TPD_L2TPD)
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_VPNGRE);
	va_cmd(IPTABLES, 6, 1, "-A", (char *)FW_INPUT, "-p", "gre", "-j", (char *)FW_VPNGRE);

	total = mib_chain_total(MIB_PPTP_TBL);
	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_PPTP_TBL, i, (void *)&PPTPEntry))
			return -1;

		if( PPTPEntry.vpn_port )
			va_cmd(IPTABLES, 6, 1, "-A", (char *)FW_VPNGRE, "-s", PPTPEntry.server, "-j", (char *)FW_ACCEPT);

		NF_Init_VPN_Policy_Route(PPTPEntry.tunnelName);
	}

	total = mib_chain_total(MIB_L2TP_TBL);
	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_L2TP_TBL, i, (void *)&L2TPEntry))
			return -1;

		if( L2TPEntry.vpn_port )
			va_cmd(IPTABLES, 6, 1, "-A", (char *)FW_VPNGRE, "-s", L2TPEntry.server, "-j", (char *)FW_ACCEPT);

		NF_Init_VPN_Policy_Route(L2TPEntry.tunnelName);
	}
#endif

	// Added by Mason Yu for accept packet with ip(127.0.0.1)
	// Magician: Modify this rule to allow to ping self. Merge 192.168.1.1-to-192.168.1.1 accepted rule and to-127.0.0.1 accpeted rule.
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_INPUT, "-i", "lo", "-j", (char *)FW_ACCEPT);

	// Single PC mode
	if (mib_get(MIB_SPC_ENABLE, (void *)value) != 0)
	{
		if (value[0]) // Single PC mode enabled
		{
			spc_enable = 1;
			mib_get(MIB_SPC_IPTYPE, (void *)value);
			if (value[0] == 0) // single private IP
			{
				spc_ip = 0;
				mib_get(MIB_ADSL_LAN_IP, (void *)value);

				// IP pool start address
				// Kaohj
				#ifndef DHCPS_POOL_COMPLETE_IP
				mib_get(MIB_ADSL_LAN_CLIENT_START, (void *)&value[3]);
				strncpy(ipaddr, inet_ntoa(*((struct in_addr *)value)), 16);
				#else
				mib_get(MIB_DHCP_POOL_START, (void *)value);
				strncpy(ipaddr, inet_ntoa(*((struct in_addr *)value)), 16);
				#endif
				ipaddr[15] = '\0';
				// iptables -A FORWARD -i $LANIF -s ! ipaddr -j DROP
				va_cmd(IPTABLES, 9, 1, (char *)FW_ADD,
					(char *)FW_FORWARD, (char *)ARG_I,
					(char *)LANIF, "!", "-s", ipaddr,
					"-j", (char *)FW_DROP);
			}
			else // single IP passthrough
			{
				spc_ip = 1;
			}
		}
		else
			spc_enable = 0;
	}

#ifdef IP_PASSTHROUGH
	// check vc
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < total; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;

		if (spc_enable && (spc_ip == 1)) // single IP passthrough (public IP)
		{
			if ((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_RT1483 &&
				ippt_itf == Entry.ifIndex)
			{	// ippt WAN interface (1483-r)
				if ((DHCP_T)Entry.ipDhcp == DHCP_DISABLED)
				{
					strncpy(ipaddr, inet_ntoa(*((struct in_addr *)Entry.ipAddr)), 16);
					ipaddr[15] = '\0';
					// iptables -A FORWARD -i $LANIF -s ! ipaddr -j DROP
					va_cmd(IPTABLES, 9, 1, (char *)FW_ADD,
						(char *)FW_FORWARD, (char *)ARG_I,
						(char *)LANIF, "!", "-s", ipaddr,
						"-j", (char *)FW_DROP);
				}
			}
		}
	}
#endif

#if defined(URL_BLOCKING_SUPPORT)||defined(URL_ALLOWING_SUPPORT)
 mib_get(MIB_URL_CAPABILITY, (void *)&urlEnable);
#endif

#ifdef URL_BLOCKING_SUPPORT
// Added by Mason Yu for URL Blocking
//  Add Chain(urlblock) for URL
 va_cmd(IPTABLES, 2, 1, "-N", "urlblock");
#ifdef SUPPORT_URL_FILTER
	set_url_filter();
#else	
 if (urlEnable == 1)  // URL Capability enabled
   filter_set_url(1);
#endif
  //iptables -A FORWARD -j urlblock
   va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", "urlblock");
 #endif

 #ifdef URL_ALLOWING_SUPPORT
   va_cmd(IPTABLES,2,1 ,"-N","urlallow");
   if(urlEnable==2)
		filter_set_url(2); //alex

 	//iptables -A FORWARD -j urlallow
   va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", "urlallow");
#endif

#ifdef LAYER7_FILTER_SUPPORT
	//App Filter
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_APPFILTER);
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_APP_P2PFILTER);
	va_cmd(IPTABLES, 4, 1, ARG_T, "mangle", "-N", (char *)FW_APPFILTER);
	setupAppFilter();
	// iptables -A FORWARD -j appfilter
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_APPFILTER);
	// iptables -t mangle -A POSTROUTING -j appfilter
	va_cmd(IPTABLES, 6, 1, ARG_T, "mangle", (char *)FW_ADD, (char *)FW_POSTROUTING, "-j", (char *)FW_APPFILTER);
#endif

#ifdef PORT_FORWARD_GENERAL
	// port forwarding
	// Add New chain on filter and nat
	// iptables -N portfw
	va_cmd(IPTABLES, 2, 1, "-N", (char *)PORT_FW);
	// iptables -A FORWARD -j portfw
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)PORT_FW);
	// iptables -t nat -N portfw
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)PORT_FW);
	// iptables -t nat -A PREROUTING -j portfw
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)PORT_FW);
	setupPortFW();
#endif

#ifdef PORT_FORWARD_ADVANCE
	setupPFWAdvance();
#endif

#ifdef NATIP_FORWARDING
	fw_setupIPForwarding();
#endif

#ifdef PORT_TRIGGERING
	// Add New chain on filter and nat
	// iptables -N portTrigger
	va_cmd(IPTABLES, 2, 1, "-N", (char *)IPTABLES_PORTTRIGGER);
	// iptables -A FORWARD -j portTrigger
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)IPTABLES_PORTTRIGGER);
	// iptables -t nat -N portTrigger
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)IPTABLES_PORTTRIGGER);
	// iptables -t nat -A PREROUTING -j portTrigger
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)IPTABLES_PORTTRIGGER);
	setupPortTriggering();
#endif
	// IP Filter
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_IPFILTER_IN);
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_IPFILTER_OUT);
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_FORWARD, ARG_I, LANIF, "-j", (char *)FW_IPFILTER_IN);
	va_cmd(IPTABLES, 7, 1, (char *)FW_ADD, (char *)FW_FORWARD, ARG_NO, ARG_I, LANIF, "-j", (char *)FW_IPFILTER_OUT);
#else
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_IPFILTER);
	// iptables -A FORWARD -j ipfilter
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_IPFILTER);
#endif
	setupIPFilter();

	// DMZ
	// Add New chain on filter and nat
	// iptables -N dmz
	va_cmd(IPTABLES, 2, 1, "-N", (char *)IPTABLE_DMZ);
	// iptables -t nat -N dmz
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)IPTABLE_DMZ);
	setupDMZ(isBoot);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	// iptables -A filter_in -j dmz
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_IPFILTER_IN, "-j", (char *)IPTABLE_DMZ);
#else
	// iptables -A filter -j dmz
	va_cmd(IPTABLES, 4, 1, "-A", (char *)FW_IPFILTER, "-j", (char *)IPTABLE_DMZ);
#endif
	// iptables -t nat -A PREROUTING -j dmz
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)IPTABLE_DMZ);

	// Set IP filter default action
	setup_default_IPFilter();

	// Mac Filter
	va_cmd(EBTABLES, 2, 1, "-N", (char *)FW_MACFILTER);
	//setupMacFilter();

#ifndef MAC_FILTER_SRC_ONLY
	// ebtables -A FORWARD -j macfilter
	va_cmd(EBTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_MACFILTER);
	setupMacFilterEbtables();
#endif

	// Mac Filter SRC
#ifdef MAC_FILTER_SRC_ONLY
	va_cmd(EBTABLES, 2, 1, "-N", (char *)FW_MACFILTER_ROUTER);
	va_cmd(EBTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_MACFILTER_ROUTER);
#endif
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)FW_MACFILTER_ROUTER);
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_INSERT, (char *)FW_PREROUTING, "-j", (char *)FW_MACFILTER_ROUTER);
	setupMacFilterTables();

#ifdef SUPPORT_ACCESS_RIGHT
	apply_accessRight(1);
#endif

#if defined CONFIG_RTK_L34_ENABLE && defined CONFIG_APOLLO_ROMEDRIVER
#ifdef CONFIG_USER_BEHAVIOR_ANALYSIS
	if(!ba_enable)
	{
#endif
	// ebtables -P FORWARD DROP, Rome driver will do it for Kernel.
	va_cmd(EBTABLES, 3, 1, "-P", (char *)FW_FORWARD, (char *)FW_DROP);
	va_cmd(EBTABLES, 2, 1, "-N", "disBCMC");
	va_cmd(EBTABLES, 2, 1, "-F", "disBCMC");
	//we want to drop RA from bridge internet WAN, we trap icmpv6 packet to PS.
	//but the kernel ebtables will drop forward path due Rome driver.
	//the mld queries is also icmpv6 which type is 130, we let it pass in here!

	va_cmd(EBTABLES, 10, 1, (char *)FW_ADD, "disBCMC", "-p", "IPv6", "--ip6-proto","58","--ip6-icmp-type","130","-j", FW_RETURN);
	va_cmd(EBTABLES, 6, 1, (char *)FW_ADD, "disBCMC", "-d", "Broadcast", "-j", FW_DROP);
	va_cmd(EBTABLES, 6, 1, (char *)FW_ADD, "disBCMC", "-d", "Multicast", "-j", FW_DROP);
	va_cmd(EBTABLES, 4, 1, (char *)FW_INSERT, (char *)FW_FORWARD, "-j", "disBCMC");
	va_cmd(EBTABLES, 3, 1, "-P", "disBCMC", (char *)FW_RETURN);
#ifdef CONFIG_USER_BEHAVIOR_ANALYSIS
	}
	else
	{
		va_cmd(EBTABLES, 3, 1, "-P", (char *)FW_FORWARD, (char *)FW_ACCEPT);
	}
#endif
#endif

#ifdef NEW_PORTMAPPING
	//Drop DHCP requests from LAN if DHCP is disabled on WAN
	va_cmd(EBTABLES, 2, 1, "-N", FW_DHCPS_DIS);
	va_cmd(EBTABLES, 3, 1, "-P", FW_DHCPS_DIS, "RETURN");
	//Check packets from DHCP client
	va_cmd(EBTABLES, 12, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "ip"
		, "--ip-protocol", "17", "--ip-sport", "68", "--ip-dport", "67"
		, "-j", FW_DHCPS_DIS);

	//Drop dns requests from LAN 
	va_cmd(EBTABLES, 2, 1, "-N", FW_DNS_DIS);
	va_cmd(EBTABLES, 3, 1, "-P", FW_DNS_DIS, "RETURN");
	//Check packets from dns client
	va_cmd(EBTABLES, 10, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "ip"
		, "--ip-protocol", "17", "--ip-dport", "53"
		, "-j", FW_DNS_DIS);
	va_cmd(EBTABLES, 10, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "IPv6"
		, "--ip6-proto", "17", "--ip6-dport", "53"
		, "-j", FW_DNS_DIS);		
#endif
#ifdef CONFIG_USER_IGMPPROXY
	// ebtables -N portmapping_igmp
	va_cmd(EBTABLES, 2, 1, "-N", PORTMAP_IGMP);
	// ebtables -P portmapping_igmp RETURN
	va_cmd(EBTABLES, 3, 1, "-P", PORTMAP_IGMP, "RETURN");
	// ebtables -A INPUT -j portmapping_igmp
	va_cmd(EBTABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", PORTMAP_IGMP);
#endif

#ifdef LAYER7_FILTER_SUPPORT
	// iptables -A FORWARD -j appp2pfilter
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_APP_P2PFILTER);
#endif

#ifdef VIRTUAL_SERVER_SUPPORT
	//execute virtual server FORWARD rules
	va_cmd(IPTABLES, 2, 1, "-N", (char *)IPTABLE_VTLSUR);
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)IPTABLE_VTLSUR);

	//execute virtual server NAT prerouting rules
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)IPTABLE_VTLSUR);
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)IPTABLE_VTLSUR);

	setupVtlsvr(VIRTUAL_SERVER_ADD);
#endif

 	// for multicast
#if 0 // move ahead to ipfilter chain
	// iptables -A FORWARD -d 224.0.0.0/4 -j ACCEPT
	va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-d",
		"224.0.0.0/4", "-j", (char *)FW_ACCEPT);
#endif

	// Kaohj --- only the LAN ports in the same group with IGMP proxy upstream interface
	// be able to accept IGMP messages
#if (defined(ITF_GROUP) && defined(CONFIG_USER_IGMPPROXY))
#ifdef CONFIG_IGMPPROXY_MULTIWAN
	mib_get(MIB_MPMODE, (void *)&value[0]);
	if(value[0]&MP_PMAP_MASK){ //Port-mapping enable
		total = mib_chain_total(MIB_ATM_VC_TBL);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				continue;
			if (!Entry.enable)
				continue;
			if (Entry.enableIGMP){ // igmpproxy upstream interface
                      		int k;
				int swtotal;
				MIB_CE_SW_PORT_T lanPort;
				swtotal = mib_chain_total(MIB_SW_PORT_TBL);
				for (k=0; k<swtotal; k++) {
					if (!mib_chain_get(MIB_SW_PORT_TBL, k, (void *)&lanPort))
						continue;
					if (lanPort.itfGroup != Entry.itfGroup){
						 //disable LAN IGMP input for other groups
						char vp[] = "1";
						vp[0] = '1' + i;
						//				printf("inport i = %d  phy %s \n",i,phy);
						// iptables -A INPUT -d 224.0.0.0/4 -i eth0_sw0 -j DROP
						// Note: the mark(nfmark) is tagged at NIC driver(re8670.c)
						//					va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-d",
						//					"224.0.0.0/4", (char *)ARG_I,  phy, "-j", (char *)FW_DROP);
						//                                iptables -A INPUT -d 224.0.0.0/4 -m mark --mark port+1 -j DROP
						// Note: the mark(nfmark) is tagged at NIC driver(re8670.c)
						va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_INPUT, "-d",
						"224.0.0.0/4", "-m", "mark", "--mark", vp, "-j", (char *)FW_DROP);
					}
				}
			}

	   }
	}
#else
	mib_get(MIB_MPMODE, (void *)&value[0]);
	mib_get(MIB_IGMP_PROXY, (void *)&value[1]);
	if ((value[0]&MP_PMAP_MASK) && (value[1] == 1)) { // Port-mapping && igmp proxy enabled
		mib_get(MIB_IGMP_PROXY_ITF, (void *)&vInt);
		total = mib_chain_total(MIB_ATM_VC_TBL);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				continue;
			if (!Entry.enable)
				continue;
			if (Entry.ifIndex == vInt)	// igmpproxy upstream interface
				break;
		}
		if (i!=total) {	// found igmpproxy upstream interface
			MIB_CE_SW_PORT_T lanPort;
			total = mib_chain_total(MIB_SW_PORT_TBL);
			for (i=0; i<total; i++) {
				if (!mib_chain_get(MIB_SW_PORT_TBL, i, (void *)&lanPort))
					continue;
				if (lanPort.itfGroup != Entry.itfGroup) {
#if 0
					// disable LAN IGMP input for other groups
					char vp[] = "1";
					vp[0] = '1' + i;
					// iptables -A INPUT -d 224.0.0.0/4 -m mark --mark port+1 -j DROP
					// Note: the mark(nfmark) is tagged at NIC driver(re8670.c)
					va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_INPUT, "-d",
					"224.0.0.0/4", "-m", "mark", "--mark", vp, "-j", (char *)FW_DROP);
#endif
                             //disable LAN IGMP input for other groups
					char phy[]="eth0_sw0";
					phy[7] = '0'+ i;
	//				printf("inport i = %d  phy %s \n",i,phy);
					// iptables -A INPUT -d 224.0.0.0/4 -i eth0_sw0 -j DROP
					// Note: the mark(nfmark) is tagged at NIC driver(re8670.c)
					va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-d",
					"224.0.0.0/4", (char *)ARG_I,  phy, "-j", (char *)FW_DROP);


				}
			}
		}
	}
#endif
#endif // of CONFIG_IGMPPROXY_MULTIWAN
	// iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	// andrew. moved to the 1st rule, or returning PING/DNS relay will be blocked.
	//va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-m", "state",
	//	"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_ACCEPT);

	// iptables -A INPUT -m state --state NEW -i $LAN_INTERFACE -j ACCEPT
	va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_INPUT, "-m", "state",
		"--state", "NEW", (char *)ARG_I, (char *)LANIF,
		"-j", (char *)FW_ACCEPT);

	// iptables -P INPUT DROP
	va_cmd(IPTABLES, 3, 1, "-P", (char *)FW_INPUT, (char *)FW_DROP);

#if 0
	/*--------------------------------------------------------------------
	 * The following are the default action and should be final rules
	 -------------------------------------------------------------------*/
	// iptables -N block
	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_BLOCK);

	// default action
	if (mib_get(MIB_IPF_OUT_ACTION, (void *)value) != 0)
	{
		vInt = (int)(*(unsigned char *)value);
		if (vInt == 1)	// ACCEPT
		{
			// iptables -A block -i $LAN_IF -j ACCEPT
			va_cmd(IPTABLES, 6, 1, (char *)FW_ADD,
				(char *)FW_BLOCK, (char *)ARG_I,
				(char *)LANIF, "-j", (char *)FW_ACCEPT);
		}
	}

	if (mib_get(MIB_IPF_IN_ACTION, (void *)value) != 0)
	{
		vInt = (int)(*(unsigned char *)value);
		if (vInt == 1)	// ACCEPT
		{
			// iptables -A block -i ! $LAN_IF -j ACCEPT
			va_cmd(IPTABLES, 7, 1, (char *)FW_ADD,
				(char *)FW_BLOCK, "!", (char *)ARG_I,
				(char *)LANIF, "-j", (char *)FW_ACCEPT);
		}
	}

	// iptables -A block -m state --state ESTABLISHED,RELATED -j ACCEPT
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_BLOCK, "-m", "state",
		"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_ACCEPT);

	/*
	// iptables -A block -m state --state NEW -i $LAN_INTERFACE -j ACCEPT
	va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_BLOCK, "-m", "state",
		"--state", "NEW", (char *)ARG_I, (char *)LANIF,
		"-j", (char *)FW_ACCEPT);
	*/

	// iptables -A block -j DROP
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, "block", "-j", (char *)FW_DROP);

	/*
	// iptables -A INPUT -j block
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", "block");
	*/

	// iptables -A FORWARD -j block
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", "block");
#endif

#ifdef CONFIG_IPV6
	// INPUT default DROP , ip6table -P INPUT  DROP
	va_cmd(IP6TABLES, 3, 1, "-P", (char *)FW_INPUT, (char *)FW_DROP);

	// ip6tables -A INPUT -p icmpv6 --icmpv6-type router-advertisement -j ACCEPT
	va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "icmpv6",
		"--icmpv6-type","router-advertisement","-j", (char *)FW_ACCEPT);

    // ip6tables -I INPUT  -p icmpv6 --icmpv6-type neighbour-solicitation -j ACCEPT
    va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "icmpv6",
            "--icmpv6-type","neighbour-solicitation","-j", (char *)FW_ACCEPT);

    // ip6tables -I INPUT  -p icmpv6 --icmpv6-type neighbour-advertisement -j ACCEPT
    va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "icmpv6",
            "--icmpv6-type","neighbour-advertisement","-j", (char *)FW_ACCEPT);

	// ip6tables -A INPUT -p icmpv6 -i $LAN_INTERFACE -j ACCEPT
	va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "icmpv6",
	(char *)ARG_I, (char *)LANIF, "-j", (char *)FW_ACCEPT);


	// ip6tables -A INPUT -p icmpv6 -i lo -j ACCEPT , let fe80::1 can pass
	va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "icmpv6",
	(char *)ARG_I, "lo", "-j", (char *)FW_ACCEPT);

	// ip6tables -A INPUT -m state --state NEW -i $LAN_INTERFACE -j ACCEPT
	va_cmd(IP6TABLES, 10, 1, (char *)FW_ADD, (char *)FW_INPUT, "-m", "state",
		"--state", "NEW", (char *)ARG_I, (char *)LANIF,
		"-j", (char *)FW_ACCEPT);

	// ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-m", "state",
			"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_ACCEPT);

	// ip6tables  -A INPUT -p udp --dport  546 -j ACCEPT
	va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, "-p", "udp",
			"--dport", "546", "-j", (char *)FW_ACCEPT);

	// ip6tables  -A INPUT -i $LAN_INTERFACE -p udp --dport  547 -j ACCEPT
	va_cmd(IP6TABLES, 8, 1, (char *)FW_ADD, (char *)FW_INPUT, (char *)ARG_I, (char *)LANIF,
			"-p", "udp", "--dport", "547", "-j", (char *)FW_ACCEPT);

	// IPv6 Filter
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_IPV6FILTER_IN);
	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_IPV6FILTER_OUT);
#else
	va_cmd(IP6TABLES, 2, 1, "-N", (char *)FW_IPV6FILTER);
#endif
	setupIPV6Filter();
	// ip6tables -A FORWARD -j ipv6filter
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	va_cmd(IP6TABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_IPV6FILTER_IN);
	va_cmd(IP6TABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_IPV6FILTER_OUT);
#else
	va_cmd(IP6TABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_IPV6FILTER);
#endif

	// Set IPV6 filter default action
	setup_default_IPV6Filter();

	// ip6tables -I INPUT -j ipv6remoteacc
	va_cmd(IP6TABLES, 4, 1, (char *)FW_INSERT, (char *)FW_INPUT, "-j", (char *)FW_IPV6REMOTEACC);
#if defined(DUAL_STACK_LITE)
	//to avoid ping ipv4 address to use vwlan address as its source ip address in dslite mode
	//we use br0's ipv4 address
	if (mib_get(MIB_ADSL_LAN_IP, (void *)value) != 0)
	{
		strncpy(ipaddr, inet_ntoa(*((struct in_addr *)value)), 16);
		ipaddr[strlen(ipaddr)] = '\0';
	}

	va_cmd(IPTABLES, 10, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_POSTROUTING, "-o", "tun1", "-j", "SNAT", "--to-source", ipaddr);
#endif
#endif
#ifdef CONFIG_RTK_L34_ENABLE
	setup_RG_IPPort_Filter_Default_Policy();
#endif
#ifdef CONFIG_CMCC_FORWARD_RULE_SUPPORT
	//execute CMCCFORWARD rules
	va_cmd(IPTABLES, 2, 1, "-N", (char *)CMCC_FORWARDRULE);
	va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", (char *)CMCC_FORWARDRULE);
	va_cmd(IP6TABLES, 2, 1, "-N", (char *)CMCC_FORWARDRULE);
	va_cmd(IP6TABLES, 4, 1, (char *)FW_ADD, (char *)FW_INPUT, "-j", (char *)CMCC_FORWARDRULE);
	
	//execute virtual server NAT prerouting rules
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-N", (char *)CMCC_FORWARDRULE);
	va_cmd(IPTABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)CMCC_FORWARDRULE);
	va_cmd(IP6TABLES, 4, 1, "-t", "nat", "-N", (char *)CMCC_FORWARDRULE);
	va_cmd(IP6TABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_PREROUTING, "-j", (char *)CMCC_FORWARDRULE);
	va_cmd(IP6TABLES, 4, 1, "-t", "nat", "-N", (char *)CMCC_FORWARDRULE_POST);
	va_cmd(IP6TABLES, 6, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_POSTROUTING, "-j", (char *)CMCC_FORWARDRULE_POST);
	
	setupCmccForwardRule(CMCC_FORWARDRULE_ADD);
#endif

#ifdef DOMAIN_BLOCKING_SUPPORT
	filter_set_domain_default();
#endif

#if defined(CONFIG_YUEME)
	setup_wlan_accessRule_netfilter_init();
#endif

	return 1;
}
#ifdef CONFIG_IP_NF_ALG_ONOFF
//add by ramen return 1--sucessful
// Mason Yu. alg_onoff_20101023
int setupAlgOnOff(void)
{
	unsigned char value=0;
#ifndef CONFIG_RTK_L34_ENABLE
#ifdef CONFIG_NF_CONNTRACK_FTP
	if(mib_get(MIB_IP_ALG_FTP,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_ftp");
	else
		system("/bin/echo 1 > /proc/algonoff_ftp");
#endif
#ifdef CONFIG_NF_CONNTRACK_TFTP
	if(mib_get(MIB_IP_ALG_TFTP,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_tftp");
	else
		system("/bin/echo 1 > /proc/algonoff_tftp");
#endif
#ifdef CONFIG_NF_CONNTRACK_H323
	if(mib_get(MIB_IP_ALG_H323,&value)&& value==0)
		system("/bin/echo 0 >/proc/algonoff_h323");
	else
		system("/bin/echo 1 >/proc/algonoff_h323");
#endif
#ifdef CONFIG_NF_CONNTRACK_IRC
	if(mib_get(MIB_IP_ALG_IRC,&value)&& value==0)
		system("/bin/echo 0 >/proc/algonoff_irc");
	else
		system("/bin/echo 1 >/proc/algonoff_irc");
#endif
#ifdef CONFIG_NF_CONNTRACK_RTSP
	if(mib_get(MIB_IP_ALG_RTSP,&value)&& value==0)
		system("/bin/echo 0 >/proc/algonoff_rtsp");
	else
		system("/bin/echo 1 >/proc/algonoff_rtsp");
#endif
#ifdef CONFIG_NF_CONNTRACK_QUAKE3
	if(mib_get(MIB_IP_ALG_QUAKE3,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_quake3");
	else
		system("/bin/echo 1 > /proc/algonoff_quake3");
#endif
#ifdef CONFIG_NF_CONNTRACK_CUSEEME
	if(mib_get(MIB_IP_ALG_CUSEEME,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_cuseeme");
	else
		system("/bin/echo 1 > /proc/algonoff_cuseeme");
#endif
#ifdef CONFIG_NF_CONNTRACK_L2TP
	if(mib_get(MIB_IP_ALG_L2TP,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_l2tp");
	else
		system("/bin/echo 1 > /proc/algonoff_l2tp");
#endif
#ifdef CONFIG_NF_CONNTRACK_IPSEC
	if(mib_get(MIB_IP_ALG_IPSEC,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_ipsec");
	else
		system("/bin/echo 1 > /proc/algonoff_ipsec");
#endif
#ifdef CONFIG_NF_CONNTRACK_SIP
	if(mib_get(MIB_IP_ALG_SIP,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_sip");
	else
		system("/bin/echo 1 > /proc/algonoff_sip");
#endif
#ifdef CONFIG_NF_CONNTRACK_PPTP
	if(mib_get(MIB_IP_ALG_PPTP,&value)&& value==0)
		system("/bin/echo 0 > /proc/algonoff_pptp");
	else
		system("/bin/echo 1 > /proc/algonoff_pptp");
#endif
#endif // !def CONFIG_RTK_L34_ENABLE
#ifdef CONFIG_RTK_L34_ENABLE
	RTK_RG_FLUSH_ALG_FILTER_RULE();
	RTK_RG_ALG_Set();
#endif
	return 0;
}
#endif


#ifdef WEB_REDIRECT_BY_MAC
static int start_web_redir_by_mac(void)
{
	int status=0;
	char tmpbuf[MAX_URL_LEN];
	char ipaddr[16], ip_port[32], redir_server[33];
	int  def_port=WEB_REDIR_BY_MAC_PORT;

	ipaddr[0]='\0'; ip_port[0]='\0';redir_server[0]='\0';
	if (mib_get(MIB_ADSL_LAN_IP, (void *)tmpbuf) != 0)
	{
		strncpy(ipaddr, inet_ntoa(*((struct in_addr *)tmpbuf)), 16);
		ipaddr[15] = '\0';
		sprintf(ip_port,"%s:%d",ipaddr,def_port);
	}//else ??

	// Enable Bridge Netfiltering
	//status|=va_cmd("/bin/brctl", 2, 0, "brnf", "on");

	//iptables -t nat -N WebRedirectByMAC
	status|=va_cmd(IPTABLES, 4, 1, "-t", "nat","-N","WebRedirectByMAC");

	//iptables -t nat -A WebRedirectByMAC -d 192.168.1.1 -j RETURN
	status|=va_cmd(IPTABLES, 8, 1, "-t", "nat","-A","WebRedirectByMAC",
		"-d", ipaddr, "-j", (char *)FW_RETURN);

	//iptables -t nat -A WebRedirectByMAC -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080
	status|=va_cmd(IPTABLES, 12, 1, "-t", "nat","-A","WebRedirectByMAC",
		"-p", "tcp", "--dport", "80", "-j", "DNAT",
		"--to-destination", ip_port);

	//iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j WebRedirectByMAC
	status|=va_cmd(IPTABLES, 12, 1, "-t", "nat","-A","PREROUTING",
		"-i", ELANIF,
		"-p", "tcp", "--dport", "80", "-j", "WebRedirectByMAC");


{
	int num,i;
	unsigned char tmp2[18];
	MIB_WEB_REDIR_BY_MAC_T	wrm_entry;

	num = mib_chain_total( MIB_WEB_REDIR_BY_MAC_TBL );
	//printf( "\nnum=%d\n", num );
	for(i=0;i<num;i++)
	{
		if( !mib_chain_get( MIB_WEB_REDIR_BY_MAC_TBL, i, (void*)&wrm_entry ) )
			continue;

		sprintf( tmp2, "%02X:%02X:%02X:%02X:%02X:%02X",
				wrm_entry.mac[0], wrm_entry.mac[1], wrm_entry.mac[2], wrm_entry.mac[3], wrm_entry.mac[4], wrm_entry.mac[5] );
		//printf( "add one mac: %s \n", tmp2 );
		// iptables -A macfilter -i eth0  -m mac --mac-source $MAC -j ACCEPT/DROP
		status|=va_cmd("/bin/iptables", 10, 1, "-t", "nat", "-I", "WebRedirectByMAC", "-m", "mac", "--mac-source", tmp2, "-j", "RETURN");
	}
}

	return 0;
}
#endif

#ifdef _SUPPORT_CAPTIVEPORTAL_PROFILE_
int start_captiveportal(void)
{
	int status = 0;
	char tmpbuf[MAX_URL_LEN];
	char lan_ipaddr[16], lan_ip_port[32];
	char ip_mask[24];
	int  def_port = CAPTIVEPORTAL_PORT, i, num;
	FILE *fp;

	lan_ipaddr[0] = '\0';
	lan_ip_port[0] = '\0';

	if (mib_get(MIB_ADSL_LAN_IP, (void *)tmpbuf) != 0)
	{
		strncpy(lan_ipaddr, inet_ntoa(*((struct in_addr *)tmpbuf)), 16);
		lan_ipaddr[15] = '\0';
		sprintf(lan_ip_port, "%s:%d", lan_ipaddr, def_port);
	}
	else
		return -1;

	//iptables -t nat -A PREROUTING -p tcp -d 192.168.1.1 --dport 80 -j RETURN
	status |= va_cmd(IPTABLES, 12, 1, "-t", "nat", "-A", "PREROUTING",	"-p", "tcp", "-d", lan_ipaddr, "--dport", "80", "-j", (char *)FW_RETURN);

	//iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:18182
	status |= va_cmd(IPTABLES, 12, 1, "-t", "nat", "-A", "PREROUTING", "-p", "tcp", "--dport", "80", "-j", "DNAT", "--to-destination", lan_ip_port);

	CWMP_CAPTIVEPORTAL_ALLOWED_LIST_T ccal_entry;

	if(!(fp = fopen("/var/cp_allow_ip", "w")))
	{
		fprintf(stderr, "Open file cp_allow_ip failed!");
		return -1;
	}

	num = mib_chain_total(CWMP_CAPTIVEPORTAL_ALLOWED_LIST);

	for( i = 0; i < num; i++ )
	{
		if(!mib_chain_get(CWMP_CAPTIVEPORTAL_ALLOWED_LIST, i, (void*)&ccal_entry))
			continue;

		if( ccal_entry.mask < 32 ) // Valid subnet mask
			sprintf(ip_mask, "%s/%d", inet_ntoa(*(struct in_addr *)&ccal_entry.ip_addr), ccal_entry.mask);
		else	// Invalid subnet mask or unset subnet mask.
			sprintf(ip_mask, "%s", inet_ntoa(*(struct in_addr *)&ccal_entry.ip_addr));

		// iptables -t nat -I PREROUTING -p tcp -d 209.85.175.104/24 --dport 80 -j RETURN
		status |= va_cmd(IPTABLES, 12, 1, "-t", "nat", "-I", "PREROUTING", "-p", "tcp", "-d", ip_mask, "--dport", "80", "-j", "RETURN");
		fprintf(fp, "%s\n", ip_mask);
	}

	fclose(fp);

#ifdef CONFIG_SUPPORT_CAPTIVE_PORTAL
	enable_http_redirect2CaptivePortalURL(1);
#endif

	return status;
}

int stop_captiveportal(void)
{
	int status = 0;
	char tmpbuf[MAX_URL_LEN];
	char lan_ipaddr[16], lan_ip_port[32];
	char ip_mask[24];
	int  def_port = CAPTIVEPORTAL_PORT, i;
	FILE *fp;

	if(fp = fopen("/var/cp_allow_ip", "r"))
	{
		char *tmp;

		while(fgets(ip_mask, 24, fp))
		{
			tmp = strchr(ip_mask, '\n');
			*tmp = '\0';

			// iptables -t nat -D PREROUTING -p tcp -d 209.85.175.104/24 --dport 80 -j RETURN
			va_cmd(IPTABLES, 12, 1, "-t", "nat", "-D", "PREROUTING", "-p", "tcp", "-d", ip_mask, "--dport", "80", "-j", "RETURN");
		}

		fclose(fp);
		unlink("/var/cp_allow_ip");
	}

	lan_ipaddr[0] = '\0';
	lan_ip_port[0] = '\0';

	if (mib_get(MIB_ADSL_LAN_IP, (void *)tmpbuf) != 0)
	{
		strncpy(lan_ipaddr, inet_ntoa(*((struct in_addr *)tmpbuf)), 16);
		lan_ipaddr[15] = '\0';
		sprintf(lan_ip_port, "%s:%d", lan_ipaddr, def_port);
	}
	else
		return -1;

	//iptables -t nat -D PREROUTING -p tcp -d 192.168.1.1 --dport 80 -j RETURN
	status |= va_cmd(IPTABLES, 12, 1, "-t", "nat", "-D", "PREROUTING", "-p", "tcp", "-d", lan_ipaddr, "--dport", "80", "-j", (char *)FW_RETURN);

	//iptables -t nat -D PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:18182
	status |= va_cmd(IPTABLES, 12, 1, "-t", "nat", "-D", "PREROUTING", "-p", "tcp", "--dport", "80", "-j", "DNAT", "--to-destination", lan_ip_port);

#ifdef CONFIG_SUPPORT_CAPTIVE_PORTAL
	enable_http_redirect2CaptivePortalURL(0);
#endif

	return status;
}
#endif

#ifdef SUPPORT_MCAST_TEST
#define IPTV_BUSSINESS_OK   0
#define NO_IPTV_CONNECTION -1
#define IPTV_DISCONNECT    -2
#define INVALID_MULTIVLAN  -3
#define IPTV_BUSSINESS_NOK -4

/*return value: 0 test success; 1 test fail*/
int multicastTest(int * diagResult)
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	char ifname[IFNAMSIZ];
	int flags, flags_found;
	FILE *fp;
	char buf[200] ={0};
	char cmd[100];
	int isBridgeUp = 0, hasMcVlan = 0, hasMcGroup = 0;
	int ret = 1;
	int mulicastFlow_portmask;
	int portbindingmask;
	int midx, prev_midx;

#ifdef CONFIG_GPON_FEATURE
	rtk_gpon_fsm_status_t onu;
	#if defined(CONFIG_RTK_L34_ENABLE)
			rtk_rg_gpon_ponStatus_get(&onu);
	#else
			rtk_gpon_ponStatus_get(&onu);
	#endif
#endif

	/*check if there is a linkup bridge wan*/
	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < entryNum; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return 1;

		if (Entry.cmode == CHANNEL_MODE_BRIDGE && (Entry.applicationtype & X_CT_SRV_OTHER))
		{
			ifGetName(Entry.ifIndex, ifname, sizeof(ifname));
			flags_found = getInFlags(ifname, &flags);

			if (flags_found)
			{
				if (flags & IFF_UP)
				{
#ifdef CONFIG_GPON_FEATURE
					if (onu == 5)
						isBridgeUp = 1;
#else
					isBridgeUp = 1;
#endif
				}
			}
			/*check if entry has multicast vlan*/
			if(Entry.mVid > 0)
				hasMcVlan = 1;
			break;
		}
	}

	/*check if there is multicast group info*/
	//need to enable rg proc pipe function, rg proc pipe function is disable by default
	sprintf(cmd, "echo 1 > /proc/rg/proc_to_pipe");
	va_cmd("/bin/sh", 2, 1, "-c", cmd);

	midx = prev_midx = 0;
	RG_get_MulticastFlow(&midx, &mulicastFlow_portmask);

	if(RG_get_WanPortBindingMask(Entry.rg_wan_idx, &portbindingmask)==0)
	{
		while(midx!=prev_midx)
		{
			prev_midx = midx;
			if(RG_get_MulticastFlow(&midx, &mulicastFlow_portmask)==0)
			{
				if(portbindingmask & mulicastFlow_portmask)
				{
					hasMcGroup = 1;
					break;
				}
			}
		}
	}
	sprintf(cmd, "echo 0 > /proc/rg/proc_to_pipe");
	va_cmd("/bin/sh", 2, 1, "-c", cmd);

	if(i >= entryNum)
	{
		*diagResult = NO_IPTV_CONNECTION;
	}
	else if(isBridgeUp == 0)
	{
		*diagResult = IPTV_DISCONNECT;
	}
	else if(hasMcVlan == 0)
	{
		*diagResult = INVALID_MULTIVLAN;
	}
	else if(hasMcGroup == 0)
	{
		*diagResult = IPTV_BUSSINESS_NOK;
	}
	else
	{
		*diagResult = IPTV_BUSSINESS_OK;
		ret = 0;
	}

	printf("%s isBridgeUp[%d],hasMcVlan[%d],hasMcGroup[%d] \n",__func__,isBridgeUp,hasMcVlan,hasMcGroup);
	return ret;
}
#endif

int disablePortBandWidthControl()
{
	int i, phyPortId;
#ifdef CONFIG_RTK_L34_ENABLE
	for(i=0; i<SW_LAN_PORT_NUM; i++)
	{
		phyPortId = RG_get_lan_phyPortId(i);
		if(-1 == phyPortId)
		{
			printf("[%s %d]Get phyPortId from logic port[%u] failed.\n", __func__, __LINE__, i);
			continue;
		}

		if(0 == rtk_rg_portIgrBandwidthCtrlRate_set(phyPortId, 0))
		{
			//printf("[%s %d]Set portIgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, port, lanPortCtlRateInfo[port].upRate);
		}
		else
		{
			printf("[%s %d]Failed to Set portIgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, phyPortId, 0);
			continue;
		}

		if(0 == rtk_rg_portEgrBandwidthCtrlRate_set(phyPortId, 0))
		{
			//printf("[%s %d]Set portEgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, port, lanPortCtlRateInfo[port].downRate);
		}
		else
		{
			printf("[%s %d]Failed to Set portEgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, phyPortId, 0);
			continue;
		}
	}
#endif
	return 0;
}

int applyPortBandWidthControl()
{
	unsigned char enable;
	int i, total;
	int phyPortId;
	unsigned int portmask = 0;
	MIB_CE_PORT_BANDWIDTH_ENTRY_T entry;

	if(0==mib_get(MIB_PORT_BANDWIDTH_CONTROL_ENABLE, &enable))
	{
		printf("[%s %d]Get MIB_PORT_BANDWIDTH_CONTROL_ENABLE failed.\n", __func__, __LINE__);
		return -1;
	}

	if(0==enable)
	{
		printf("[%s %d]PORT_BANDWIDTH_CONTROL is disabled.\n", __func__, __LINE__);
		disablePortBandWidthControl();
		return 0;
	}

	total = mib_chain_total(MIB_PORT_BANDWIDTH_TBL);
	for(i=0; i<total; i++)
	{
		if(0==mib_chain_get(MIB_PORT_BANDWIDTH_TBL, i, (void*)&entry))
		{
			continue;
		}
		if(entry.port>=SW_LAN_PORT_NUM)
			continue;
		portmask |= (1<<entry.port);
#ifdef CONFIG_RTK_L34_ENABLE		
		phyPortId = RG_get_lan_phyPortId(entry.port);
		if(-1 == phyPortId)
		{
			printf("[%s %d]Get phyPortId from logic port[%u] failed.\n", __func__, __LINE__, entry.port);
			continue;
		}

		if(0 == rtk_rg_portIgrBandwidthCtrlRate_set(phyPortId, entry.upRate))
		{
			//printf("[%s %d]Set portIgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, phyPortId, entry.upRate);
		}
		else
		{
			printf("[%s %d]Failed to Set portIgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, phyPortId, entry.upRate);
			continue;
		}

		if(0 == rtk_rg_portEgrBandwidthCtrlRate_set(phyPortId, entry.downRate))
		{
			//printf("[%s %d]Set portEgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, phyPortId, entry.downRate);
		}
		else
		{
			printf("[%s %d]Failed to Set portEgrBandwidthCtrlRate, port=%d, rate=%d\n", __func__, __LINE__, phyPortId, entry.downRate);
			continue;
		}
#endif
	}

	for(i=0; i<SW_LAN_PORT_NUM; i++)
	{
		if(0==(portmask&(1<<i)))
		{
#ifdef CONFIG_RTK_L34_ENABLE
			phyPortId = RG_get_lan_phyPortId(i);
			if(-1!=phyPortId)
			{
				rtk_rg_portIgrBandwidthCtrlRate_set(phyPortId, 0);
				rtk_rg_portEgrBandwidthCtrlRate_set(phyPortId, 0);
			}
#endif
		}
	}

	return 0;
}

int setPortBandWidthControl(unsigned int port, unsigned int upRate, unsigned int downRate)
{
	//upRate & downRate in unit of kbps
	int i, total;
	MIB_CE_PORT_BANDWIDTH_ENTRY_T entry;

	if(port >= SW_LAN_PORT_NUM)
	{
		printf("[%s %d]Port should be 0 - 3\n", __func__, __LINE__);
		return -1;
	}

	if((upRate > 1024*1024)||(downRate > 1024*1024))
	{
		printf("[%s %d]max rate should be 1024*1024kbps\n", __func__, __LINE__);
		return -1;
	}

	total = mib_chain_total(MIB_PORT_BANDWIDTH_TBL);
	for(i=0; i<total; i++)
	{
		if(0==mib_chain_get(MIB_PORT_BANDWIDTH_TBL, i, (void*)&entry))
		{
			printf("[%s %d]Get mib failed.\n", __func__, __LINE__);
			return -1;
		}

		if(port == entry.port)
		{
			break;
		}
	}

	entry.port = port;
	entry.upRate = upRate;
	entry.downRate = downRate;
	if(i < total)
	{
		mib_chain_update(MIB_PORT_BANDWIDTH_TBL, (void*)&entry, i);
	}
	else
	{
		mib_chain_add(MIB_PORT_BANDWIDTH_TBL, (void*)&entry);
	}

#ifdef COMMIT_IMMEDIATELY
	Commit();
#endif
	applyPortBandWidthControl();

	return 0;
}

#ifdef SUPPORT_WAN_BANDWIDTH_INFO
//siyuan 2016-1-8 calculate wan bandwidth rate
typedef struct wan_bandwidth_info{
	unsigned int ifIndex;
	int rg_wan_idx;
	struct  timeval    oldtv;
	unsigned long long oldUploadCnt;   /* save upload counter last time */
	unsigned long long oldDownloadCnt; /* save download counter last time */
	int uploadRate;   /* in unit of kbps */
	int downloadRate; /* in unit of kbps */
}WAN_BANDWIDTH_INFO;

int bandwidthInit = 0;
int bandwidthNum = 0;
struct webserver_callout bandwidth_ch;
WAN_BANDWIDTH_INFO bandwidthInfo[MAX_VC_NUM];

void initWanBandwidthInfo()
{
	int i, entryNum;
	MIB_CE_ATM_VC_T entry;
	WAN_BANDWIDTH_INFO * bandwidth;

	memset(bandwidthInfo, 0, sizeof(bandwidthInfo));

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, &entry)) {
			printf("get MIB chain error\n");
			break;
		}
		bandwidth = &bandwidthInfo[i];

		bandwidth->ifIndex = entry.ifIndex;
		bandwidth->rg_wan_idx = entry.rg_wan_idx;

		gettimeofday(&bandwidth->oldtv,NULL);
		RG_get_interface_counter(bandwidth->rg_wan_idx, &bandwidth->oldUploadCnt, &bandwidth->oldDownloadCnt);
	}
	bandwidthNum = entryNum;
}

int calWanBandwidth(WAN_BANDWIDTH_INFO * bandwidth)
{
	unsigned long long uploadcnt, downloadcnt;
	struct  timeval  tv;
	int msecond;
	int ret;

	gettimeofday(&tv,NULL);

	ret = RG_get_interface_counter(bandwidth->rg_wan_idx, &uploadcnt, &downloadcnt);
	if(ret < 0)
	{
		return -1;
	}

	/* calculate upload and download rate */
	if((uploadcnt <= bandwidth->oldUploadCnt) || (downloadcnt <= bandwidth->oldDownloadCnt))
	{
		bandwidth->uploadRate = 0;
		bandwidth->downloadRate = 0;
	}
	else
	{
		msecond = (tv.tv_sec - bandwidth->oldtv.tv_sec) * 1000 +
				  ((int)(tv.tv_usec) - (int)(bandwidth->oldtv.tv_usec)) / 1000;

		bandwidth->uploadRate = ((uploadcnt - bandwidth->oldUploadCnt) * 1000 / msecond) >> 7;
		bandwidth->downloadRate = ((downloadcnt - bandwidth->oldDownloadCnt) * 1000 / msecond) >> 7;
	}

	bandwidth->oldUploadCnt = uploadcnt;
	bandwidth->oldDownloadCnt = downloadcnt;
	bandwidth->oldtv.tv_sec = tv.tv_sec;
	bandwidth->oldtv.tv_usec = tv.tv_usec;
	return 0;
}

/* check if any wan interface has changed*/
int checkWanChange()
{
	int i, entryNum;
	MIB_CE_ATM_VC_T entry;

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);

	if(entryNum != bandwidthNum)
		return -1;

	for (i = 0; i < entryNum; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, &entry)) {
			printf("get MIB chain error\n");
			return -1;
		}

		if((entry.ifIndex != bandwidthInfo[i].ifIndex) ||
		   (entry.rg_wan_idx != bandwidthInfo[i].rg_wan_idx))
			return -1;
	}

	return 0;
}

void calAllWanBandwidth()
{
	int i;

	if(checkWanChange() < 0)
	{
		initWanBandwidthInfo();
		return;
	}

	for (i = 0; i < bandwidthNum; i++)
	{
		calWanBandwidth(&bandwidthInfo[i]);
	}
}

void poll_bandwidth(void *dummy)
{
	unsigned char enable;
	unsigned int interval;

	mib_get(MIB_WAN_BANDWIDTH_ENABLE, (void *)&enable);
	if(enable == 0)
	{
		TIMEOUT(poll_bandwidth, 0, 1, bandwidth_ch);
		return;
	}
	else
	{
		mib_get(MIB_WAN_BANDWIDTH_INTERVAL, (void *)&interval);

		if(bandwidthInit == 0)
		{
			initWanBandwidthInfo();
			bandwidthInit = 1;
		}
		else
		{
			calAllWanBandwidth();
		}

		TIMEOUT(poll_bandwidth, 0, interval, bandwidth_ch);
	}
}

int wan_bandwidth_get(int rg_wan_idx, int * uploadrate, int * downloadrate)
{
	int i;
	unsigned char enable;

	mib_get(MIB_WAN_BANDWIDTH_ENABLE, (void *)&enable);
	if(enable == 0)
	{
		goto end;
	}

	for (i = 0; i < bandwidthNum; i++)
	{
		if(bandwidthInfo[i].rg_wan_idx == rg_wan_idx)
		{
			*uploadrate = bandwidthInfo[i].uploadRate;
			*downloadrate = bandwidthInfo[i].downloadRate;
			return 0;
		}
	}

end:
	*uploadrate = 0;
	*downloadrate = 0;
	return -1;
}

int wan_bandwidth_set(unsigned char enable, unsigned int interval)
{
	unsigned char oldEnable;

	mib_get(MIB_WAN_BANDWIDTH_ENABLE, (void *)&oldEnable);

	mib_set(MIB_WAN_BANDWIDTH_ENABLE, (void *)&enable);
	mib_set(MIB_WAN_BANDWIDTH_INTERVAL, (void *)&interval);

	//printf("%s enable[%d] interval[%d] \n", __func__,enable,interval);
	if((oldEnable == 0) && (enable == 1))
	{
		bandwidthInit = 0;
	}

#ifdef COMMIT_IMMEDIATELY
	Commit();
#endif
	return 0;
}
#endif
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
#define PON_FLOW_STATISTICS_TXFILE "/var/pon_flow_txbytes.txt"
#define PON_FLOW_STATISTICS_TMP_TXFILE "/var/pon_flow_txbytes.txt.tmp"

#define PON_FLOW_STATISTICS_RXFILE "/var/pon_flow_rxbytes.txt"
#define PON_FLOW_STATISTICS_TMP_RXFILE "/var/pon_flow_rxbytes.txt.tmp"

#define PON_FLOW_STATISTICS_LOCKFILE	"/var/run/pon_flow_statistic.lock."

int lock_pon_statistic_file_by_flock()
{
	int lockfd;

	if ((lockfd = open(PON_FLOW_STATISTICS_LOCKFILE, O_RDWR|O_CREAT)) == -1) {
		perror("open shm lockfile");
		return lockfd;
	}
	while (flock(lockfd, LOCK_EX) == -1 && errno==EINTR) {
		printf("configd write lock failed by flock. errno=%d\n", errno);
	}
	return lockfd;
}

int unlock_pon_statistic_file_by_flock(int lockfd)
{
	while (flock(lockfd, LOCK_UN) == -1 && errno==EINTR) {
		printf("configd write unlock failed by flock. errno=%d\n", errno);
	}
	close(lockfd);
	return 0;
}


struct webserver_callout ponFlowTxBytes_ch;
void poll_ponFlowTxBytes(void *arg){
	
	unsigned char queue_num=0;
#if defined(CONFIG_RTK_OMCI_V1)
	mib_get(MIB_OMCI_WAN_QOS_QUEUE_NUM,&queue_num);
#endif
	int j = 0;
	FILE* fp=NULL;
	FILE* fp_tmp=NULL;
	//tx statistic
	rtk_rg_table_flowmib_t *flowMib=NULL;

	flowMib=(rtk_rg_table_flowmib_t*)malloc(sizeof(rtk_rg_table_flowmib_t)*queue_num);
	memset(flowMib,0,sizeof(rtk_rg_table_flowmib_t)*queue_num);

	int lockfd=lock_pon_statistic_file_by_flock();
	if ((fp = fopen(PON_FLOW_STATISTICS_TXFILE, "a+")) == NULL){
		goto out; 
	}
	if ((fp_tmp = fopen(PON_FLOW_STATISTICS_TMP_TXFILE, "w")) == NULL){
		goto out; 
	}
	for(j=0;j < queue_num; j++){
		unsigned long long lastUsStatsBytes = 0;
		int flow = 0;
		rtk_rg_flowMibCounter_get(j, &flowMib[j]);
		//diag_util_mprintf("ingress packet count: %u\n", flowMib.in_packet_cnt);
		//diag_util_mprintf("ingress byte count: %llu\n", flowMib.in_byte_cnt);
		//diag_util_mprintf("egress packet count: %u\n", flowMib.out_packet_cnt);
		//diag_util_mprintf("egress byte count: %llu\n", flowMib.out_byte_cnt);
		fscanf(fp,"%d %llu %*llu\n",&flow,&lastUsStatsBytes);
		fprintf(fp_tmp,"%d %llu %llu\n",j,flowMib[j].out_byte_cnt,flowMib[j].out_byte_cnt-lastUsStatsBytes);
	}
	if(fp){
		fflush(fp);
		fclose(fp);
	}
	if(fp_tmp){
		fflush(fp_tmp);
		fclose(fp_tmp);
	}
	remove(PON_FLOW_STATISTICS_TXFILE);
	rename(PON_FLOW_STATISTICS_TMP_TXFILE, PON_FLOW_STATISTICS_TXFILE);
	//rx statistic
	if ((fp = fopen(PON_FLOW_STATISTICS_RXFILE, "a+")) == NULL){
		goto out; 
	}
	if ((fp_tmp = fopen(PON_FLOW_STATISTICS_TMP_RXFILE, "w")) == NULL){
		goto out; 
	}
	for(j=0;j < queue_num; j++){
		unsigned long long currentDsStatsBytes = 0;
		unsigned long long lastDsStatsBytes = 0;
		int flow = 0;
		fscanf(fp,"%d %llu %*llu\n",&flow,&lastDsStatsBytes);
		fprintf(fp_tmp,"%d %llu %llu\n",j,flowMib[j].in_byte_cnt,flowMib[j].in_byte_cnt-lastDsStatsBytes);
	}
	if(fp){
		fflush(fp);
		fclose(fp);
	}
	if(fp_tmp){
		fflush(fp_tmp);
		fclose(fp_tmp);
	}
	remove(PON_FLOW_STATISTICS_RXFILE);
	rename(PON_FLOW_STATISTICS_TMP_RXFILE, PON_FLOW_STATISTICS_RXFILE);
out:
	unlock_pon_statistic_file_by_flock(lockfd);
	if(flowMib)
		free(flowMib);
	TIMEOUT(poll_ponFlowTxBytes, 0, 1, ponFlowTxBytes_ch);
}
#endif
#ifdef CONFIG_USER_QUICKINSTALL
typedef struct wan_downSpeed_info{
	struct  timeval    oldtv;
	unsigned long long oldDownloadCnt; /* save download counter last time */
	unsigned int downloadRate; /* in unit of kbps */
}WAN_DOWNSPEED_INFO;

int downspeedInit = 0;
struct webserver_callout downspeed_ch;
WAN_DOWNSPEED_INFO downspeedInfo;
static void calWanDownSpeed();

void initWanDownSpeedInfo()
{
	memset(&downspeedInfo, 0, sizeof(downspeedInfo));
	gettimeofday(downspeedInfo.oldtv, NULL);
	calWanDownSpeed();
}

#define WANDOWNSPEEDFILE "/var/fh_speedtest_ds"
int writeWanDownSpeedInfo()
{
	int fd;
	int i, portNum=4;

	fd = open(WANDOWNSPEEDFILE, O_RDWR|O_CREAT, 0644);
	if (fd < 0)
	{
		return -1;
	}

	if( !flock_set(fd, F_WRLCK) )
	{
		/* clear /var/fh_speedtest_ds */
		if ( !truncate(WANDOWNSPEEDFILE, 0) )
		{
			write(fd, (void *)&downspeedInfo.downloadRate, sizeof(int));
		}

		flock_set(fd, F_UNLCK);
	}

	close(fd);
	return 0;
}

static void calWanDownSpeed(void)
{
	unsigned long long downloadcnt;
	struct  timeval  tv;
	int msecond;
	int ret;

	gettimeofday(&tv,NULL);

	ret = RG_get_pon_port_stat(&downloadcnt);
	if(ret < 0)
	{
		return -1;
	}

	/* calculate upload and download rate */
	if(downloadcnt <= downspeedInfo.oldDownloadCnt)
	{
		downspeedInfo.downloadRate = 0;
	}
	else
	{
		msecond = (tv.tv_sec - downspeedInfo.oldtv.tv_sec) * 1000 +
				  ((int)(tv.tv_usec) - (int)(downspeedInfo.oldtv.tv_usec)) / 1000;

		downspeedInfo.downloadRate = ((downloadcnt - downspeedInfo.oldDownloadCnt) * 1000 / msecond) >> 7;
	}

	downspeedInfo.oldDownloadCnt = downloadcnt;
	downspeedInfo.oldtv.tv_sec = tv.tv_sec;
	downspeedInfo.oldtv.tv_usec = tv.tv_usec;

	//printf("[%s %d]:downloadRate=%d\n", __func__, __LINE__, downspeedInfo.downloadRate);
	return 0;
}

static int isHostSpeedupEnable(void)
{
	FILE *fp;
	int val;

	if ((fp = fopen("/proc/HostSpeedUP", "r")) == NULL)
		return -1;
	fscanf(fp, "%d", &val);
	fclose(fp);

	return val;
}

void poll_wan_downspeed(void *dummy)
{
	unsigned char enable;
	unsigned int interval;
    int vInt;
    static int hostSpeedUp=0, upCnt=0;

	if(downspeedInit == 0)
	{
		initWanDownSpeedInfo();
		downspeedInit = 1;
	}
	else
		calWanDownSpeed();

	writeWanDownSpeedInfo();

    vInt = isHostSpeedupEnable();
    if (0 == hostSpeedUp)
    {
        if (1 == vInt)
        {
            if (upCnt++ >= 5)
                hostSpeedUp = 1;
        }
        else
        {
            upCnt = 0;
        }
    }
    else
    {
        if (0 == vInt)
        {
            hostSpeedUp = 0;
            upCnt = 0;
        }
    }

    if (hostSpeedUp)
        TIMEOUT(poll_wan_downspeed, 0, 5, downspeed_ch);
    else
        TIMEOUT(poll_wan_downspeed, 0, 1, downspeed_ch);
}
#endif

#ifdef SUPPORT_WEB_PUSHUP
static struct webserver_callout upgradeWebPushUpTimer;
char firmware_upgrade_pushup_base_url[1024];

static char HTTP_FIRMWARE_UPGRADE_PUSHUP[] =
{
	"HTTP/1.0 200 OK\r\n"
	"Connection: keep-alive\r\n"
	"Content-Type: text/html\r\n"
	"\r\n"
	"<!doctype html>\r\n"
    "<html>\r\n"
    "<head>\r\n"
	"<meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"utf-8\">\r\n"
    "<title></title>\r\n"
    "</head>\r\n"
    "<body>\r\n"
    "<script>\r\n"
	"function openwin(u, w, h) {\r\n"
	"	var l = (screen.width - w)/2;\r\n"
	"	var t = (screen.height - h) / 2;\r\n"
	"	var s = 'width=' + w + ', height=' + h + ', top=' + t + ', left=' + l +"
	"      ', toolbar=no, scrollbars=no, menubar=no, location=no, resizable=no';\r\n"
	"	window.open(u, \"_blank\", s);\r\n"
	"}\r\n"
	"openwin(\"http://192.168.1.1/upgrade_pop.asp\", 400, 100);\r\n"
	"window.location.href=\"http://%s\";\r\n"
    "</script>\r\n"
    "</body>\r\n"
    "</html>"
};

int upgradeWebSet(int enable)
{
	char content[1024] = {0};

	if(enable)
	{
		memset(content, 0, sizeof(content));
		strcpy(content, HTTP_FIRMWARE_UPGRADE_PUSHUP);
		printf("content:\n%s\n", content);
		RG_set_redirect_http_all(2, content, strlen(content), -1);
	}
	else
	{
		RG_set_redirect_http_all(0, content, 0, -1);
	}

	return 1;
}

static int isValidImageFile(const char *fname)
{
	int ret;
	char buf[256];

	// todo: validate the image file
	snprintf(buf, sizeof(buf), "/bin/tar tf %s md5.txt > /dev/null", fname);
        /* To prevent system() to return ECHILD */
        signal(SIGCHLD, SIG_DFL);
        fprintf(stderr, "%s\n", buf);
	ret = system(buf);

	return !ret;
}

void startUpgradeFirmware(int needreboot)
{
	char filename[100];
	char userStr[100], passwdStr[100];
	char pathStr[100];
	char portStr[100];
	char downUrl[128];
	struct stat statbuf;
	int fd;
	int urlLen, i;

	snprintf(userStr, 100, "user=%s", "anonymous");
	snprintf(passwdStr, 100, "passwd=%s", "anonymous");
	#ifdef CONFIG_YUEME
	snprintf(pathStr, 100, "path=%s", "/var/tmp2");
	#else
	snprintf(pathStr, 100, "path=%s", "/tmp");
	#endif
	snprintf(portStr, 100, "port=%d", 21);
	mib_get(MIB_FIRMWARE_DOWNURL, (void *)downUrl);

	va_cmd("/bin/wget_manage", 5, 1, userStr, passwdStr, pathStr, portStr, downUrl);

	/* get filename */
	urlLen = strlen(downUrl);
	if (downUrl[urlLen-1] == '/') downUrl[urlLen-1] = 0;

	for (i=urlLen-1; i>=0; i--)
	{
		if (downUrl[i] == '/')
			break;
	}
	if (i>=0)//finename found
	{
		#ifdef CONFIG_YUEME
		snprintf(filename, 100, "/var/tmp2/%s", &downUrl[i+1]);
		#else
		snprintf(filename, 100, "/tmp/%s", &downUrl[i+1]);	
		#endif
	}
	if (!isValidImageFile(filename)) {
		printf("Incorrect image file\n");
		unlink(filename);
		return;
	}

	// Save file for upgrade Firmware
	fd = open(filename, O_RDWR);
	fstat(fd, &statbuf);
	close(fd);
	cmd_upload(filename, 0, statbuf.st_size, needreboot);
}

static void upgradeWebPushupCheck(void)
{
	upgradeWebSet(1);
}

void startPushwebTimer(unsigned int time)//time unit: seconds
{
	TIMEOUT((void*)upgradeWebPushupCheck, 0, time, upgradeWebPushUpTimer);
}

#define	FIRMWARE_UPGRADE_STATUS		"/var/config/firmware_upgrade_status"

FW_UPGRADE_STATUS_T firmwareUpgradeConfigStatus( void )
{
	FILE *fp;
	char line[64];
	FW_UPGRADE_STATUS_T status;


	if(!(fp = fopen(FIRMWARE_UPGRADE_STATUS, "r")))
		return FW_UPGRADE_STATUS_NONE;

	fgets(line, 12, fp);
	sscanf(line, "%d", &status);

	fclose(fp);

	return status;
}

void firmwareUpgradeConfigStatusClean( void )
{
	char buf[100];

	sprintf(buf, "/bin/echo %d > %s", FW_UPGRADE_STATUS_NONE, FIRMWARE_UPGRADE_STATUS);
	system(buf);
}

void firmwareUpgradeConfigStatusSet( FW_UPGRADE_STATUS_T status )
{
	char buf[100];

	sprintf(buf, "/bin/echo %d > %s", status, FIRMWARE_UPGRADE_STATUS);
	system(buf);
}

int firmwareUpgradeConfigSet(char *downUrl, int mode, int method, int needreboot, char *upgradeID)
{
	/*sanity check for parameter*/
	if (NULL == downUrl)
	{
		printf("downURL should not be NULL.\n");
		if (0 == mode)
			firmwareUpgradeConfigStatusSet(FW_UPGRADE_STATUS_OTHERS);
		return 0;
	}

	if (strncmp(downUrl, "ftp://", 6) &&
		strncmp(downUrl, "http://", 7))
	{
		printf("wrong downURL!\n");
		if (0 == mode)
			firmwareUpgradeConfigStatusSet(FW_UPGRADE_STATUS_OTHERS);
		return 0;
	}

	if ((mode < 0) || (mode > 5))
	{
		printf("unknown mode, should be 0~5.\n");
		firmwareUpgradeConfigStatusSet(FW_UPGRADE_STATUS_OTHERS);
		return 0;
	}

	if ((method != 0) && (method != 1))
	{
		printf("unknow method, should be 0 or 1!\n");
		if (0 == mode)
			firmwareUpgradeConfigStatusSet(FW_UPGRADE_STATUS_OTHERS);
		return 0;
	}

	/* save the config */
	mib_set(MIB_FIRMWARE_DOWNURL, (void *)downUrl);
	mib_set(MIB_UPGRADE_MODE, (void *)&mode);
	mib_set(MIB_UPGRADE_METHOD, (void *)&method);
	mib_set(MIB_UPGRADE_ID, (void *)upgradeID);

	/* take effect now */
	UNTIMEOUT(upgradeWebPushupCheck, 0, upgradeWebPushUpTimer);

	if (0 == mode)//upgrade firmware
	{
#if !defined(YUEME_3_0_SPEC)
		if (0 == method)
		{//proposal for upgrade
			upgradeWebSet(1);
		}
		else if (1 == method)
#endif
		{//force to upgrade
			firmwareUpgradeConfigStatusSet(FW_UPGRADE_STATUS_PROGGRESSING);
			startUpgradeFirmware(needreboot);
		}
	}
	else
	{
		//TODO: upgrade OSGI framework, java machine, NOS, etc...
	}
}
#endif//end of SUPPORT_WEB_PUSHUP

#ifdef SUPPORT_WEB_REDIRECT
//siyuan 2016-1-11 add pushweb and web redirect
struct pushweb{
	char url[128];
	int width;
	int height;
	int top;
	int left;
};

char HTTP_HEADER[] =
{
	"HTTP/1.0 200 OK\r\n"
	"Connection: close\r\n"
	"Content-Type: text/html\r\n"
	"Content-Length: %d\r\n"
	"\r\n"
	"%s"
};

#if 0
char HTTP_BODY_PUSHWEB[] =
{
	"<!doctype html>"
    "<html>"
    "<head>"
	"<meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"utf-8\">"
    "<title></title>"
    "</head>"
    "<body>"
    "<script>"
    "window.open(\"%s\", \"_blank\", \"height=%d,width=%d,top=%d,left=%d\");"
    "</script>"
    "</body>"
    "</html>"
};
#else
char HTTP_BODY_PUSHWEB[] =
{
	"<!doctype html>"
    "<html>"
    "<head>"
	"<meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"utf-8\">"
    "<title></title>"
    "</head>"
    "<body>"
    "<script>"
    "window.open(\"%s\", \"pushweb\", \"height=%d,width=%d,top=%d,left=%d\");"
    "</script>"
    "</body>"
    "</html>"
};
#endif

static struct pushweb pushWebCfg;
struct webserver_callout pushWeb_ch;

static int welcomeInit = 0;
static int welcomeDay;
struct webserver_callout welcome_ch;
static int redirectInit = 0;

static void pushWebGenerateHttp(struct pushweb * cfg, char * content, int size)
{
	char buff[512] = {0};
	int filesize;

	snprintf(buff, 512, HTTP_BODY_PUSHWEB, cfg->url,
			 cfg->height,cfg->width, cfg->top, cfg->left);
	filesize = strlen(buff);

	snprintf(content, size, HTTP_HEADER, filesize, buff);
}

static void pushWebEnable(int enable, int count)
{
#ifdef CONFIG_RTK_L34_ENABLE
	char content[728] = {0};
    FILE *fp;
    char cmdStr[100];
	//printf("in <%s>enable:%d\n",__func__,enable);
	if(enable)
	{
	    /* when enable push web function, hwnat rule should be created at tcp handshake phase.*/
        fp = fopen("/proc/rg/tcp_hw_learning_at_syn", "w");
	    if(fp)
    	{
    		fprintf(fp, "0\n");
    		fclose(fp);
    	}else
    		fprintf(stderr, "open /proc/rg/tcp_hw_learning_at_syn fail!\n");

		
        fp = fopen("/proc/rg/check_http_mechanism_before_ps", "w");
        if(fp)
    	{
    		fprintf(fp, "1\n");
    		fclose(fp);
    	}else
    		fprintf(stderr, "open /proc/rg/check_http_mechanism_before_ps fail!\n");
		
 		RG_set_http_trap_for_bridge(1);
		pushWebGenerateHttp(&pushWebCfg, content, 728);
		//RG_set_redirect_http_all(1, content, strlen(content), count);
		RG_set_redirect_http_Count(1,content, strlen(content), count);
	}
	else
	{
/*
        fp = fopen("/proc/rg/tcp_hw_learning_at_syn", "w");
	    if(fp)
    	{
    		fprintf(fp, "1\n");
    		fclose(fp);
    	}else
    		fprintf(stderr, "open /proc/rg/tcp_hw_learning_at_syn fail!\n");
*/
		
        fp = fopen("/proc/rg/check_http_mechanism_before_ps", "w");
        if(fp)
    	{
    		fprintf(fp, "0\n");
    		fclose(fp);
    	}else
    		fprintf(stderr, "open /proc/rg/check_http_mechanism_before_ps fail!\n");
		
		RG_set_http_trap_for_bridge(0);
		//RG_set_redirect_http_all(0, content, 0, count);
		RG_set_redirect_http_Count(0, content, 0, count);
	}
#endif
}

/* timeout, should disable pushweb */
static void pushWebCheck()
{
	pushWebEnable(0, -1);
	UNTIMEOUT(pushWebCheck, 0, pushWeb_ch);
}

void pushWebDisable(void)
{
	pushWebEnable(0, -1);
	UNTIMEOUT(pushWebCheck, 0, pushWeb_ch);
}

int pushWebSet(int enable, int width, int height, int top, int left,
					char * url, int second)
{
	memset((void*)&pushWebCfg, 0 , sizeof(pushWebCfg));

	if(url == NULL || strlen(url) == 0)
		return -1;

	if((strlen(url) >= MAX_URL_LEN) || strncmp(url, "http://", 7 ))
			return -1;

	strncpy(pushWebCfg.url, url, sizeof(pushWebCfg.url));
	pushWebCfg.width = width;
	pushWebCfg.height = height;
	pushWebCfg.top = top;
	pushWebCfg.left = left;

	pushWebEnable(enable, -1);
	if(enable)
		TIMEOUT(pushWebCheck, 0, second, pushWeb_ch);

	return 0;
}

int webRedirectSetRGRule(int add)
{
#ifdef CONFIG_RTK_L34_ENABLE
	int i;
	int num;
	MIB_REDIRECT_URL_LIST_T redirectUrl;
	MIB_REDIRECT_WHITE_LIST_T whiteUrl;

	num = mib_chain_total(MIB_REDIRECT_URL_LIST);

	for( i = 0; i < num; i++ )
	{
		if(!mib_chain_get(MIB_REDIRECT_URL_LIST, i, (void*)&redirectUrl))
			continue;

		if(add)
			RG_add_redirectHttpURL(&redirectUrl);
		else
			RG_del_redirectHttpURL(&redirectUrl);
	}

	num = mib_chain_total(MIB_REDIRECT_WHITE_LIST);

	for( i = 0; i < num; i++ )
	{
		if(!mib_chain_get(MIB_REDIRECT_WHITE_LIST, i, (void*)&whiteUrl))
			continue;

		if(add)
			RG_add_redirectWhiteUrl(&whiteUrl);
		else
			RG_del_redirectWhiteUrl(&whiteUrl);
	}
#endif
	return 0;
}

/* strip prefix "http://" from url content */
static void stripHttpFromUrl(char * url, int len)
{
	int offset;
	char buff[MAX_URL_LEN];

	if(strncmp(url, "http://", 7 ) == 0)
	{
		offset = 7;
	}
	else if(strncmp(url, "https://", 8 ) == 0)
	{
		offset = 8;
	}
	else
		return;

	memmove(url, url+offset, len-offset);
	url[len-offset] = '\0';
}

int webRedirectSetRule(MIB_REDIRECT_URL_LIST_T * redirect, int redirectNum,
							 MIB_REDIRECT_WHITE_LIST_T * white, int whiteNum)
{
	int i;
	int num;

	if(redirectInit == 0)
	{
		redirectInit = 1;
	}
	else
	{/* clear old rg redirect rule */
		webRedirectSetRGRule(0);
	}

	mib_chain_clear(MIB_REDIRECT_URL_LIST);
	num = (redirectNum <= MAX_REDIRECT_URL_LIST) ? redirectNum : MAX_REDIRECT_URL_LIST;
	for(i = 0; i < num; i++)
	{
		stripHttpFromUrl(redirect[i].srcUrl, strlen(redirect[i].srcUrl));
		stripHttpFromUrl(redirect[i].dstUrl, strlen(redirect[i].dstUrl));
		mib_chain_add(MIB_REDIRECT_URL_LIST, (void*)&redirect[i]);
	}

	num = (whiteNum <= MAX_REDIRECT_WHITE_LIST) ? whiteNum : MAX_REDIRECT_WHITE_LIST;
	mib_chain_clear(MIB_REDIRECT_WHITE_LIST);
	for(i = 0; i < num; i++)
	{
		stripHttpFromUrl(white[i].url, strlen(white[i].url));
		mib_chain_add(MIB_REDIRECT_WHITE_LIST, (void*)&white[i]);
	}

	/* add rg redirect rule */
	webRedirectSetRGRule(1);

	return 0;
}

void welcomeRedirectSet(int enable)
{
#ifdef CONFIG_RTK_L34_ENABLE
	char url[MAX_URL_LEN] = {0};
	char buff[MAX_URL_LEN] = {0};
	unsigned int second;

	if(enable)
	{
		mib_get( MIB_REDIRECT_WELCOME_URL, (void *)url);
		mib_get( MIB_REDIRECT_WELCOME_TIME, (void *)&second);

		snprintf(buff, MAX_URL_LEN, "%s?length=%d&url=", url, second);
		RG_set_welcome_redirect(1, buff);
	}
	else
	{
		RG_set_welcome_redirect(0, url);
	}
#endif
}

void welcomeRedirectCheck(void *arg)
{
	unsigned char enable;
	int welcomeSet = 0;
	struct tm curTm;
	time_t curTime;

	mib_get(MIB_REDIRECT_WELCOME_ENABLE, (void *)&enable);
	if(enable == 0)
	{
		UNTIMEOUT(welcomeRedirectCheck, 0, welcome_ch);
		return;
	}

	time(&curTime);
	memcpy(&curTm, localtime((const time_t *)&time), sizeof(curTm));

	if(welcomeInit == 0)
	{
		welcomeDay = curTm.tm_yday;
		welcomeInit = 1;
		welcomeSet = 1;
	}
	else
	{
		/* check if a new day comes */
		if (welcomeDay != curTm.tm_yday)
		{
			welcomeSet = 1;
			welcomeDay = curTm.tm_yday;
		}
	}

	if(welcomeSet)
		welcomeRedirectSet(1);

	TIMEOUT(welcomeRedirectCheck, 0, 3600, welcome_ch);
}

int webRedirectSet(unsigned char welcome, char * url, unsigned int second,
						MIB_REDIRECT_URL_LIST_T * redirect, int redirectNum,
						MIB_REDIRECT_WHITE_LIST_T * white, int whiteNum)
{
	int i;
	int num;
	unsigned char oldEnable;

	mib_get(MIB_REDIRECT_WELCOME_ENABLE, (void *)&oldEnable);
	mib_set(MIB_REDIRECT_WELCOME_ENABLE, (void *)&welcome);

	if(url == NULL || strlen(url) == 0)
	{
		mib_set( MIB_REDIRECT_WELCOME_URL, (void *)"");
	}
	else
	{
		stripHttpFromUrl(url, strlen(url));
		mib_set( MIB_REDIRECT_WELCOME_URL, (void *)url);
	}

	mib_set(MIB_REDIRECT_WELCOME_TIME, (void *)&second);

	webRedirectSetRule(redirect, redirectNum, white, whiteNum);

	if(welcome)
	{
		welcomeInit = 0;
		welcomeRedirectCheck(NULL);
	}
	else if((welcome == 0) && oldEnable)
	{
		UNTIMEOUT(welcomeRedirectCheck, 0, welcome_ch);
		welcomeRedirectSet(0);
	}

#ifdef COMMIT_IMMEDIATELY
	Commit();
#endif

	return 0;
}

int updateRedirectIPAddr(unsigned int ipAddr)
{
	struct in_addr ip4Addr;
	if (0xFFFFFFFF == ipAddr)
		return 0;

	//cxy 2016-02-25: set redirect ip to 0 means dns redirect func close
	mib_set(MIB_REDIRECT_IP, (void *)&ipAddr);
	ip4Addr.s_addr = ipAddr;
	syslog( LOG_DEBUG, "set REDIRECT addr to %s",inet_ntoa(ip4Addr));
	restart_dnsrelay();
	return 1;
}

int updateITMSAddr(unsigned int ipAddr)
{
	struct in_addr ip4Addr;
	if ((0 == ipAddr) || (0xFFFFFFFF == ipAddr))
		return 0;

	mib_set(MIB_ITMS_ADDR, (void *)&ipAddr);
	ip4Addr.s_addr = ipAddr;
	syslog( LOG_DEBUG, "set ITMS addr to %s",inet_ntoa(ip4Addr));
	restart_dnsrelay();
	return 1;
}

void web404RedirectCheck(void)
{
    rtk_rg_redirectHttpRsp_t redirectHttpRsp;
    char url[MAX_URL_LEN];
    unsigned char enable;

    mib_get(MIB_404_REDIRECT_ENABLE, &enable);
    if (enable)
    {
        mib_get(MIB_404_REDIRECT_URL, (void *)url);

        redirectHttpRsp.enable = 1;
        redirectHttpRsp.statusCode = 404;
        snprintf(redirectHttpRsp.url_str, MAX_URL_FILTER_STR_LENGTH, "%s", url);
        rtk_rg_redirectHttpRsp_set(&redirectHttpRsp);
    }
    else
    {
        rtk_rg_redirectHttpRsp_get(&redirectHttpRsp);
        redirectHttpRsp.enable = 0;
        rtk_rg_redirectHttpRsp_set(&redirectHttpRsp);
    }
}

void web404RedirectSet(char *url, int enable)
{
    unsigned char redirectEn;

    redirectEn = !!enable;
    mib_set(MIB_404_REDIRECT_ENABLE, (void *)&redirectEn);

    if (url)
        mib_set(MIB_404_REDIRECT_URL, (void *)url);

    web404RedirectCheck();
}

#ifdef SUPPORT_PUSHWEB_FOR_FIRMWARE_UPGRADE
struct webserver_callout pushweb_fresh_ch;
unsigned int pushweb_alive=0;

void pushweb_timeout(void)
{
    pushweb_alive = 0;
}

void pushweb_fresh(void)
{
    unsigned int dlPhase;
    unsigned int time;

    pushweb_alive = 1;

    mib_get(MIB_CWMP_DL_PHASE, (void *)&dlPhase);
    if (1 == dlPhase)
        time = 2 + 1; //web will refresh after 2s, 1 more second for robust
    else if (2 == dlPhase)
        time = 90 + 10;//web will refresh after 90s, 10 more seconf for robust
    else
        return;

    UNTIMEOUT(pushweb_timeout, 0, pushweb_fresh_ch);
    TIMEOUT((void*)pushweb_timeout, 0, time, pushweb_fresh_ch);
}

/*****************************************************************************
     : fwupgrade_pushweb_set
   : when do fwupgrade, push warn web for every user
 ? : int enable
             int width
             int height
             int top
             int left
             char * url
             int second
             int count
 ? : 
   ?  : static
 ?  :
   :

 ??      :
  1.       : 2016321
           : ql_xu
    ?   : ?

*****************************************************************************/
void fwupgrade_pushweb_set(int enable, int width, int height, int top, int left,
					char * url, int second, int count)
{
	memset((void*)&pushWebCfg, 0 , sizeof(pushWebCfg));

	if(url == NULL || strlen(url) == 0)
		return;

	if((strlen(url) >= MAX_URL_LEN) || strncmp(url, "http://", 7 ))
			return;

	strncpy(pushWebCfg.url, url, sizeof(pushWebCfg.url));
	pushWebCfg.width = width;
	pushWebCfg.height = height;
	pushWebCfg.top = top;
	pushWebCfg.left = left;

	pushWebEnable(enable, count);
	if(enable)
    {
        UNTIMEOUT(pushWebCheck, 0, pushWeb_ch);
		TIMEOUT(pushWebCheck, 0, second, pushWeb_ch);
    }

	return;
}

/*****************************************************************************
     : update_fwupgrade_phase
   : pushweb notify enable when do fwupgrade
 ? : phase: 1-firmware upgrading   2-rebooting 3-finish
 ? : 
   ?  :
 ?  :
   :

 ??      :
  1.       : 2016318
           : ql_xu
    ?   : ?

*****************************************************************************/
void update_fwupgrade_phase(int phase)
{
    unsigned char fwupgrade_pushwebnotify;
    unsigned int time=0;

    mib_set(MIB_CWMP_DL_PHASE, (void *)&phase);

    if (1 == phase)
        time = 180; //pushweb timeout
    else if (2 == phase)
        time = 180;
    else
        time = 30;

    mib_get(PROVINCE_FWUPGRADE_PUSHWEBNOTIFY, (void *)&fwupgrade_pushwebnotify);

    /*pushweb page is still alive, dont enable pushweb funtion anymore */
    if (pushweb_alive)
    {
        if ((1 == phase) || (2 == phase))
            sleep(30);
        return;
     }

	if (1 == fwupgrade_pushwebnotify)
	{
#ifdef CONFIG_YUEME
		fwupgrade_pushweb_set(1, 500, 300, 100, 100, "http://192.168.1.1:8080/dl_notify.asp", time, -1);
#else
		fwupgrade_pushweb_set(1, 500, 300, 100, 100, "http://192.168.1.1/dl_notify.asp", time, -1);
#endif
	}

    //wait for any user access web server
    if ((1 == phase) || (2 == phase))
    {
        printf("[sleep 30s in phase %d]\n", phase);
        sleep(30);
    }
}
#endif//endof SUPPORT_PUSHWEB_FOR_FIRMWARE_UPGRADE
#endif

#if defined(CONFIG_GPON_FEATURE)||defined(CONFIG_EPON_FEATURE)
#ifdef CONFIG_RTK_L34_ENABLE
#include <rtk_rg_define.h>
#endif
static int checkPONLinkStatus(void)
{
	int ponmode = 0;
	mib_get(MIB_PON_MODE, &ponmode);
#if defined(CONFIG_GPON_FEATURE)
	if(ponmode == GPON_MODE)
	{
		rtk_gpon_fsm_status_t gpon_state;

		memset( &gpon_state, 0, sizeof(rtk_gpon_fsm_status_t) );
#ifdef CONFIG_RTK_L34_ENABLE
		rtk_rg_gpon_ponStatus_get(&gpon_state);
#else
		rtk_gpon_ponStatus_get(&gpon_state);
#endif
		if(gpon_state == GPON_STATE_O5)
			return 1;
		fprintf(stderr, "<%s %d> gpon state:%d\n",__func__,__LINE__,gpon_state);
	}
#endif
#if defined(CONFIG_EPON_FEATURE)
	if(ponmode == EPON_MODE)
	{
		rtk_epon_llid_entry_t  llidEntry;

		memset(&llidEntry, 0, sizeof(rtk_epon_llid_entry_t));
		llidEntry.llidIdx = 0;
#ifdef CONFIG_RTK_L34_ENABLE
		rtk_rg_epon_llid_entry_get(&llidEntry);
#else
		rtk_epon_llid_entry_get(&llidEntry);
#endif
		if(llidEntry.valid)
			return 1;
		fprintf(stderr, "<%s %d> epon state:%d\n",__func__,__LINE__,llidEntry.valid);
	}
#endif
	return 0;
}

#ifdef CONFIG_GPON_FEATURE
#ifdef CONFIG_RTK_HOST_SPEEDUP
#define GPON_FLOWID_FILE "/proc/rtk_tr142/wan_info"
#define MAX_GPON_QUEUE_NUM 8
int set_speedup_usflow(MIB_CE_ATM_VC_T *pEntry)
{
        FILE*fp;
        char buff[128];
        int wanidx=-1;
        int usflow[MAX_GPON_QUEUE_NUM];
        char cmdStr[128];
        int pon_mode=0;

        mib_get(MIB_PON_MODE, (void *)&pon_mode);
        if (GPON_MODE != pon_mode)
                return -1;

        if(pEntry->rg_wan_idx == -1)
                return -1;

        if(fp=fopen(GPON_FLOWID_FILE,"r"))
        {
                int i,j;

                while(fgets(buff,sizeof(buff),fp)!=NULL)
                {
                        if(strstr(buff,"wanIdx"))
                        {
                                if(wanidx != -1)//another wan
                                        break;
                                //printf("buff= %s\n",buff);
                                if(sscanf(buff,"%*[^=]= %d", &wanidx)==1 && wanidx != pEntry->rg_wan_idx)
                                        wanidx = -1;
                        }
                        else if(wanidx!=-1)
                        {
                                //printf("<%s %d> get wan idx:%d\n",__func__,__LINE__,wanidx);
                                //printf("buff= %s\n",buff);
                                if(strstr(buff,"usFlowId"))
                                {
                                        sscanf(buff,"%*s = %d %d %d %d %d %d %d %d",
                                                &usflow[0],&usflow[1],&usflow[2],&usflow[3],
                                                &usflow[4],&usflow[5],&usflow[6],&usflow[7]);
                                }
                        }
                }
                fclose(fp);

                if(wanidx == -1)
                {
                        printf("<%s %d> not find valid wanidx\n",__func__,__LINE__);
                        return -1;
                }

                //snprintf(cmdStr, sizeof(cmdStr), "echo %d > /proc/HostSpeedUP-FLOWID", usflow[0]);
                //printf("<%s %d> %s\n", __func__, __LINE__, cmdStr);
                //system(cmdStr);
                add_rg_cf_rule_for_speedtest(pEntry, usflow[0]);

                return 0;
        }
        return -1;
}

int clear_speedup_usflow(void)
{
        flush_rg_cf_rule_for_speedtest();
}

int routeInternetWanCheck(void)
{
	int total, i, ret;
	MIB_CE_ATM_VC_T entry;
	struct in_addr inAddr;
	char ifname[64];

	total = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < total; i++)
	{
		if (mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
			continue;

		if ((entry.cmode != CHANNEL_MODE_BRIDGE) && (entry.applicationtype & X_CT_SRV_INTERNET) &&
				ifGetName(entry.ifIndex, ifname, sizeof(ifname)) &&
				getInFlags(ifname, &ret) &&
				(ret & IFF_UP) &&
				getInAddr(ifname, IP_ADDR, &inAddr))
		{
			set_speedup_usflow(&entry);
			return i;
		}
	}

	return -1;
}
#endif
#endif
#endif

#ifdef BOOT_SELF_CHECK
//cxy 2016-6-2: do self check after system up and wait for 20 seconds
#define MEM_TEST_SIZE 1000000
static int memtest(void)
{
	unsigned char* mem=NULL;
	unsigned char* mem1=NULL;
	int i;

	mem = malloc(MEM_TEST_SIZE);
	if(mem==NULL)
	{
		fprintf(stderr, "<%s %d> malloc memory fail\n",__func__,__LINE__);
		return 0;
	}
	mem1 = malloc(MEM_TEST_SIZE);
	if(mem1==NULL)
	{
		free(mem);
		fprintf(stderr, "<%s %d> malloc memory fail\n",__func__,__LINE__);
		return 0;
	}

	memset(mem, 0x5a, MEM_TEST_SIZE);
	for(i=0; i<MEM_TEST_SIZE; i++)
	{
		unsigned char* temp=mem+i;
		if(*temp != 0x5a)
			goto TEST_FAIL;
	}
	memcpy(mem1, mem, MEM_TEST_SIZE);
	if(memcmp(mem1, mem, MEM_TEST_SIZE)!=0)
		goto TEST_FAIL;

	memset(mem1, 0xa5, MEM_TEST_SIZE);
	for(i=0; i<MEM_TEST_SIZE; i++)
	{
		unsigned char* temp=mem1+i;
		if(*temp != 0xa5)
			goto TEST_FAIL;
	}
	memcpy(mem, mem1, MEM_TEST_SIZE);
	if(memcmp(mem, mem1, MEM_TEST_SIZE)!=0)
		goto TEST_FAIL;

	free(mem);
	free(mem1);
	return 1;
TEST_FAIL:
	free(mem);
	free(mem1);
	fprintf(stderr, "<%s %d>memory test fail!!!\n",__func__, __LINE__);
	return 0;
}

#ifdef CONFIG_USER_CWMP_TR069
static int checkTr069IpObtain(struct in_addr *tr069ip, char *tr069ifname)
{
	MIB_CE_ATM_VC_T entry;
	int i,total;
	struct in_addr ipaddr;

	total = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0; i<total; i++)
	{
		char intfname[IFNAMSIZ];

		if(!mib_chain_get(MIB_ATM_VC_TBL, i, &entry))
			continue;
		if(!entry.enable || !(entry.applicationtype&X_CT_SRV_TR069))
			continue;
		if(ifGetName(entry.ifIndex, intfname, sizeof(intfname)) == 0)
			continue;
		if(tr069ifname!=NULL)
			strcpy(tr069ifname, intfname);
		if(getInAddr(intfname, IP_ADDR, &ipaddr))
		{
			if(tr069ip!=NULL)
				memcpy(tr069ip,&ipaddr,sizeof(ipaddr));
			return 1;
		}
	}
	return 0;
}

static int checkTr069ServerReachable(void)
{
	char acsurl[256], ITMS_Server[256];
	char tr069ifname[IFNAMSIZ];
	char cmdstr[256];
	FILE*fp;
	int pktrecv=0;

	if(checkTr069IpObtain(NULL, tr069ifname)==0)
	{
		fprintf(stderr, "<%s %d> not exist tr069 interface or tr069 interface not get ip!\n",__func__,__LINE__);
		return 0;
	}
	fprintf(stderr, "tr069 ip is obtained\n");
	if(!mib_get(CWMP_ACS_URL, (void*)acsurl))
	{
		fprintf(stderr, "<%s %d> Get mib value CWMP_ACS_URL failed!\n",__func__,__LINE__);
		return 0;
	}

	set_endpoint(ITMS_Server, acsurl);
	snprintf(cmdstr, sizeof(cmdstr),"/bin/ping -c 3 -W 6 -I %s %s > /tmp/tr069acspingresult", tr069ifname, ITMS_Server);
	//fprintf(stderr, "%s\n",cmdstr);
	system(cmdstr);
	if(fp=fopen("/tmp/tr069acspingresult","r"))
	{
		while(fgets(cmdstr, sizeof(cmdstr), fp))
		{
			if(sscanf(cmdstr,"%*s packets transmitted, %d packets received, %*s packet loss",&pktrecv)==1)
				break;
		}
		fclose(fp);
		if(pktrecv > 0)
			return 1;
	}
	fprintf(stderr, "<%s %d> ACS server unreachable!\n",__func__,__LINE__);
	return 0;
}
#endif

int bootSelfCheck(void)
{
	fprintf(stderr, "start boot self check##########\n");
	if(memtest()==0)
	{
		goto CHECK_FAIL;
	}
	fprintf(stderr, "memtest pass\n");
#if defined(CONFIG_GPON_FEATURE)||defined(CONFIG_EPON_FEATURE)
	if(checkPONLinkStatus()==0)
	{
		goto CHECK_FAIL;
	}
	fprintf(stderr, "PON port link up\n");
#endif
#ifdef CONFIG_USER_CWMP_TR069
//	if(checkTr069ServerReachable() == 0)
//	{
//		goto CHECK_FAIL;
//	}
//	fprintf(stderr, "tr069 server is reachable\n");
#endif

	fprintf(stderr, "endof boot self check success##########\n");
	return 1;
CHECK_FAIL:
	fprintf(stderr, "endof boot self check fail##########\n");
#ifdef SUPPORT_WEB_REDIRECT
	char lanipbuf[32];
	getMIB2Str(MIB_ADSL_LAN_IP,lanipbuf);
	sprintf(pushWebCfg.url, "http://%s/selfcheckfail.asp",lanipbuf);
	pushWebCfg.width = 500;
	pushWebCfg.height = 300;
	pushWebCfg.top = 100;
	pushWebCfg.left = 100;

	pushWebEnable(1, -1);
	sleep(60);
	pushWebEnable(0, -1);
#endif
	return 0;
}
#endif

#ifdef CONFIG_RTK_L34_ENABLE
#include "rtusr_rg_api.h"
#endif

#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
void flush_old_ip6sec_prefix(const char *filename, PREFIX_V6_INFO_T *prefixInfo)
{
	FILE* fp=NULL;
	char buf[256];
	char *p_start,*p_end;
	unsigned int prefix_len;
	struct in6_addr	ip6_addr;

	if(fp=fopen(filename, "r"))
	{
		while(fgets(buf, sizeof(buf), fp))
		{
			if(p_start=strstr(buf,"prefix "))
			{
				p_start+=7;
				if(p_end=strstr(p_start,"/"))
				{
					*p_end='\0';
					p_end++;
					inet_pton(AF_INET6, p_start, &ip6_addr);
					prefix_len = atoi(p_end);
					if(!prefixInfo || (prefixInfo->prefixLen != prefix_len) || memcmp(prefixInfo->prefixIP,&ip6_addr,IP6_ADDR_LEN))		
						va_cmd(IP6SECCTRL,5,1,"-D","-a",p_start,"-l",p_end);
				}			
			}
		}
		fclose(fp);
	}
}
#endif

static int startWanServiceDependency(int ipEnabled, int isBoot)
{
	char vChar=-1;
	int ret;

#ifdef DEFAULT_GATEWAY_V2
	unsigned char dgwip[16];
	unsigned int dgw;
	if (mib_get(MIB_ADSL_WAN_DGW_ITF, (void *)&dgw) != 0) {
		if (dgw == DGW_NONE && getMIB2Str(MIB_ADSL_WAN_DGW_IP, dgwip) == 0) {
			if (ifExistedDGW() == 1)
				va_cmd(ROUTE, 2, 1, ARG_DEL, "default");
			// route add default gw remotip
			va_cmd(ROUTE, 4, 1, ARG_ADD, "default", "gw", dgwip);
		}
	}
#endif

	// Add static routes
	// Mason Yu. Init hash table for all routes on RIP
	addStaticRoute();
#ifdef CONFIG_IPV6
	addStaticV6Route();
#endif

#if defined(CONFIG_IPV6) && defined(CONFIG_USER_RADVD)
	//Kill originally running RADVD daemon.
//Alan
//1. fix IPv4 routing WAN only, the radvd process still exist
//2. configd and boa both will restart radvd, we leave configd to start radvd
	ret = radvdRunningMode();
	if (ret == RADVD_RUNNING_MODE_DISABLE)
	{
		int pid = read_pid((char *)RADVD_PID);
		if ( pid > 0)
		{
			printf("Bridge mode or only IPv4 WAN, kill the original radvd deamon.\n");
			kill(pid,SIGTERM);
			//radvd will remove pid file, we do not remove pid file
			//va_cmd("/bin/rm", 1, 0, (char *)RADVD_PID);
#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
			flush_old_ip6sec_prefix(RADVD_CONF, NULL);
#endif
		}
	}
	else if (ret == RADVD_RUNNING_MODE_STATIC) {
		restartRadvd();
	}
#endif

//update dnsmasq.conf
	cmd_set_dns_config(NULL);

//IulianWu. move the proc operation to /etc/init.d/rcX
/*

    if (ipEnabled!=1)
	{
		setup_ipforwarding(0);
	}
*/

#ifdef CONFIG_USER_ROUTED_ROUTED
	if (startRip() == -1)
	{
		printf("start RIP failed !\n");
		ret = -1;
	}
#endif

#ifdef TIME_ZONE
	if (startNTP())
	{
		printf("start SNTP failed !\n");
		ret = -1;
	}
#endif

#ifdef CONFIG_CMCC_OSGIMANAGE
	if (startOsgiManage() == -1)
	{
		printf("start OsgiManage failed !\n");
		ret = -1;
	}
#endif


#ifdef CONFIG_USER_ZEBRA_OSPFD_OSPFD
	if (startOspf() == -1)
	{
		printf("start OSPF failed !\n");
		ret = -1;
	}
#endif

#ifdef CONFIG_USER_IGMPPROXY
#ifdef CONFIG_IGMPPROXY_MULTIWAN
		if (setting_Igmproxy() == -1)
		{
			printf("start IGMP proxy failed !\n");
			ret = -1;
		}
#else
		if (startIgmproxy() == -1)
		{
			printf("start IGMP proxy failed !\n");
			ret = -1;
		}
#endif // of CONFIG_IGMPPROXY_MULTIWAN
#endif // of CONFIG_USER_IGMPPROXY

// Mason Yu. MLD Proxy
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_ECMH
		if (startMLDproxy() == -1)
		{
			printf("start MLD proxy failed !\n");
			ret = -1;
		}
#endif // of CONFIG_USER_ECMH
#endif
	// execute firewall rules
	if (setupFirewall(isBoot) == -1)
	{
		printf("execute firewall rules failed !\n");
		ret = -1;
	}
#ifdef CONFIG_IP_NF_ALG_ONOFF
	if(setupAlgOnOff()==-1)
	{
		printf("execute ALG on-off failed!\n");
	}
#endif

#if 0 //eason path for pvc add/del and conntrack killall
	// Kaohj --- remove all conntracks
	va_cmd("/bin/ethctl", 2, 1, "conntrack", "killall");
#endif

#ifdef WEB_REDIRECT_BY_MAC
	if( -1==start_web_redir_by_mac() )
		ret=-1;
#endif

#ifdef _SUPPORT_CAPTIVEPORTAL_PROFILE_
	unsigned char cp_enable;
	char cp_url[MAX_URL_LEN];

	mib_get(MIB_CAPTIVEPORTAL_ENABLE, (void *)&cp_enable);
	mib_get(MIB_CAPTIVEPORTAL_URL, (void *)cp_url);
	
	if(cp_enable && cp_url[0])
	{
		if( -1 == start_captiveportal() )
			ret = -1;
	}
#ifdef CONFIG_SUPPORT_CAPTIVE_PORTAL	
	else
		enable_http_redirect2CaptivePortalURL(0);
#endif	

#endif

	return ret;
}

#if ! defined(_LINUX_2_6_) && defined(CONFIG_RTL_MULTI_WAN)
int initWANMode()
{
	FILE *fp;
	int wan_mode=0;
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE) || defined(CONFIG_FIBER_FEATURE)
	mib_get(MIB_PON_MODE, &wan_mode);
#endif
	
	fp = fopen("/proc/rtk_smux/wan_mode", "w");
	if(fp){
		fprintf(fp, "%d", wan_mode);
		fclose(fp);
	}
#if defined(CONFIG_FIBER_FEATURE)	
	if(wan_mode == FIBER_MODE){
		system("/bin/ethctl enable_nas0_wan 1");
	}
#endif
	return 1;
}
static void checkWanModeStatus()
{
	int wan_mode=0, ret = 0;
	char cmd[64] = {0};
	
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE) || defined(CONFIG_FIBER_FEATURE)
	mib_get(MIB_PON_MODE, &wan_mode);
	if(wan_mode == FIBER_MODE || wan_mode == ETH_MODE)
		ret = 1;
#if defined(CONFIG_EPON_FEATURE) 
	else if(wan_mode == EPON_MODE)
	{
		rtk_epon_llid_entry_t  llidEntry;
		memset(&llidEntry, 0, sizeof(rtk_epon_llid_entry_t));
		llidEntry.llidIdx = 0;
#ifdef CONFIG_RTK_L34_ENABLE
		rtk_rg_epon_llid_entry_get(&llidEntry);
#else
		rtk_epon_llid_entry_get(&llidEntry);
#endif
		if(llidEntry.valid){
			ret = epon_getAuthState(llidEntry.llidIdx);
		}
	}
#endif
#else
	ret = 1;
#endif

	if (ret == 1){
		printf(">>>> Checked WAN Mode is connected, recover SMUX interface status ......\n");
		snprintf(cmd, sizeof(cmd)-1, "/bin/ethctl setsmux %s \"*\" carrier 1", ALIASNAME_NAS0);
		system (cmd);
	}
}
#endif

#if defined(CONFIG_CT_AWIFI_JITUAN_SMARTWIFI)
static int get_internet_wan_name(char *name, unsigned int len)
{
	int i,vcTotal;
	char ifname[IFNAMSIZ];
	MIB_CE_ATM_VC_T Entry;

	vcTotal = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < vcTotal; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;
		if (Entry.enable == 0)
			continue;
		if((Entry.applicationtype & X_CT_SRV_INTERNET) && (Entry.cmode != CHANNEL_MODE_BRIDGE))
		{
			if(ifGetName(Entry.ifIndex, ifname, len))
			{
				int flags_found,flags;
				struct in_addr inAddr;
				flags_found = getInFlags(ifname, &flags);
				if (flags_found && getInAddr(ifname, IP_ADDR, &inAddr) == 1){
					strcpy(name,ifname);
					return 1;
				}
			}
		}
	}
	return 0;
}
struct webserver_callout wifiAuth_ch;
void wifiAuthCheck(void * null)
{
	int ret=0,retDog=0,retAudit=0,retWan,restart=0;
	char cmdWanName[WA_MAX_WAN_NAME]={0};
	char curWanName[WA_MAX_WAN_NAME]={0};
	static char internetWanName[WA_MAX_WAN_NAME]={0};
	char wifidogenable=0;
	int retQzt=0;

	unsigned char awifi_audit_mode=0;

	static int lanauthrule=0;

	if(!lanauthrule){
		awifiAddFwRuleChain();
		lanauthrule=1;
	}
	if((access(WIFIDOGPATH,F_OK))==-1) 	
	{
		printf(WIFIDOGPATH" not exists.\n");
		system("cp /bin/smartwifi "WIFIDOGPATH);
	}

	if((access(WIFIDOGBAKCONFPATH,F_OK))==-1) 	
	{
		printf(WIFIDOGBAKCONFPATH" not exists.\n");
		system("cp /etc/awifi.conf "WIFIDOGBAKCONFPATH);
	}
	
	if((access(WIFIDOGCONFPATH,F_OK))==-1) 	
	{
		printf(WIFIDOGCONFPATH" not exists.\n");
		system("cp /var/config/awifi/awifi_bak.conf "WIFIDOGCONFPATH);
	}

	if((access("/var/config/awifi/smctl",F_OK))==-1) 	
	{
		printf("/var/config/awifi/smctl not exists.\n");
		system("cp /bin/smctl /var/config/awifi/smctl");
	}

	if((access("/var/config/awifi/awifi.html",F_OK))==-1) 	
	{
		printf("/var/config/awifi/awifi.html not exists.\n");
		system("cp /etc/awifi.html /var/config/awifi/awifi.html");
	}

	if((access("/var/config/awifi/libhttpd.so",F_OK))==-1) 	
	{
		printf("/var/config/awifi/libhttpd.so not exists.\n");
		system("cp /etc/libhttpd.so /var/config/awifi/libhttpd.so");
		system("ln -s /var/config/awifi/libhttpd.so /var/config/awifi/libhttpd.so.0");
	}

	if((access("/var/config/awifi/libawifi.so",F_OK))==-1) 	
	{
		printf("/var/config/awifi/libawifi.so not exists.\n");
		system("cp /etc/libawifi.so /var/config/awifi/libawifi.so");
	}

#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_CT_AWIFI_JITUAN_SMARTWIFI)
	static char awifienable_orig=0;
	char awifienable=0;
	MIB_CE_MBSSIB_T Entry;
	ret=wlan_getEntry(&Entry, 1);
	if(ret)
	{
		awifienable=!Entry.wlanDisabled;
	}	

	if(awifienable !=awifienable_orig)
	{
		RTK_RG_Wifidog_Rule_set();
		awifienable_orig = awifienable;
	}
#endif

#if 0
	MIB_CE_MBSSIB_T Entry;
	ret=wlan_getEntry(&Entry, 1);
	if(ret)
	{
		wifidogenable=!Entry.wlanDisabled;
	}
#else
	wifidogenable=1;
#endif
	{
		FILE *fp;
		char buf[64];
		unsigned int killflag=0;
		unsigned int wlanrestartflag=0;
		unsigned int resetdhcpflag=0;

		fp=fopen("/tmp/wlanrestart","r");
		if(fp){
			if(fgets(buf,64,fp)){
				sscanf(buf,"restart:%u\n",&wlanrestartflag);
			}
			if(wlanrestartflag){
				printf("get restart %d\n",wlanrestartflag);
			}
			fclose(fp);
			if(wlanrestartflag){
#ifdef CONFIG_WIFI_SIMPLE_CONFIG // WPS
				update_wps_configured(0);
#endif
				config_WLAN(ACT_RESTART, CONFIG_SSID_ALL);
			}	
			unlink("/tmp/wlanrestart");
			goto AUTH_END;
		}

		fp=fopen("/tmp/killsmartwifi","r");
		if(fp){
			if(fgets(buf,64,fp)){
				sscanf(buf,"killflag:%u\n",&killflag);
			}
			if(killflag){
				printf("get killflag %d\n",killflag);
			}
			fclose(fp);
			if(killflag){
				wifidogenable=0;
			}
			unlink("/tmp/killsmartwifi");
		}

		fp=fopen("/tmp/resetdhcp","r");
		if(fp){
			if(fgets(buf,64,fp)){
				sscanf(buf,"resetdhcp:%u\n",&resetdhcpflag);
			}
			if(resetdhcpflag){
				printf("get resetdhcp %d\n",resetdhcpflag);
			}
			fclose(fp);
			if(resetdhcpflag){
				unsigned int i,numpool;
				unsigned char sourceinterface;
				unsigned char lan1port,lan2port,lan3port,lan4port,ssid1port;
				int changeflag=0;

				mib_get(AWIFI_LAN1_AUTH_ENABLE,&lan1port);
				mib_get(AWIFI_LAN2_AUTH_ENABLE,&lan2port);
				mib_get(AWIFI_LAN3_AUTH_ENABLE,&lan3port);
				mib_get(AWIFI_LAN4_AUTH_ENABLE,&lan4port);
				mib_get(AWIFI_WLAN1_AUTH_ENABLE,&ssid1port);
				
				sourceinterface=0x20;
				if(lan1port)
					sourceinterface|=0x01;
				if(lan2port)
					sourceinterface|=0x02;
				if(lan3port)
					sourceinterface|=0x04;
				if(lan4port)
					sourceinterface|=0x08;
				if(ssid1port)
					sourceinterface|=0x10;
				numpool = mib_chain_total( MIB_DHCPS_SERVING_POOL_AWIFI_TBL );
				for( i=0; i<numpool;i++ )
				{
					unsigned int j,num;
					DHCPS_SERVING_POOL_T entrypool;

					if( !mib_chain_get( MIB_DHCPS_SERVING_POOL_AWIFI_TBL, i, (void*)&entrypool ) )
						continue;

					//skip disable or relay pools
					if( entrypool.enable==0)
						continue;

					if(strcmp(entrypool.poolname,"awifi"))
						continue;

					printf("find pool!\n");

					if(entrypool.sourceinterface != sourceinterface)
						changeflag = 1;
					entrypool.sourceinterface = sourceinterface;

					printf("change awifi pool interface to 0x%x\n",entrypool.sourceinterface);

					mib_chain_update(MIB_DHCPS_SERVING_POOL_AWIFI_TBL,(void*)&entrypool,i);
					break;
				}
				if(changeflag){
					restart_dhcp();
                    RTK_RG_Wifidog_Rule_set();
// Magician: Commit immediately
#ifdef COMMIT_IMMEDIATELY
					Commit();
#endif // of #if COMMIT_IMMEDIATELY
				}
			}
			unlink("/tmp/resetdhcp");
		}
	}
#if 1
	FILE *fp;
	size_t len=0;
	ssize_t read;
	char *line=NULL;
	int line_cnt=0;
	fp=popen("ps","r");
	while((read = getline(&line,&len,fp))!=-1)
	{
		line_cnt++;
		//printf("%s\n",line);
		if(!retDog && strstr(line, WIFIDOGPATH))
		{
			retDog=1;
		}
		if(retDog 
		)
		{
			break;
		}
	}
	if(line)
		free(line);
	pclose(fp);
	if(line_cnt == 0)
	{
		printf("%s:%d: nothing can be read from ps !\n",__func__,__LINE__);
		goto AUTH_END;
	}
#else
	retDog=find_pid_by_name("wifidog",NULL,0);
	//printf("@@---%s#%d---retDog=%d--retAudit=%d--@@\n",__FUNCTION__,__LINE__,retDog,retAudit);
#endif
	//printf("@@---%s#%d---retDog=%d--wifidogenable=%d--@@\n",__FUNCTION__,__LINE__,retDog,wifidogenable);
	if(!wifidogenable)
	{
		if(retDog)
		{
			system(KILLWIFIDOGSTR);
		}
		goto AUTH_END;
	}
	retWan=get_internet_wan_name(curWanName,sizeof(curWanName));
	if(!retDog)
	{//wifidog hasn't started
		if(retWan)
		{
            void *null;
			printf("%s:%d:start wifi dog!\n",__func__,__LINE__);
			startWiFiDog(null);
			restart=1;
		}
		//no internet wan keep stop
	}else
	{//started
		if(retWan)
		{
			if(strncmp(curWanName,internetWanName,WA_MAX_WAN_NAME))
			{//internet wan changed
				printf("%s:%d:restart wifi dog!\n",__func__,__LINE__);
				restartWiFiDog(0);
				restart=1;
			}
		}else
		{//no internet wan
			if(retDog)
			{
				printf("%s:%d:kill wifi dog!\n",__func__,__LINE__);
				system(KILLWIFIDOGSTR);
			}
		}
	}
	if(retWan)
		strncpy(internetWanName,curWanName,WA_MAX_WAN_NAME);
	else
		internetWanName[0]=0;
	if(!restart && g_wan_modify && retWan)
	{
		printf("%s:%d:start wifi auth!\n",__func__,__LINE__);
		restartWiFiDog(0);
		g_wan_modify=0;
	}

AUTH_END:
	TIMEOUT(wifiAuthCheck, 0, 5, wifiAuth_ch); 
}
#endif

//--------------------------------------------------------
// WAN startup
// return value:
// 1  : successful
// -1 : failed
// configAll = CONFIGALL,  pEntry = NULL  : start all WAN connections(include VC, ETHWAN, PTMWAN, VPN, 3g).
// configAll = CONFIGONE, pEntry != NULL : start specified VC, ETHWAN, PTMWAN connection and VPN, 3g connections.
// configAll = CONFIGONE, pEntry = NULL  : start VPN, 3g connections.
int startWan(int configAll, MIB_CE_ATM_VC_Tp pEntry, int isBoot)
{
	char action_type_str[128] = {0};
	int vcTotal, i, ret;
	MIB_CE_ATM_VC_T Entry;
	int ipEnabled;
	FILE *fp;
	char vcNum[16];
	char ifname[IFNAMSIZ];
	char vChar=-1;
#ifdef CONFIG_USER_BEHAVIOR_ANALYSIS
	unsigned char ba_enable = 0;
	mib_get(MIB_BA_ENABLE, &ba_enable);
/*
 * FIXME: br_wan rules let snort cannot inspect packets.
*/
	if(!ba_enable)	
#endif	
	block_br_wan();

	ret = 1;
	vcTotal = mib_chain_total(MIB_ATM_VC_TBL);

	ipEnabled = 0;
	AUG_PRT("%s %s\n", __func__, config_WAN_action_type_to_str(configAll, pEntry, 1, action_type_str));
	syslog(LOG_INFO, "%s", config_WAN_action_type_to_str(configAll, pEntry, 1, action_type_str));

	// Mason Yu.
	//If it is a router modem , we should config forwarding first.
	// Because the /proc/.../conf/all/forwarding value, will affect /proc/.../conf/vc0/forwarding value.
	//IulianWu. move the proc operation to /etc/init.d/rcX
	//setup_ipforwarding(1);

	//check slave wifi enable should before RG_add_wan()
#if defined(WLAN_DUALBAND_CONCURRENT) && defined(CONFIG_LUNA_DUAL_LINUX)
	check_slave_wifi_bind_en();
	check_slave_wifi_en();
#endif

#if defined(CONFIG_RTL_MULTI_ETH_WAN)



	for (i = 0; i < vcTotal; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				return -1;

		if (Entry.enable == 0)
			continue;

		if(configAll == CONFIGALL)
		{
			//need add smux interafce first, because, for GPON case, use TR142 notify SMUX carrier on
			addEthWANdev(&Entry); 
#ifdef CONFIG_RTK_L34_ENABLE
			RG_flush_vlanBinding_by_WanVID(Entry.vid);
			// Call RG_add_wan before addEthWANdev because addEthWANdev() will trigger link change events.
			RG_add_wan(&Entry, i);
#endif
		}
		else if(configAll == CONFIGONE)
		{
			 if(pEntry && Entry.ifIndex == pEntry->ifIndex)
			 {
				//need add smux interafce first, because, for GPON case, use TR142 notify SMUX carrier on
				addEthWANdev(&Entry);
#ifdef CONFIG_RTK_L34_ENABLE
				RG_flush_vlanBinding_by_WanVID(Entry.vid);
				// Call RG_add_wan before addEthWANdev because addEthWANdev() will trigger link change events.
				RG_add_wan(&Entry, i);
#endif
				break;
			 }
		}
	}
#endif	//defined(CONFIG_RTL_MULTI_ETH_WAN)

	// If we set forwarding=1 for all, then the every interafce's forwarding will be modified to 1.
	// So we must set forwarding=1 for all first, then set every interafce's forwarding.
	// Mason Yu.
	//IulianWu. move the proc operation to /etc/init.d/rcX
	//setup_ipforwarding(1);
#ifdef CONFIG_USER_PPPOMODEM
	// wan3g run as routed mode
	ipEnabled = wan3g_start();
#endif //CONFIG_USER_PPPOMODEM

	if (configAll == CONFIGCWMP)
	{
		printf("[%s@%d] CONFIGCWMP start\n", __FUNCTION__, __LINE__);
		FILE *f_start = NULL;
		f_start = fopen(CWMP_START_WAN_LIST, "r");
		int ifIdx = 0;
		if (f_start == NULL)
		{
			printf("[%s@%d] Open list file fail\n", __FUNCTION__, __LINE__);
			return -1;
		}
		else
		{
			while (fscanf(f_start, "%d\n", &ifIdx) != EOF)
			{
				printf("[%s@%d] ifIdx = %d\n", __FUNCTION__, __LINE__, ifIdx);
				for (i = 0; i < vcTotal; i++)
				{
					if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
						continue;

					if (Entry.enable == 0)
						continue;

					if (Entry.ifIndex == ifIdx)
					{
#if defined(CONFIG_RTL_MULTI_ETH_WAN)
						addEthWANdev(&Entry);
#ifdef CONFIG_RTK_L34_ENABLE
						RG_flush_vlanBinding_by_WanVID(Entry.vid);
						// Call RG_add_wan before addEthWANdev because addEthWANdev() will trigger link change events.
						RG_add_wan(&Entry, i);
#endif
#endif

						ret |= startConnection(&Entry, i);
						break;
					}
				}
			}
			fclose(f_start);
		}
	}
	else
	{
		for (i = 0; i < vcTotal; i++)
		{
			/* get the specified chain record */
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				return -1;

			if(!isInterfaceMatch(Entry.ifIndex))  // Magician: Only raise interfaces that was set by wan mode.
				continue;

			if (Entry.enable == 0)
				continue;

			if (configAll == CONFIGALL) 		// config for ALL
				ret|=startConnection(&Entry, i);
			else	 if (configAll == CONFIGONE)	// config for one
			{
				if (pEntry != NULL) {
					if ( Entry.ifIndex == pEntry->ifIndex) {
						ret|=startConnection(&Entry, i);
					}
					else
						continue;
				}
				else
					break;		// If pEntry == NULL, It mean we want to delete this channel.
			}

		}
	}

	startSNAT();
	for (i = 0; i < vcTotal; i++) /* Check have any ROUTING WAN, IulianWu*/
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;
		if (Entry.enable == 0)
			continue;
		if ((CHANNEL_MODE_T)Entry.cmode != CHANNEL_MODE_BRIDGE)
			ipEnabled = 1;
	}

	ret = startWanServiceDependency(ipEnabled, isBoot);
	
#if ! defined(_LINUX_2_6_) && defined(CONFIG_RTL_MULTI_WAN)
	checkWanModeStatus();
#endif
	return ret;
}

#ifdef E8B_NEW_DIAGNOSE
int findpvcfileid(const pvc_status_entry oldentry)
{
	int i;
	char buf[32];
	FILE *fp;
	pvc_status_entry entry;

	memset(&entry, 0, sizeof(entry));
	for (i = 1; ; i++) {
		sprintf(buf, "%s%d", PVC_FILE, i);
		fp = fopen(buf, "rb+");
		if (fp) {
			fread(&entry, 1, sizeof(entry), fp);
			fclose(fp);
			if (entry.vpi == oldentry.vpi && entry.vci == oldentry.vci) {
				break;
			}
		} else {
			break;
		}
	}

	return i;
}

int findmatchpvcfileid(pvc_status_entry *pvcentry)
{
	int i;
	char buf[32];
	FILE *fp;
	pvc_status_entry entry;

	memset(&entry, 0, sizeof(entry));
	for (i = 1; ; i++) {
		sprintf(buf, "%s%d", PVC_FILE, i);
		fp = fopen(buf, "rb+");
		if (fp) {
			fread(&entry, 1, sizeof(entry), fp);
			fclose(fp);
			if (entry.vpi == pvcentry->vpi && entry.vci == pvcentry->vci) {
				memcpy(pvcentry, &entry, sizeof(entry));
				return i;
			}
		} else {
			return 0;
		}
	}
}

void clearpvcfile()
{
	int i;
	char buf[32];
	FILE *fp;

	for (i = 1; ; i++) {
		sprintf(buf, "%s%d", PVC_FILE, i);
		fp = fopen(buf, "rb+");
		if (fp) {
			fclose(fp);
			unlink(buf);
		} else {
			break;
		}
	}
}

void cleardelpvcfile()
{
	int i;
	char buf[32];
	FILE *fp;
	pvc_status_entry entry;

	for (i = 1; ; i++) {
		sprintf(buf, "%s%d", PVC_FILE, i);
		fp = fopen(buf, "rb+");
		if (fp) {
			fread(&entry, 1, sizeof(entry), fp);
			fclose(fp);
			if (!strcmp(entry.action, "del"))
				unlink(buf);
		} else {
			break;
		}
	}
}

void clearssidfile()
{
	int i;
	char buf[32];
	FILE *fp;
	pvc_status_entry entry;

	for (i = 1; i <= 5; i++) {
		sprintf(buf, "%s%d", SSID_FILE, i);
		unlink(buf);
	}
}

void clearremotefile()
{
	clearpvcfile();
	clearssidfile();
	unlink(USERLIMIT_FILE);
	unlink(QOS_FILE);
	unlink(NEW_SETTING);
}

void check_inform_status(int firstflag)
{
	char tmpbuf[256 + 1];
	FILE *fp;
	unsigned int regResult;

	if (firstflag) {
		fp = fopen(CONNREQ_STATUS_FILE, "w");
		if (fp) {
			fprintf(fp, "%d", NO_REQUEST);
			fclose(fp);
		}
	}

	mib_get(CWMP_USERINFO_RESULT, &regResult);
	if (regResult == SET_FAULT) {
		fp = fopen(NEW_SETTING, "r");
		if (fp) {
			fgets(tmpbuf, sizeof(tmpbuf), fp);
			fclose(fp);
		}
		if (!strcmp(tmpbuf, PVC_FILE)) {
			clearpvcfile();
		} else if (!strcmp(tmpbuf, SSID_FILE)) {
			clearssidfile();
		} else if (!strcmp(tmpbuf, USERLIMIT_FILE)) {
			unlink(USERLIMIT_FILE);
		} else if (!strcmp(tmpbuf, QOS_FILE)) {
			unlink(QOS_FILE);
		}
	}
}
#endif	//E8B_NEW_DIAGNOSE

#ifdef CONFIG_MIDDLEWARE
void mwSetFirewall(int set)
{
	const char *act;
	if(set)
		act = FW_ADD;
	else
		act = FW_DEL;
	va_cmd(IPTABLES, 8, 1, (char *)act, (char *)FW_INPUT, "-p",
		"tcp", (char *)FW_DPORT, "9080", "-j", (char *)FW_ACCEPT);
	va_cmd(IPTABLES, 8, 1, (char *)act, (char *)FW_INPUT, "-p",
		"tcp", (char *)FW_DPORT, "30005", "-j", (char *)FW_ACCEPT);
}

int sendMsg2MidProcess(struct mwMsg * pMsg)
{
	int spid;
	FILE * spidfile;
	int msgid;
	msgid = msgget((key_t)1357,  0666);
	if(msgid <= 0){
	//	fprintf(stdout,"Saved: get cwmp msgqueue error in %s!\n",__FUNCTION__);
		return -1;
	}

	/* get midware interface pid*/
	if ((spidfile = fopen(CWMP_MIDPROC_RUNFILE, "r"))) {
		fscanf(spidfile, "%d\n", &spid);
		fclose(spidfile);
	}else{
		fprintf(stdout,"Saved: midware midprocess pidfile not exists in %s\n",__FUNCTION__);
		return -1;
	}

	pMsg->msg_type = spid;
	pMsg->msg_datatype = MSG_MIDWARE;
	if(msgsnd(msgid, (void *)pMsg, MW_MSG_SIZE, 0) < 0){
		fprintf(stdout,"Saved: send message to midprocess error in %s!\n",__FUNCTION__);
		return -1;
	}

	return 0;
}

int sendSetDefaultFlagMsg2MidProcess()
 {
	struct mwMsg sendMsg;
	char * sendBuf = sendMsg.msg_data;

	*(sendBuf) = OP_SetDefaultFlag;
	return(sendMsg2MidProcess(&sendMsg));

 }

int sendInformEventMsg2MidProcess( unsigned char eventCode )
{
	struct mwMsg sendMsg;
	char * sendBuf = sendMsg.msg_data;
	*(sendBuf) = OP_informEvent;
	*(sendBuf+1) = eventCode;
	*(sendBuf+2) = 0;
	return (sendMsg2MidProcess(&sendMsg));
}

 static int sendMsg2MidIntf(struct mwMsg * pMsg)
{
	int spid;
	FILE * spidfile;
	int msgid;

	msgid = msgget((key_t)1357,  0666);
	if(msgid <= 0){
		fprintf(stdout,"Saved: get cwmp msgqueue error in %s!\n",__FUNCTION__);
		return -1;
	}

	/* get midware interface pid*/
	if ((spidfile = fopen(MW_INTF_RUNFILE, "r"))) {
		fscanf(spidfile, "%d\n", &spid);
		fclose(spidfile);
	}else{
		fprintf(stdout,"Saved: midware interface pidfile not exists in %s\n",__FUNCTION__);
		return -1;
	}

	pMsg->msg_type = spid;
	pMsg->msg_datatype = PACKET_OK;
	if(msgsnd(msgid, (void *)pMsg, MW_MSG_SIZE, 0) < 0){
		fprintf(stdout,"Saved: send message to midwareintf error in %s!\n",__FUNCTION__);
		return -1;
	}

	return 0;
}

int sendSetDefaultRetMsg2MidIntf()
{
	struct mwMsg sendMsg;
	char * sendBuf = sendMsg.msg_data;

	*sendBuf = OP_SetDefaultRet;		/*Opcode*/
	*(sendBuf+1) = 0;				/*N*/
	return(sendMsg2MidIntf(&sendMsg));
}


/* send Exit cmd:boa process -> midProcess(tr069) -> midware_inf process -> ctadmin
 * ctadmin will exit itself
 */
 int sendMWExit2Midproc()
 {
	struct mwMsg sendMsg;
	char * sendBuf = sendMsg.msg_data;

	*(sendBuf) = OP_MWExit;
	return(sendMsg2MidProcess(&sendMsg));
 }

int apply_Midware( int action_type, int id, void *olddata )	/*note: cann't restart cwmp process for apply immediately*/
{
	unsigned char oldValue,vChar;

	oldValue = *((unsigned char *)olddata);
	mib_get(CWMP_TR069_ENABLE,(void *)&vChar);

	if(oldValue == 1 && vChar == 2){	/*start midware*/
		/*midprocess thread will be started in cwmp_main process*/
		//setMidwareRouteFW(1);
		mwSetFirewall(1);
		if(read_pid((char*)MWINTF_MAIN_RUNFILE) <= 0){ //midware interface is not started
			va_cmd( "/bin/midware_intf", 0, 0 );
		}
		//start midware bootprocess
		//va_cmd( "/usr/bin/ctadmin_realtek", 1, 0,"s=2" );	//call ct_midware bootstrap
		va_cmd( "/usr/local/ct/ctadmin", 1, 0,"s=2" );	//call ct_midware bootstrap
	}

	if(oldValue == 2 && vChar == 1){	/*close midware*/
		int loopcount = MW_EXIT_WAIT_TIME;
		int midware_intf_pid = 0;
		/*midprocess thread will be closed by itself*/
		/*wait ct_midware Exit*/
		while(loopcount){
			midware_intf_pid = read_pid((char*)MWINTF_MAIN_RUNFILE);
			if(midware_intf_pid > 0)
				loopcount--;
			else
				break;
			sleep(1);
		}

		mwSetFirewall(0);
		//delMidwareRouteFW();//delete MW route entry
		midware_intf_pid = read_pid((char*)MWINTF_MAIN_RUNFILE);
		if(midware_intf_pid > 0)
			kill(midware_intf_pid,SIGTERM);
	}

	return 0;
}
#endif

#ifdef CONFIG_USER_DBUS_CTC_IGD
int send_msg_ctc_igd_server(struct ctc_igd_sys_msgbuf *pMsg)
{
	int msgid;
	key_t key;
	key = ftok( "/bin/ctc-igd-server", 'c');
	if(read_pid("/var/run/ctc-igd-server.pid") > 0){
		if((msgid = msgget(key, 0)) > 0)
		{
			pMsg->mtype = CTC_IGD_MSG_FROM_SYSTEMD;
			if(msgsnd(msgid, (void *)pMsg, sizeof(struct ctc_igd_sys_msgbuf)-sizeof(long), 0) < 0)
				printf("%s %d error\n", __FUNCTION__, __LINE__);
		}
	}
	return 0;
}
#endif

#ifdef _CWMP_MIB_ /*jiunming, mib for cwmp-tr069*/
int startCWMP(void)
{
	char vChar=0;
	char strPort[16];
	unsigned int conreq_port=0;

	//lan interface enable or disable
	mib_get(CWMP_LAN_IPIFENABLE, (void *)&vChar);
	if(vChar==0)
	{
		va_cmd(IFCONFIG, 2, 1, BRIF, "down");
		printf("Disable br0 interface\n");
	}
	//eth0 interface enable or disable
	mib_get(CWMP_LAN_ETHIFENABLE, (void *)&vChar);
	if(vChar==0)
	{
		va_cmd(IFCONFIG, 2, 1, ELANIF, "down");
		printf("Disable eth0 interface\n");
	}

	/*add a wan port to pass */
	mib_get(CWMP_CONREQ_PORT, (void *)&conreq_port);
	if(conreq_port==0) conreq_port=7547;
	sprintf(strPort, "%u", conreq_port );
	va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", "-A", (char *)FW_PREROUTING,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);

	set_TR069_Firewall(1);

#ifdef CONFIG_RTK_L34_ENABLE
	mib_get(MIB_DMZ_ENABLE, &vChar);
	if(vChar)
	{
		Flush_RTK_RG_gatewayService();
		RTK_RG_gatewayService_add();
	}
#endif

	/*start the cwmpClient program*/
	mib_get(CWMP_FLAG, (void *)&vChar);
	if( vChar&CWMP_FLAG_AUTORUN )
	{
		va_niced_cmd( "/bin/cwmpClient", 0, 0 );
	}

#ifdef CONFIG_MIDDLEWARE
	mib_get(CWMP_TR069_ENABLE,(void *)&vChar);	//CWMP_TR069_ENABLE: 0-run midware;1-run normal tr069; 2 run midware and normal tr069
	if(vChar == 0 || vChar == 2){
		//setMidwareRouteFW(1);
		if(read_pid((char*)MWINTF_MAIN_RUNFILE) <= 0){ //midware interface is not started
			va_cmd( "/bin/midware_intf", 0, 0 );
		}
		//start midware bootprocess
		if(vChar == 0)
			va_cmd( "/usr/local/ct/ctadmin", 1, 0,"s=0" );	//call midware bootstrap
		else
		va_cmd( "/usr/local/ct/ctadmin", 1, 0,"s=2" );	//call midware bootstrap
		mwSetFirewall(1);
	}
#endif
#ifdef E8B_NEW_DIAGNOSE
	check_inform_status(1);
#endif

#ifdef CONFIG_USER_CWMP_UPNP_DM
	// Start UPnP DM proxy
	{
		int pid = read_pid("/var/run/upnpmd_cp.pid");
		if(pid > 0)
		{
			//SIGTERM is not used
			kill(pid, SIGKILL);
			unlink("/var/run/upnpmd_cp.pid");
		}
		va_niced_cmd( "/bin/upnpmd_cp", 0, 0 );
	}
#endif
	return 0;
}
#endif

#ifdef E8B_GET_OUI
void getOUIfromMAC(char *oui)
{
	unsigned char buffer[MAC_ADDR_LEN];
	int i;

	if (mib_get(MIB_ELAN_MAC_ADDR, buffer)) {
		sprintf(oui, "%02x%02x%02x", buffer[0], buffer[1], buffer[2]);
		for (i = 0; i < strlen(oui); i++) {
			oui[i] = toupper(oui[i]);
		}
		oui[i] = '\0';
	} else {
		strcpy(oui, DEF_MANUFACTUREROUI_STR);
	}
}
#endif


// return 1: found Prefix Delegation.
// return 0: can not find Prefix Delegation.
int getLeasesInfo(const char *fname, DLG_INFO_Tp pInfo)
{
	FILE *fp;
	char temps[0x100];
	char *str, *endStr;
	int offset, RNTime, RBTime, PLTime, MLTime;
	struct in6_addr addr6;

	int ret=0;

	if ((fp = fopen(fname, "r")) == NULL)
	{
		printf("Open file %s fail !\n", fname);
		return 0;
	}

	while (fgets(temps,0x100,fp))
	{
		if (temps[strlen(temps)-1]=='\n')
			temps[strlen(temps)-1] = 0;

		if (str=strstr(temps, "ia-pd"))
		{
			ret = 1;
			fgets(temps,0x100,fp);

			// Get renew
			fgets(temps,0x100,fp);
			if ( str=strstr(temps, "renew") ) {
				offset = strlen("renew")+1;
				if ( endStr=strchr(str+offset, ';')) {
					*endStr=0;
					sscanf(str+offset, "%u", &RNTime);
					pInfo->RNTime = RNTime;
				}
			}

			// Get rebind
			fgets(temps,0x100,fp);
			if ( str=strstr(temps, "rebind")) {
				offset = strlen("rebind")+1;
				if ( endStr=strchr(str+offset, ';')) {
					*endStr=0;
					sscanf(str+offset, "%u", &RBTime);
					pInfo->RBTime = RBTime;
				}
			}

			// Get prefix
			fgets(temps,0x100,fp);
			if ( str=strstr(temps, "iaprefix")) {
				offset = strlen("iaprefix")+1;
				if ( endStr=strchr(str+offset, ' ')) {
					*endStr=0;

					endStr=strchr(str+offset, '/');
					*endStr=0;

					// PrefixIP
					inet_pton(PF_INET6, (str+offset), &addr6);
					memcpy(pInfo->prefixIP, &addr6, IP6_ADDR_LEN);

					// Prefix Length
					//sscanf((endStr+1), "%d", &(Info.prefixLen));
					pInfo->prefixLen = (char)atoi((endStr+1));
				}

			}


			fgets(temps,0x100,fp);

			// Get preferred-life
			fgets(temps,0x100,fp);
			if ( str=strstr(temps, "preferred-life")) {
				offset = strlen("preferred-life")+1;
				if ( endStr=strchr(str+offset, ';') ) {
					*endStr=0;
					sscanf(str+offset, "%u", &PLTime);
					pInfo->PLTime = PLTime;
				}
			}

			// Get max-life
			fgets(temps,0x100,fp);
			if( str=strstr(temps, "max-life")) {
				offset = strlen("max-life")+1;
				if ( endStr=strchr(str+offset, ';')) {
					*endStr=0;
					sscanf(str+offset, "%u", &MLTime);
					pInfo->MLTime = MLTime;
				}
			}
		}
		if ( str=strstr(temps, "dhcp6.name-servers")) {
			offset = strlen("dhcp6.name-servers")+1;
			if ( endStr=strchr(str+offset, ';')) {
				*endStr=0;
				//printf("Name server=%s\n", str+offset);
				memcpy(pInfo->nameServer, (unsigned char *)(str+offset),  256);
			}
		}
	}
	fclose(fp);

	return ret;
}

int getMIB2Str(unsigned int id, char *strbuf)
{
	unsigned char buffer[64];

	if (!strbuf)
		return -1;

	switch (id) {
		// INET address
		case MIB_ADSL_LAN_IP:
		case MIB_ADSL_LAN_SUBNET:
		case MIB_ADSL_LAN_IP2:
		case MIB_ADSL_LAN_SUBNET2:
		case MIB_ADSL_WAN_DNS1:
		case MIB_ADSL_WAN_DNS2:
		case MIB_ADSL_WAN_DNS3:
		case MIB_ADSL_WAN_DHCPS:
		case MIB_DMZ_IP:
#ifdef CONFIG_USER_SNMPD_SNMPD_V2CTRAP
		case MIB_SNMP_TRAP_IP:
#endif
		case MIB_DHCP_POOL_START:
		case MIB_DHCP_POOL_END:
		case MIB_DHCPS_DNS1:
		case MIB_DHCPS_DNS2:
		case MIB_DHCPS_DNS3:
		case MIB_DHCP_SUBNET_MASK:
#ifdef AUTO_PROVISIONING
		case MIB_HTTP_SERVER_IP:
#endif
		case MIB_ADSL_LAN_DHCP_GATEWAY:
#if 1
#if defined(_PRMT_X_CT_COM_DHCP_)||defined(IP_BASED_CLIENT_TYPE)
		case CWMP_CT_STB_MINADDR:
		case CWMP_CT_STB_MAXADDR:
		case CWMP_CT_PHN_MINADDR:
		case CWMP_CT_PHN_MAXADDR:
		case CWMP_CT_CMR_MINADDR:
		case CWMP_CT_CMR_MAXADDR:
		case CWMP_CT_PC_MINADDR:
		case CWMP_CT_PC_MAXADDR:
		case CWMP_CT_HGW_MINADDR:
		case CWMP_CT_HGW_MAXADDR:
#endif //_PRMT_X_CT_COM_DHCP_
#endif
		//ql 20090122 add
#ifdef IMAGENIO_IPTV_SUPPORT
		case MIB_IMAGENIO_DNS1:
		case MIB_IMAGENIO_DNS2:
/*ping_zhang:20090930 START:add for Telefonica new option 240*/
#if 0
		case MIB_OPCH_ADDRESS:
#endif
/*ping_zhang:20090930 END*/
#endif

#ifdef ADDRESS_MAPPING
#ifndef MULTI_ADDRESS_MAPPING
		case MIB_LOCAL_START_IP:
		case MIB_LOCAL_END_IP:
		case MIB_GLOBAL_START_IP:
		case MIB_GLOBAL_END_IP:
#endif //end of !MULTI_ADDRESS_MAPPING
#endif
#ifdef DEFAULT_GATEWAY_V2
		case MIB_ADSL_WAN_DGW_IP:
#endif
#ifdef CONFIG_USER_RTK_SYSLOG
#ifdef CONFIG_USER_RTK_SYSLOG_REMOTE
		case MIB_SYSLOG_SERVER_IP:
#endif
#ifdef SEND_LOG
		case MIB_LOG_SERVER_IP:
#endif
#endif
#ifdef _PRMT_TR143_
		case TR143_UDPECHO_SRCIP:
#endif //_PRMT_TR143_
			if(!mib_get( id, (void *)buffer))
				return -1;
			// Mason Yu
			if ( ((struct in_addr *)buffer)->s_addr == INADDR_NONE ) {
				sprintf(strbuf, "%s", "");
			} else {
				sprintf(strbuf, "%s", inet_ntoa(*((struct in_addr *)buffer)));
			}
			break;
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
		// INET6 address
		case MIB_DHCPV6S_RANGE_START:
		case MIB_DHCPV6S_RANGE_END:
			if(!mib_get( id, (void *)buffer))
				return -1;
			inet_ntop(PF_INET6, buffer, strbuf, 48);
			break;
		case MIB_DHCPV6S_MIN_ADDRESS:
		case MIB_DHCPV6S_MAX_ADDRESS:
		case MIB_IPV6_LAN_PREFIX:
			if(!mib_get( id, (void *)strbuf))
				return -1;
			break;
#endif
		case MIB_ADSL_WAN_DNSV61:
		case MIB_ADSL_WAN_DNSV62:
		case MIB_ADSL_WAN_DNSV63:
			if(!mib_get( id, (void *)buffer))
				return -1;
			inet_ntop(PF_INET6, buffer, strbuf, 48);
			break;
#endif
		// Ethernet address
		case MIB_ELAN_MAC_ADDR:
		case MIB_WLAN_MAC_ADDR:
			if(!mib_get( id,  (void *)buffer))
				return -1;
			sprintf(strbuf, "%02x%02x%02x%02x%02x%02x", buffer[0], buffer[1],
				buffer[2], buffer[3], buffer[4], buffer[5]);
			break;
		// Char
		case MIB_ADSL_LAN_CLIENT_START:
		case MIB_ADSL_LAN_CLIENT_END:
#ifdef WLAN_SUPPORT
		case MIB_WLAN_CHAN_NUM:
		case MIB_WLAN_CHANNEL_WIDTH:
		case MIB_WLAN_NETWORK_TYPE:
		case MIB_WIFI_TEST:

#ifdef WLAN_UNIVERSAL_REPEATER
		case MIB_REPEATER_ENABLED1:
#endif
#ifdef WLAN_WDS
		case MIB_WLAN_WDS_ENABLED:
#endif

#endif
#ifdef CONFIG_USER_RTK_SYSLOG
		case MIB_SYSLOG_LOG_LEVEL:
		case MIB_SYSLOG_DISPLAY_LEVEL:
#ifdef CONFIG_USER_RTK_SYSLOG_REMOTE
		case MIB_SYSLOG_MODE:
#endif
#endif
#if 0
#if defined(_PRMT_X_CT_COM_DHCP_)||defined(IP_BASED_CLIENT_TYPE)
		case CWMP_CT_STB_MINADDR:
		case CWMP_CT_STB_MAXADDR:
		case CWMP_CT_PHN_MINADDR:
		case CWMP_CT_PHN_MAXADDR:
		case CWMP_CT_CMR_MINADDR:
		case CWMP_CT_CMR_MAXADDR:
		case CWMP_CT_PC_MINADDR:
		case CWMP_CT_PC_MAXADDR:
		case CWMP_CT_HGW_MINADDR:
		case CWMP_CT_HGW_MAXADDR:
#endif //_PRMT_X_CT_COM_DHCP_
#endif
#if defined(CONFIG_IPV6) && defined (CONFIG_USER_DHCPV6_ISC_DHCP411)
		case MIB_DHCPV6S_PREFIX_LENGTH:
		case MIB_DHCPV6S_DNS_ASSIGN_MODE:
		case MIB_DHCPV6S_POOL_ADDR_FORMAT:
#endif
#ifdef CONFIG_RTK_L34_ENABLE
		case MIB_MAC_BASED_TAG_DECISION:
#endif
#if defined(CONFIG_IPV6)
		case MIB_LAN_DNSV6_MODE:
		case MIB_PREFIXINFO_PREFIX_MODE:
#endif
		case CWMP_CONFIGURABLE:
			if(!mib_get(id,  (void *)buffer))
				return -1;
	   		sprintf(strbuf, "%u", *(unsigned char *)buffer);
	   		break;
	   	// Short
	   	case MIB_BRCTL_AGEINGTIME:
#ifdef WLAN_SUPPORT
	   	case MIB_WLAN_FRAG_THRESHOLD:
	   	case MIB_WLAN_RTS_THRESHOLD:
	   	case MIB_WLAN_BEACON_INTERVAL:
#endif
#ifdef CONFIG_USER_RTK_SYSLOG
#ifdef CONFIG_USER_RTK_SYSLOG_REMOTE
		case MIB_SYSLOG_SERVER_PORT:
#endif
#endif
		//ql 20090122 add
#ifdef IMAGENIO_IPTV_SUPPORT
/*ping_zhang:20090930 START:add for Telefonica new option 240*/
#if 0
		case MIB_OPCH_PORT:
#endif
/*ping_zhang:20090930 END*/
#endif
			if(!mib_get( id,  (void *)buffer))
				return -1;
			sprintf(strbuf, "%u", *(unsigned short *)buffer);
			break;
	   	// Interger
		case MIB_ADSL_LAN_DHCP_LEASE:
			// Mason Yu
			if(!mib_get( id,  (void *)buffer))
				return -1;
			// if MIB_ADSL_LAN_DHCP_LEASE=0xffffffff, it indicate an infinate lease
			if ( *(unsigned long *)buffer == 0xffffffff )
				sprintf(strbuf, "-1");
			else
				sprintf(strbuf, "%u", *(unsigned int *)buffer);
			break;
		// Interger
#ifdef WEB_REDIRECT_BY_MAC
		case MIB_WEB_REDIR_BY_MAC_INTERVAL:
#endif
		case MIB_IGMP_PROXY_ITF:
#if defined(CONFIG_USER_UPNPD)||defined(CONFIG_USER_MINIUPNPD)
		case MIB_UPNP_EXT_ITF:
#endif
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_ECMH		// Mason Yu. MLD Proxy
		case MIB_MLD_PROXY_EXT_ITF:
#endif
#endif

#ifdef IP_PASSTHROUGH
		case MIB_IPPT_ITF:
		case MIB_IPPT_LEASE:
#endif
#ifdef DEFAULT_GATEWAY_V2
		case MIB_ADSL_WAN_DGW_ITF:
#endif
		case MIB_MAXLOGLEN:
#ifdef _CWMP_MIB_
		case CWMP_INFORM_INTERVAL:
#endif
#ifdef DOS_SUPPORT
		case MIB_DOS_SYSSYN_FLOOD:
		case MIB_DOS_SYSFIN_FLOOD:
		case MIB_DOS_SYSUDP_FLOOD:
		case MIB_DOS_SYSICMP_FLOOD:
		case MIB_DOS_PIPSYN_FLOOD:
		case MIB_DOS_PIPFIN_FLOOD:
		case MIB_DOS_PIPUDP_FLOOD:
		case MIB_DOS_PIPICMP_FLOOD:
		case MIB_DOS_BLOCK_TIME:
#endif
#ifdef TCP_UDP_CONN_LIMIT
		case MIB_CONNLIMIT_UDP:
		case MIB_CONNLIMIT_TCP:
#endif
#ifdef _CWMP_MIB_
		case CWMP_CONREQ_PORT:
		case CWMP_WAN_INTERFACE:
#endif
#ifdef CONFIG_MIDDLEWARE
		case CWMP_MIDWARE_SERVER_PORT:
#endif
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
		case MIB_DHCPV6S_DEFAULT_LEASE:
		case MIB_DHCPV6S_PREFERRED_LIFETIME:
		case MIB_DHCPV6S_RENEW_TIME:
		case MIB_DHCPV6S_REBIND_TIME:
#endif
#endif
#ifdef CONFIG_RTK_L34_ENABLE
		case MIB_LAN_VLAN_ID1:
		case MIB_LAN_VLAN_ID2:
#endif
		case MIB_WAN_MODE:
		case MIB_DMZ_WAN:
#ifdef TIME_ZONE
		case MIB_NTP_TIMEZONE_DB_INDEX:
#endif
#ifdef _PRMT_X_CT_COM_USERINFO_
		case CWMP_USERINFO_STATUS:
		case CWMP_USERINFO_RESULT:
#endif

#if defined(CONFIG_IPV6)
		case MIB_PREFIXINFO_DELEGATED_WANCONN:
		case MIB_DNSINFO_WANCONN:
#endif
			if(!mib_get( id,  (void *)buffer))
				return -1;
			sprintf(strbuf, "%u", *(unsigned int *)buffer);
			break;
		// String
		case MIB_ADSL_LAN_DHCP_DOMAIN:
#ifdef CONFIG_USER_SNMPD_SNMPD_V2CTRAP
		case MIB_SNMP_SYS_DESCR:
		case MIB_SNMP_SYS_CONTACT:
		case MIB_SNMP_SYS_LOCATION:
		case MIB_SNMP_SYS_OID:
		case MIB_SNMP_COMM_RO:
		case MIB_SNMP_COMM_RW:
#endif
		case MIB_SNMP_SYS_NAME:
#ifdef WLAN_SUPPORT
#ifdef WLAN_UNIVERSAL_REPEATER
		case MIB_REPEATER_SSID1:
#endif
#ifdef WLAN_WDS
		case MIB_WLAN_WDS_PSK:
#endif
#endif
#ifdef AUTO_PROVISIONING
		case MIB_CONFIG_VERSION:
#endif
#ifdef TIME_ZONE
		case MIB_NTP_ENABLED:
/*ping_zhang:20081217 START:patch from telefonica branch to support WT-107*/
		case MIB_NTP_SERVER_HOST1:
		case MIB_NTP_SERVER_HOST2:
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		case MIB_NTP_SERVER_HOST3:
		case MIB_NTP_SERVER_HOST4:
		case MIB_NTP_SERVER_HOST5:
#endif
#endif
/*ping_zhang:20081217*/
#ifdef _CWMP_MIB_
		case CWMP_PROVISIONINGCODE:
		case CWMP_ACS_URL:
		case CWMP_ACS_USERNAME:
		case CWMP_ACS_PASSWORD:
		case CWMP_CONREQ_USERNAME:
		case CWMP_CONREQ_PASSWORD:
		case CWMP_CONREQ_PATH:
		case CWMP_LAN_CONFIGPASSWD:
		case CWMP_SERIALNUMBER:
		case CWMP_DL_COMMANDKEY:
		case CWMP_RB_COMMANDKEY:
		case CWMP_ACS_PARAMETERKEY:
		case CWMP_CERT_PASSWORD:
#ifdef _PRMT_USERINTERFACE_
		case UIF_AUTOUPDATESERVER:
		case UIF_USERUPDATESERVER:
#endif
		case CWMP_SI_COMMANDKEY:
		case CWMP_ACS_KICKURL:
		case CWMP_ACS_DOWNLOADURL:
#ifdef _PRMT_X_CT_COM_PORTALMNT_
		case CWMP_CT_PM_URL4PC:
		case CWMP_CT_PM_URL4STB:
		case CWMP_CT_PM_URL4MOBILE:
#endif
#endif
#ifdef CONFIG_WIFI_SIMPLE_CONFIG //WPS
		case MIB_WSC_PIN:
		case MIB_WSC_SSID:
#endif
#ifdef CONFIG_USER_RTK_SYSLOG
#ifdef SEND_LOG
		case MIB_LOG_SERVER_NAME:
#endif
#endif
#if defined(CONFIG_IPV6) && defined(CONFIG_USER_RADVD)
		case MIB_V6_MAXRTRADVINTERVAL:
		case MIB_V6_MINRTRADVINTERVAL:
		case MIB_V6_ADVCURHOPLIMIT:
		case MIB_V6_ADVDEFAULTLIFETIME:
		case MIB_V6_ADVREACHABLETIME:
		case MIB_V6_ADVRETRANSTIMER:
		case MIB_V6_ADVLINKMTU:
		case MIB_V6_PREFIX_IP:
		case MIB_V6_PREFIX_LEN:
		case MIB_V6_VALIDLIFETIME:
		case MIB_V6_PREFERREDLIFETIME:
		case MIB_V6_RDNSS1:
		case MIB_V6_RDNSS2:
		case MIB_V6_ULAPREFIX_ENABLE:
		case MIB_V6_ULAPREFIX:
		case MIB_V6_ULAPREFIX_LEN:
		case MIB_V6_ULAPREFIX_VALID_TIME:
		case MIB_V6_ULAPREFIX_PREFER_TIME:
#endif
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
		case MIB_DHCPV6S_CLIENT_DUID:
#endif
#endif
		case MIB_SUSER_NAME:
		case MIB_USER_NAME:
#ifdef CONFIG_USER_SAMBA
#ifdef CONFIG_USER_NMBD
		case MIB_SAMBA_NETBIOS_NAME:
#endif
		case MIB_SAMBA_SERVER_STRING:
#endif
			if(!mib_get( id,  (void *)strbuf)){
				return -1;
			}
			break;

#ifdef CONFIG_RTL_WAPI_SUPPORT
		case MIB_WLAN_WAPI_MCAST_REKEYTYPE:
		case MIB_WLAN_WAPI_UCAST_REKETTYPE:
			if(!mib_get( id,  (void *)buffer)){
				return -1;
			}
			sprintf(strbuf, "%d", buffer[0]);
			break;
		case MIB_WLAN_WAPI_MCAST_TIME:
		case MIB_WLAN_WAPI_MCAST_PACKETS:
		case MIB_WLAN_WAPI_UCAST_TIME:
		case MIB_WLAN_WAPI_UCAST_PACKETS:
			if(!mib_get( id,  (void *)buffer)){
				return -1;
			}
			sprintf(strbuf, "%u", *(unsigned int *)buffer);
			break;
#endif
                // below are version information for tr069 inform packet
                case RTK_DEVID_MANUFACTURER:
                case RTK_DEVID_OUI:
                case RTK_DEVID_PRODUCTCLASS:
                case RTK_DEVINFO_HWVER:
                case RTK_DEVINFO_SWVER:
                case RTK_DEVINFO_SPECVER:
                case MIB_HW_SERIAL_NUMBER:
#if defined(CONFIG_GPON_FEATURE)
                case MIB_GPON_SN:
#endif
		case MIB_HW_CWMP_MANUFACTURER:
		case MIB_HW_CWMP_PRODUCTCLASS:
		case MIB_HW_HWVER:
#ifdef CONFIG_MIDDLEWARE
				case CWMP_MIDWARE_SERVER_ADDR:
#endif
#ifdef CONFIG_USER_CTMANAGEDEAMON
		case MIB_BUCPE_MANAGEMENT_PLATFORM:
		case MIB_BUCPE_BACKUP_MANAGEMENT_PLATFORM:
		case MIB_BUCPE_TRACE_URL:
#endif
#ifdef CONFIG_SUPPORT_CAPTIVE_PORTAL
		case MIB_CAPTIVEPORTAL_URL:
#endif
#ifdef CONFIG_CT_AWIFI_JITUAN_SMARTWIFI
		case AWIFI_IMAGE_URL:
		case AWIFI_REPORT_URL:
		case MIB_DEVICE_NAME:
		case AWIFI_APPLYID:	
		case AWIFI_CITY:
#endif			
		if(!mib_get( id,  (void *)strbuf))
			return -1;
		break;

		default:
			return -1;
	}

	return 0;
}

int getSYSInfoTimer() {
	struct sysinfo info;
	int systimer=0;
	sysinfo(&info);
	systimer = (int)info.uptime;
	return systimer;
}

int getSYS2Str(SYSID_T id, char *strbuf)
{
	unsigned char buffer[128], vChar;
	struct sysinfo info;
	int updays, uphours, upminutes, len, i;
	time_t tm;
	struct tm tm_time, *ptm_time;
	FILE *fp;
	unsigned char tmpBuf[64], *pStr;
	unsigned short vUShort;
	unsigned int vUInt;
#ifdef CONFIG_IPV6
	struct ipv6_ifaddr ip6_addr[6];
#endif
	struct stat f_status;
#ifdef WLAN_SUPPORT
	MIB_CE_MBSSIB_T Entry;
#endif

	if (!strbuf)
		return -1;

	strbuf[0] = '\0';

	switch (id) {
		case SYS_UPTIME:
			sysinfo(&info);
			updays = (int) info.uptime / (60*60*24);
			if (updays)
				sprintf(strbuf, "%d day%s, ", updays, (updays != 1) ? "s" : "");
			len = strlen(strbuf);
			upminutes = (int) info.uptime / 60;
			uphours = (upminutes / 60) % 24;
			upminutes %= 60;
			if(uphours)
				sprintf(&strbuf[len], "%2d:%02d", uphours, upminutes);
			else
				sprintf(&strbuf[len], "%d min", upminutes);
			break;
		case SYS_DATE:
	 		time(&tm);
			memcpy(&tm_time, localtime(&tm), sizeof(tm_time));
			strftime(strbuf, 200, "%a %b %e %H:%M:%S %Z %Y", &tm_time);
			break;
		case SYS_YEAR:
	 		time(&tm);
			ptm_time = localtime(&tm);
			snprintf(strbuf, 64, "%d", (ptm_time->tm_year+ 1900));
			break;
		case SYS_MONTH:
	 		time(&tm);
			ptm_time = localtime(&tm);
			snprintf(strbuf, 64, "%d", (ptm_time->tm_mon+ 1));
			break;
		case SYS_DAY:
	 		time(&tm);
			ptm_time = localtime(&tm);
			snprintf(strbuf, 64, "%d", (ptm_time->tm_mday));
			break;
		case SYS_HOUR:
	 		time(&tm);
			ptm_time = localtime(&tm);
			snprintf(strbuf, 64, "%d", (ptm_time->tm_hour));
			break;
		case SYS_MINUTE:
	 		time(&tm);
			ptm_time = localtime(&tm);
			snprintf(strbuf, 64, "%d", (ptm_time->tm_min));
			break;
		case SYS_SECOND:
	 		time(&tm);
			ptm_time = localtime(&tm);
			snprintf(strbuf, 64, "%d", (ptm_time->tm_sec));
			break;
		case SYS_FWVERSION:
#ifdef CONFIG_LUNA_FIRMWARE_UPGRADE_SUPPORT
			{
				int swActive=0;
				char str_active[64], header_buf[64];

				sprintf(header_buf, "%s", BOOTLOADER_SW_ACTIVE);
				rtk_env_get(header_buf, str_active, sizeof(str_active));
				sscanf(str_active, "sw_active=%d", &swActive);

				sprintf(header_buf, "%s%d", BOOTLOADER_SW_VERSION, swActive);
				rtk_env_get(header_buf, str_active, sizeof(str_active));
				sscanf(str_active, "%*[^=]=%s", strbuf);
			}
#else
#ifdef EMBED
			tmpBuf[0]=0;
			pStr = 0;
			fp = fopen("/etc/version", "r");
			if (fp!=NULL) {
				fgets(tmpBuf, sizeof(tmpBuf), fp);  //main version
				fclose(fp);
				pStr = strchr(tmpBuf, ' ');
				*pStr=0;
			};
			sprintf(strbuf, "%s", tmpBuf);
#else
			sprintf(strbuf, "%s.%s", "Realtek", "1");
#endif
#endif //CONFIG_LUNA_FIRMWARE_UPGRADE_SUPPORT
			break;
		case SYS_BUILDTIME:
			tmpBuf[0]=0;
			pStr = 0;
			fp = fopen("/etc/buildtime", "r");
			if (fp!=NULL) {
				fgets(tmpBuf, sizeof(tmpBuf), fp);  //buildtime
				fclose(fp);
				pStr = strchr(tmpBuf, '\n');
				*pStr=0;
			};
			sprintf(strbuf, "%s", tmpBuf);
			break;
		case SYS_LAN_DHCP:
			if ( !mib_get( MIB_DHCP_MODE, (void *)buffer) )
				return -1;
			if (DHCP_LAN_SERVER == buffer[0])
				strcpy(strbuf, STR_ENABLE);
			else
				strcpy(strbuf, STR_DISABLE);
			break;
		case SYS_DHCP_LAN_IP:
#if defined(CONFIG_SECONDARY_IP) && !defined(DHCPS_POOL_COMPLETE_IP)
			mib_get(MIB_ADSL_LAN_ENABLE_IP2, (void *)&vChar);
			if (vChar)
				mib_get(MIB_ADSL_LAN_DHCP_POOLUSE, (void *)&vChar);
#else
			vChar = 0;
#endif
			if (vChar == 0) // primary LAN
				getMIB2Str(MIB_ADSL_LAN_IP, strbuf);
			else // secondary LAN
				getMIB2Str(MIB_ADSL_LAN_IP2, strbuf);
			break;
		case SYS_DHCP_LAN_SUBNET:
#if defined(CONFIG_SECONDARY_IP) && !defined(DHCPS_POOL_COMPLETE_IP)
			mib_get(MIB_ADSL_LAN_ENABLE_IP2, (void *)&vChar);
			if (vChar)
				mib_get(MIB_ADSL_LAN_DHCP_POOLUSE, (void *)&vChar);
#else
			vChar = 0;
#endif
			if (vChar == 0) // primary LAN
				getMIB2Str(MIB_ADSL_LAN_SUBNET, strbuf);
			else // secondary LAN
				getMIB2Str(MIB_ADSL_LAN_SUBNET2, strbuf);
			break;
			// Kaohj
		case SYS_DHCPS_IPPOOL_PREFIX:
#if defined(CONFIG_SECONDARY_IP) && !defined(DHCPS_POOL_COMPLETE_IP)
			mib_get(MIB_ADSL_LAN_ENABLE_IP2, (void *)&vChar);
			if (vChar)
				mib_get(MIB_ADSL_LAN_DHCP_POOLUSE, (void *)&vChar);
#else
			vChar = 0;
#endif
			if (vChar == 0) // primary LAN
				mib_get(MIB_ADSL_LAN_IP, (void *)&tmpBuf[0]) ;
			else // secondary LAN
				mib_get(MIB_ADSL_LAN_IP2, (void *)&tmpBuf[0]) ;
			pStr = tmpBuf;
			sprintf(strbuf, "%d.%d.%d.", pStr[0], pStr[1], pStr[2]);
			break;
#ifdef WLAN_SUPPORT
		case SYS_WLAN:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if (0 == Entry.wlanDisabled)
				strcpy(strbuf, STR_ENABLE);
			else
				strcpy(strbuf, STR_DISABLE);
			break;
		case SYS_WLAN_SSID:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			strcpy(strbuf, Entry.ssid);
			break;
		case SYS_WLAN_DISABLED:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf,"%u", Entry.wlanDisabled);
			break;
		case SYS_WLAN_HIDDEN_SSID:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf,"%u", Entry.hidessid);
			break;
		case SYS_WLAN_MODE_VAL:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf,"%u", Entry.wlanMode);
			break;
		case SYS_WLAN_BCASTSSID:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if (0 == Entry.hidessid)
				strcpy(strbuf, STR_ENABLE);
			else
				strcpy(strbuf, STR_DISABLE);
			break;
		case SYS_WLAN_ENCRYPT_VAL:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf,"%u", Entry.encrypt);
			break;
		case SYS_WLAN_WPA_CIPHER_SUITE:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf,"%u", Entry.unicastCipher);
			break;
		case SYS_WLAN_WPA2_CIPHER_SUITE:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf,"%u", Entry.wpa2UnicastCipher);
			break;
		case SYS_WLAN_WPA_AUTH:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf,"%u", Entry.wpaAuth);
			break;
		case SYS_WLAN_BAND:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			strcpy(strbuf, wlan_band[(BAND_TYPE_T)Entry.wlanBand]);
			break;
		case SYS_WLAN_AUTH:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if(Entry.authType >= 0 && Entry.authType <= 2)
				strcpy(strbuf, wlan_auth[(AUTH_TYPE_T)Entry.authType]);
			else
				strcpy(strbuf, "None");
			break;
		case SYS_WLAN_PREAMBLE:
			if ( !mib_get( MIB_WLAN_PREAMBLE_TYPE, (void *)buffer) )
				return -1;
			strcpy(strbuf, wlan_preamble[(PREAMBLE_T)buffer[0]]);
			break;
		case SYS_WLAN_ENCRYPT:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			switch(Entry.encrypt) {
				case WIFI_SEC_NONE:
				case WIFI_SEC_WEP:
				case WIFI_SEC_WPA:
					strcpy(strbuf, wlan_encrypt[(WIFI_SECURITY_T)Entry.encrypt]);
					break;
				case WIFI_SEC_WPA2:
					strcpy(strbuf, wlan_encrypt[3]);
					break;
				case WIFI_SEC_WPA2_MIXED:
					strcpy(strbuf, wlan_encrypt[4]);
					break;
				#ifdef CONFIG_RTL_WAPI_SUPPORT
				case WIFI_SEC_WAPI:
					strcpy(strbuf, wlan_encrypt[5]);
					break;
				#endif
				default:
					strcpy(strbuf, wlan_encrypt[0]);
			}
			break;
		// Mason Yu. 201009_new_security
		case SYS_WLAN_WPA_CIPHER:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if ( Entry.unicastCipher == 0 )
				strcpy(strbuf, "");
			else
				strcpy(strbuf, wlan_Cipher[Entry.unicastCipher-1]);
			break;
		case SYS_WLAN_WPA2_CIPHER:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if ( Entry.wpa2UnicastCipher == 0 )
				strcpy(strbuf, "");
			else
				strcpy(strbuf, wlan_Cipher[Entry.wpa2UnicastCipher-1]);
			break;
		case SYS_WLAN_PSKFMT:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			strcpy(strbuf, wlan_pskfmt[Entry.wpaPSKFormat]);
			break;
		case SYS_WLAN_PSKVAL:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			for (len=0; len<strlen(Entry.wpaPSK); len++)
				strbuf[len]='*';
			strbuf[len]='\0';
			break;
		case SYS_WLAN_WEP_KEYLEN:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			strcpy(strbuf, wlan_wepkeylen[Entry.wep]);
			break;
		case SYS_WLAN_WEP_KEYFMT:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			strcpy(strbuf, wlan_wepkeyfmt[Entry.wepKeyType]);
			break;
		case SYS_WLAN_WPA_MODE:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if (Entry.wpaAuth == WPA_AUTH_AUTO)
				strcpy(strbuf, "Enterprise (RADIUS)");
			else if (Entry.wpaAuth == WPA_AUTH_PSK)
				strcpy(strbuf, "Personal (Pre-Shared Key)");
			break;
		case SYS_WLAN_RSPASSWD:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			for (len=0; len<strlen(Entry.rsPassword); len++)
				strbuf[len]='*';
			strbuf[len]='\0';
			break;
		case SYS_WLAN_RS_PORT:
			if(!mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf, "%u", Entry.rsPort);
			break;
		case SYS_WLAN_RS_IP:
			if(!mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if ( ((struct in_addr *)Entry.rsIpAddr)->s_addr == INADDR_NONE ) {
				sprintf(strbuf, "%s", "");
			} else {
				sprintf(strbuf, "%s", inet_ntoa(*((struct in_addr *)Entry.rsIpAddr)));
			}
			break;
		case SYS_WLAN_RS_PASSWORD:
			if(!mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf, "%s", Entry.rsPassword);
			break;
		case SYS_WLAN_ENABLE_1X:
			if(!mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf, "%u", Entry.enable1X);
			break;
		// Added by Jenny
		case SYS_TX_POWER:
			if ( !mib_get( MIB_TX_POWER, (void *)&buffer) )
				return -1;
			if (0 == buffer[0])
				strcpy(strbuf, "100%");
			else if(1 == buffer[0])
				strcpy(strbuf, "70%");
			else if(2 == buffer[0])
				strcpy(strbuf, "50%");
			else if(3 == buffer[0])
				strcpy(strbuf, "35%");
			else if(4 == buffer[0])
				strcpy(strbuf, "15%");
			break;
		case SYS_WLAN_MODE:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			strcpy(strbuf, wlan_mode[(WLAN_MODE_T)Entry.wlanMode]);
			break;
		case SYS_WLAN_TXRATE:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
					return -1;
			if (0 == Entry.rateAdaptiveEnabled){
				for (i=0; i<12; i++)
					if (1<<i == Entry.fixedTxRate)
						strcpy(strbuf, wlan_rate[i]);
			}
			else if (1 == Entry.rateAdaptiveEnabled)
				strcpy(strbuf, STR_AUTO);
			break;
		case SYS_WLAN_BLOCKRELAY:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if (0 == Entry.userisolation)
				strcpy(strbuf, STR_DISABLE);
			else
				strcpy(strbuf, STR_ENABLE);
			break;
		case SYS_WLAN_BLOCK_ETH2WIR:
			if ( !mib_get( MIB_WLAN_BLOCK_ETH2WIR, (void *)buffer) )
				return -1;
			if (0 == buffer[0])
				strcpy(strbuf, STR_DISABLE);
			else
				strcpy(strbuf, STR_ENABLE);
			break;
		case SYS_WLAN_AC_ENABLED:
			if ( !mib_get( MIB_WLAN_AC_ENABLED, (void *)&buffer) )
				return -1;
			if (0 == buffer[0])
				strcpy(strbuf, STR_DISABLE);
			else if(1 == buffer[0])
				strcpy(strbuf, "Allow Listed");
			else if(2 == buffer[0])
				strcpy(strbuf, "Deny Listed");
			else
				strcpy(strbuf, STR_ERR);
			break;
		case SYS_WLAN_WDS_ENABLED:
			if ( !mib_get( MIB_WLAN_WDS_ENABLED, (void *)buffer) )
				return -1;
			if (0 == buffer[0])
				strcpy(strbuf, STR_DISABLE);
			else
				strcpy(strbuf, STR_ENABLE);
			break;
#ifdef WLAN_QoS
		case SYS_WLAN_QoS:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if (0 == Entry.wmmEnabled)
				strcpy(strbuf, STR_DISABLE);
			else
				strcpy(strbuf, STR_ENABLE);
			break;
#endif
#ifdef CONFIG_WIFI_SIMPLE_CONFIG // WPS
		case SYS_WLAN_WPS_ENABLED:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if (0 == Entry.wsc_disabled)
				strcpy(strbuf, STR_ENABLE);
			else
				strcpy(strbuf, STR_DISABLE);
			break;
		case SYS_WLAN_WPS_STATUS:
			if( !mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			if (0 == Entry.wsc_configured)
				strcpy(strbuf, "Unconfigured");
			else
				strcpy(strbuf, "Configured");
			break;
		// for PIN brute force attack
		case SYS_WLAN_WPS_LOCKDOWN:
			if (stat("/tmp/wscd_lock_stat", &f_status) == 0) {
				//printf("[%s %d] %s exist\n",__FUNCTION__,__LINE__,WSCD_LOCK_STAT);
				strbuf[0]='1';
			}else{
				strbuf[0]='0';
			}

			strbuf[1] = '\0';
			break;
		case SYS_WSC_DISABLE:
			if(!mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf, "%u", Entry.wsc_disabled);
			break;
		case SYS_WSC_AUTH:
			if(!mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf, "%u", Entry.wsc_auth);
			break;
		case SYS_WSC_ENC:
			if(!mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry))
				return -1;
			sprintf(strbuf, "%u", Entry.wsc_enc);
			break;
#endif
#endif // #ifdef WLAN_SUPPORT
		case SYS_DNS_MODE:
			if ( !mib_get( MIB_ADSL_WAN_DNS_MODE, (void *)buffer) )
				return -1;
			if (0 == buffer[0])
				strcpy(strbuf, STR_AUTO);
			else
				strcpy(strbuf, STR_MANUAL);
			break;

		case SYS_DHCP_MODE:
			if(!mib_get( MIB_DHCP_MODE, (void *)buffer) )
				return -1;
			strcpy(strbuf, dhcp_mode[(DHCP_TYPE_T)buffer[0]]);
			break;

		case SYS_IPF_OUT_ACTION:
			if(!mib_get(MIB_IPF_OUT_ACTION, (void *)buffer) ){
				return -1;
			}
			if (0 == buffer[0])
				strcpy(strbuf, "Deny");
			else if(1 == buffer[0])
				strcpy(strbuf, "Allow");
			else
				strcpy(strbuf, "err");
			break;

		case SYS_DEFAULT_PORT_FW_ACTION:
			if(!mib_get(MIB_PORT_FW_ENABLE, (void *)buffer) ){
				return -1;
			}
			if (0 == buffer[0])
				strcpy(strbuf, "Disable");
			else if(1 == buffer[0])
				strcpy(strbuf, "Enable");
			else
				strcpy(strbuf, "err");
			break;
#if defined(CONFIG_RTL_IGMP_SNOOPING)
		// Added by Jenny
		case SYS_IGMP_SNOOPING:
			if(!mib_get( MIB_MPMODE, (void *)&vChar)) {
				return -1;
			}
			if (vChar&MP_IGMP_MASK)
				strcpy(strbuf, STR_ENABLE);
			else
				strcpy(strbuf, STR_DISABLE);
			break;
#endif
		case SYS_IP_QOS:
			if(!mib_get( MIB_MPMODE, (void *)&vChar)) {
				return -1;
			}
			if (vChar&MP_IPQ_MASK)
				strcpy(strbuf, STR_ENABLE);
			else
				strcpy(strbuf, STR_DISABLE);
			break;


		// Added by Mason Yu
		case SYS_IPF_IN_ACTION:
			if ( !mib_get( MIB_IPF_IN_ACTION, (void *)buffer) )
				return -1;
			if (0 == buffer[0])
				strcpy(strbuf, "Deny");
			else if(1 == buffer[0])
				strcpy(strbuf, "Allow");
			else
				strcpy(strbuf, "err");
			break;

#ifdef CONFIG_SECONDARY_IP
		case SYS_LAN_IP2:
			if (!mib_get( MIB_ADSL_LAN_ENABLE_IP2, (void *)&vChar))
				return -1;
			if (vChar == 0)
				strcpy(strbuf, STR_DISABLE);
			else
				strcpy(strbuf, STR_ENABLE);
			break;

		case SYS_LAN_DHCP_POOLUSE:
			if (!mib_get( MIB_ADSL_LAN_DHCP_POOLUSE, (void *)&vChar))
				return -1;
			if (vChar == 0)
				strcpy(strbuf, "Primary LAN");
			else
				strcpy(strbuf, "Secondary LAN");
			break;
#endif

#ifdef URL_BLOCKING_SUPPORT
		case SYS_DEFAULT_URL_BLK_ACTION:
			if(!mib_get(MIB_URL_CAPABILITY, (void *)buffer) ){
				return -1;
			}
			if (0 == buffer[0])
				strcpy(strbuf, "Disable");
			else if(1 == buffer[0])
				strcpy(strbuf, "Enable");
			else
				strcpy(strbuf, "err");
			break;
#endif

#ifdef DOMAIN_BLOCKING_SUPPORT
		case SYS_DEFAULT_DOMAIN_BLK_ACTION:
			if(!mib_get(MIB_DOMAINBLK_CAPABILITY, (void *)buffer) ){
				return -1;
			}
			if (0 == buffer[0])
				strcpy(strbuf, "Disable");
			else if(1 == buffer[0])
				strcpy(strbuf, "Enable");
			else
				strcpy(strbuf, "err");
			break;
#endif
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
		case SYS_DHCPV6_MODE:
			if(!mib_get( MIB_DHCPV6_MODE, (void *)buffer) )
				return -1;
			strcpy(strbuf, dhcp_mode[(DHCP_TYPE_T)buffer[0]]);
			break;

		case SYS_DHCPV6_RELAY_UPPER_ITF:
			if(!mib_get( MIB_DHCPV6R_UPPER_IFINDEX, (void *)&vUInt) )
				return -1;

			if (vUInt != DUMMY_IFINDEX)
			{
				ifGetName(vUInt, strbuf, 8);
			}
			else
			{
				snprintf(strbuf, 6, "None");
				return 0;
			}
			break;
#endif
		case SYS_LAN_IP6_LL:
			i=getifip6((char *)LANIF, IPV6_ADDR_LINKLOCAL, ip6_addr, 1);
			if (!i)
				strbuf[0] = 0;
			else
				inet_ntop(PF_INET6, &ip6_addr[0].addr, tmpBuf, INET6_ADDRSTRLEN);
				sprintf(strbuf, "%s/%d", tmpBuf, ip6_addr[0].prefix_len);
			break;
		case SYS_LAN_IP6_LL_NO_PREFIX:
			i=getifip6((char *)LANIF, IPV6_ADDR_LINKLOCAL, ip6_addr, 1);
			if (!i)
				strbuf[0] = 0;
			else
				inet_ntop(PF_INET6, &ip6_addr[0].addr, tmpBuf, 256);
				sprintf(strbuf, "%s", tmpBuf);
			break;
		case SYS_LAN_IP6_GLOBAL:
			i=getifip6((char *)LANIF, IPV6_ADDR_UNICAST, ip6_addr, 6);
			strbuf[0] = 0;
			if (i) {
				for (len=0; len<i; len++) {
					inet_ntop(PF_INET6, &ip6_addr[len].addr, tmpBuf, INET6_ADDRSTRLEN);
					if (len == 0)
						sprintf(strbuf, "%s/%d", tmpBuf, ip6_addr[len].prefix_len);
					else
						sprintf(strbuf, "%s, %s/%d", strbuf, tmpBuf, ip6_addr[len].prefix_len);
				}
			}
			break;
#endif // of CONFIG_IPV6

		default:
			return -1;
	}

	return 0;
}

int ifWanNum(const char *name)
{
	int ifnum=0, wtype=-1;
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	int type;
	unsigned char protocol = IPVER_IPV4_IPV6; // 1:IPv4, 2: IPv6, 3: Both. Mason Yu. MLD Proxy

	if ( !strcmp(name, "all") )
		type = 0;
	else if ( !strcmp(name, "rt") )
	{
		type = 1;	// route interface
		protocol = IPVER_IPV4;
	}
	else if ( !strcmp(name, "rtv6") )	// Mason Yu. MLD Proxy
	{
		type = 1;	// route interface
		protocol = IPVER_IPV6;
	}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	else if ( !strcmp(name, "rtOther") )	
	{
		type = 1;	// route interface
		wtype = 1;
	}
	else if ( !strcmp(name, "rtInternetOther") )	
	{
		type = 1;	// route interface
		wtype = 2;
	}
#endif
	else if ( !strcmp(name, "br") )
		type = 2;	// bridge interface
	else
		type = 1;	// default to route

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);

	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
			return -1;
		}

		if (Entry.enable == 0)
			continue;
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		if(wtype == 1)
		{
			if(!(((Entry.cmode == CHANNEL_MODE_IPOE||Entry.cmode == CHANNEL_MODE_PPPOA||Entry.cmode == CHANNEL_MODE_PPPOE \
			||Entry.cmode == CHANNEL_MODE_RT1483))&&(Entry.applicationtype&X_CT_SRV_OTHER)))
				continue;
		}
		if(wtype == 2)
		{
			if(!(((Entry.cmode == CHANNEL_MODE_IPOE||Entry.cmode == CHANNEL_MODE_PPPOA||Entry.cmode == CHANNEL_MODE_PPPOE \
			||Entry.cmode == CHANNEL_MODE_RT1483))&&((Entry.applicationtype&X_CT_SRV_INTERNET)||(Entry.applicationtype&X_CT_SRV_OTHER))))
				continue;
		}
#endif
// Mason Yu. MLD Proxy
#ifdef CONFIG_IPV6
		if ( protocol == IPVER_IPV4_IPV6 || Entry.IpProtocol == IPVER_IPV4_IPV6 || protocol == Entry.IpProtocol ) {
			if (type == 2) {
				if (Entry.cmode == CHANNEL_MODE_BRIDGE)
				{
					ifnum++;
				}
			}
			else {  // rt or all (1 or 0)
				if (type == 1 && Entry.cmode == CHANNEL_MODE_BRIDGE)
					continue;

				ifnum++;
			}
		}
#else
		if (type == 2) {
			if (Entry.cmode == CHANNEL_MODE_BRIDGE)
			{
				ifnum++;
			}
		}
		else {  // rt or all (1 or 0)
			if (type == 1 && Entry.cmode == CHANNEL_MODE_BRIDGE)
				continue;

			ifnum++;
		}
#endif

	}

	return ifnum;
}

#ifdef SUPPORT_INCOMING_FILTER
int if_a_string_is_a_valid_address_s(char *ip_str)
{
    struct in_addr ipv4_addr;
    struct in6_addr ipv6_addr;
    int ret, ret1, ret2;

    ret1 = inet_pton(AF_INET, ip_str, &ipv4_addr);

    if(ret1 > 0)
    {
         ret = IN_COMING_IS_IPV4;
    }
    else
    {
        ret2 = inet_pton(AF_INET6, ip_str, &ipv6_addr);

        if(ret2 > 0)
        {
            ret = IN_COMING_IS_IPV6;
        }
        else
        {
            ret = -1;
        }
    }

    return ret;
}

/******************************************************************
* INPUT
*        cmd --> add  IN_COMING_API_ADD
*            --> del  IN_COMING_API_DEL
*        in_coming_val --> struct smart_func_in_coming_val
*        errdesc --> output error
* RETURN : success 0
*          fail -1
********************************************************************/
int smart_func_add_in_coming_api(int cmd, smart_func_in_coming_val *in_coming_val, char *errdesc)
{
	char cmd_buf[IN_COMING_CMD_BUF_MAX_LEN] = {0};
	char act_buf[4] = {0};
	char iptables_buf[16] = {0};
	char remoteIpBuf[68] = {0};
	const char lanIf[] = "br0";
	const char wanIF1[] = "nas+";
	const char wanIF2[] = "ppp+";

	printf("%s:\n", (cmd == IN_COMING_API_ADD) ? "Add":"Del");
	printf("in_coming_val.remoteIP:[%s]\n", in_coming_val->remoteIP);
	printf("in_coming_val.protocol:[%d]\n", in_coming_val->protocol);
	printf("in_coming_val.interface:[%d]\n", in_coming_val->interface);
	printf("in_coming_val.port:[%d]\n", in_coming_val->port);

	if(cmd == IN_COMING_API_ADD)
	{
		sprintf(act_buf, "-A");
	}
	else if(cmd == IN_COMING_API_DEL)
	{
		sprintf(act_buf, "-D");
	}
	else
	{
		sprintf(errdesc, "CMD ERROR.");
		return IN_COMING_RET_FAIL;
	}

	if(strlen(in_coming_val->remoteIP))
	{
		if(if_a_string_is_a_valid_address_s(in_coming_val->remoteIP) == IN_COMING_IS_IPV4)
		{
			sprintf(iptables_buf, "iptables");
		}
		else if(if_a_string_is_a_valid_address_s(in_coming_val->remoteIP) == IN_COMING_IS_IPV6)
		{
			sprintf(iptables_buf, "ip6tables");
		}
		else
		{
			sprintf(errdesc, "remote ip invaild.");
			return IN_COMING_RET_FAIL;
		}
		sprintf(remoteIpBuf, " -d %s ", in_coming_val->remoteIP);
	}
	else
	{
		sprintf(iptables_buf, "iptables");
		sprintf(remoteIpBuf, " ");
	}

	if(in_coming_val->interface == IN_COMING_INTERFACE_LAN_E)
	{
		if(in_coming_val->protocol == IN_COMING_PROTO_TCP_E)
		{
			sprintf(cmd_buf, "%s %s %s -i %s -p TCP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, lanIf, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
		}
		else if(in_coming_val->protocol == IN_COMING_PROTO_UDP_E)
		{
			sprintf(cmd_buf, "%s %s %s -i %s -p UDP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, lanIf, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
		}
		else if(in_coming_val->protocol == IN_COMING_PROTO_TCP_AND_UDP_E)
		{
			sprintf(cmd_buf, "%s %s %s -i %s -p TCP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, lanIf, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
			sprintf(cmd_buf, "%s %s %s -i %s -p UDP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, lanIf, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
		}
		else
		{
			sprintf(errdesc, "PROTO ERROR.");
			return IN_COMING_RET_FAIL;
		}
	}
	else if(in_coming_val->interface == IN_COMING_INTERFACE_WAN_E)
	{
		if(in_coming_val->protocol == IN_COMING_PROTO_TCP_E)
		{
			sprintf(cmd_buf, "%s %s %s -i %s -p TCP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF1, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
			sprintf(cmd_buf, "%s %s %s -i %s -p TCP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF2, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
		}
		else if(in_coming_val->protocol == IN_COMING_PROTO_UDP_E)
		{
			sprintf(cmd_buf, "%s %s %s -i %s -p UDP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF1, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
			sprintf(cmd_buf, "%s %s %s -i %s -p UDP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF2, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
		}
		else if(in_coming_val->protocol == IN_COMING_PROTO_TCP_AND_UDP_E)
		{
			sprintf(cmd_buf, "%s %s %s -i %s -p TCP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF1, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
			sprintf(cmd_buf, "%s %s %s -i %s -p UDP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF1, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
			sprintf(cmd_buf, "%s %s %s -i %s -p TCP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF2, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
			sprintf(cmd_buf, "%s %s %s -i %s -p UDP%s--dport %d -j ACCEPT", iptables_buf, act_buf, FW_IN_COMMING, wanIF2, remoteIpBuf, in_coming_val->port);
			system(cmd_buf);
		}
		else
		{
			sprintf(errdesc, "PROTO ERROR.");
			return IN_COMING_RET_FAIL;
		}
	}
	else
	{
		sprintf(errdesc, "Interface ERROR.");
		return IN_COMING_RET_FAIL;
	}

	return IN_COMING_RET_SUCCESSFUL;
}
#endif

#ifdef REMOTE_ACCESS_CTL
#ifdef CONFIG_YUEME
void remote_access_modify(MIB_CE_ACC_T accEntry, int enable)
{
	char *act;
	char strPort[8];
	int ret;
    unsigned char ftp_enable = 0;
    unsigned char smba_enable = 0;
	 
	if (enable)
		act = (char *)"-I";
	else
		act = (char *)FW_DEL;

#ifdef SUPPORT_INCOMING_FILTER
	int totalEntry = 0, num = 0;
	char errdesc[256] = {0};
	smart_func_in_coming_val addincomingentry;
	MIB_CE_IN_COMMING_T in_coming_t;

	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_IN_COMMING);
	va_cmd(IP6TABLES, 2, 1, "-F", (char *)FW_IN_COMMING);

	totalEntry = mib_chain_total(MIB_IN_COMMING_TBL);
	for (num = 0; num < totalEntry; num++)
	{
		memset(&in_coming_t, 0, sizeof(MIB_CE_IN_COMMING_T));
		if (mib_chain_get(MIB_IN_COMMING_TBL, num, (void *)&in_coming_t))
		{
			memset(&addincomingentry, 0, sizeof(smart_func_in_coming_val));
			strcpy(addincomingentry.remoteIP, in_coming_t.remoteIP);
			addincomingentry.protocol = in_coming_t.protocol;
			addincomingentry.port = in_coming_t.port;
			addincomingentry.interface = in_coming_t.interface;
			ret = smart_func_add_in_coming_api(IN_COMING_API_ADD, &addincomingentry, errdesc);

			if (ret != IN_COMING_RET_SUCCESSFUL) {
				printf("smart_func_add_in_coming_api fail: %s\n", errdesc);
			}
		}
	}
#endif

/**modify by wanghy at 20160714*/
/*add by susha at 2016-2-3*/
    syslog(LOG_ERR, "iptables:in %s(%d)\r\n", __FUNCTION__, __LINE__);
#ifdef FTP_SERVER_INTERGRATION
	mib_get(MIB_FTP_ENABLE, (void *)&ftp_enable);
#else
    mib_get(MIB_VSFTP_ENABLE, (void *)&ftp_enable);
#endif
    syslog(LOG_ERR, "iptables:in %s(%d):ftp_enable[%d]\r\n", __FUNCTION__, __LINE__, ftp_enable);

    //add ftp_account chain
    va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_FTP_ACCOUNT);
    va_cmd(IP6TABLES, 2, 1, "-F", (char *)FW_FTP_ACCOUNT);
    /*0:ftpserver disable;1:local enbale,remote disable;2:local disable,remote enable;3:local enbale,remote enbale*/
	if(ftp_enable == 0)
    {
        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);

        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
    }
    else if(ftp_enable == 1)
    {
        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);

        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
    }
    else if(ftp_enable == 2)
    {
        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);

        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
#if 0
        //iptables -A inacc -i nas+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i nas+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i br0 -p TCP --dport 21 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
#endif
    }
    else if(ftp_enable == 3)
    {
        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);

        //iptables -A ftp_account -i nas+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i ppp+  -p TCP --dport 21 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
        //iptables -A ftp_account -i br0 -p TCP --dport 21 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_FTP_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
#if 0
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);

        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
#endif
    }
    //iptables -A inacc -i nas+  -p TCP --dport 21 -j ACCEPT

    mib_get(MIB_SMB_SERVER_ENABLE, (void *)&smba_enable);
    syslog(LOG_ERR, "iptables:in %s(%d):smba_enable[%d]\r\n", __FUNCTION__, __LINE__, smba_enable);

    //add samba_account chain
    va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_SAMBA_ACCOUNT);
    va_cmd(IP6TABLES, 2, 1, "-F", (char *)FW_SAMBA_ACCOUNT);
    /*0:sambaserver disable;1:local enbale,remote disable;2:local disable,remote enable;3:local enbale,remote enbale*/

    if(smba_enable == 1)
    {
        //iptables -A samba_account -i nas+  -p TCP --dport 445 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i nas+  -p TCP --dport 139 -j DROP
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
//       (char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i nas+  -p UDP  --dport 137 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i nas+  -p UDP  --dport 138 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_DROP);

        //iptables -A samba_account -i ppp+  -p TCP --dport 445 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i ppp+  -p TCP --dport 139 -j DROP
 //       va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 137 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 138 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_DROP);

        //iptables -A samba_account -i br0  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p TCP --dport 139 -j ACCEPT
 //       va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);


        //iptables -A samba_account -i nas+  -p TCP --dport 445 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i nas+  -p TCP --dport 139 -j DROP
 //       va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i nas+  -p UDP  --dport 137 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i nas+  -p UDP  --dport 138 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_DROP);

        //iptables -A samba_account -i ppp+  -p TCP --dport 445 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i ppp+  -p TCP --dport 139 -j DROP
//        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 137 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 138 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_DROP);

        //iptables -A samba_account -i br0  -p TCP --dport 445 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);
    }
    else if(smba_enable == 2)
    {
        //iptables -A samba_account -i nas+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i ppp+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p TCP --dport 139 -j ACCEPT
 //       va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i br0  -p TCP --dport 445 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i br0  -p TCP --dport 139 -j DROP
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i br0  -p UDP  --dport 137 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i br0  -p UDP  --dport 138 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_DROP);


        //iptables -A samba_account -i nas+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p TCP --dport 139 -j ACCEPT
 //       va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i ppp+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p TCP --dport 139 -j ACCEPT
 //       va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i br0  -p TCP --dport 445 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i br0  -p TCP --dport 139 -j DROP
 //       va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i br0  -p UDP  --dport 137 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
        //iptables -A samba_account -i br0  -p UDP  --dport 138 -j DROP
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_DROP);

        #if 0
        //iptables -A inacc -i nas+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i nas+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
//         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i nas+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i nas+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

       //iptables -A inacc -i ppp+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i ppp+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
//         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i ppp+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i ppp+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i br0 -p TCP --dport 445 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_DROP);

        //iptables -A inacc -i br0 -p TCP --dport 445 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "139", "-j", (char *)FW_DROP);

        //iptables -A inacc -i br0 -p TCP --dport 445 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_DROP);

        //iptables -A inacc -i br0 -p TCP --dport 445 -j DROP
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_DROP);
        #endif
    }
    else if(smba_enable == 3)
    {
        //iptables -A samba_account -i nas+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i ppp+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i br0  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);


        //iptables -A samba_account -i nas+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p TCP --dport 139 -j ACCEPT
 //       va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
 //        (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
 //       (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i nas+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i ppp+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i ppp+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        //iptables -A samba_account -i br0  -p TCP --dport 445 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
//         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
        //iptables -A samba_account -i br0  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, act, (char *)FW_SAMBA_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

        #if 0
        //iptables -A inacc -i nas+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i nas+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
//         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i nas+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i nas+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);

       //iptables -A inacc -i ppp+  -p TCP --dport 445 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i ppp+  -p TCP --dport 139 -j ACCEPT
//        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
//         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
//        (char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i ppp+  -p UDP  --dport 137 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);

        //iptables -A inacc -i ppp+  -p UDP  --dport 138 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_UDP,
        (char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);
        #endif
    }
    else
    {

    }
       syslog(LOG_ERR, "iptables:in %s(%d)\r\n", __FUNCTION__, __LINE__);

    /*add by susha at 2016-2-3*/
/**end modify by wanghy at 20160714*/

//add start telnet_account chain by duanxy 20160718
	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_TELNET_ACCOUNT);
	/*0:telnetserver disable;1:local enbale,remote disable;2:local disable,remote enbale;3:local enbale,remote enbale*/
    if(accEntry.telnet == 0)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j DROP
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23 -j DROP
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j DROP
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
    }
    else if(accEntry.telnet == 1)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j DROP
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23-j DROP
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
    }
    else if(accEntry.telnet == 2)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);

    }
    else if(accEntry.telnet == 3)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j ACCEPT
        va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
    }
	/*add end by duanxy*/
    /*add by liuxm 2016.12.9 start*/
#ifdef CONFIG_IPV6
	va_cmd(IP6TABLES, 2, 1, "-F", (char *)FW_TELNET_ACCOUNT_V6);
    if(accEntry.telnet == 0)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j DROP
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23 -j DROP
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j DROP
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
    }
    else if(accEntry.telnet == 1)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j DROP
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23-j DROP
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
    }
    else if(accEntry.telnet == 2)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);

    }
    else if(accEntry.telnet == 3)
    {
        //iptables -A telnet_account -i nas+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "nas+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i ppp+  -p TCP --dport 23 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, "ppp+", "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
        //iptables -A telnet_account -i br0  -p TCP --dport 23 -j ACCEPT
        va_cmd(IP6TABLES, 10, 1, "-I", (char *)FW_TELNET_ACCOUNT_V6,
         (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
        (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
    }
#endif
    /*add by liuxm 2016.12.9 end*/
#if 0  /*modify by duanxy*/
	// telnet service: bring up by inetd
	#ifdef CONFIG_USER_TELNETD_TELNETD
	if (!(accEntry.telnet & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p TCP --dport 23 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
		(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, "23", "-j", (char *)FW_DROP);

	#ifdef CONFIG_IPV6
		//ip6tables -I ipv6remoteacc -i br0 -p TCP --dport 23 -j DROP
		va_cmd(IP6TABLES, 10, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, (char *)LANIF
				, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
	#endif
	}
	if (accEntry.telnet & 0x01) {	// can WAN access
		snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.telnet_port);
		va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_PREROUTING,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);

		// redirect if this is not standard port
		if (accEntry.telnet_port != 23) {
			ret = va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "23");
		}

		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 23 -j ACCEPT
		#if 0
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);

		fprintf(stderr, "telnet = %d\n", accEntry.telnet_port);
		if (accEntry.telnet_port != 23) {
			ret = va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "23");
			fprintf(stderr, "telnet cmd = %d\n", ret);
		}
		#endif

	#ifdef CONFIG_IPV6
		//block IPv6 WAN access
		//FIXME: There's no redirect rule support for IPv6, we can only block standard port.

		//ip6tables -I ipv6remoteacc -i ! br0 -p TCP --dport 23 -j ACCEPT
		va_cmd(IP6TABLES, 11, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, "!", (char *)LANIF
				, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
	#endif

	}
	#endif	//CONFIG_USER_TELNETD_TELNETD
    #endif


	#ifdef CONFIG_USER_FTPD_FTPD
	// ftp service: bring up by inetd  edit by susha at 2016-1-27 for del ftp rules
	if (!(accEntry.ftp & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p TCP --dport 21 -j DROP
	//	va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
	//	(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
	//	(char *)FW_DPORT, "21", "-j", (char *)FW_DROP);

	#ifdef CONFIG_IPV6
		//ip6tables -I ipv6remoteacc -i br0 -p TCP --dport 21 -j DROP
	//	va_cmd(IP6TABLES, 10, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, (char *)LANIF
	//			, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
	#endif
	}
	if (accEntry.ftp & 0x01) {	// can WAN access
		snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.ftp_port);
		va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_PREROUTING,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);

		// redirect if this is not standard port
		if (accEntry.ftp_port != 21) {
			ret = va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "21");
		}

		#if 0
		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 21 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
		#endif
#ifdef CONFIG_IPV6
		//block IPv6 WAN access
		//FIXME: There's no redirect rule support for IPv6, we can only block standard port.

		//ip6tables -A ipv6remoteacc -i ! br0 -p TCP --dport 23 -j ACCEPT
		va_cmd(IP6TABLES, 11, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, "!", (char *)LANIF
				, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
#endif

	}
	#endif	//CONFIG_USER_FTPD_FTPD

	#ifdef CONFIG_USER_TFTPD_TFTPD
	// tftp service: bring up by inetd
	if (!(accEntry.tftp & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p UDP --dport 69 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
		(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
		(char *)FW_DPORT, "69", "-j", (char *)FW_DROP);
	}
	if (accEntry.tftp & 0x01) {	// can WAN access
		// iptables -A inacc -i ! $LAN_IF -p UDP --dport 69 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
		(char *)FW_DPORT, "69", "-j", (char *)FW_ACCEPT);
	}
	#endif

	// HTTP service
		if (!(accEntry.web & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p TCP --dport 80 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "80", "-j", (char *)FW_DROP);
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "8080", "-j", (char *)FW_DROP);
		}
		if (accEntry.web & 0x01) {	// can WAN access
			snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.web_port);
			// iptables -A inacc -i ! $LAN_IF -p TCP --dport 80 -j ACCEPT
			va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_PREROUTING,
				 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
				(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);
			#if 0
			va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "80", "-j", (char *)FW_ACCEPT);
			#endif
			if (accEntry.web_port != 80) {
				va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "80");
			}
			snprintf(strPort, sizeof(strPort)-1, "8080");
			// iptables -A inacc -i ! $LAN_IF -p TCP --dport 80 -j ACCEPT
			va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_PREROUTING,
				 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
				(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);
		}

  #ifdef CONFIG_USER_BOA_WITH_SSL
  	  //HTTPS service
		if (!(accEntry.https & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p TCP --dport 443 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "443", "-j", (char *)FW_DROP);
		}
		if (accEntry.https & 0x01) {	// can WAN access
			snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.https_port);
			// iptables -t mangle  -I PREROUTING -i !$LAN_IF -p TCP --dport 443 -j MARK --set-mark 0x1000
			va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_PREROUTING,
				 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
				(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);

			if (accEntry.https_port != 443) {
				va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "443");
			}

		}
  #endif

	#ifdef CONFIG_USER_SNMPD_SNMPD_V2CTRAP
	// snmp service
	//if (accEntry.snmp !=0) {	// have snmp server
		if (!(accEntry.snmp & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p UDP --dport 161:162 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "161:162", "-j", (char *)FW_DROP);
		}
		if (accEntry.snmp & 0x01) {	// can WAN access
			// iptables -A inacc -i ! $LAN_IF -p UDP --dport 161:162 -m limit
			//  --limit 100/s --limit-burst 500 -j ACCEPT
			va_cmd(IPTABLES, 17, 1, act, (char *)FW_INACC,
				 "!", (char *)ARG_I, (char *)LANIF, "-p",
				(char *)ARG_UDP, (char *)FW_DPORT, "161:162", "-m",
				"limit", "--limit", "100/s", "--limit-burst",
				"500", "-j", (char *)FW_ACCEPT);
		}
	#endif

	#ifdef CONFIG_USER_SSH_DROPBEAR
	// ssh service
		if (!(accEntry.ssh & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p TCP --dport 22 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "22", "-j", (char *)FW_DROP);
#ifdef CONFIG_IPV6
			//nessus scan ssh port in ipv6			
			va_cmd(IP6TABLES, 10, 1, act, (char *)FW_IPV6REMOTEACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "22", "-j", (char *)FW_DROP);
#endif			
		}
		if (accEntry.ssh & 0x01) {	// can WAN access
			// iptables -A inacc -i ! $LAN_IF -p TCP --dport 22 -j ACCEPT
			va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "22", "-j", (char *)FW_ACCEPT);
			//nessus scan ssh port in ipv6
#ifdef CONFIG_IPV6			
			va_cmd(IP6TABLES, 11, 1, act, (char *)FW_IPV6REMOTEACC,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "22", "-j", (char *)FW_ACCEPT);
#endif			
		}
	#endif

	// ping service
	/*
	if (1) // can LAN access
	{
		// iptables -A INPUT -i $LAN_IF  -p ICMP --icmp-type echo-request -m limit
		//   --limit 1/s -j ACCEPT
		va_cmd(IPTABLES, 14, 1, act, (char *)FW_INPUT,
			(char *)ARG_I, (char *)LANIF, "-p", "ICMP",
			"--icmp-type", "echo-request", "-m", "limit",
			"--limit", "1/s", "-j", (char *)FW_ACCEPT);
	}
	*/

	if (accEntry.icmp & 0x01) // can WAN access
	{
		// iptables -A inacc -i ! $LAN_IF  -p ICMP --icmp-type echo-request -m limit
		//   --limit 1/s -j ACCEPT
		va_cmd(IPTABLES, 15, 1, act, (char *)FW_INACC,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", "ICMP",
			"--icmp-type", "echo-request", "-m", "limit",
			"--limit", "20/s", "-j", (char *)FW_ACCEPT);

#ifdef CONFIG_IPV6
		//ip6tables -A ipv6remoteacc -i !br0 -p icmpv6 --icmpv6-type echo-request -m limit --limit 1/sec -j ACCEPT
		va_cmd(IP6TABLES, 15, 1, (char *)FW_ADD, (char *)FW_IPV6REMOTEACC,	"!", (char *)ARG_I, (char *)LANIF,
			"-p", "icmpv6", "--icmpv6-type", "echo-request","-m", "limit","--limit", "20/s", "-j", (char *)FW_ACCEPT);
#endif	
	}

	#ifdef CONFIG_USER_NETLOGGER_SUPPORT
	if (accEntry.netlog & 0x01) {	// can WAN access
		snprintf(strPort, sizeof(strPort)-1, "%u", 0x1234);
		va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_PREROUTING,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);
	}
	#endif //CONFIG_USER_NETLOGGER_SUPPORT

#ifdef CONFIG_USER_SAMBA
	if (!(accEntry.smb & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p TCP --dport 139 -j DROP
//		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
//			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
//			(char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
		// iptables -A inacc -i $LAN_IF -p TCP --dport 445 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
		// iptables -A inacc -i $LAN_IF -p UDP --dport 137 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
		// iptables -A inacc -i $LAN_IF -p UDP --dport 138 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "138", "-j", (char *)FW_DROP);
	}
	if (accEntry.ssh & 0x01) {	// can WAN access
		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 139 -j ACCEPT
//		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
//		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
//			(char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 445 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
		// iptables -A inacc -i ! $LAN_IF -p UDP --dport 137 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
		// iptables -A inacc -i ! $LAN_IF -p UDP --dport 138 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);
	}
#endif

	/* For NESSUS 11612 */
	va_cmd(IPTABLES, 10, 1, "-I", (char *)FW_INACC, "-i", "br0", "-p", "udp", "--dport", "4011", "-j", FW_DROP);
}
#else
void remote_access_modify(MIB_CE_ACC_T accEntry, int enable)
{
	char *act = (char *)"-I";
	char strPort[8];
	int ret;
	unsigned char dhcpvalue[32];
	unsigned char vChar;
	int dhcpmode;

	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_INACC);

	// iptables -t mangle -F inacc
	va_cmd(IPTABLES, 4, 1, ARG_T, "mangle", "-F", FW_INACC);

	va_cmd(IPTABLES, 11, 1, "-A", (char *)FW_INACC,
		 "!", (char *)ARG_I, LANIF, "-m", "mark", "--mark", RMACC_MARK, "-j", FW_ACCEPT);

	// Added by Mason Yu for dhcp Relay. Open DHCP Relay Port for Incoming Packets.
	if (mib_get(MIB_DHCP_MODE, (void *)dhcpvalue) != 0)
	{
		dhcpmode = (unsigned int)(*(unsigned char *)dhcpvalue);
		if (dhcpmode == DHCP_LAN_SERVER || dhcpmode == DHCP_LAN_RELAY){
			// iptables -A inacc -i ! br0 -p udp --dport 67 -j ACCEPT
			va_cmd(IPTABLES, 11, 1, (char *)FW_ADD, (char *)FW_INACC, "!", (char *)ARG_I, BRIF, "-p", "udp", (char *)FW_DPORT, (char *)PORT_DHCP, "-j", (char *)FW_ACCEPT);
		}
	}

#ifdef CONFIG_USER_ROUTED_ROUTED
	// Added by Mason Yu. Open RIP Port for Incoming Packets.
	if (mib_get( MIB_RIP_ENABLE, (void *)&vChar) != 0)
	{
		if (1 == vChar)
		{
			// iptables -A inacc -i ! br0 -p udp --dport 520 -j ACCEPT
			va_cmd(IPTABLES, 11, 1, (char *)FW_ADD, (char *)FW_INACC, "!", "-i", BRIF, "-p", "udp", (char *)FW_DPORT, "520", "-j", (char *)FW_ACCEPT);
		}
	}
#endif

	if(!enable)
		return;

	// telnet service: bring up by inetd
	//#ifdef CONFIG_USER_TELNETD_TELNETD
	if (!(accEntry.telnet & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p TCP --dport 23 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
		(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, "23", "-j", (char *)FW_DROP);

	#ifdef CONFIG_IPV6
		//ip6tables -I ipv6remoteacc -i br0 -p TCP --dport 23 -j DROP
		va_cmd(IP6TABLES, 10, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, (char *)LANIF
				, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "23", "-j", (char *)FW_DROP);
	#endif
	}
	if (accEntry.telnet & 0x01) {	// can WAN access
		snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.telnet_port);
		va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);

		// redirect if this is not standard port
		if (accEntry.telnet_port != 23) {
			ret = va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "23");
		}

		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 23 -j ACCEPT
		#if 0
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);

		fprintf(stderr, "telnet = %d\n", accEntry.telnet_port);
		if (accEntry.telnet_port != 23) {
			ret = va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "23");
			fprintf(stderr, "telnet cmd = %d\n", ret);
		}
		#endif

	#ifdef CONFIG_IPV6
		//block IPv6 WAN access
		//FIXME: There's no redirect rule support for IPv6, we can only block standard port.

		//ip6tables -I ipv6remoteacc -i ! br0 -p TCP --dport 23 -j ACCEPT
		va_cmd(IP6TABLES, 11, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, "!", (char *)LANIF
				, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
	#endif

	}
	//#endif	//CONFIG_USER_TELNETD_TELNETD


	#ifdef CONFIG_USER_FTPD_FTPD
	// ftp service: bring up by inetd
	if (!(accEntry.ftp & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p TCP --dport 21 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
		(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, "21", "-j", (char *)FW_DROP);

	#ifdef CONFIG_IPV6
		//ip6tables -I ipv6remoteacc -i br0 -p TCP --dport 21 -j DROP
		va_cmd(IP6TABLES, 10, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, (char *)LANIF
				, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "21", "-j", (char *)FW_DROP);
	#endif
	}
	if (accEntry.ftp & 0x01) {	// can WAN access
		snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.ftp_port);
		va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);

		// redirect if this is not standard port
		if (accEntry.ftp_port != 21) {
			ret = va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "21");
		}

		#if 0
		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 21 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
		(char *)FW_DPORT, "21", "-j", (char *)FW_ACCEPT);
		#endif
#ifdef CONFIG_IPV6
		//block IPv6 WAN access
		//FIXME: There's no redirect rule support for IPv6, we can only block standard port.

		//ip6tables -A ipv6remoteacc -i ! br0 -p TCP --dport 23 -j ACCEPT
		va_cmd(IP6TABLES, 11, 1, act, (char *)FW_IPV6REMOTEACC, (char *)ARG_I, "!", (char *)LANIF
				, "-p", (char *)ARG_TCP, (char *)FW_DPORT, "23", "-j", (char *)FW_ACCEPT);
#endif

	}
	#endif	//CONFIG_USER_FTPD_FTPD

	#ifdef CONFIG_USER_TFTPD_TFTPD
	// tftp service: bring up by inetd
	if (!(accEntry.tftp & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p UDP --dport 69 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
		(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
		(char *)FW_DPORT, "69", "-j", (char *)FW_DROP);
	}
	if (accEntry.tftp & 0x01) {	// can WAN access
		// iptables -A inacc -i ! $LAN_IF -p UDP --dport 69 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
		(char *)FW_DPORT, "69", "-j", (char *)FW_ACCEPT);
	}
	#endif

	// HTTP service
		if (!(accEntry.web & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p TCP --dport 80 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "80", "-j", (char *)FW_DROP);
#ifdef CONFIG_YUEME
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "8080", "-j", (char *)FW_DROP);
#endif
		}
		if (accEntry.web & 0x01) {	// can WAN access
			snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.web_port);
			// iptables -A inacc -i ! $LAN_IF -p TCP --dport 80 -j ACCEPT
			va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_INACC,
				 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
				(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);
			#if 0
			va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "80", "-j", (char *)FW_ACCEPT);
			#endif
			if (accEntry.web_port != 80) {
				va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "80");
			}
#ifdef CONFIG_YUEME
			snprintf(strPort, sizeof(strPort)-1, "8080");
			// iptables -A inacc -i ! $LAN_IF -p TCP --dport 80 -j ACCEPT
			va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_INACC,
				 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
				(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);
#endif
		}

  #ifdef CONFIG_USER_BOA_WITH_SSL
  	  //HTTPS service
		if (!(accEntry.https & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p TCP --dport 443 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "443", "-j", (char *)FW_DROP);
		}
		if (accEntry.https & 0x01) {	// can WAN access
			snprintf(strPort, sizeof(strPort)-1, "%u", accEntry.https_port);
			// iptables -t mangle  -I PREROUTING -i !$LAN_IF -p TCP --dport 443 -j MARK --set-mark 0x1000
			va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_INACC,
				 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
				(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);

			if (accEntry.https_port != 443) {
				va_cmd(IPTABLES, 15, 1, "-t", "nat",
					(char *)act, (char *)FW_PREROUTING,
					 "!", (char *)ARG_I, (char *)LANIF,
					"-p", ARG_TCP,
					(char *)FW_DPORT, strPort, "-j",
					"REDIRECT", "--to-ports", "443");
			}

		}
  #endif

	#ifdef CONFIG_USER_SNMPD_SNMPD_V2CTRAP
	// snmp service
	//if (accEntry.snmp !=0) {	// have snmp server
		if (!(accEntry.snmp & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p UDP --dport 161:162 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "161:162", "-j", (char *)FW_DROP);
		}
		if (accEntry.snmp & 0x01) {	// can WAN access
			// iptables -A inacc -i ! $LAN_IF -p UDP --dport 161:162 -m limit
			//  --limit 100/s --limit-burst 500 -j ACCEPT
			va_cmd(IPTABLES, 17, 1, act, (char *)FW_INACC,
				 "!", (char *)ARG_I, (char *)LANIF, "-p",
				(char *)ARG_UDP, (char *)FW_DPORT, "161:162", "-m",
				"limit", "--limit", "100/s", "--limit-burst",
				"500", "-j", (char *)FW_ACCEPT);
		}
	#endif

	#ifdef CONFIG_USER_SSH_DROPBEAR
	// ssh service
		if (!(accEntry.ssh & 0x02)) {	// not LAN access
			// iptables -A inacc -i $LAN_IF -p TCP --dport 22 -j DROP
			va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "22", "-j", (char *)FW_DROP);
		}
		if (accEntry.ssh & 0x01) {	// can WAN access
			// iptables -A inacc -i ! $LAN_IF -p TCP --dport 22 -j ACCEPT
			va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "22", "-j", (char *)FW_ACCEPT);
		}
	#endif

	// ping service
	/*
	if (1) // can LAN access
	{
		// iptables -A INPUT -i $LAN_IF  -p ICMP --icmp-type echo-request -m limit
		//   --limit 1/s -j ACCEPT
		va_cmd(IPTABLES, 14, 1, act, (char *)FW_INPUT,
			(char *)ARG_I, (char *)LANIF, "-p", "ICMP",
			"--icmp-type", "echo-request", "-m", "limit",
			"--limit", "1/s", "-j", (char *)FW_ACCEPT);
	}
	*/

	if (accEntry.icmp & 0x01) // can WAN access
	{
		// iptables -A inacc -i ! $LAN_IF  -p ICMP --icmp-type echo-request -m limit
		//   --limit 1/s -j ACCEPT
		va_cmd(IPTABLES, 15, 1, act, (char *)FW_INACC,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", "ICMP",
			"--icmp-type", "echo-request", "-m", "limit",
			"--limit", "1/s", "-j", (char *)FW_ACCEPT);
#ifdef CONFIG_IPV6
		//ip6tables -A ipv6remoteacc -i !br0 -p icmpv6 --icmpv6-type echo-request -m limit --limit 1/sec -j ACCEPT
		va_cmd(IP6TABLES, 15, 1, (char *)FW_ADD, (char *)FW_IPV6REMOTEACC,  "!", (char *)ARG_I, (char *)LANIF,
		"-p", "icmpv6",	"--icmpv6-type", "echo-request","-m", "limit","--limit", "1/s", "-j", (char *)FW_ACCEPT);

#endif
	}

	#ifdef CONFIG_USER_NETLOGGER_SUPPORT
	if (accEntry.netlog & 0x01) {	// can WAN access
		snprintf(strPort, sizeof(strPort)-1, "%u", 0x1234);
		va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", act, (char *)FW_INACC,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);
	}
	#endif //CONFIG_USER_NETLOGGER_SUPPORT

#ifdef CONFIG_USER_SAMBA
	if (!(accEntry.smb & 0x02)) {	// not LAN access
		// iptables -A inacc -i $LAN_IF -p TCP --dport 139 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "139", "-j", (char *)FW_DROP);
		// iptables -A inacc -i $LAN_IF -p TCP --dport 445 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "445", "-j", (char *)FW_DROP);
		// iptables -A inacc -i $LAN_IF -p UDP --dport 137 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "137", "-j", (char *)FW_DROP);
		// iptables -A inacc -i $LAN_IF -p UDP --dport 138 -j DROP
		va_cmd(IPTABLES, 10, 1, act, (char *)FW_INACC,
			(char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "138", "-j", (char *)FW_DROP);
	}
	if (accEntry.smb & 0x01) {	// can WAN access
		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 139 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "139", "-j", (char *)FW_ACCEPT);
		// iptables -A inacc -i ! $LAN_IF -p TCP --dport 445 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_TCP,
			(char *)FW_DPORT, "445", "-j", (char *)FW_ACCEPT);
		// iptables -A inacc -i ! $LAN_IF -p UDP --dport 137 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "137", "-j", (char *)FW_ACCEPT);
		// iptables -A inacc -i ! $LAN_IF -p UDP --dport 138 -j ACCEPT
		va_cmd(IPTABLES, 11, 1, act, (char *)FW_INACC,
		 	"!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, "138", "-j", (char *)FW_ACCEPT);
	}
#endif
#ifdef CONFIG_CT_AWIFI_JITUAN_SMARTWIFI
    unsigned char functype=0;
    mib_get(AWIFI_PROVINCE_CODE, &functype);
    if(functype == AWIFI_ZJ){
	va_cmd(IPTABLES, 2, 1, "-N", "LanAuth_Web");
	va_cmd(IPTABLES, 6, 1, "-A", (char *)FW_INACC, "-i", "br0", "-j", "LanAuth_Web");
    }
#endif
}
#endif // of YUEME
void filter_set_remote_access(int enable)
{
	MIB_CE_ACC_T accEntry;
	if (!mib_chain_get(MIB_ACC_TBL, 0, (void *)&accEntry))
		return;
	remote_access_modify( accEntry, enable );

	return;

}
#endif // of REMOTE_ACCESS_CTL

#ifdef IP_ACL
void filter_set_acl(int enable)
{
	int i, total;
	struct in_addr src;
	char ssrc[40];
	MIB_CE_ACL_IP_T Entry;

#ifdef ACL_IP_RANGE
	struct in_addr start,end;
	char sstart[16],send[16];
#endif

#ifdef MAC_ACL
	MIB_CE_ACL_MAC_T MacEntry;
	char macaddr[18];
#endif


	// Added by Mason Yu for ACL.
	// check if ACL Capability is enabled ?
	if (!enable)
		va_cmd(IPTABLES, 2, 1, "-F", "aclblock");
	else {
		// Add policy to aclblock chain
		total = mib_chain_total(MIB_ACL_IP_TBL);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_ACL_IP_TBL, i, (void *)&Entry))
			{
				return;
			}

//    		printf("\nstartip=%x,endip=%x\n",*(unsigned long*)Entry.startipAddr,*(unsigned long*)Entry.endipAddr);

			// Check if this entry is enabled
			if ( Entry.Enabled == 1 ) {
#ifdef ACL_IP_RANGE
				start.s_addr = *(unsigned long*)Entry.startipAddr;
				end.s_addr = *(unsigned long*)Entry.endipAddr;
				strcpy(sstart, inet_ntoa(start));
				strcpy(send, inet_ntoa(end));
				strcpy(ssrc,sstart);
				strcat(ssrc,"-");
				strcat(ssrc,send);

#else
				src.s_addr = *(unsigned long *)Entry.ipAddr;

				// inet_ntoa is not reentrant, we have to
				// copy the static memory before reuse it
				strcpy(ssrc, inet_ntoa(src));
				snprintf(ssrc, 20, "%s/%d", ssrc, Entry.maskbit);

#endif
		        	if ( Entry.Interface == IF_DOMAIN_LAN ) {

#ifdef ACL_IP_RANGE
					if(*(unsigned long*)Entry.startipAddr != *(unsigned long*)Entry.endipAddr)
					// iptables -A aclblock -m iprange --src-range x.x.x.x-1x.x.x.x -j RETURN
						va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, "aclblock", "-i", BRIF, "-m", "iprange", "--src-range", ssrc, "-j", (char *)FW_RETURN);
					else
						va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, "aclblock", "-i", BRIF, "-s", sstart, "-j", (char *)FW_RETURN);
#else
					// iptables -A INPUT -s xxx.xxx.xxx.xxx
					va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, "aclblock", "-i", BRIF, "-s", ssrc, "-j", (char *)FW_RETURN);
#endif
				} else {
					// iptables -A INPUT -s xxx.xxx.xxx.xxx
					va_cmd(IPTABLES, 9, 1, (char *)FW_ADD, "aclblock", "!", "-i", BRIF, "-s", ssrc, "-j", (char *)FW_RETURN);
				}
			}
		}
#ifdef MAC_ACL
		total = mib_chain_total(MIB_ACL_MAC_TBL);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_ACL_MAC_TBL, i, (void *)&MacEntry))
			{
				return;
			}

			// Check if this entry is enabled
			if ( MacEntry.Enabled == 1 ) {
				snprintf(macaddr, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
					MacEntry.macAddr[0], MacEntry.macAddr[1],
					MacEntry.macAddr[2], MacEntry.macAddr[3],
					MacEntry.macAddr[4], MacEntry.macAddr[5]);

		        if ( MacEntry.Interface == IF_DOMAIN_LAN ) {
		 			// iptables -A aclblock -i br0  -m mac --mac-source $MAC -j RETURN
					va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, "aclblock",
							(char *)ARG_I, BRIF, "-m", "mac",
							"--mac-source",  macaddr, "-j", (char *)FW_RETURN);
				} else {
					// iptables -A aclblock -i ! br0  -m mac --mac-source $MAC -j RETURN
					va_cmd(IPTABLES, 11, 1, (char *)FW_ADD, "aclblock",
							 "!", (char *)ARG_I, BRIF, "-m", "mac",
							"--mac-source",  macaddr, "-j", (char *)FW_RETURN);
				}
			}
		}
#endif

		// allowing DNS request during ACL enabled
		// iptables -A aclblock -p udp -i br0 --dport 53 -j RETURN
		va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, "aclblock", "-p", "udp", "-i", BRIF,(char*)FW_DPORT, (char *)PORT_DNS, "-j", (char *)FW_RETURN);
		// allowing DHCP request during ACL enabled
		// iptables -A aclblock -p udp -i br0 --dport 67 -j RETURN
		va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, "aclblock", "-p", "udp", "-i", BRIF, (char*)FW_DPORT, (char *)PORT_DHCP, "-j", (char *)FW_RETURN);

		// iptables -A aclblock -i lo -j RETURN
		// Local Out DNS query will refer the /etc/resolv.conf(DNS server is 127.0.0.1). We should accept this DNS query when enable ACL.
		va_cmd(IPTABLES, 6, 1, (char *)FW_ADD, "aclblock", "-i", "lo", "-j", (char *)FW_RETURN);
		// iptables -A aclblock -j DROP
		va_cmd(IPTABLES, 4, 1, (char *)FW_ADD, "aclblock", "-j", (char *)FW_DROP);
	}
}
#endif

#ifdef NAT_CONN_LIMIT
//ql_xu add
int restart_connlimit(void)
{
	unsigned char connlimitEn;

	va_cmd(IPTABLES, 2, 1, "-F", "connlimit");

	mib_get(MIB_NAT_CONN_LIMIT, (void *)&connlimitEn);
	if (connlimitEn == 1)
		set_conn_limit();
}

void set_conn_limit(void)
{
	int i, total;
	char ssrc[20];
	char connNum[10];
	MIB_CE_CONN_LIMIT_T Entry;

	// Add policy to connlimit chain
	//iptables -A connlimit -m state --state RELATED,ESTABLISHED -j RETURN
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, "connlimit", "-m", "state",
		"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_RETURN);

	total = mib_chain_total(MIB_CONN_LIMIT_TBL);
	for (i=0; i<total; i++) {
		if (!mib_chain_get(MIB_CONN_LIMIT_TBL, i, (void *)&Entry))
			continue;

		// Check if this entry is enabled
		if ( Entry.Enabled == 1 ) {
			// inet_ntoa is not reentrant, we have to
			// copy the static memory before reuse it
			strncpy(ssrc, inet_ntoa(*((struct in_addr *)&Entry.ipAddr)), 16);
			ssrc[15] = '\0';

			snprintf(connNum, 10, "%d", Entry.connNum);

			// iptables -A connlimit -i br0 -s xxx.xxx.xxx.xxx
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, "connlimit", "-s", ssrc, "-m", "iplimit",
				"--iplimit-above", connNum, "--iplimit-mask", "255.255.255.255", "-j", "REJECT");
		}
	}
}
#endif
#ifdef TCP_UDP_CONN_LIMIT
int restart_connlimit(void)
{
	unsigned char connlimitEn;

	va_cmd(IPTABLES, 2, 1, "-F", "connlimit");

	mib_get(MIB_CONNLIMIT_ENABLE, (void *)&connlimitEn);
	if (connlimitEn == 1)
		set_conn_limit();
}

void set_conn_limit(void)
{
	int 					i, total;
	char 				ssrc[20];
	char 				connNum[10];
	MIB_CE_TCP_UDP_CONN_LIMIT_T Entry;

	// Add policy to connlimit chain, allow all established ~
	//iptables -A connlimit -m state --state RELATED,ESTABLISHED -j RETURN
	va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, "connlimit", "-m", "state",
		"--state", "ESTABLISHED,RELATED", "-j", (char *)FW_RETURN);

	total = mib_chain_total(MIB_TCP_UDP_CONN_LIMIT_TBL);
	for (i=0; i<total; i++) {
		if (!mib_chain_get(MIB_TCP_UDP_CONN_LIMIT_TBL, i, (void *)&Entry))
			continue;
		// Check if this entry is enabled and protocol is TCP
		if (( Entry.Enabled == 1 ) && ( Entry.protocol == 0 )) {
			// inet_ntoa is not reentrant, we have to
			// copy the static memory before reuse it
			strncpy(ssrc, inet_ntoa(*((struct in_addr *)&Entry.ipAddr)), 16);
			ssrc[15] = '\0';
			snprintf(connNum, 10, "%d", Entry.connNum);

			// iptables -A connlimit -p tcp -s 192.168.1.99 -m iplimit --iplimit-above 2 -j REJECT
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, "connlimit","-p","tcp", "-s", ssrc, "-m", "iplimit",
				"--iplimit-above", connNum, "-j", "REJECT");
		}
		// UDP
		else if  (( Entry.Enabled == 1 ) && ( Entry.protocol == 1 )) {
			strncpy(ssrc, inet_ntoa(*((struct in_addr *)&Entry.ipAddr)), 16);
			ssrc[15] = '\0';
			snprintf(connNum, 10, "%d", Entry.connNum);

			//iptables -A connlimit -p udp -s 192.168.1.99 -m udplimit --udplimit-above 2 -j REJECT
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, "connlimit","-p","udp", "-s", ssrc, "-m", "udplimit",
				"--udplimit-above", connNum, "-j", "REJECT");
		}

	}

	//The Global rules goes last ~
	//TCP
	mib_get(MIB_CONNLIMIT_TCP, (void *)&i);
	if (i >0)
	{
		snprintf(connNum, 10, "%d", i);
		va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, "connlimit","-p","tcp",  "-m", "iplimit",
					"--iplimit-above", connNum, "-j", "REJECT");
	}
	//UDP
	mib_get(MIB_CONNLIMIT_UDP, (void *)&i);
	if (i >0)
	{
		snprintf(connNum, 10, "%d", i);
		va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, "connlimit","-p","udp",  "-m", "udplimit",
					"--udplimit-above", connNum, "-j", "REJECT");
	}

}
#endif//TCP_UDP_CONN_LIMIT

#ifdef URL_BLOCKING_SUPPORT
void filter_set_url(int mode)
{
	int i, total;
	MIB_CE_URL_FQDN_T entry;
	char portStr[6];

	//Kevin, check does it need to enable/disable IP fastpath status
	UpdateIpFastpathStatus();

	va_cmd(IPTABLES, 2, 1, "-F", "urlblock");
	va_cmd(IPTABLES, 2, 1, "-F", "urlallow");

#ifdef CONFIG_RTK_L34_ENABLE
	Flush_RTK_RG_URL_Filter();
#endif

#ifdef CONFIG_RTK_L34_ENABLE
	RTK_RG_URL_Filter_Set_By_Key(mode);
#endif

	if(1 == mode) {//blacklist
		printf("urlblock\n");
		// Add URL policy to urlblock chain
		total = mib_chain_total(MIB_URL_FQDN_TBL);

		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_URL_FQDN_TBL, i, (void *)&entry))
				return;

			snprintf(portStr, 6, "%d", entry.port);
			printf("port:%s key:%s", portStr, entry.key);
		 	// iptables -A urlblock -p tcp --dport 80 -m string --url "tw.yahoo.com" -j DROP
			va_cmd(IPTABLES, 14, 1, (char *)FW_ADD, "urlblock", "-p", "tcp", "--dport",
				portStr, "-m", "string", "--algo", "bm", "--url", entry.key, "-j", (char *)FW_DROP);
		}
#ifdef _PRMT_C_CU_USERACCOUNT_
		printf("user account urlblock\n");
		USER_ACCOUNT_URL_T uentry;	
		// Add URL policy to urlblock chain
		total = mib_chain_total(CONFIG_USER_ACCOUNT_URL_BLACK);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(CONFIG_USER_ACCOUNT_URL_BLACK, i, (void *)&uentry))
				continue;
			if(!strcmp(uentry.filter,""))
				continue;
		 	// iptables -A urlblock -p tcp --dport 80 -m string --algo bm --url "tw.yahoo.com" -j DROP
			va_cmd(IPTABLES, 14, 1, (char *)FW_ADD, "urlblock", "-p", "tcp", "--dport",
				"80", "-m", "string", "--algo", "bm", "--url", uentry.filter, "-j", (char *)FW_DROP);
		}

#endif
	}
	else if (2 == mode) {//whitelist
		printf("urlallow\n");
		// Add URL policy to urlblock chain
		total = mib_chain_total(MIB_URL_FQDN_TBL);

		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_URL_FQDN_TBL, i, (void *)&entry))
				return;

			snprintf(portStr, 6, "%d", entry.port);
			// iptables -A urlallow -p tcp --dport 80 -m string --url "tw.yahoo.com" -j ACCEPT
			va_cmd(IPTABLES, 14, 1, (char *)FW_ADD, "urlallow", "-p", "tcp", "--dport",
				portStr, "-m", "string", "--algo", "bm", "--urlalw", entry.key, "-j", (char *)FW_ACCEPT);
		}
#ifdef _PRMT_C_CU_USERACCOUNT_
		printf("user account urlallow\n");
		USER_ACCOUNT_URL_T uentry;	
		total = mib_chain_total(CONFIG_USER_ACCOUNT_URL_WHITE);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(CONFIG_USER_ACCOUNT_URL_WHITE, i, (void *)&uentry))
				continue;
			if(!strcmp(uentry.filter,""))
				continue;
			va_cmd(IPTABLES, 14, 1, (char *)FW_ADD, "urlallow", "-p", "tcp", "--dport",
				"80", "-m", "string", "--algo", "bm", "--urlalw", uentry.filter, "-j", (char *)FW_ACCEPT);
		}
#endif
		//&endofurl& is flag for drop other urls
		va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, "urlallow", "-p", "tcp", "-m", "string",
			"--urlalw", "endofurl" ,"-j", (char *)FW_DROP);
	}
}

int restart_urlblocking(void)
{
	unsigned char urlEnable;

	va_cmd(IPTABLES, 2, 1, "-F", "urlblock");

#ifdef CONFIG_RTK_L34_ENABLE
	Flush_RTK_RG_URL_Filter();
#endif

	mib_get(MIB_URL_CAPABILITY, (void *)&urlEnable);
	filter_set_url(urlEnable);

	return 0;
}

#ifdef SUPPORT_URL_FILTER
int parse_ur_filter(char *url, char *key, int *port)
{
	char urlTmp[256]={0};
	char *pTmp;
	
	if((url == NULL) || (key == NULL) || (port == NULL) || (strlen(url) == 0))
		return 0;

	if (!strncmp(url, "http://", 7))
		strcpy(urlTmp, url+7);
	else
		strcpy(urlTmp, url);

	pTmp = strtok(urlTmp, ":");

	if (!strncmp(pTmp, "www.", 4)) 
	{
		if (pTmp[4]) 
			strcpy(key, pTmp + 3);
	} 
	else 
	{
		if (pTmp[0]) 
			strcpy(key, pTmp);
	}

	pTmp = strtok(NULL, ":");
	if(pTmp == NULL)
		*port = 80;
	else
		*port = atoi(pTmp);

	printf("url key:%s, port=%d\n", key, *port);
	return 1;
}

void set_url_filter()
{
	int i, total, port;
	MIB_CE_URL_FILTER_T entry;
	char portStr[6];
	char key[256]={0};

	//Kevin, check does it need to enable/disable IP fastpath status
	UpdateIpFastpathStatus();


#ifdef CONFIG_RTK_L34_ENABLE
	Flush_RTK_RG_URL_Filter_new();
#endif

#ifdef CONFIG_RTK_L34_ENABLE
	RTK_RG_URL_Filter_Set_By_Key_new();
#endif

#if 0
	printf("urlfilter\n");
	total = mib_chain_total(MIB_URL_FILTER_TBL);
	for (i=0; i<total; i++) {
		if (!mib_chain_get(MIB_URL_FILTER_TBL, i, (void *)&entry))
			return;

		if(entry.Enable == 0)
			continue;

		parse_ur_filter(entry.url, key, &port);
		snprintf(portStr, 6, "%d", port);
		 // iptables -A urlblock -p tcp --dport 80 -m string --url "tw.yahoo.com" -j DROP
		va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, "urlblock", "-p", "tcp", "--dport",
			portStr, "-m", "string", "--url", key, "-j", (char *)FW_DROP);
	}
#endif	
	
}
int restart_urlfilter(void)
{
	unsigned char urlEnable;

	va_cmd(IPTABLES, 2, 1, "-F", "urlblock");

#ifdef CONFIG_RTK_L34_ENABLE
	Flush_RTK_RG_URL_Filter();
#endif

	set_url_filter();

	return 0;
}
#endif

#ifdef URL_ALLOWING_SUPPORT
void set_url(int enable)
{
	int i, j, total, totalKeywd;
	MIB_CE_URL_FQDN_T Entry;

	// check if URL Capability is enabled ?

	if (!enable)

		va_cmd(IPTABLES, 2, 1, "-F", "urlallow");

	else {

		// Add URL policy to urlblock chain
		total = mib_chain_total(MIB_URL_ALLOW_FQDN_TBL);

		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_URL_ALLOW_FQDN_TBL, i, (void *)&Entry))
			{
				return;
			}

		 	// iptables -A urlallow -p tcp --dport 80 -m string --url "tw.yahoo.com" -j ACCEPT
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, "urlallow", "-p", "tcp", "--dport", "80", "-m", "string", "--urlalw", Entry.fqdn, "-j", (char *)FW_ACCEPT);
		}
	//&endofurl& is flag for drop other urls
              va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, "urlallow", "-p", "tcp", "--dport", "80", "-m", "string", "--urlalw", "&endofurl&" ,"-j", (char *)FW_DROP);
	}
}

int restart_url(void)
{
	unsigned char urlEnable;

	va_cmd(IPTABLES, 2, 1, "-F", "urlallow");
	va_cmd(IPTABLES, 2, 1, "-F", "urlblock");
	mib_get(MIB_URL_CAPABILITY, (void *)&urlEnable);
	if (urlEnable == 1)  // URL Capability enabled
		filter_set_url(1);
	else if(urlEnable == 2) //URL allow
		set_url(2);

	return 0;
}
#endif
#endif

#ifdef DOMAIN_BLOCKING_SUPPORT
// Added by Mason Yu for Domain Blocking
void filter_set_domain(int enable)
{
	int i, total;
	MIB_CE_DOMAIN_BLOCKING_T Entry;
	unsigned char sdest[MAX_DOMAIN_LENGTH];
	int j, k;
    	unsigned char *needle_tmp, *str;
    	char len[MAX_DOMAIN_GROUP];
    	unsigned char seg[MAX_DOMAIN_GROUP][MAX_DOMAIN_SUB_STRING];
    	unsigned char cmpStr[MAX_DOMAIN_LENGTH]="\0";

	//Kevin, check does it need to enable/disable IP fastpath status
    UpdateIpFastpathStatus();

	// check if Domain Blocking Capability is enabled ?
	if (!enable)
		va_cmd(IPTABLES, 2, 1, "-F", "domainblk");
	else {
		// Add policy to domainblk chain
		total = mib_chain_total(MIB_DOMAIN_BLOCKING_TBL);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_DOMAIN_BLOCKING_TBL, i, (void *)&Entry))
			{
				return;
			}

			// Mason Yu
			// calculate domain sub string lengh and form the compare sub string.
			// Foe example, If the domain is aa.bbb.cccc, the compare sub string 1 is 0x02 0x61 0x61.
			// The compare sub string 2 is 0x03 0x62 0x62 0x62. The compare sub string 3 is 0x04 0x63 0x63 0x63 0x63.
			needle_tmp = Entry.domain;

			for (j=0; (str =strchr(needle_tmp, '.'))!= NULL; j++)
    			{
    				*str = '\0';

    				strncpy(seg[j]+1, needle_tmp, (MAX_DOMAIN_SUB_STRING - 1));
    				seg[j][MAX_DOMAIN_SUB_STRING - 1]='\0';
    				//printf(" seg[%d]= %s...(1)\n", j, seg[j]);

    				//seg[j][0]= len[j];
    				seg[j][0] = strlen(needle_tmp);
    				//printf(" seg[%d]= %s...(2)\n", j, seg[j]);

    				needle_tmp = str+1;
   			}

    			// calculate the laster domain sub string lengh and form the laster compare sub string
    			strncpy(seg[j]+1, needle_tmp, (MAX_DOMAIN_SUB_STRING - 1));
    			seg[j][MAX_DOMAIN_SUB_STRING - 1]='\0';

    			seg[j][0]= strlen(needle_tmp);
    			//printf(" seg[%d]= %s...(3)\n", j, seg[j]);

    			// Merge the all compare sub string into a final compare string.
    			for ( k=0; k<=j; k++) {
    				//printf(" seg[%d]= %s", k, seg[k]);
    				strcat(cmpStr, seg[k]);
    				//printf(" cmpStr=%s\n", cmpStr);
    			}
    			//printf("\n");

		 	// iptables -A domainblk -p udp --dport 53 -m string --domain yahoo.com -j DROP
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, "domainblk", "-p", "udp", "--dport", "53", "-m", "string", "--domain", cmpStr, "-j", (char *)FW_DROP);
			cmpStr[0] = '\0';
		}

	}
}

int restart_domainBLK(void)
{
	unsigned char domainEnable;

	va_cmd(IPTABLES, 2, 1, "-F", "domainblk");
	mib_get(MIB_DOMAINBLK_CAPABILITY, (void *)&domainEnable);
	if (domainEnable == 1)  // domain blocking Capability enabled
		filter_set_domain(1);
	else
		filter_set_domain(0);
	return 0;
}
#endif

#if defined(CONFIG_USER_ROUTED_ROUTED) || defined(CONFIG_USER_ZEBRA_OSPFD_OSPFD)
static const char ROUTED_CONF[] = "/var/run/routed.conf";

int startRip(void)
{
	FILE *fp;
	unsigned char ripOn, ripInf, ripVer;
	int rip_pid;

	unsigned int entryNum, i;
	MIB_CE_RIP_T Entry;
	char ifname[IFNAMSIZ], receive_mode[5], send_mode[5];

	if (mib_get(MIB_RIP_ENABLE, (void *)&ripOn) == 0)
		ripOn = 0;
	rip_pid = read_pid((char *)ROUTED_PID);
	if (rip_pid >= 1) {
		// kill it
		if (kill(rip_pid, SIGTERM) != 0) {
			printf("Could not kill pid '%d'", rip_pid);
		}
	}

	if (!ripOn)
		return 0;

	printf("start rip!\n");
	if ((fp = fopen(ROUTED_CONF, "w")) == NULL)
	{
		printf("Open file %s failed !\n", ROUTED_CONF);
		return -1;
	}

#if 0
	if (mib_get(MIB_RIP_VERSION, (void *)&ripVer) == 0)
		ripVer = 1;	// default version 2

	fprintf(fp, "version %u\n", ripVer+1);

	// LAN interface
	if (mib_get(MIB_ADSL_LAN_RIP, (void *)&ripOn) != 0)
	{
		if (ripOn)
			fprintf(fp, "network br0\n");
	}

	// WAN interface
	vcTotal = mib_chain_total(MIB_ATM_VC_TBL);

	for (i=0; i<vcTotal; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;

		if (Entry.enable == 0)
			continue;

		if (Entry.cmode != CHANNEL_MODE_BRIDGE && Entry.rip)
		{
			if (PPP_INDEX(Entry.ifIndex) != 0x0f)
			{	// PPP interface
				snprintf(ifname, 6, "ppp%u", PPP_INDEX(Entry.ifIndex));
			}
			else
			{	// vc interface
				snprintf(ifname, 6, "vc%u", VC_INDEX(Entry.ifIndex));
			}

			fprintf(fp, "network %s\n", ifname);
		}
	}
#endif

	entryNum = mib_chain_total(MIB_RIP_TBL);

	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_RIP_TBL, i, (void *)&Entry))
		{
			fclose(fp);
  			printf("Get MIB_RIP_TBL chain record error!\n");
			return -1;
		}

		if (!ifGetName(Entry.ifIndex, ifname, sizeof(ifname))) {
			strncpy(ifname, BRIF, strlen(BRIF));
			ifname[strlen(BRIF)] = '\0';
		}

		fprintf(fp, "network %s %d %d\n", ifname, Entry.receiveMode, Entry.sendMode);
	}

	fclose(fp);
	// Modified by Mason Yu for always as a supplier for RIP
	//va_cmd(ROUTED, 0, 0);
	va_cmd(ROUTED, 1, 0, "-s");
	return 1;
}
#endif	// of CONFIG_USER_ROUTED_ROUTED

#ifdef CONFIG_USER_ZEBRA_OSPFD_OSPFD
static const char ZEBRA_CONF[] = "/etc/config/zebra.conf";
static const char OSPFD_CONF[] = "/etc/config/ospfd.conf";

// OSPF server configuration
// return value:
// 0  : not enabled
// 1  : successful
// -1 : startup failed
int startOspf(void)
{
	FILE *fp;
	char *argv[6];
	int pid;
	unsigned char ospfOn;
	unsigned int entryNum, i, j;
	MIB_CE_OSPF_T Entry;
	char *netIp[20];
	unsigned int uMask;
	unsigned int uIp;

	if (mib_get(MIB_OSPF_ENABLE, (void *)&ospfOn) == 0)
		ospfOn = 0;
	//kill old zebra
	pid = read_pid((char *)ZEBRA_PID);
	if (pid >= 1) {
		if (kill(pid, SIGTERM) != 0) {
			printf("Could not kill pid '%d'\n", pid);
		}
	}
	//kill old ospfd
	pid = read_pid((char *)OSPFD_PID);
	if (pid >= 1) {
		if (kill(pid, SIGTERM) != 0)
			printf("Could not kill pid '%d'\n", pid);
	}

	if (!ospfOn)
		return 0;

	printf("start ospf!\n");
	//create zebra.conf
	if ((fp = fopen(ZEBRA_CONF, "w")) == NULL)
	{
		printf("Open file %s failed !\n", ZEBRA_CONF);
		return -1;
	}
	fprintf(fp, "hostname Router\n");
	fprintf(fp, "password zebra\n");
	fprintf(fp, "enable password zebra\n");
	fclose(fp);

	//create ospfd.conf
	if ((fp = fopen(OSPFD_CONF, "w")) == NULL)
	{
		printf("Open file %s failed !\n", OSPFD_CONF);
		return -1;
	}
	fprintf(fp, "hostname ospfd\n");
	fprintf(fp, "password zebra\n");
	fprintf(fp, "enable password zebra\n");
	fprintf(fp, "router ospf\n");
	//ql_xu test.
	//fprintf(fp, "network %s area 0\n", "192.168.2.0/24");
	entryNum = mib_chain_total(MIB_OSPF_TBL);

	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_OSPF_TBL, i, (void *)&Entry))
		{
  			printf("Get MIB_OSPF_TBL chain record error!\n");
			return -1;
		}

		uIp = *(unsigned int *)Entry.ipAddr;
		uMask = *(unsigned int *)Entry.netMask;
		uIp = uIp & uMask;
		strcpy(netIp, inet_ntoa(*((struct in_addr *)&uIp)));

		for (j=0; j<32; j++)
			if ((uMask>>j) & 0x01)
				break;
		uMask = 32 - j;

		sprintf(netIp, "%s/%d", netIp, uMask);
		fprintf(fp, "network %s area 0\n", netIp);
	}
	fclose(fp);

	//start zebra
	argv[1] = "-d";
	argv[2] = "-k";
	argv[3] = NULL;
	TRACE(STA_SCRIPT, "%s %s %s\n", ZEBRA, argv[1], argv[2]);
	do_nice_cmd(ZEBRA, argv, 0);

	//start ospfd
	argv[1] = "-d";
	argv[2] = NULL;
	TRACE(STA_SCRIPT, "%s %s\n", OSPFD, argv[1]);
	do_nice_cmd(OSPFD, argv, 0);

	return 1;
}
#endif

#include <linux/atm.h>

//up_flag:0, itf down; non-zero: itf up
void itfcfg(char *if_name, int up_flag)
{
#ifdef EMBED
	int fd;
	struct ifreq ifr;
	char cmd;

	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) >= 0) {
		int flags;
		if (getInFlags(if_name, &flags) == 1) {
			if (up_flag)
				flags |= IFF_UP;
			else
				flags &= ~IFF_UP;

			setInFlags(if_name, flags);
		}
		close(fd);
	}
#endif
}

#ifdef XOR_ENCRYPT
const char XOR_KEY[] = "tecomtec";
void xor_encrypt(char *inputfile, char *outputfile)
{
	FILE *input  = fopen(inputfile, "rb");
	FILE *output = fopen(outputfile, "wb");

	if(input != NULL && output != NULL) {
		unsigned char buffer[MAX_CONFIG_FILESIZE];
		size_t count, i, j = 0;
		do {
			count = fread(buffer, sizeof *buffer, sizeof buffer, input);
			for(i = 0; i<count; ++i) {
				buffer[i] ^= XOR_KEY[j++];
				if(XOR_KEY[j] == '\0')
					j = 0; /* restart at the beginning of the key */
			}
			fwrite(buffer, sizeof *buffer, count, output);
		} while (count == sizeof buffer);
		fclose(input);
		fclose(output);
	}
}
#endif

unsigned short
ipchksum(unsigned char *ptr, int count, unsigned short resid)
{
	register unsigned int sum = resid;
       if ( count==0)
       	return(sum);

	while(count > 1) {
		//sum += ntohs(*ptr);
		sum += (( ptr[0] << 8) | ptr[1] );
		if ( sum>>31)
			sum = (sum&0xffff) + ((sum>>16)&0xffff);
		ptr += 2;
		count -= 2;
	}

	if (count > 0)
		sum += (*((unsigned char*)ptr) << 8) & 0xff00;

	while (sum >> 16)
		sum = (sum & 0xffff) + (sum >> 16);

	if (sum == 0xffff)
		sum = 0;
	return (unsigned short)sum;
}

int getLinkStatus(struct ifreq *ifr)
{
	int status=0;

#ifdef __mips__
	if (do_ioctl(SIOCGMEDIALS, ifr) == 1)
		status = 1;
#endif
	return status;
}

/***port forwarding APIs*******/
#ifdef PORT_FORWARD_GENERAL
/*move from startup.c:iptable_fw()*/
static void iptable_fw( int del, int negate, const char *ifname, const char *proto, const char *remoteIP, const char *extPort, const char *dstIP)
{
	char *act;

	if(del) act = (char *)FW_DEL;
	else act = (char *)FW_ADD;


//	if (negate && remoteIP) {
	if (negate && remoteIP && extPort) {
		va_cmd(IPTABLES, 17, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			 "!", (char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			"-s", (char *)remoteIP,
			(char *)FW_DPORT, extPort, "-j",
			"DNAT", "--to-destination", dstIP);
	} else if (negate && remoteIP) {
		va_cmd(IPTABLES, 15, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			 "!", (char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			"-s", (char *)remoteIP,
			"-j", "DNAT", "--to-destination", dstIP);
//	} else if (negate) {
	} else if (negate && extPort) {
		va_cmd(IPTABLES, 15, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			 "!", (char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			(char *)FW_DPORT, extPort, "-j",
			"DNAT", "--to-destination", dstIP);
//	} else if (remoteIP) {
	} else if (remoteIP && extPort) {
		va_cmd(IPTABLES, 16, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			(char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			"-s", (char *)remoteIP,
			(char *)FW_DPORT, extPort, "-j",
			"DNAT", "--to-destination", dstIP);
	} else if (negate) {
		va_cmd(IPTABLES, 13, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			 "!", (char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			"-j", "DNAT", "--to-destination", dstIP);
	} else if (remoteIP) {
		va_cmd(IPTABLES, 14, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			(char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			"-s", (char *)remoteIP,
			"-j", "DNAT", "--to-destination", dstIP);
//	} else {
	} else if (extPort) {
		va_cmd(IPTABLES, 14, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			(char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			(char *)FW_DPORT, extPort, "-j",
			"DNAT", "--to-destination", dstIP);
	} else {
		va_cmd(IPTABLES, 12, 1, "-t", "nat",
			(char *)act,	(char *)PORT_FW,
			(char *)ARG_I, (char *)ifname,
			"-p", (char *)proto,
			 "-j", "DNAT", "--to-destination", dstIP);
	}

}

/*move from startup.c:iptable_filter()*/
static void iptable_filter( int del, int negate, const char *ifname, const char *proto, const char *remoteIP, const char *intPort)
{
	char *strInsert="-I";
	char *strThird="3";
	char *act, *rulenum;

	if(del)
	{
		act = (char *)FW_DEL;

//		if (negate && remoteIP) {
		if (negate && remoteIP && intPort) {
			va_cmd(IPTABLES, 15, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				(char *)FW_DPORT, intPort,
				"-j",(char *)FW_ACCEPT);
		} else if (negate && remoteIP) {
			va_cmd(IPTABLES, 13, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				"-j",(char *)FW_ACCEPT);
//		} else if (negate) {
		} else if (negate && intPort) {
			va_cmd(IPTABLES, 13, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				(char *)FW_DPORT, intPort,
				"-j",(char *)FW_ACCEPT);
//		} else if (remoteIP) {
		} else if (remoteIP && intPort) {
			va_cmd(IPTABLES, 14, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				(char *)FW_DPORT, intPort,
				"-j",(char *)FW_ACCEPT);
		} else if (negate) {
			va_cmd(IPTABLES, 11, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-j",(char *)FW_ACCEPT);
		} else if (remoteIP) {
			va_cmd(IPTABLES, 12, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				"-j",(char *)FW_ACCEPT);
//		} else {
		} else if (intPort) {
			va_cmd(IPTABLES, 12, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				(char *)FW_DPORT, intPort, "-j",
				(char *)FW_ACCEPT);
		} else {
			va_cmd(IPTABLES, 10, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-j", (char *)FW_ACCEPT);
		}
	}else
	{
		//act = strInsert; //use insert, not append => need rulenum
		//rulenum = strThird;
 		act = (char *)FW_ADD;

//		if (negate && remoteIP) {
		if (negate && remoteIP && intPort) {
			va_cmd(IPTABLES, 15, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				(char *)FW_DPORT, intPort,
				"-j",(char *)FW_ACCEPT);
		} else if (negate && remoteIP) {
			va_cmd(IPTABLES, 13, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				"-j",(char *)FW_ACCEPT);
//		} else if (negate) {
		} else if (negate && intPort) {
			va_cmd(IPTABLES, 13, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				(char *)FW_DPORT, intPort,
				"-j",(char *)FW_ACCEPT);
//		} else if (remoteIP) {
		} else if (remoteIP && intPort) {
			va_cmd(IPTABLES, 14, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				(char *)FW_DPORT, intPort,
				"-j",(char *)FW_ACCEPT);
		} else if (negate) {
			va_cmd(IPTABLES, 11, 1, act,
				(char *)PORT_FW, "!", (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-j",(char *)FW_ACCEPT);
		} else if (remoteIP) {
			va_cmd(IPTABLES, 12, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-s", remoteIP,
				"-j",(char *)FW_ACCEPT);
//		} else {
		} else if (intPort) {
			va_cmd(IPTABLES, 12, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				(char *)FW_DPORT, intPort, "-j",
				(char *)FW_ACCEPT);
		} else {
			va_cmd(IPTABLES, 10, 1, act,
				(char *)PORT_FW, (char *)ARG_I, ifname,
				(char *)ARG_O,
				(char *)LANIF, "-p", (char *)proto,
				"-j", (char *)FW_ACCEPT);
		}
	}
}

/*move from startup.c ==> part of setupFirewall()*/
void portfw_modify( MIB_CE_PORT_FW_T *p, int del )
{
	int negate=0, hasRemote=0, hasLocalPort=0, hasExtPort=0;
	char * proto = 0;
	char intPort[32], extPort[32];
	char ipaddr[32], extra[32], ifname[IFNAMSIZ];

	if(p==NULL) return;

#if 0
	{
		fprintf( stderr,"<portfw_modify>\n" );
		fprintf( stderr,"\taction:%s\n", (del==0)?"ADD":"DEL" );
		fprintf( stderr,"\tifIndex:0x%x\n", p->ifIndex );
		fprintf( stderr,"\tenable:%u\n", p->enable );
		fprintf( stderr,"\tleaseduration:%u\n", p->leaseduration );
		fprintf( stderr,"\tremotehost:%s\n", inet_ntoa(*((struct in_addr *)p->remotehost))  );
		fprintf( stderr,"\texternalport:%u\n", p->externalport );
		fprintf( stderr,"\tinternalclient:%s\n", inet_ntoa(*((struct in_addr *)p->ipAddr)) );
		fprintf( stderr,"\tinternalport:%u\n", p->toPort );
		fprintf( stderr,"\tprotocol:%u\n", p->protoType ); /*PROTO_TCP=1, PROTO_UDP=2*/
		fprintf( stderr,"<end portfw_modify>\n" );
	}
#endif

	if( del==0 ) //add
	{
		char vCh=0;
		mib_get(MIB_PORT_FW_ENABLE, (void *)&vCh);
		if(vCh==0) return;

		if (!p->enable) return;
	}

/*	snprintf(intPort, 12, "%u", p->fromPort);

	if (p->externalport) {
		snprintf(extPort, sizeof(extPort), "%u", p->externalport);
		snprintf(intPort, sizeof(intPort), "%u", p->fromPort);
		snprintf(ipaddr, sizeof(ipaddr), "%s:%s", inet_ntoa(*((struct in_addr *)p->ipAddr)), intPort);
	} else {
		snprintf(intPort, sizeof(extPort), "%u", p->fromPort);
		strncpy(extPort, intPort, sizeof(intPort));
		strncpy(ipaddr, inet_ntoa(*((struct in_addr *)p->ipAddr)), 16);
	}
	*/
    if (p->fromPort)
    {
        if (p->fromPort == p->toPort)
        {
            snprintf(intPort, sizeof(intPort), "%u", p->fromPort);
        }
        else
        {
            /* "%u-%u" is used by port forwarding */
            snprintf(intPort, sizeof(intPort), "%u-%u", p->fromPort, p->toPort);
        }

        snprintf(ipaddr, sizeof(ipaddr), "%s:%s", inet_ntoa(*((struct in_addr *)p->ipAddr)), intPort);

        if (p->fromPort != p->toPort)
        {
            /* "%u:%u" is used by filter */
            snprintf(intPort, sizeof(intPort), "%u:%u", p->fromPort, p->toPort);
        }
        hasLocalPort = 1;
    }
    else
    {
        snprintf(ipaddr, sizeof(ipaddr), "%s", inet_ntoa(*((struct in_addr *)p->ipAddr)));
        hasLocalPort = 0;
    }

	if (p->externalfromport && p->externaltoport && (p->externalfromport != p->externaltoport)) {
		snprintf(extPort, sizeof(extPort), "%u:%u", p->externalfromport, p->externaltoport);
		hasExtPort = 1;
	} else if (p->externalfromport) {
		snprintf(extPort, sizeof(extPort), "%u", p->externalfromport);
		hasExtPort = 1;
	} else if (p->externaltoport) {
		snprintf(extPort, sizeof(extPort), "%u", p->externaltoport);
		hasExtPort = 1;
	} else {
		hasExtPort = 0;
	}
	//printf( "extPort:%s hasExtPort=%d\n",  extPort, hasExtPort);
	//printf( "entry.externalfromport:%d entry.externaltoport=%d\n",  p->externalfromport, p->externaltoport);

	if (ifGetName(p->ifIndex, ifname, sizeof(ifname)))
		negate = 0;
	else {
		strcpy(ifname, LANIF);
		negate = 1;
	}

	if (p->remotehost[0]) {
		snprintf(extra, sizeof(extra), "%s", inet_ntoa(*((struct in_addr *)p->remotehost)));
		hasRemote = 1;
	} else {
		hasRemote = 0;
	}

	//fprintf( stderr, "ipaddr:%s, intPort:%s\n", ipaddr, intPort );
	//check something
	//internalclient can't be zeroip
	if( strncmp(ipaddr,"0.0.0.0", 7)==0 ) return;
	//internalport can't be zero
//	if( strcmp(intPort,"0")==0 ) return;
	//fprintf( stderr, "Pass ipaddr:%s, intPort:%s\n", ipaddr, intPort );

	if (p->protoType == PROTO_TCP || p->protoType == PROTO_UDPTCP)
	{
		// iptables -t nat -A PREROUTING -i ! $LAN_IF -p TCP --dport dstPortRange -j DNAT --to-destination ipaddr
//		iptable_fw( del, negate, ifname, ARG_TCP, hasRemote ? extra : 0, extPort, ipaddr);
		iptable_fw( del, negate, ifname, ARG_TCP, hasRemote ? extra : 0, hasExtPort ? extPort : 0, ipaddr);
		// iptables -I ipfilter 3 -i ! $LAN_IF -o $LAN_IF -p TCP --dport dstPortRange -j RETURN
//		iptable_filter( del, negate, ifname, ARG_TCP, hasRemote ? extra : 0, intPort);
		iptable_filter( del, negate, ifname, ARG_TCP, hasRemote ? extra : 0, hasLocalPort ? intPort : 0);
	}

	if (p->protoType == PROTO_UDP || p->protoType == PROTO_UDPTCP)
	{
//		iptable_fw( del, negate, ifname, ARG_UDP, hasRemote ? extra : 0, extPort, ipaddr);
		iptable_fw( del, negate, ifname, ARG_UDP, hasRemote ? extra : 0, hasExtPort ? extPort : 0, ipaddr);
		// iptables -I ipfilter 3 -i ! $LAN_IF -o $LAN_IF -p UDP --dport dstPortRange -j RETURN
//		iptable_filter( del, negate, ifname, ARG_UDP, hasRemote ? extra : 0, intPort);
		iptable_filter( del, negate, ifname, ARG_UDP, hasRemote ? extra : 0, hasLocalPort ? intPort : 0);
	}
}
#endif // of PORT_FORWARD_GENERAL

/***end port forwarding APIs*******/

#ifdef SUPPORT_DHCP_RESERVED_IPADDR
static const char DHCPReservedIPAddrFile[] = "/var/udhcpd/DHCPReservedIPAddr.txt";
static int setupDHCPReservedIPAddr( void )
{
	FILE *fp;

	fp=fopen( DHCPReservedIPAddrFile, "w" );
	if(!fp) return -1;

	{//default pool
		unsigned int j,num;
		num = mib_chain_total( MIB_DHCP_RESERVED_IPADDR_TBL );
		fprintf( fp, "START %u\n", 0 );
		for( j=0;j<num;j++ )
		{
			MIB_DHCP_RESERVED_IPADDR_T entryip;
			if(!mib_chain_get( MIB_DHCP_RESERVED_IPADDR_TBL, j, (void*)&entryip ))
				continue;
			if( entryip.InstanceNum==0 )
			{
				fprintf( fp, "%s\n",  inet_ntoa(*((struct in_addr *)&(entryip.IPAddr))) );
			}
		}
		fprintf( fp, "END\n" );
	}

#ifdef _PRMT_X_TELEFONICA_ES_DHCPOPTION_
{
	unsigned int i,numpool;
	numpool = mib_chain_total( MIB_DHCPS_SERVING_POOL_TBL );
	for( i=0; i<numpool;i++ )
	{
		unsigned int j,num;
		DHCPS_SERVING_POOL_T entrypool;

		if( !mib_chain_get( MIB_DHCPS_SERVING_POOL_TBL, i, (void*)&entrypool ) )
			continue;

		//skip disable or relay pools
		if( entrypool.enable==0 || entrypool.localserved==0 )
			continue;

		num = mib_chain_total( MIB_DHCP_RESERVED_IPADDR_TBL );
		fprintf( fp, "START %u\n", entrypool.InstanceNum );
		for( j=0;j<num;j++ )
		{
			MIB_DHCP_RESERVED_IPADDR_T entryip;
			if(!mib_chain_get( MIB_DHCP_RESERVED_IPADDR_TBL, j, (void*)&entryip ))
				continue;
			if( entryip.InstanceNum==entrypool.InstanceNum )
			{
				fprintf( fp, "%s\n",  inet_ntoa(*((struct in_addr *)&(entryip.IPAddr))) );
			}
		}
		fprintf( fp, "END\n" );
	}
}
#endif //_PRMT_X_TELEFONICA_ES_DHCPOPTION_

	fclose(fp);
	return 0;
}

int clearDHCPReservedIPAddrByInstNum(unsigned int instnum)
{
	int j,num;
	num = mib_chain_total( MIB_DHCP_RESERVED_IPADDR_TBL );
	if( num>0 )
	{
		for( j=num-1;j>=0;j-- )
		{
			MIB_DHCP_RESERVED_IPADDR_T entryip;
			if(!mib_chain_get( MIB_DHCP_RESERVED_IPADDR_TBL, j, (void*)&entryip ))
				continue;
			if( entryip.InstanceNum==instnum )
			{
				mib_chain_delete( MIB_DHCP_RESERVED_IPADDR_TBL, j );
			}
		}
	}
	return 0;
}
#endif //SUPPORT_DHCP_RESERVED_IPADDR



// DHCP server configuration
// return value:
// 0  : not active
// 1  : active
// -1 : setup failed
int setupDhcpd(void)
{
	unsigned char value[32];
	unsigned int uInt, uLTime;
	DNS_TYPE_T dnsMode;
	FILE *fp, *fp2;
	char ipstart[16], ipend[16];
#ifdef IMAGENIO_IPTV_SUPPORT
/*ping_zhang:20090930 START:add for Telefonica new option 240*/
#if 0
	char opchaddr[16]={0}, stbdns1[16]={0}, stbdns2[16]={0};
	unsigned short opchport;
#endif
/*ping_zhang:20090930 END*/
#endif
	char subnet[16], ipaddr[16], ipaddr2[16];
	char dhcpsubnet[16];
	char dns1[16], dns2[16], dns3[16], dhcps[16];
	char domain[MAX_NAME_LEN];
	unsigned int entryNum, i, j;
	MIB_CE_MAC_BASE_DHCP_T Entry;
#ifdef IP_PASSTHROUGH
	int ippt;
	unsigned int ippt_itf;
#endif
	int spc_enable=0, spc_ip=0;
	struct in_addr myip;
	//ql: check if pool is in first IP subnet or in secondary IP subnet.
	int subnetIdx=0;
	struct in_addr lanip1, lanmask1, lanip2, lanmask2, inpoolstart;
	char serverip[16];
	int lockfd = -1;
#ifdef CONFIG_CT_AWIFI_JITUAN_FEATURE
	char serverip_awifi[16];
#endif

/*ping_zhang:20080919 START:add for new telefonica tr069 request: dhcp option*/
#ifdef _PRMT_X_TELEFONICA_ES_DHCPOPTION_
	DHCPS_SERVING_POOL_T dhcppoolentry;
	int dhcppoolnum;
	unsigned char macempty[6]={0,0,0,0,0,0};
	char *ipempty="0.0.0.0";
#endif
	char macaddr[20];

/*ping_zhang:20080919 END*/

	// check if dhcp server on ?
	// Modified by Mason Yu for dhcpmode
	//if (mib_get(MIB_ADSL_LAN_DHCP, (void *)value) != 0)
	if (mib_get(MIB_DHCP_MODE, (void *)value) != 0)
	{
		uInt = (unsigned int)(*(unsigned char *)value);
		if (uInt != DHCP_LAN_SERVER)
		{
			return 0;	// dhcp Server not on
		}
	}

#ifdef CONFIG_SECONDARY_IP
	mib_get(MIB_ADSL_LAN_ENABLE_IP2, (void *)value);
	if (value[0])
		mib_get(MIB_ADSL_LAN_DHCP_POOLUSE, (void *)value);
#else
	value[0] = 0;
#endif

#ifdef DHCPS_POOL_COMPLETE_IP
	mib_get(MIB_DHCP_SUBNET_MASK, (void *)value);
	strncpy(dhcpsubnet, inet_ntoa(*((struct in_addr *)value)), 16);
	dhcpsubnet[15] = '\0';
	// IP Pool start
	mib_get(MIB_DHCP_POOL_START, (void *)value);
	strncpy(ipstart, inet_ntoa(*((struct in_addr *)value)), 16);
	// IP Pool end
	mib_get(MIB_DHCP_POOL_END, (void *)value);
	strncpy(ipend, inet_ntoa(*((struct in_addr *)value)), 16);
#else
	if (value[0] == 0) { // primary LAN
		if (mib_get(MIB_ADSL_LAN_SUBNET, (void *)value) != 0)
		{
			strncpy(dhcpsubnet, inet_ntoa(*((struct in_addr *)value)), 16);
			dhcpsubnet[15] = '\0';
		}
		else
			return -1;

		mib_get(MIB_ADSL_LAN_IP, (void *)value);
	}
	else { // secondary LAN
		if (mib_get(MIB_ADSL_LAN_SUBNET2, (void *)value) != 0)
		{
			strncpy(dhcpsubnet, inet_ntoa(*((struct in_addr *)value)), 16);
			dhcpsubnet[15] = '\0';
		}
		else
			return -1;

		mib_get(MIB_ADSL_LAN_IP2, (void *)value);
	}

	// IP pool start address
	mib_get(MIB_ADSL_LAN_CLIENT_START, (void *)&value[3]);
		strncpy(ipstart, inet_ntoa(*((struct in_addr *)value)), 16);
		ipstart[15] = '\0';
	// IP pool end address
	mib_get(MIB_ADSL_LAN_CLIENT_END, (void *)&value[3]);
		strncpy(ipend, inet_ntoa(*((struct in_addr *)value)), 16);
		ipend[15] = '\0';
	#endif

	// Added by Mason Yu for MAC base assignment. Start
	if ((fp2 = fopen("/var/dhcpdMacBase.txt", "w")) == NULL)
	{
		printf("***** Open file /var/dhcpdMacBase.txt failed !\n");
		goto dhcpConf;
	}

//star: reserve local ip for dhcp server
		MIB_CE_MAC_BASE_DHCP_T entry;

		strcpy(macaddr, "localmac");
		//printf("entry.macAddr = %s\n", entry.macAddr);
		if (mib_get(MIB_ADSL_LAN_IP, (void *)value) != 0)
		{
			//strncpy(entry.ipAddr, inet_ntoa(*((struct in_addr *)value)), 16);
			//entry.ipAddr[15] = '\0';
			fprintf(fp2, "%s: %s\n", macaddr, inet_ntoa(*((struct in_addr *)value)));
		}

#ifdef CONFIG_SECONDARY_IP
		mib_get(MIB_ADSL_LAN_ENABLE_IP2, (void *)value);
		if (value[0] == 1) {
			strcpy(macaddr, "localsecmac");
			//printf("entry.macAddr = %s\n", entry.macAddr);
			if (mib_get(MIB_ADSL_LAN_IP2, (void *)value) != 0)
			{
				//strncpy(entry.ipAddr, inet_ntoa(*((struct in_addr *)value)), 16);
				//entry.ipAddr[15] = '\0';
				fprintf(fp2, "%s: %s\n", macaddr, inet_ntoa(*((struct in_addr *)value)) );
			}

		}

#endif

//star: check mactbl
	struct in_addr poolstart,poolend,macip;
	unsigned long v1;

	inet_aton(ipstart, &poolstart);
	inet_aton(ipend, &poolend);
check_mactbl:
	entryNum = mib_chain_total(MIB_MAC_BASE_DHCP_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_MAC_BASE_DHCP_TBL, i, (void *)&Entry))
		{
  			printf("setupDhcpd:Get chain(MIB_MAC_BASE_DHCP_TBL) record error!\n");
		}
		//inet_aton(Entry.ipAddr, &macip);
		v1 = *((unsigned long *)Entry.ipAddr_Dhcp);
		if( v1 < poolstart.s_addr || v1 > poolend.s_addr )
		//if(macip.s_addr<poolstart.s_addr||macip.s_addr>poolend.s_addr)
		{
			if(mib_chain_delete(MIB_MAC_BASE_DHCP_TBL, i)!=1)
			{
				fclose(fp2);
				printf("setupDhcpd:Delete chain(MIB_MAC_BASE_DHCP_TBL) record error!\n");
				return -1;
			}
			break;
		}
	}
	if((int)i<((int)entryNum-1))
		goto check_mactbl;

	entryNum = mib_chain_total(MIB_MAC_BASE_DHCP_TBL);
	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_MAC_BASE_DHCP_TBL, i, (void *)&Entry))
		{
  			printf("setupDhcpd:Get chain(MIB_MAC_BASE_DHCP_TBL) record error!\n");
		}

		snprintf(macaddr, 18, "%02x-%02x-%02x-%02x-%02x-%02x",
				Entry.macAddr_Dhcp[0], Entry.macAddr_Dhcp[1],
				Entry.macAddr_Dhcp[2], Entry.macAddr_Dhcp[3],
				Entry.macAddr_Dhcp[4], Entry.macAddr_Dhcp[5]);

		for (j=0; j<17; j++){
			if ( macaddr[j] != '-' ) {
				macaddr[j] = tolower(macaddr[j]);
			}
		}

		//fprintf(fp2, "%s: %s\n", Entry.macAddr, Entry.ipAddr);
		fprintf(fp2, "%s: %s\n", macaddr, inet_ntoa(*((struct in_addr *)Entry.ipAddr_Dhcp)) );
	}
	fclose(fp2);
	// Added by Mason Yu for MAC base assignment. End

dhcpConf:

#ifdef SUPPORT_DHCP_RESERVED_IPADDR
	setupDHCPReservedIPAddr();
#endif //SUPPORT_DHCP_RESERVED_IPADDR

#ifdef IMAGENIO_IPTV_SUPPORT
/*ping_zhang:20090930 START:add for Telefonica new option 240*/
#if 0
	if (mib_get(MIB_OPCH_ADDRESS, (void *)&value[0]) != 0) {
		strncpy(opchaddr, inet_ntoa(*(struct in_addr *)value), 16);
		opchaddr[15] = '\0';
	} else
		return -1;

	if (mib_get(MIB_IMAGENIO_DNS1, (void *)&value[0]) != 0) {
		strncpy(stbdns1, inet_ntoa(*(struct in_addr *)value), 16);
		stbdns1[15] = '\0';
	} else
		return -1;

	mib_get(MIB_IMAGENIO_DNS2, (void *)&myip);
	if ((myip.s_addr != 0xffffffff) && (myip.s_addr != 0)) { // not empty
		strncpy(stbdns2, inet_ntoa(myip), 16);
		stbdns2[15] = '\0';
	}

	if (!mib_get(MIB_OPCH_PORT, (void *)&opchport))
		return -1;
#endif
/*ping_zhang:20090930 END*/
#endif

	// IP max lease time
	if (mib_get(MIB_ADSL_LAN_DHCP_LEASE, (void *)&uLTime) == 0)
		return -1;

	if (mib_get(MIB_ADSL_LAN_DHCP_DOMAIN, (void *)domain) == 0)
		return -1;

	// get DNS mode
	if (mib_get(MIB_ADSL_WAN_DNS_MODE, (void *)value) != 0)
	{
		dnsMode = (DNS_TYPE_T)(*(unsigned char *)value);
	}
	else
		return -1;

	// Commented by Mason Yu for LAN_IP as DNS Server
	if ((fp = fopen(DHCPD_CONF, "w")) == NULL)
	{
		printf("Open file %s failed !\n", DHCPD_CONF);
		return -1;
	}

	if (mib_get(MIB_SPC_ENABLE, (void *)value) != 0)
	{
		if (value[0])
		{
			spc_enable = 1;
			mib_get(MIB_SPC_IPTYPE, (void *)value);
			spc_ip = (unsigned int)(*(unsigned char *)value);
		}
		else
			spc_enable = 0;
	}

/*ping_zhang:20080919 START:add for new telefonica tr069 request: dhcp option*/
#ifdef _PRMT_X_TELEFONICA_ES_DHCPOPTION_
	fprintf(fp,"poolname default\n");
#endif
/*ping_zhang:20080919 END*/
	//ql: check if pool is in first IP subnet or in secondary IP subnet.
	mib_get(MIB_DHCP_POOL_START, (void *)&inpoolstart);
	mib_get(MIB_ADSL_LAN_IP, (void *)&lanip1);
	mib_get(MIB_ADSL_LAN_SUBNET, (void *)&lanmask1);
	if ((inpoolstart.s_addr & lanmask1.s_addr) == (lanip1.s_addr & lanmask1.s_addr))
		subnetIdx = 0;
	else {
#ifdef CONFIG_SECONDARY_IP
		mib_get(MIB_ADSL_LAN_IP2, (void *)&lanip2);
		mib_get(MIB_ADSL_LAN_SUBNET2, (void *)&lanmask2);
		if ((inpoolstart.s_addr & lanmask2.s_addr) == (lanip2.s_addr & lanmask2.s_addr))
			subnetIdx = 1;
		else
#endif //CONFIG_SECONDARY_IP
			subnetIdx = 0;
	}
	if (0 == subnetIdx)
		snprintf(serverip, 16, "%s", inet_ntoa(lanip1));
	else
		snprintf(serverip, 16, "%s", inet_ntoa(lanip2));

	fprintf(fp, "interface %s\n", LANIF);
	//ql add
	fprintf(fp, "server %s\n", serverip);
	// Mason Yu. For Test
#if 0
	fprintf(fp, "locallyserved no\n" );
	if (mib_get(MIB_ADSL_WAN_DHCPS, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(dhcps, inet_ntoa(*((struct in_addr *)value)), 16);
			dhcps[15] = '\0';
		}
		else
			dhcps[0] = '\0';
	}
	fprintf(fp, "dhcpserver %s\n", dhcps);
#endif

	if (spc_enable)
	{
		if (spc_ip == 0) { // single private ip
			fprintf(fp, "start %s\n", ipstart);
			fprintf(fp, "end %s\n", ipstart);
		}
		//else { // single shared ip
	}
	else
	{
		fprintf(fp, "start %s\n", ipstart);
		fprintf(fp, "end %s\n", ipend);
	}
#if 0
#ifdef IP_BASED_CLIENT_TYPE
	fprintf(fp, "pcstart %s\n", pcipstart);
	fprintf(fp, "pcend %s\n", pcipend);
	fprintf(fp, "cmrstart %s\n", cmripstart);
	fprintf(fp, "cmrend %s\n", cmripend);
	fprintf(fp, "stbstart %s\n", stbipstart);
	fprintf(fp, "stbend %s\n", stbipend);
	fprintf(fp, "phnstart %s\n", phnipstart);
	fprintf(fp, "phnend %s\n", phnipend);
	fprintf(fp, "hgwstart %s\n", hgwipstart);
	fprintf(fp, "hgwend %s\n", hgwipend);
	//ql 20090122 add
	fprintf(fp, "pcopt60 %s\n", pcopt60);
	fprintf(fp, "cmropt60 %s\n", cmropt60);
	fprintf(fp, "stbopt60 %s\n", stbopt60);
	fprintf(fp, "phnopt60 %s\n", phnopt60);
#endif
#endif

#if 0
/*ping_zhang:20090319 START:replace ip range with serving pool of tr069*/
#ifndef _PRMT_X_TELEFONICA_ES_DHCPOPTION_
#ifdef IP_BASED_CLIENT_TYPE
	{
		MIB_CE_IP_RANGE_DHCP_T Entry;
		int i, entrynum=mib_chain_total(MIB_IP_RANGE_DHCP_TBL);

		for (i=0; i<entrynum; i++)
		{
			if (!mib_chain_get(MIB_IP_RANGE_DHCP_TBL, i, (void *)&Entry))
				continue;

			strncpy(devipstart, inet_ntoa(*((struct in_addr *)Entry.startIP)), 16);
			strncpy(devipend, inet_ntoa(*((struct in_addr *)Entry.endIP)), 16);

/*ping_zhang:20090317 START:change len of option60 to 100*/
			//fprintf(fp, "range start=%s:end=%s:option=%s:devicetype=%d\n", devipstart, devipend, Entry.option60,Entry.deviceType);
			//fprintf(fp, "range start=%s:end=%s:option=%s:devicetype=%d:optCode=%d:optStr=%s\n", devipstart, devipend, Entry.option60,Entry.deviceType,Entry.optionCode,Entry.optionStr);
			//fprintf(fp, "range s=%s:e=%s:o=%s:t=%d:oC=%d:oS=%s\n",	devipstart, devipend, Entry.option60,Entry.deviceType,Entry.optionCode,Entry.optionStr);
			fprintf(fp, "range i=%d:s=%s:e=%s:o=%s:t=%d\n",i,devipstart, devipend, Entry.option60,Entry.deviceType);
			fprintf(fp, "range_optRsv i=%d:oC=%d:oS=%s\n",i,Entry.optionCode,Entry.optionStr);
/*ping_zhang:20090317 END*/
		}
	}
#endif
#endif
#endif //#if 0

/*ping_zhang:20090319 END*/
#ifdef IMAGENIO_IPTV_SUPPORT
/*ping_zhang:20090930 START:add for Telefonica new option 240*/
#if 0
	fprintf(fp, "opchaddr %s\n", opchaddr);
	fprintf(fp, "opchport %d\n", opchport);
	fprintf(fp, "stbdns1 %s\n", stbdns1);
	if (stbdns2[0])
		fprintf(fp, "stbdns2 %s\n", stbdns2);
#endif
/*ping_zhang:20090930 END*/
#endif

#ifdef IP_PASSTHROUGH
	ippt = 0;
	if (mib_get(MIB_IPPT_ITF, (void *)&ippt_itf) != 0)
		if (ippt_itf != DUMMY_IFINDEX) // IP passthrough
			ippt = 1;

	if (ippt)
	{
		fprintf(fp, "ippt yes\n");
		mib_get(MIB_IPPT_LEASE, (void *)&uInt);
		fprintf(fp, "ipptlt %d\n", uInt);
	}
#endif

	fprintf(fp, "opt subnet %s\n", dhcpsubnet);

	// Added by Mason Yu
	if (mib_get(MIB_ADSL_LAN_DHCP_GATEWAY, (void *)value) != 0)
	{
		strncpy(ipaddr2, inet_ntoa(*((struct in_addr *)value)), 16);
		ipaddr2[15] = '\0';
	}
	else
		return -1;
	fprintf(fp, "opt router %s\n", ipaddr2);

	// Modified by Mason Yu for LAN_IP as DNS Server
#if 0
	if (dnsMode == DNS_AUTO)
	{
		fprintf(fp, "opt dns %s\n", ipaddr);
	}
	else	// DNS_MANUAL
	{
		if (dns1[0])
			fprintf(fp, "opt dns %s\n", dns1);
		if (dns2[0])
			fprintf(fp, "opt dns %s\n", dns2);
		if (dns3[0])
			fprintf(fp, "opt dns %s\n", dns3);
	}
#endif

	// Kaohj
#ifdef DHCPS_DNS_OPTIONS
	mib_get(MIB_DHCP_DNS_OPTION, (void *)value);
	if (value[0] == 0)
		fprintf(fp, "opt dns %s\n", ipaddr2);
	else if (value[0] == 2) { //DNS From ISP
		dns1[0] = dns2[0] = '\0';
		if(check_user_is_registered() == 1 && get_network_dns(dns1, dns2) > 0){
			if (dns1[0]) fprintf(fp, "opt dns %s\n", dns1);
			if (dns2[0]) fprintf(fp, "opt dns %s\n", dns2);
		}
		else{ 
			//If not register to IMS or not get DNS address form Internet, lease time fix to 30 sec.
			fprintf(fp, "opt dns %s\n", ipaddr2);
			uLTime = 30;
		}
	} else { // check manual setting
		mib_get(MIB_DHCPS_DNS1, (void *)&myip);
		strncpy(ipaddr, inet_ntoa(myip), 16);
		ipaddr[15] = '\0';
		fprintf(fp, "opt dns %s\n", ipaddr);
		mib_get(MIB_DHCPS_DNS2, (void *)&myip);
		if (myip.s_addr != INADDR_NONE) { // not empty
			strncpy(ipaddr, inet_ntoa(myip), 16);
			ipaddr[15] = '\0';
			fprintf(fp, "opt dns %s\n", ipaddr);
			mib_get(MIB_DHCPS_DNS3, (void *)&myip);
			if (myip.s_addr != INADDR_NONE) { // not empty
				strncpy(ipaddr, inet_ntoa(myip), 16);
				ipaddr[15] = '\0';
				fprintf(fp, "opt dns %s\n", ipaddr);
			}
		}
	}
#else
	fprintf(fp, "opt dns %s\n", ipaddr2);
#endif
	fprintf(fp, "opt lease %u\n", uLTime);
#ifndef CTC_YUNMESTB_DHCPD_DHCPOPTION
	if (domain[0])
		fprintf(fp, "opt domain %s\n", domain);
	else
		// per TR-068, I-188
		fprintf(fp, "opt domain domain_not_set.invalid\n");
#endif
#ifdef _CWMP_MIB_ /*jiunming, for cwmp-tr069*/
{
	//format: opt venspec [enterprise-number] [sub-option code] [sub-option data] ...
	//opt vendspec: dhcp option 125 Vendor-Identifying Vendor-Specific
	//enterprise-number: 3561(ADSL Forum)
	//sub-option code: 4(GatewayManufacturerOUI)
	//sub-option code: 5(GatewaySerialNumber)
	//sub-option code: 6(GatewayProductClass)
	char opt125_sn[65];
	mib_get(MIB_HW_SERIAL_NUMBER, (void *)opt125_sn);
	#ifdef CONFIG_YUEME
	char manufacturer[65]={0};
	char productclass[65]={0};
	mib_get(MIB_HW_CWMP_MANUFACTURER, (void *)manufacturer);
	mib_get(MIB_HW_CWMP_PRODUCTCLASS, (void *)productclass);
	fprintf( fp, "opt venspec 0 1 %s 2 %s 3 %s\n", manufacturer, "HGW-CT", productclass);	
	#else
	fprintf( fp, "opt venspec 3561 4 %s 5 %s 6 %s\n", MANUFACTURER_OUI, opt125_sn, PRODUCT_CLASS );
	#endif
}
#endif

#ifdef CONFIG_CT_AWIFI_JITUAN_FEATURE
    unsigned char functype=0;
    mib_get(AWIFI_PROVINCE_CODE, &functype);
    if(functype == AWIFI_ZJ){
	fprintf(fp, "poolend end\n");
	memset(&dhcppoolentry,0,sizeof(DHCPS_SERVING_POOL_T));

/*test code*
	dhcppoolentry.enable=1;
	dhcppoolentry.poolorder=1;
	strcpy(dhcppoolentry.poolname,"poolone");
	strcpy(dhcppoolentry.vendorclass,"MSFT 5.0");
	strcpy(dhcppoolentry.clientid,"");
	strcpy(dhcppoolentry.userclass,"");

	inet_aton("192.168.1.40",((struct in_addr *)(dhcppoolentry.startaddr)));
	inet_aton("192.168.1.50",((struct in_addr *)(dhcppoolentry.endaddr)));
	inet_aton("255.255.255.0",((struct in_addr *)(dhcppoolentry.subnetmask)));
	inet_aton("192.168.1.1",((struct in_addr *)(dhcppoolentry.iprouter)));
	inet_aton("172.29.17.10",((struct in_addr *)(dhcppoolentry.dnsserver1)));
	strcpy(dhcppoolentry.domainname,"poolone.com");
	dhcppoolentry.leasetime=86400;
	dhcppoolentry.dnsservermode=1;
	dhcppoolentry.InstanceNum=1;
	entryNum = mib_chain_total(MIB_DHCPS_SERVING_POOL_TBL);
printf("\nentryNum=%d\n",entryNum);
	if(entryNum==0)
		mib_chain_add(MIB_DHCPS_SERVING_POOL_TBL,(void*)&dhcppoolentry);
****/

	entryNum = mib_chain_total(MIB_DHCPS_SERVING_POOL_AWIFI_TBL);

	for(i=0;i<entryNum;i++){
		memset(&dhcppoolentry,0,sizeof(DHCPS_SERVING_POOL_T));
		if(!mib_chain_get(MIB_DHCPS_SERVING_POOL_AWIFI_TBL,i,(void*)&dhcppoolentry))
			continue;
		if(dhcppoolentry.enable==1){
			strncpy(ipstart, inet_ntoa(*((struct in_addr *)(dhcppoolentry.startaddr))), 16);
			strncpy(ipend, inet_ntoa(*((struct in_addr *)(dhcppoolentry.endaddr))), 16);
			strncpy(dhcpsubnet, inet_ntoa(*((struct in_addr *)(dhcppoolentry.subnetmask))), 16);
			strncpy(ipaddr2, inet_ntoa(*((struct in_addr *)(dhcppoolentry.iprouter))), 16);

			if( dhcppoolentry.localserved ) //check only for locallyserved==true
			{
				if(!strcmp(ipstart,ipempty) ||
					!strcmp(ipend,ipempty) ||
					!strcmp(dhcpsubnet,ipempty))
					continue;
			}


			fprintf(fp, "poolname %s\n",dhcppoolentry.poolname);
			fprintf(fp, "cwmpinstnum %d\n",dhcppoolentry.InstanceNum);
			fprintf(fp, "poolorder %u\n",dhcppoolentry.poolorder);
			fprintf(fp, "interface %s\n", LANIF);
			//ql add
			mib_get(MIB_ADSL_LAN_IP2, (void *)&lanip2);
			snprintf(serverip_awifi, 16, "%s", inet_ntoa(lanip2));
			
			fprintf(fp, "server %s\n", serverip_awifi);
			fprintf(fp, "start %s\n", ipstart);
			fprintf(fp, "end %s\n", ipend);

			fprintf(fp, "sourceinterface %u\n",dhcppoolentry.sourceinterface);
			if(dhcppoolentry.vendorclass[0]!=0){
				fprintf(fp, "vendorclass %s\n",dhcppoolentry.vendorclass);
				fprintf(fp, "vendorclassflag %u\n",dhcppoolentry.vendorclassflag);
				if(dhcppoolentry.vendorclassmode[0]!=0)
					fprintf(fp, "vendorclassmode %s\n",dhcppoolentry.vendorclassmode);
			}
			if(dhcppoolentry.clientid[0]!=0){
				fprintf(fp, "clientid %s\n",dhcppoolentry.clientid);
				fprintf(fp, "clientidflag %u\n",dhcppoolentry.clientidflag);
			}
			if(dhcppoolentry.userclass[0]!=0){
				fprintf(fp, "userclass %s\n",dhcppoolentry.userclass);
				fprintf(fp, "userclassflag %u\n",dhcppoolentry.userclassflag);
			}
			if(memcmp(dhcppoolentry.chaddr,macempty,6)){
				fprintf(fp, "chaddr %02x%02x%02x%02x%02x%02x\n",dhcppoolentry.chaddr[0],dhcppoolentry.chaddr[1],dhcppoolentry.chaddr[2],
					dhcppoolentry.chaddr[3],dhcppoolentry.chaddr[4],dhcppoolentry.chaddr[5]);
				if(memcmp(dhcppoolentry.chaddrmask,macempty,6))
					fprintf(fp, "chaddrmask %02x%02x%02x%02x%02x%02x\n",dhcppoolentry.chaddrmask[0],dhcppoolentry.chaddrmask[1],dhcppoolentry.chaddrmask[2],
						dhcppoolentry.chaddrmask[3],dhcppoolentry.chaddrmask[4],dhcppoolentry.chaddrmask[5]);
				fprintf(fp, "chaddrflag %u\n",dhcppoolentry.chaddrflag);
			}

#ifdef IP_PASSTHROUGH
			ippt = 0;
			if (mib_get(MIB_IPPT_ITF, (void *)&ippt_itf) != 0)
				if (ippt_itf != DUMMY_IFINDEX) // IP passthrough
					ippt = 1;

			if (ippt)
			{
				fprintf(fp, "ippt yes\n");
				mib_get(MIB_IPPT_LEASE, (void *)&uInt);
				fprintf(fp, "ipptlt %d\n", uInt);
			}
#endif
#ifdef IMAGENIO_IPTV_SUPPORT
			//fprintf(fp, "pcopt60 %s\n", pcopt60);
			//fprintf(fp, "cmropt60 %s\n", cmropt60);
			//fprintf(fp, "stbopt60 %s\n", stbopt60);
			//fprintf(fp, "phnopt60 %s\n", phnopt60);
/*ping_zhang:20090930 START:add for Telefonica new option 240*/
#if 0
			fprintf(fp, "opchaddr %s\n", opchaddr);
			fprintf(fp, "opchport %d\n", opchport);
			fprintf(fp, "stbdns1 %s\n", stbdns1);
			if (stbdns2[0])
				fprintf(fp, "stbdns2 %s\n", stbdns2);
#endif
/*ping_zhang:20090930 END*/
#endif

			if(strcmp(dhcpsubnet,ipempty))
				fprintf(fp, "opt subnet %s\n", dhcpsubnet);
			if(strcmp(ipaddr2,ipempty))
				fprintf(fp, "opt router %s\n", ipaddr2);

			// Kaohj
#ifdef DHCPS_DNS_OPTIONS
			if (dhcppoolentry.dnsservermode == 0)
				fprintf(fp, "opt dns %s\n", ipaddr2);
			else { // check manual setting
				strncpy(ipaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dnsserver1))), 16);
				ipaddr[15] = '\0';
				fprintf(fp, "opt dns %s\n", ipaddr);
				strncpy(ipaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dnsserver2))), 16);
				ipaddr[15] = '\0';
				if(strcmp(ipaddr,ipempty)) { // not empty
					fprintf(fp, "opt dns %s\n", ipaddr);
					strncpy(ipaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dnsserver3))), 16);
					ipaddr[15] = '\0';
					if(strcmp(ipaddr,ipempty)) { // not empty
						fprintf(fp, "opt dns %s\n", ipaddr);
					}
				}
			}
#else
			fprintf(fp, "opt dns %s\n", ipaddr2);
#endif
			fprintf(fp, "opt lease %u\n", (unsigned int)(dhcppoolentry.leasetime));
#ifndef CTC_YUNMESTB_DHCPD_DHCPOPTION
			if (dhcppoolentry.domainname[0])
				fprintf(fp, "opt domain %s\n", dhcppoolentry.domainname);
			else
				// per TR-068, I-188
				fprintf(fp, "opt domain domain_not_set.invalid\n");
#endif
#ifdef _CWMP_MIB_ /*jiunming, for cwmp-tr069*/
#ifdef _PRMT_X_CT_COM_DHCP_
		{
			//format: opt venspec [enterprise-number] [sub-option code] [sub-option data] ...
			//opt vendspec: dhcp option 125 Vendor-Identifying Vendor-Specific
			//enterprise-number: 0(e8 temprary enterprise code)
			//sub-option code: 2(DHCP server type)
			//sub-option code: 10(Internet VID)
			//sub-option code: 11(IPTV VID)
			//sub-option code: 12(TR069 VID)
			//sub-option code: 13(VoIP VID)
			unsigned char send_opt_125;
			mib_get(CWMP_CT_DHCPS_SEND_OPT_125, &send_opt_125);
			if(send_opt_125)
				fprintf( fp, "opt venspec 0 2 %s\n", "HGW-CT");
		}
#else
		{
			//format: opt venspec [enterprise-number] [sub-option code] [sub-option data] ...
			//opt vendspec: dhcp option 125 Vendor-Identifying Vendor-Specific
			//enterprise-number: 3561(ADSL Forum)
			//sub-option code: 4(GatewayManufacturerOUI)
			//sub-option code: 5(GatewaySerialNumber)
			//sub-option code: 6(GatewayProductClass)
			char opt125_sn[65];
			mib_get(MIB_HW_SERIAL_NUMBER, (void *)opt125_sn);
			fprintf( fp, "opt venspec 3561 4 %s 5 %s 6 %s\n", MANUFACTURER_OUI, opt125_sn, PRODUCT_CLASS );
		}
#endif
#endif
			//relayinfo
			if( dhcppoolentry.localserved==0 )
			{
				char dhcpserveripaddr[16];
				fprintf(fp, "locallyserved no\n" );
				strncpy(dhcpserveripaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dhcprelayip))), 16);
				dhcpserveripaddr[15]='\0';
				fprintf(fp, "dhcpserver %s\n", dhcpserveripaddr );
			}

			fprintf(fp, "poolend end\n");

		}
	}
    }
#endif


/*write dhcp serving pool config*/
/*ping_zhang:20080919 START:add for new telefonica tr069 request: dhcp option*/
#ifdef _PRMT_X_TELEFONICA_ES_DHCPOPTION_
	fprintf(fp, "poolend end\n");
	memset(&dhcppoolentry,0,sizeof(DHCPS_SERVING_POOL_T));

/*test code*
	dhcppoolentry.enable=1;
	dhcppoolentry.poolorder=1;
	strcpy(dhcppoolentry.poolname,"poolone");
	strcpy(dhcppoolentry.vendorclass,"MSFT 5.0");
	strcpy(dhcppoolentry.clientid,"");
	strcpy(dhcppoolentry.userclass,"");

	inet_aton("192.168.1.40",((struct in_addr *)(dhcppoolentry.startaddr)));
	inet_aton("192.168.1.50",((struct in_addr *)(dhcppoolentry.endaddr)));
	inet_aton("255.255.255.0",((struct in_addr *)(dhcppoolentry.subnetmask)));
	inet_aton("192.168.1.1",((struct in_addr *)(dhcppoolentry.iprouter)));
	inet_aton("172.29.17.10",((struct in_addr *)(dhcppoolentry.dnsserver1)));
	strcpy(dhcppoolentry.domainname,"poolone.com");
	dhcppoolentry.leasetime=86400;
	dhcppoolentry.dnsservermode=1;
	dhcppoolentry.InstanceNum=1;
	entryNum = mib_chain_total(MIB_DHCPS_SERVING_POOL_TBL);
printf("\nentryNum=%d\n",entryNum);
	if(entryNum==0)
		mib_chain_add(MIB_DHCPS_SERVING_POOL_TBL,(void*)&dhcppoolentry);
****/

	entryNum = mib_chain_total(MIB_DHCPS_SERVING_POOL_TBL);

	for(i=0;i<entryNum;i++){
		memset(&dhcppoolentry,0,sizeof(DHCPS_SERVING_POOL_T));
		if(!mib_chain_get(MIB_DHCPS_SERVING_POOL_TBL,i,(void*)&dhcppoolentry))
			continue;
		if(dhcppoolentry.enable==1){
			strncpy(ipstart, inet_ntoa(*((struct in_addr *)(dhcppoolentry.startaddr))), 16);
			strncpy(ipend, inet_ntoa(*((struct in_addr *)(dhcppoolentry.endaddr))), 16);
			strncpy(dhcpsubnet, inet_ntoa(*((struct in_addr *)(dhcppoolentry.subnetmask))), 16);
			strncpy(ipaddr2, inet_ntoa(*((struct in_addr *)(dhcppoolentry.iprouter))), 16);

			if( dhcppoolentry.localserved ) //check only for locallyserved==true
			{
				if(!strcmp(ipstart,ipempty) ||
					!strcmp(ipend,ipempty) ||
					!strcmp(dhcpsubnet,ipempty))
					continue;
			}


			fprintf(fp, "poolname %s\n",dhcppoolentry.poolname);
			fprintf(fp, "cwmpinstnum %d\n",dhcppoolentry.InstanceNum);
			fprintf(fp, "poolorder %u\n",dhcppoolentry.poolorder);
			fprintf(fp, "interface %s\n", LANIF);
			//ql add
			fprintf(fp, "server %s\n", serverip);
			fprintf(fp, "start %s\n", ipstart);
			fprintf(fp, "end %s\n", ipend);

			fprintf(fp, "sourceinterface %u\n",dhcppoolentry.sourceinterface);
			if(dhcppoolentry.vendorclass[0]!=0){
				fprintf(fp, "vendorclass %s\n",dhcppoolentry.vendorclass);
				fprintf(fp, "vendorclassflag %u\n",dhcppoolentry.vendorclassflag);
				if(dhcppoolentry.vendorclassmode[0]!=0)
					fprintf(fp, "vendorclassmode %s\n",dhcppoolentry.vendorclassmode);
			}
			if(dhcppoolentry.clientid[0]!=0){
				fprintf(fp, "clientid %s\n",dhcppoolentry.clientid);
				fprintf(fp, "clientidflag %u\n",dhcppoolentry.clientidflag);
			}
			if(dhcppoolentry.userclass[0]!=0){
				fprintf(fp, "userclass %s\n",dhcppoolentry.userclass);
				fprintf(fp, "userclassflag %u\n",dhcppoolentry.userclassflag);
			}
			if(memcmp(dhcppoolentry.chaddr,macempty,6)){
				fprintf(fp, "chaddr %02x%02x%02x%02x%02x%02x\n",dhcppoolentry.chaddr[0],dhcppoolentry.chaddr[1],dhcppoolentry.chaddr[2],
					dhcppoolentry.chaddr[3],dhcppoolentry.chaddr[4],dhcppoolentry.chaddr[5]);
				if(memcmp(dhcppoolentry.chaddrmask,macempty,6))
					fprintf(fp, "chaddrmask %02x%02x%02x%02x%02x%02x\n",dhcppoolentry.chaddrmask[0],dhcppoolentry.chaddrmask[1],dhcppoolentry.chaddrmask[2],
						dhcppoolentry.chaddrmask[3],dhcppoolentry.chaddrmask[4],dhcppoolentry.chaddrmask[5]);
				fprintf(fp, "chaddrflag %u\n",dhcppoolentry.chaddrflag);
			}

#ifdef IP_PASSTHROUGH
			ippt = 0;
			if (mib_get(MIB_IPPT_ITF, (void *)&ippt_itf) != 0)
				if (ippt_itf != DUMMY_IFINDEX) // IP passthrough
					ippt = 1;

			if (ippt)
			{
				fprintf(fp, "ippt yes\n");
				mib_get(MIB_IPPT_LEASE, (void *)&uInt);
				fprintf(fp, "ipptlt %d\n", uInt);
			}
#endif
#ifdef IMAGENIO_IPTV_SUPPORT
			//fprintf(fp, "pcopt60 %s\n", pcopt60);
			//fprintf(fp, "cmropt60 %s\n", cmropt60);
			//fprintf(fp, "stbopt60 %s\n", stbopt60);
			//fprintf(fp, "phnopt60 %s\n", phnopt60);
/*ping_zhang:20090930 START:add for Telefonica new option 240*/
#if 0
			fprintf(fp, "opchaddr %s\n", opchaddr);
			fprintf(fp, "opchport %d\n", opchport);
			fprintf(fp, "stbdns1 %s\n", stbdns1);
			if (stbdns2[0])
				fprintf(fp, "stbdns2 %s\n", stbdns2);
#endif
/*ping_zhang:20090930 END*/
#endif

			if(strcmp(dhcpsubnet,ipempty))
				fprintf(fp, "opt subnet %s\n", dhcpsubnet);
			if(strcmp(ipaddr2,ipempty))
				fprintf(fp, "opt router %s\n", ipaddr2);

			// Kaohj
#ifdef DHCPS_DNS_OPTIONS
			if (dhcppoolentry.dnsservermode == 0)
				fprintf(fp, "opt dns %s\n", ipaddr2);
			else { // check manual setting
				strncpy(ipaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dnsserver1))), 16);
				ipaddr[15] = '\0';
				fprintf(fp, "opt dns %s\n", ipaddr);
				strncpy(ipaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dnsserver2))), 16);
				ipaddr[15] = '\0';
				if(strcmp(ipaddr,ipempty)) { // not empty
					fprintf(fp, "opt dns %s\n", ipaddr);
					strncpy(ipaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dnsserver3))), 16);
					ipaddr[15] = '\0';
					if(strcmp(ipaddr,ipempty)) { // not empty
						fprintf(fp, "opt dns %s\n", ipaddr);
					}
				}
			}
#else
			fprintf(fp, "opt dns %s\n", ipaddr2);
#endif
			fprintf(fp, "opt lease %u\n", (unsigned int)(dhcppoolentry.leasetime));
#ifndef CTC_YUNMESTB_DHCPD_DHCPOPTION
			if (dhcppoolentry.domainname[0])
				fprintf(fp, "opt domain %s\n", dhcppoolentry.domainname);
			else
				// per TR-068, I-188
				fprintf(fp, "opt domain domain_not_set.invalid\n");
#endif
#ifdef _CWMP_MIB_ /*jiunming, for cwmp-tr069*/
#ifdef _PRMT_X_CT_COM_DHCP_
		{
			//format: opt venspec [enterprise-number] [sub-option code] [sub-option data] ...
			//opt vendspec: dhcp option 125 Vendor-Identifying Vendor-Specific
			//enterprise-number: 0(e8 temprary enterprise code)
			//sub-option code: 2(DHCP server type)
			//sub-option code: 10(Internet VID)
			//sub-option code: 11(IPTV VID)
			//sub-option code: 12(TR069 VID)
			//sub-option code: 13(VoIP VID)
			unsigned char send_opt_125;
			mib_get(CWMP_CT_DHCPS_SEND_OPT_125, &send_opt_125);
			if(send_opt_125)
				fprintf( fp, "opt venspec 0 2 %s\n", "HGW-CT");
		}
#else
		{
			//format: opt venspec [enterprise-number] [sub-option code] [sub-option data] ...
			//opt vendspec: dhcp option 125 Vendor-Identifying Vendor-Specific
			//enterprise-number: 3561(ADSL Forum)
			//sub-option code: 4(GatewayManufacturerOUI)
			//sub-option code: 5(GatewaySerialNumber)
			//sub-option code: 6(GatewayProductClass)
			char opt125_sn[65];
			mib_get(MIB_HW_SERIAL_NUMBER, (void *)opt125_sn);
			fprintf( fp, "opt venspec 3561 4 %s 5 %s 6 %s\n", MANUFACTURER_OUI, opt125_sn, PRODUCT_CLASS );
		}
#endif
#endif
			//relayinfo
			if( dhcppoolentry.localserved==0 )
			{
				char dhcpserveripaddr[16];
				fprintf(fp, "locallyserved no\n" );
				strncpy(dhcpserveripaddr, inet_ntoa(*((struct in_addr *)(dhcppoolentry.dhcprelayip))), 16);
				dhcpserveripaddr[15]='\0';
				fprintf(fp, "dhcpserver %s\n", dhcpserveripaddr );
			}

			fprintf(fp, "poolend end\n");

		}
	}
#endif
/*ping_zhang:20080919 END*/

	fclose(fp);

//star: retain the lease file between during dhcdp restart
	if ((lockfd = lock_file_by_flock(DHCPSERVERPID, 1)) == -1) //write file should wait
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		goto err;
	}

	if((fp = fopen(DHCPD_LEASE, "r")) == NULL)
	{
		if ((fp = fopen(DHCPD_LEASE, "w")) == NULL)
		{
			printf("Open file %s failed !\n", DHCPD_LEASE);
			goto err;
		}
		fprintf(fp, "\n");
		fclose(fp);
	}
	else
		fclose(fp);
		
	if(-1 != lockfd)
		unlock_file_by_flock(lockfd);

	return 1;

err:
	if(-1 != lockfd)
		unlock_file_by_flock(lockfd);

	return -1;
}



// Added by Mason Yu for Dhcp Relay
// return value:
// 0  : not active
// 1  : active
// -1 : setup failed
int startDhcpRelay(void)
{
	unsigned char value[32];
	unsigned int dhcpmode=2;
	char dhcps[16];
	int status=0;


	if (mib_get(MIB_DHCP_MODE, (void *)value) != 0)
	{
		dhcpmode = (unsigned int)(*(unsigned char *)value);
		if (dhcpmode != DHCP_LAN_RELAY)
			return 0;	// dhcp Relay not on
	}

	// DHCP Relay is on
	if (dhcpmode == DHCP_LAN_RELAY) {

		//printf("DHCP Relay is on\n");

		if (mib_get(MIB_ADSL_WAN_DHCPS, (void *)value) != 0)
		{
			if (((struct in_addr *)value)->s_addr != 0)
			{
				strncpy(dhcps, inet_ntoa(*((struct in_addr *)value)), 16);
				dhcps[15] = '\0';
			}
			else
				dhcps[0] = '\0';
		}
		else
			return -1;

		//printf("dhcps = %s\n", dhcps);
#ifndef COMBINE_DHCPD_DHCRELAY
		status=va_niced_cmd("/bin/dhcrelay", 1, 0, dhcps);
#else
		status=va_niced_cmd(DHCPD, 2, 0, "-R", dhcps);
#endif
		status=(status==-1)?-1:1;

		return status;

	}

	return status;
}
#ifdef _PRMT_X_CT_COM_IPoEDiagnostics_
#define DEFAULT_DHCPC_ERROR_FILE "/var/run/udhcpc.error"
/*
"SendDHCPMsgError" ->1
"ServerNotFound" ->2
"ServerDeny" ->3
*/

int getDHCPError(char *interface)
{
	FILE *fp;
	char filename[64];
	int error; 
	
	sprintf(filename, "%s.%s", DEFAULT_DHCPC_ERROR_FILE, interface);
	if(fp = fopen(filename, "r")){
		if(fscanf(fp, "%d", &error)!=1){
			error = -1;
		}
		fclose(fp);
	}
	else{ 
		error = 0;
	}
	return error;
}
int setDHCPError(char *interface, int error)
{
	int DHCPSuccessNumber = 0;
	FILE *fp;
	char filename[64];
	sprintf(filename, "%s.%s", DEFAULT_DHCPC_ERROR_FILE, interface);
	if(fp = fopen(filename, "w+")){
		fprintf(fp, "%d", error);
		fclose(fp);
		return 0;
	}
	else{ 
		return -1;
	}
}
int clearDHCPError(char *interface){
	char filename[64];

	sprintf(filename, "%s.%s", DEFAULT_DHCPC_ERROR_FILE, interface);
	unlink(filename);
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_RegisterNumberEnable_
#define DEFAULT_DHCPC_REG_FILE "/var/run/udhcpc.reg"
#define DEFAULT_DHCPC_REG_LOCKFILE "/var/run/udhcpc.reg.lock"
int getDHCPRegisterNumber(){
	int DHCPRegisterNumber = 0;
	FILE *fp = NULL;
	char ch;
	int lockfd = 0;
	if ((lockfd = lock_file_by_flock(DEFAULT_DHCPC_REG_LOCKFILE, 0)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, DEFAULT_DHCPC_REG_FILE);
		return 0;
	}
	if(fp = fopen(DEFAULT_DHCPC_REG_FILE, "r")){
		if(fscanf(fp, "%d", &DHCPRegisterNumber)!=1){
			printf("can not read DHCPRegisterNumber from %s!!\n",DEFAULT_DHCPC_REG_FILE);
			DHCPRegisterNumber = 0;
		}
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_DHCPC_REG_FILE);
		DHCPRegisterNumber = 0;
	}
	//printf("read DHCPRegisterNumber=%d\n",DHCPRegisterNumber);
end:
	unlock_file_by_flock(lockfd);
	return DHCPRegisterNumber;
}
void addDHCPRegisterNumber(){
	int DHCPRegisterNumber = 0;
	FILE *fp = NULL;
	char ch;
	int lockfd = 0;
	DHCPRegisterNumber = getDHCPRegisterNumber();
	if ((lockfd = lock_file_by_flock(DEFAULT_DHCPC_REG_LOCKFILE, 1)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, DEFAULT_DHCPC_REG_FILE);
		return;
	}
	if(fp = fopen(DEFAULT_DHCPC_REG_FILE, "w+")){
		DHCPRegisterNumber++;
		//printf("add DHCPRegisterNumber=%d\n",DHCPRegisterNumber);
		fprintf(fp, "%d", DHCPRegisterNumber);
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_DHCPC_REG_FILE);
	}
end:
	unlock_file_by_flock(lockfd);
	return;
}
void clearDHCPRegisterNumber(){
	int DHCPRegisterNumber = 0;
	FILE *fp = NULL;
	char ch;
	int lockfd = 0;
	if ((lockfd = lock_file_by_flock(DEFAULT_DHCPC_REG_LOCKFILE, 1)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, DEFAULT_DHCPC_REG_FILE);
		return;
	}
	if(fp = fopen(DEFAULT_DHCPC_REG_FILE, "w+")){
		//printf("clearDHCPRegisterNumber!!\n");
		fprintf(fp, "0");
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_DHCPC_REG_FILE);
	}
end:
	unlock_file_by_flock(lockfd);
	return;
}
#define DEFAULT_ITMS_REG_FILE "/var/run/itms.reg"
#define DEFAULT_ITMS_LOCK     "/var/run/itms.lock"
int getRegisterNumberITMS(){
	int ITMSRegisterNumber = 0,lockfd=0;
	FILE *fp=NULL;
	char ch;
    if ((lockfd = lock_file_by_flock(DEFAULT_ITMS_LOCK, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		return -1;
	}
	if(fp = fopen(DEFAULT_ITMS_REG_FILE, "r")){
		if(fscanf(fp, "%d", &ITMSRegisterNumber)!=1){
			printf("can not readITMSRegisterNumber from %s!!\n",DEFAULT_ITMS_REG_FILE);
			ITMSRegisterNumber=0;
		}
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_ITMS_REG_FILE);
		ITMSRegisterNumber = 0;
	}
    unlock_file_by_flock(lockfd);
	printf("read ITMSRegisterNumber=%d\n",ITMSRegisterNumber);
	return ITMSRegisterNumber;
}
int addRegisterNumberITMS(){
	int ITMSRegisterNumber = 0,lockfd=0;
	FILE *fp=NULL;
	char ch;
    
	ITMSRegisterNumber = getRegisterNumberITMS();
    if ((lockfd = lock_file_by_flock(DEFAULT_ITMS_LOCK, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		return -1;
	}
	if(fp = fopen(DEFAULT_ITMS_REG_FILE, "w+")){
		ITMSRegisterNumber++;
		printf("add ITMSRegisterNumber=%d\n",ITMSRegisterNumber);
		fprintf(fp, "%d", ITMSRegisterNumber);
		fclose(fp);
        unlock_file_by_flock(lockfd);
		return 0;
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_ITMS_REG_FILE);
        unlock_file_by_flock(lockfd);
		return -1;
	}
}
int defRegisterNumberITMS(){
	int ITMSRegisterNumber = 0,lockfd=0;
	FILE *fp=NULL;
	char ch;
    if ((lockfd = lock_file_by_flock(DEFAULT_ITMS_LOCK, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		return -1;
	}
	if(fp = fopen(DEFAULT_ITMS_REG_FILE, "w+")){
		printf("defITMSRegisterNumber!!\n");
		fprintf(fp, "0");
		fclose(fp);
        unlock_file_by_flock(lockfd);
		return 0;
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_ITMS_REG_FILE);
        unlock_file_by_flock(lockfd);
		return -1;
	}
}

#endif
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_RegisterSuccessNumberEnable_
#define DEFAULT_DHCPC_SUCCESS_FILE "/var/run/udhcpc.success"
#define DEFAULT_DHCPC_SUCCESS_LOCKFILE "/var/run/udhcpc.success.lock"
int getDHCPSuccessNumber(){
	int DHCPSuccessNumber = 0;
	FILE *fp;
	char ch;
	int lockfd = 0;
	if ((lockfd = lock_file_by_flock(DEFAULT_DHCPC_SUCCESS_LOCKFILE, 0)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, DEFAULT_DHCPC_SUCCESS_FILE);
		return 0;
	}
	if(fp = fopen(DEFAULT_DHCPC_SUCCESS_FILE, "r")){
		if(fscanf(fp, "%d", &DHCPSuccessNumber)!=1){
			printf("can not read DHCPSuccessNumber from %s!!\n",DEFAULT_DHCPC_SUCCESS_FILE);
			DHCPSuccessNumber = 0;
		}
		//printf("DHCPSuccessNumber=%d\n",DHCPSuccessNumber);
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_DHCPC_SUCCESS_FILE);
		DHCPSuccessNumber = 0;
	}
end:
	unlock_file_by_flock(lockfd);
	return DHCPSuccessNumber;
}
int addDHCPSuccessNumber(){
	int DHCPSuccessNumber = 0;
	FILE *fp;
	DHCPSuccessNumber = getDHCPSuccessNumber();
	int lockfd = 0;
	if ((lockfd = lock_file_by_flock(DEFAULT_DHCPC_SUCCESS_LOCKFILE, 1)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, DEFAULT_DHCPC_SUCCESS_FILE);
		return -1;
	}
	if(fp = fopen(DEFAULT_DHCPC_SUCCESS_FILE, "w+")){
		DHCPSuccessNumber++;
		fprintf(fp, "%d", DHCPSuccessNumber);
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_DHCPC_SUCCESS_FILE);
	}
end:
	unlock_file_by_flock(lockfd);
	return -1;
}
int clearDHCPSuccessNumber(){
	FILE *fp;
	int lockfd = 0;
	if ((lockfd = lock_file_by_flock(DEFAULT_DHCPC_SUCCESS_LOCKFILE, 1)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, DEFAULT_DHCPC_SUCCESS_FILE);
		return -1;
	}
	if(fp = fopen(DEFAULT_DHCPC_SUCCESS_FILE, "w+")){
		printf("clearDHCPSuccessNumber\n");
		fprintf(fp, "0");
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_DHCPC_SUCCESS_FILE);
	}
end:
	unlock_file_by_flock(lockfd);
	return -1;
}

#define DEFAULT_ITMS_SUCCESS_FILE "/var/run/itms.success"
#define DEFAULT_ITMS_SUCCESS_LOCK "/var/run/itmssucc.lock"
int getRegisterSuccNumITMS(){
	int ITMSSuccessNumber = 0,lockfd=0;
	FILE *fp=NULL;
	char ch;
    if ((lockfd = lock_file_by_flock(DEFAULT_ITMS_SUCCESS_LOCK, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		return -1;
	}
	if(fp = fopen(DEFAULT_ITMS_SUCCESS_FILE, "r")){
		if(fscanf(fp, "%d", &ITMSSuccessNumber)!=1){
			printf("can not read ITMSSuccessNumber from %s!!\n",DEFAULT_ITMS_SUCCESS_FILE);
			ITMSSuccessNumber = 0;
		}
		printf("ITMSSuccessNumber=%d\n",ITMSSuccessNumber);
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_ITMS_SUCCESS_FILE);
		ITMSSuccessNumber = 0;
	}
    unlock_file_by_flock(lockfd);
	return ITMSSuccessNumber;
}
int addRegisterSuccNumITMS(){
	int ITMSSuccessNumber = 0,lockfd=0;
	FILE *fp=NULL;
	ITMSSuccessNumber = getRegisterSuccNumITMS();
    if ((lockfd = lock_file_by_flock(DEFAULT_ITMS_SUCCESS_LOCK, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		return -1;
	}
	if(fp = fopen(DEFAULT_ITMS_SUCCESS_FILE, "w+")){
		ITMSSuccessNumber++;
		fprintf(fp, "%d", ITMSSuccessNumber);
		fclose(fp);
        unlock_file_by_flock(lockfd);
		return 0;
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_ITMS_REG_FILE);
        unlock_file_by_flock(lockfd);
		return -1;
	}
}
int defRegisterSuccNumITMS(){
	FILE *fp=NULL;
    int lockfd=0;
    if ((lockfd = lock_file_by_flock(DEFAULT_ITMS_SUCCESS_LOCK, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		return -1;
	}
	if(fp = fopen(DEFAULT_ITMS_SUCCESS_FILE, "w+")){
		printf("defITMSSuccessNumber\n");
		fprintf(fp, "0");
		fclose(fp);
        unlock_file_by_flock(lockfd);
		return 0;
	}
	else{ 
		printf("fail to open file %s\n",DEFAULT_ITMS_REG_FILE);
        unlock_file_by_flock(lockfd);
		return -1;
	}
}
#endif
int delete_line(const char *filename, int delete_line)
{
	FILE *fileptr1, *fileptr2;
	int ch;
	int temp = 1;
	char *tmpFileName="/var/tmp/replica";

	//open file in read mode
	fileptr1 = fopen(filename, "r");
	fseek(fileptr1, 0, SEEK_SET);

	//open new file in write mode
	fileptr2 = fopen(tmpFileName, "w+");
	while ((ch = getc(fileptr1)) != EOF)
	{
		if (ch == '\n')
			temp++;

		//except the line to be deleted
		if (temp != delete_line)
		{
			//copy all lines in file replica.c
			putc(ch, fileptr2);
		}
	}
	fclose(fileptr1);
	fclose(fileptr2);
	remove(filename);
	//rename the file replica.c to original name
	rename(tmpFileName, filename);
	return 0;
}

int delete_hosts(unsigned char *yiaddr)
{
	FILE *fp;
	int dnsrelaypid=0;
	char temps[256+MAX_NAME_LEN]="", *pwd;
	char tmp1[20]="";
	int tmp_line = 0;

del_again:
	if ((fp = fopen(HOSTS, "r")) == NULL)
	{
		printf("Open file %s failed !\n", HOSTS);
		return 0;
	}

	fseek(fp, 0, SEEK_SET);
	temps[0] = '\0';
	tmp1[0] = '\0';
	tmp_line = 0;

	while (fgets(temps, 256+MAX_NAME_LEN, fp)) {
		tmp_line++;
		pwd = strstr(temps, yiaddr);
		if (pwd) {
			if(sscanf(temps, "%s%*", tmp1) == 1)
			{
				if (!strcmp(tmp1, yiaddr)) {
					fclose(fp);
					delete_line(HOSTS, tmp_line);
					goto del_again;
				}
			}
		}
	}
	fclose(fp);

	dnsrelaypid = read_pid((char*)DNSRELAYPID);
	if(dnsrelaypid > 0)
		kill(dnsrelaypid, SIGHUP);
	return 1;
}

int delete_dsldevice_on_hosts()
{
	unsigned char value[32];
	unsigned char IPStr[16]={0};

	// Get DNS entry "dsldevice" for its own address
	mib_get(MIB_ADSL_LAN_IP, (void *)value);
	strncpy(IPStr, inet_ntoa(*((struct in_addr *)value)), 16);
	delete_hosts(IPStr);
	return 1;
}

int add_dsldevice_on_hosts()
{
	unsigned char value, value2[32];
	FILE *fp;
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)	
	char domain[64];
#else
	char domain[MAX_NAME_LEN];
#endif
	char devName[MAX_NAME_LEN];
	int dnsrelaypid=0;

#ifdef CONFIG_USER_DHCP_SERVER
	mib_get(MIB_DHCP_MODE, (void *)&value);
	if (value== DHCP_SERVER)
	{
		if ((fp = fopen(HOSTS, "a")) == NULL)
		{
			printf("Open file %s failed on DHCP_SERVER mode !\n", HOSTS);
			return -1;
		}
	}
	else
#endif
	{
		if ((fp = fopen(HOSTS, "w")) == NULL)
		{
			printf("Open file %s failed on Not DHCP_SERVER mode !\n", HOSTS);
			return -1;
		}
	}

	// add DNS entry "dsldevice" for its own address
	mib_get(MIB_ADSL_LAN_IP, (void *)value2);
	fprintf(fp, "%s\t", inet_ntoa(*((struct in_addr *)value2)));

	domain[0] = devName[0] = 0;
	mib_get(MIB_DEVICE_NAME, (void *)devName);

#ifdef CONFIG_USER_DHCP_SERVER
	if (value  == DHCP_SERVER)
	{	// add domain
		mib_get(MIB_ADSL_LAN_DHCP_DOMAIN, (void *)domain);
		if (domain[0])
			fprintf(fp, "%s.%s ", devName, domain);
	}
#endif
	fprintf(fp, "%s\n", devName);
	fclose(fp);

	dnsrelaypid = read_pid((char*)DNSRELAYPID);
	if(dnsrelaypid > 0)
		kill(dnsrelaypid, SIGHUP);

	return 1;
}

/* clear dnsmasq cache
   return value: 1 success, 0 fail */
int reloadDnsRelay()
{
	int dnsrelaypid=0;
	dnsrelaypid = read_pid((char*)DNSRELAYPID);
	if(dnsrelaypid > 0)
	{
		kill(dnsrelaypid, SIGHUP);
		return 1;
	}
	return 0;
}

const char RESOLV[] = "/var/resolv.conf";
const char DNSMASQ_CONF[] = "/var/dnsmasq.conf";
const char RESOLV_BACKUP[] = "/var/resolv_backup.conf";
const char MANUAL_RESOLV[] = "/var/resolv.manual.conf";
// Mason Yu. for copy the ppp & dhcp nameserver to the /var/resolv.conf
const char AUTO_RESOLV[] = "/var/resolv.auto.conf";	/*add resolv.auto.conf to distinguish DNS manual and auto config*/
const char DNS_RESOLV[] = "/var/udhcpc/resolv.conf";
const char DNS6_RESOLV[] = "/var/resolv6.conf";
const char PPP_RESOLV[] = "/etc/ppp/resolv.conf";
const char HOSTS[] = "/var/tmp/hosts";
const char DBUS_DNS_FILE[] = "/var/dbus_dns";

// DNS relay server configuration
// return value:
// 1  : successful
// -1 : startup failed
int startDnsRelay(void)
{
	unsigned char value[32];
	FILE *fp;
	DNS_TYPE_T dnsMode;
	char *str;
	unsigned int i, vcTotal, resolvopt;
	char dns1[16], dns2[16], dns3[16];
	char dnsv61[48]={0};
	char dnsv62[48]={0};
	char dnsv63[48]={0};
	char domain[MAX_NAME_LEN];
	FILE *dnsfp=fopen(RESOLV,"w");		/* resolv.conf*/

	fprintf(dnsfp, "nameserver 127.0.0.1\n");
#ifdef CONFIG_IPV6
	fprintf(dnsfp, "nameserver ::1\n");
#endif
	fclose(dnsfp);
#ifdef OLD_DNS_MANUALLY
	if (mib_get(MIB_ADSL_WAN_DNS1, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != INADDR_NONE && ((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(dns1, inet_ntoa(*((struct in_addr *)value)), 16);
			dns1[15] = '\0';
		}
		else
			dns1[0] = '\0';
	}
	else
		return -1;

	if (mib_get(MIB_ADSL_WAN_DNS2, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != INADDR_NONE && ((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(dns2, inet_ntoa(*((struct in_addr *)value)), 16);
			dns2[15] = '\0';
		}
		else
			dns2[0] = '\0';
	}
	else
		return -1;

	if (mib_get(MIB_ADSL_WAN_DNS3, (void *)value) != 0)
	{
		if (((struct in_addr *)value)->s_addr != INADDR_NONE && ((struct in_addr *)value)->s_addr != 0)
		{
			strncpy(dns3, inet_ntoa(*((struct in_addr *)value)), 16);
			dns3[15] = '\0';
		}
		else
			dns3[0] = '\0';
	}
	else
		return -1;

#ifdef CONFIG_IPV6
	if (mib_get(MIB_ADSL_WAN_DNSV61, (void *)value) != 0)	{
		if (memcmp( ((struct in6_addr *)value)->s6_addr, dnsv61, 16))
		{
			inet_ntop(PF_INET6, &value, dnsv61, 48);
			dnsv61[47] = '\0';
		}
		else
			dnsv61[0] = '\0';
	}
	else
		return -1;

	if (mib_get(MIB_ADSL_WAN_DNSV62, (void *)value) != 0)	{
		if (memcmp( ((struct in6_addr *)value)->s6_addr, dnsv62, 16))
		{
			inet_ntop(PF_INET6, &value, dnsv62, 48);
			dnsv62[47] = '\0';
		}
		else
			dnsv62[0] = '\0';
	}
	else
		return -1;

	if (mib_get(MIB_ADSL_WAN_DNSV63, (void *)value) != 0)	{
		if (memcmp( ((struct in6_addr *)value)->s6_addr, dnsv63, 16))
		{
			inet_ntop(PF_INET6, &value, dnsv63, 48);
			dnsv63[47] = '\0';
		}
		else
			dnsv63[0] = '\0';
	}
	else
		return -1;
#endif

	// get DNS mode
	if (mib_get(MIB_ADSL_WAN_DNS_MODE, (void *)value) != 0)
	{
		dnsMode = (DNS_TYPE_T)(*(unsigned char *)value);
	}
	else
		return -1;

	if ((fp = fopen(MANUAL_RESOLV, "w")) == NULL)
	{
		printf("Open file %s failed !\n", MANUAL_RESOLV);
		return -1;
	}

	if (dns1[0])
		fprintf(fp, "nameserver %s\n", dns1);
	if (dns2[0])
		fprintf(fp, "nameserver %s\n", dns2);
	if (dns3[0])
		fprintf(fp, "nameserver %s\n", dns3);
#ifdef CONFIG_IPV6
	if (dnsv61[0])
		fprintf(fp, "nameserver %s\n", dnsv61);
	if (dnsv62[0])
		fprintf(fp, "nameserver %s\n", dnsv62);
	if (dnsv63[0])
		fprintf(fp, "nameserver %s\n", dnsv63);
#endif
	fclose(fp);

	if (dnsMode != REQUEST_DNS)
	{
		// dnsmasq -h -i LANIF -r MANUAL_RESOLV
		TRACE(STA_INFO, "get DNS from manual\n");
		str=(char *)MANUAL_RESOLV;
	}
	else	// DNS_AUTO
	{
#if 0
		MIB_CE_ATM_VC_T Entry;

		resolvopt = 0;
		vcTotal = mib_chain_total(MIB_ATM_VC_TBL);

		for (i = 0; i < vcTotal; i++)
		{
			/* get the specified chain record */
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				return -1;

			if (Entry.enable == 0)
				continue;

			if ((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_PPPOE ||
				(CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_PPPOA)
				resolvopt = 1;
			else if ((DHCP_T)Entry.ipDhcp == DHCP_CLIENT)
				resolvopt = 2;
		}

#ifdef CONFIG_USER_PPPOMODEM
		{
			MIB_WAN_3G_T entry,*p;
			p=&entry;
			if(mib_chain_get( MIB_WAN_3G_TBL, 0, (void*)p))
			{
				if(p->enable) resolvopt = 1;
			}
		}
#endif //CONFIG_USER_PPPOMODEM

		if (resolvopt == 1) // get from PPP
		{
			// dnsmasq -h -i LANIF -r PPP_RESOLV
			TRACE(STA_INFO, "get DNS from PPP\n");
			str=(char *)PPP_RESOLV;
		}
		else if (resolvopt == 2) // get from DHCP client
		{
			// dnsmasq -h -i LANIF -r DNS_RESOLV
			TRACE(STA_INFO, "get DNS from DHCP client\n");
			str=(char *)DNS_RESOLV;
		}
		else	// get from manual
		{
			// dnsmasq -h -i LANIF -r MANUAL_RESOLV
			TRACE(STA_INFO, "get DNS from manual\n");
			str=(char *)MANUAL_RESOLV;
		}
#endif

		fp=fopen(AUTO_RESOLV,"r");
		if(fp)
			fclose(fp);
		else{
			fp=fopen(AUTO_RESOLV,"w");
			if(fp)
				fclose(fp);
		}
		str=(char *)AUTO_RESOLV;
	}
#endif

	// create hosts file
	delete_dsldevice_on_hosts();
	add_dsldevice_on_hosts();

	#if 0
	//va_niced_cmd(DNSRELAY, 4, 0, (char *)ARG_I, (char *)LANIF, "-r", str);
	if (va_niced_cmd(DNSRELAY, 2, 0, "-r", str))
	    return -1;
	#endif

#ifdef OLD_DNS_MANUALLY
//star: for the dns restart
	unlink(RESOLV);

	if (symlink(str, RESOLV)) {
			printf("failed to link %s --> %s\n", str, RESOLV);
			return -1;
	}
#endif

#ifdef SUPPORT_WEB_REDIRECT
	/* Do NOT cache failed DNS search results */
#ifdef CONFIG_USER_BEHAVIOR_ANALYSIS
	MIB_NETWORK_PERFORMANCE_T NPEntry;
	int total = 0, idx = 0;

	total = mib_chain_total(MIB_NETWORK_PERFORMANCE_TBL);
	for (idx = 0; idx < total; idx++) {
		if (!mib_chain_get(MIB_NETWORK_PERFORMANCE_TBL, idx, (void *)&NPEntry))
			continue;

		if (NPEntry.performance_type == NETWORK_PERFORMANCE_DNS_QUERY)
			break;
	}

	if ((idx < total) && (NPEntry.enable == 1)) {
		if (va_niced_cmd(DNSRELAY, 7, 0, "-C", DNSMASQ_CONF, "-r", RESOLV, "-N", "-c", "0"))
			return -1;
	}
	else
#endif
	if (va_niced_cmd(DNSRELAY, 5, 0, "-C", DNSMASQ_CONF, "-r", RESOLV, "-N"))
	    return -1;
#else
	if (va_niced_cmd(DNSRELAY, 4, 0, "-C", DNSMASQ_CONF, "-r", RESOLV))
	    return -1;
#endif

	return 1;
}

/*ql: 20081114 START: new IP QoS*/
#ifdef NEW_IP_QOS_SUPPORT
#define QOS_SETUP_DEBUG
static unsigned int qos_setup_debug = 3;

#ifdef QOS_SETUP_DEBUG
#define QOS_SETUP_PRINT_FUNCTION                    \
    do{if(qos_setup_debug&0x1) fprintf(stderr,"%s: %s  %d\n", __FILE__, __FUNCTION__,__LINE__);}while(0)
#else
#define QOS_SETUP_PRINT_FUNCTION do{}while(0)
#endif

enum qos_mode_t
{
	QOS_NONE=0,
	QOS_RULE,
	QOS_TC
};

static char* proto2str2layer[] = {
    [0]" ",
    [1]"--ip-proto 6",
    [2]"--ip-proto 17",
    [3]"--ip-proto 1",
};

static char* proto2str[] = {
    [0]" ",
    [1]"-p TCP",
    [2]"-p UDP",
    [3]"-p ICMP",
};

static const char QOS_CHAIN_EBT[] =  "ebt_rule";
static const char QOS_CHAIN_IPT[] =  "ipt_rule";

/****************************************
* getUpLinkRate:
* DESC: get upstream link rate.
****************************************/
static unsigned int getUpLinkRate(void)
{
	// Ethernet upLink: 100Mbps
	return 102400;
}

/************************************************************
* NAME: setupQosChain
* DESC: setup user defined chain in iptable tables or ebtables table
* RETURN: 0 - success; 1 - fail
************************************************************/
static int setupQoSChain(int enable)
{
	QOS_SETUP_PRINT_FUNCTION;

	if (enable) {
		va_cmd(EBTABLES, 4, 1, "-t", "broute", "-N", "ebt_rule");
		va_cmd(EBTABLES, 5, 1, "-t", "broute", "-P", "ebt_rule", "RETURN");
#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-N", "ipt_rule");
		va_cmd(IPTABLES, 6, 1, "-t", "mangle", "-A", "PREROUTING", "-j", "ipt_rule");
#else
		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-N", "ipt_rule");
		va_cmd(IPTABLES, 6, 1, "-t", "mangle", "-A", "FORWARD", "-j", "ipt_rule");
#endif
		//va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-N", "qos_rule");
		//va_cmd(IPTABLES, 6, 1, "-t", "mangle", "-A", "FORWARD", "-j", "qos_rule");
	} else {
		va_cmd(EBTABLES, 4, 1, "-t", "broute", "-F", "ebt_rule");
		va_cmd(EBTABLES, 6, 1, "-t", "broute", "-D", "BROUTING", "-j", "ebt_rule");
		va_cmd(EBTABLES, 4, 1, "-t", "broute", "-X", "ebt_rule");

#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-F", "ipt_rule");
		va_cmd(IPTABLES, 6, 1, "-t", "mangle", "-D", "PREROUTING", "-j", "ipt_rule");
		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-X", "ipt_rule");
#else
		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-F", "ipt_rule");
		va_cmd(IPTABLES, 6, 1, "-t", "mangle", "-D", "FORWARD", "-j", "ipt_rule");
		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-X", "ipt_rule");
#endif
	}
	return 0;
}

/********************************************************************
* NAME: setupQosTcChain
* DESC: setup user defined chain in iptable tables or ebtables table for tc shaping
* RETURN: 0 - success; 1 - fail
********************************************************************/
static int setupQosTcChain(unsigned int enable)
{
	QOS_SETUP_PRINT_FUNCTION;

	if (enable)
	{
		va_cmd(EBTABLES, 4, 1, "-t", "broute", "-N", "ebt_rule");
		va_cmd(EBTABLES, 6, 1, "-t", "broute", "-A", "BROUTING", "-j", "ebt_rule");

		va_cmd(IPTABLES, 4, 1, "-t", "filter", "-N", "qos_filter");
		va_cmd(IPTABLES, 7, 1, "-t", "filter", "-I", "FORWARD", "1", "-j", "qos_filter");

		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-N", "qos_traffic");
		va_cmd(IPTABLES, 6, 1, "-t", "mangle", "-A", "POSTROUTING", "-j", "qos_traffic");
	} else {
		va_cmd(EBTABLES, 4, 1, "-t", "broute", "-F", "ebt_rule");
		va_cmd(EBTABLES, 6, 1, "-t", "broute", "-D", "BROUTING", "-j", "ebt_rule");
		va_cmd(EBTABLES, 4, 1, "-t", "broute", "-X", "ebt_rule");

		va_cmd(EBTABLES, 4, 1, "-t", "filter", "-F", "INPUT");

		va_cmd(IPTABLES, 4, 1, "-t", "filter", "-F", "qos_filter");
		va_cmd(IPTABLES, 6, 1, "-t", "filter", "-D", "FORWARD", "-j", "qos_filter");
		va_cmd(IPTABLES, 4, 1, "-t", "filter", "-X", "qos_filter");

		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-F", "qos_traffic");
		va_cmd(IPTABLES, 6, 1, "-t", "mangle", "-D", "POSTROUTING", "-j", "qos_traffic");
		va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-X", "qos_traffic");
	}

	return 1;
}

/*******************************************************
* enableIMQ:
* DESC: setup IMQ device and redirect all packet to IMQ queue.
********************************************************/
static int enableIMQ(void)
{
	DOCMDINIT;

	QOS_SETUP_PRINT_FUNCTION;

	DOCMDARGVS(IFCONFIG, DOWAIT, "imq0 txqueuelen 100");
	DOCMDARGVS(IFCONFIG, DOWAIT, "imq0 up");

	DOCMDARGVS(IPTABLES, DOWAIT, "-t mangle -A PREROUTING -i br+ -j IMQ --todev 0");

	return 0;
}

/*******************************************************
* cleanup_qos_setting:
* DESC: clean all tc rule and relevant iptables/ebtables rules.
********************************************************/
static void cleanupQdiscRule(void)
{
	MIB_CE_ATM_VC_T pvcEntry;
	int i = 0, vcNum = 0;
	char ifname[IFNAMSIZ];
	DOCMDINIT;

	//clear all tc rule on pvc...
	vcNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<vcNum; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&pvcEntry) || !pvcEntry.enable)
			continue;
		if (!pvcEntry.enableIpQos)
			continue;

		//interface
		ifGetName(pvcEntry.ifIndex, ifname, sizeof(ifname));

		DOCMDARGVS(TC, DOWAIT, "qdisc del dev %s root", ifname);
	}
}

static void cleanup_qos_setting(void)
{
	unsigned char qosmode;
	DOCMDINIT;

	QOS_SETUP_PRINT_FUNCTION;

	mib_get(MIB_QOS_MODE, (void *)&qosmode);
	if (qosmode == QOS_NONE)
		return;
	else if (qosmode == QOS_TC) {
		setupQosTcChain(0);
		cleanupQdiscRule();
	}
	else if (qosmode == QOS_RULE) {
#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
		DOCMDARGVS(IPTABLES, DOWAIT, "-t mangle -D PREROUTING -i br+ -j IMQ --todev 0");
		DOCMDARGVS(IFCONFIG, DOWAIT, "imq0 down");
#endif

		setupQoSChain(0);

		//clear all tc rule on imq0.
#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
		DOCMDARGVS(TC, DOWAIT, "qdisc del dev imq0 root");
#else
		cleanupQdiscRule();
#endif
	}
}

/******************************************************
* NAME: setup_filter_rule
* DESC: setup filter rule for relevant qdisc, and tag packet
                   according to qos rule.
* ARGS: policy 0 - PRIO; 1 - WRR
* RETURN: 0 - success; 1 - fail
******************************************************/
static int setup_filter_rule(unsigned char policy)
{
    MIB_CE_IP_QOS_T entry;
    int i = 0, EntryNum = 0;
	MIB_CE_ATM_VC_T pvcEntry;
	int j = 0, vcNum = 0;
    DOCMDINIT;

    EntryNum = mib_chain_total(MIB_IP_QOS_TBL);
	vcNum = mib_chain_total(MIB_ATM_VC_TBL);
    for(i=0; i<EntryNum; i++)
	{
		unsigned int mark=0;

		if(!mib_chain_get(MIB_IP_QOS_TBL, i, (void*)&entry)||!entry.enable)
		    continue;

		for (j=0; j<vcNum; j++)
		{
			char ifname[IFNAMSIZ];
			char phyPort[16]={0};
			char sport[48], dport[48], saddr[48], daddr[48], strmark[48];
			char strdscp[24] = {0};
			char *proto=NULL;
			char *eth_proto = NULL;
// Mason Yu. combine_1p_4p_PortMapping
#if (defined( ITF_GROUP_1P) && defined(ITF_GROUP))
			unsigned int wan_vlan_enable = 0;
#endif
			unsigned int bridge=0;
			unsigned char tos=0, dscp=0;

			if (!mib_chain_get(MIB_ATM_VC_TBL, j, (void *)&pvcEntry))
				continue;

			if (!pvcEntry.enable)
				continue;
			if (!pvcEntry.enableIpQos || pvcEntry.ifIndex != entry.outif)
				continue;

// Mason Yu. combine_1p_4p_PortMapping
#if (defined( ITF_GROUP_1P) && defined(ITF_GROUP))
			if (pvcEntry.vlan)
				wan_vlan_enable = 1;
#endif
			if (pvcEntry.cmode == CHANNEL_MODE_BRIDGE)
				bridge = 1;

			//interface
			ifGetName(pvcEntry.ifIndex, ifname, sizeof(ifname));

			//dscp match
#ifdef QOS_DSCP_MATCH
			if(0 != entry.qosDscp)
			{
				if (bridge)
					snprintf(strdscp, 24, "--ip-tos 0x%x", (entry.qosDscp-1)&0xFF);
				else
					snprintf(strdscp, 24, "-m dscp --dscp 0x%x", entry.qosDscp>>2);
			}else{
				strdscp[0]='\0';
			}
#endif

			//source address
			if(0 != entry.sip[0]) {
				if(0 != entry.smaskbit) {
					if (bridge)
						snprintf(saddr, 48, "--ip-source %s/%d",
							inet_ntoa(*(struct in_addr*)entry.sip), entry.smaskbit);
					else
						snprintf(saddr, 48, "-s %s/%d",
							inet_ntoa(*(struct in_addr*)entry.sip), entry.smaskbit);
				} else {
					if (bridge)
						snprintf(saddr, 48, "--ip-source %s", inet_ntoa(*(struct in_addr*)entry.sip));
					else
						snprintf(saddr, 48, "-s %s", inet_ntoa(*(struct in_addr*)entry.sip));
				}
			} else
				saddr[0]='\0';

			//dest address
			if(0 != entry.dip[0]) {
				if(0 != entry.dmaskbit) {
					if (bridge)
						snprintf(daddr, 48, "--ip-destination %s/%d",
							inet_ntoa(*(struct in_addr*)entry.dip), entry.dmaskbit);
					else
						snprintf(daddr, 48, "-d %s/%d",
							inet_ntoa(*(struct in_addr*)entry.dip), entry.dmaskbit);
				} else {
					if (bridge)
						snprintf(daddr, 48, "--ip-destination %s", inet_ntoa(*(struct in_addr*)entry.dip));
					else
						snprintf(daddr, 48, "-d %s", inet_ntoa(*(struct in_addr*)entry.dip));
				}
			} else
				daddr[0]='\0';

			//protocol
			if (bridge)
				proto = proto2str2layer[entry.protoType];//for ebtables
			else
				proto = proto2str[entry.protoType];//for iptables

			//source port (range)
			if((PROTO_NONE == entry.protoType) ||
				(PROTO_ICMP == entry.protoType) ||
				(0 == entry.sPort))
			{//if protocol is icmp or none or port not set, ignore the port
				sport[0] = '\0';
			}
			else
			{
				if (bridge)
					snprintf(sport, 48, "--ip-source-port %d", entry.sPort);
				else
					snprintf(sport, 48, "--sport %d", entry.sPort);
			}

			//dest port (range)
			if((PROTO_NONE == entry.protoType) ||
				(PROTO_ICMP == entry.protoType) ||
				(0 == entry.dPort))
			{//if protocol is icmp or none or port not set, ignore the port
				dport[0] = '\0';
			}
			else
			{
				if (bridge)
					snprintf(dport, 48, "--ip-destination-port %d", entry.dPort);
				else
					snprintf(dport, 48, "--dport %d", entry.dPort);
			}

			//lan port, USB, eth0_sw0-eth0_sw3, wlan
			if (entry.phyPort != 0xff) {
#if defined (IP_QOS_VPORT)
				if (entry.phyPort < SW_LAN_PORT_NUM)
					snprintf(phyPort, 16, "-i %s", SW_LAN_PORT_IF[entry.phyPort]);
#else
				if (entry.phyPort == 0)
					snprintf(phyPort, 16, "-i %s", ELANIF);
#endif
#ifdef CONFIG_USB_ETH
				else if (entry.phyPort == IFUSBETH_PHYNUM)
					snprintf(phyPort, 16, "-i %s", USBETHIF);
#endif
#ifdef WLAN_SUPPORT
				else {
					snprintf(phyPort, 16, "-i %s", getWlanIfName());
				}
#endif
			} else {
				if (bridge)
					phyPort[0] = '\0';
				else
					snprintf(phyPort, 16, "-i br0");
			}

			//lan 802.1p mark, 0-7 bit
			if(0 != entry.vlan1p) {
				if (bridge)
					snprintf(strmark, 48, "--vlan-prio %d", (entry.vlan1p-1)&0xff);
				else
					snprintf(strmark, 48, "-m mark --mark 0x%x", (entry.vlan1p-1)&0xff);
			} else
				strmark[0] = '\0';

			if (bridge) {
				if(strmark[0] != '\0')//vlan 802.1p priority, use 802.1Q ethernet protocol
				{
					eth_proto = "-p 0x8100";
				}else {//use ipv4 for ethernet protocol
					eth_proto = "-p 0x0800";
				}
			}

			//wan 802.1p mark
// Mason Yu. combine_1p_4p_PortMapping
#if defined( ITF_GROUP_1P) && defined(ITF_GROUP)
			if(wan_vlan_enable && (0 != entry.m_1p))
#else
			if (0 != entry.m_1p)
#endif
				mark = (entry.m_1p-1)&0xf;
			mark |= (i+1) << 8;

			//set the mark
			if (bridge) {
				DOCMDARGVS(EBTABLES, DOWAIT, "-t broute -A %s %s %s %s %s %s %s %s %s %s -j mark --set-mark 0x%x",
					QOS_CHAIN_EBT, phyPort, eth_proto, proto, saddr, sport, daddr, dport, strdscp, strmark, mark);
			} else {
				DOCMDARGVS(IPTABLES, DOWAIT, "-t mangle -A %s %s %s %s %s %s %s %s %s -j MARK --set-mark 0x%x",
					QOS_CHAIN_IPT, phyPort, proto, saddr, sport, daddr, dport, strdscp, strmark, mark);
			}

			//reset match_mark
			if(strmark[0] != '\0') {
				if (bridge)
					snprintf(strmark, 48, "--vlan-prio %d", mark);
				else
					snprintf(strmark, 48, "-m mark --mark 0x%x", mark);
			}

			//set dscp
#ifdef QOS_DSCP
			if (entry.dscp) {//dscp target
				if (entry.m_dscp != 0) {
					if (bridge) {
						DOCMDARGVS(EBTABLES, DOWAIT, "-t broute -A %s %s %s %s %s %s %s %s %s %s -j ftos --set-ftos 0x%x",
							QOS_CHAIN_EBT, phyPort, eth_proto, proto, saddr, sport, daddr, dport, strdscp, strmark, (entry.m_dscp-1)&0xff);
					} else {
						DOCMDARGVS(IPTABLES, DOWAIT, "-t mangle -A %s %s %s %s %s %s %s %s %s -j DSCP --set-dscp 0x%x",
							QOS_CHAIN_IPT, phyPort, proto, saddr, sport, daddr, dport, strdscp, strmark, entry.m_dscp>>2);
					}
				}
			} else  {
#endif
			if ((entry.m_ipprio != 0) || (entry.m_iptos != 0xff)) {
				if (entry.m_ipprio != 0)
					tos = (entry.m_ipprio-1) << 5;
				if (entry.m_iptos != 0xff)
					tos |= entry.m_iptos;

				if (bridge) {
					DOCMDARGVS(EBTABLES, DOWAIT, "-t broute -A %s %s %s %s %s %s %s %s %s %s -j ftos --set-ftos 0x%x",
						QOS_CHAIN_EBT, phyPort, eth_proto, proto, saddr, sport, daddr, dport, strdscp, strmark, tos);
				} else {
					DOCMDARGVS(IPTABLES, DOWAIT, "-t mangle -A %s %s %s %s %s %s %s %s %s -j TOS --set-tos 0x%x",
						QOS_CHAIN_IPT, phyPort, proto, saddr, sport, daddr, dport, strdscp, strmark, tos);
				}
			}
#ifdef QOS_DSCP
			}
#endif

#if !defined(CONFIG_IMQ) && !defined(CONFIG_IMQ_MODULE)
			if(PLY_WRR == policy)//weighted round robin
			{
				DOCMDARGVS(TC, DOWAIT, "filter add dev %s parent 1: prio 1 protocol ip handle 0x%x fw flowid 1:%d00",
					ifname, mark, entry.prior+1);
			}
			else if (PLY_PRIO == policy)//priority queue
			{
				DOCMDARGVS(TC, DOWAIT, "filter add dev %s parent 1: prio %d protocol ip handle 0x%x fw flowid 1:%d",
					ifname, entry.prior+1, mark, entry.prior+1);
			}
#endif
		}

#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
		if(PLY_WRR == policy)//weighted round robin
		{
			DOCMDARGVS(TC, DOWAIT, "filter add dev imq0 parent 1: prio 1 protocol ip handle 0x%x fw flowid 1:%d00",
				mark, entry.prior+1);
		}
		else if (PLY_PRIO == policy)//priority queue
		{
			DOCMDARGVS(TC, DOWAIT, "filter add dev imq0 parent 1: prio %d protocol ip handle 0x%x fw flowid 1:%d",
				entry.prior+1, mark, entry.prior+1);
		}
#endif
	}

    return 0;
}

/****************************************************************
 *NAME:      setup_traffic_rule
 *DESC:      tc class add dev $DEV parent 10:1 handle 10:$SUBID htb rate $RATE ceil $CEIL
 *           tc filter add dev $DEV parent 10: protocol ip prio 0 handle $HANDLE fw classid 10:$SUBID
 *           iptables -p $PROTO -s $SADDR -d $DADDR --sport $SPORT --dport $DPORT -j MARK --set-mark $HANDLE
 *           setup traffic control for every configuration
 *ARGS:      index, start from 1
 *RETURN:    0 success, others  fail
 ****************************************************************/
static int setup_traffic_rule(MIB_CE_IP_TC_Tp entry)
{
	char ifname[IFNAMSIZ];
	char* tc_act = NULL, *fw_act=NULL;
	char* proto1 = NULL, *proto2 = NULL;
	char wanPort[16]={0};
	char  saddr[24], daddr[24], sport[16], dport[16];
	int upLinkRate=0, childRate=0;
	int mark;
	DOCMDINIT;

	QOS_SETUP_PRINT_FUNCTION;

	tc_act = (char*)ARG_ADD;
	fw_act = (char*)FW_ADD;

	if(NULL == entry) {
		printf("Invalid traffic contolling rule!\n");
		goto error;
	}

	ifGetName(entry->ifIndex, ifname, sizeof(ifname));

	//wan interface
	snprintf(wanPort, 16, "-o %s", ifname);

	//source address and netmask
	if(0 != entry->srcip)
	{
		if(0 != entry->smaskbits) {
			snprintf(saddr, 24, "-s %s/%d", inet_ntoa(*((struct in_addr*)(&entry->srcip))), entry->smaskbits);
		} else {
			snprintf(saddr, 24, "-s %s", inet_ntoa(*((struct in_addr*)(&entry->srcip))));
		}
	}
	else {//if not specify the source ip
		saddr[0] = '\0';
	}

	//destination address and netmask
	if(0 != entry->dstip) {
		if(0 != entry->dmaskbits) {
			snprintf(daddr, 24, "-d %s/%d", inet_ntoa(*((struct in_addr*)(&entry->dstip))), entry->dmaskbits);
		} else {
			snprintf(daddr, 24, "-d %s", inet_ntoa(*((struct in_addr*)(&entry->dstip))));
		}
	} else {//if not specify the dest ip
		daddr[0] = '\0';
	}

	//source port
	if(0 != entry->sport) {
		snprintf(sport, 16, "--sport %d", entry->sport);
	} else {
		sport[0] = '\0';
	}

	//destination port
	if(0 != entry->dport) {
		snprintf(dport, 16, "--dport %d", entry->dport);
	} else {
		dport[0] = '\0';
	}

	//protocol
	if (((0 != entry->sport) || (0 != entry->dport)) &&
		(entry->protoType < 2))
		entry->protoType = 4;

	if(entry->protoType>4)//wrong protocol index
	{
		printf("Wrong protocol\n");
		goto error;
	} else {
		switch(entry->protoType)
		{
			case 0://NONE
				proto1 = " ";
				//filt_proto1 = " ";
				break;
			case 1://ICMP
				proto1 = "-p ICMP";
				//filt_proto1 = "match ip ptotocol 1 0xff";
				break;
			case 2://TCP
				proto1 = "-p TCP";
				//filt_proto1 = "match ip protocol 6 0xff";
				break;
			case 3://UDP
				proto1 = "-p UDP";
				//filt_proto1 = "match ip protocol 17 0xff";
				break;
			case 4://TCP/UDP
				proto1 = "-p TCP";
				proto2 = "-p UDP";
				//filt_proto1 = "match ip protocol 6 0xff";
				//filt_proto2 = "match ip protocol 17 0xff";
				break;
		}
	}

	upLinkRate = entry->limitSpeed;
	if(0 != upLinkRate)
	{
		//get mark
		mark = (entry->entryid<<12);

		//patch: true bandwidth will be a little greater than limit value, so I minish 7% of set limit value ahead.
		int ceil;
		ceil = upLinkRate/100 * 93;

		//childRate = (10 > upLinkRate)?upLinkRate:10;
		childRate = (10>ceil)?ceil:10;

		DOCMDARGVS(TC, DOWAIT, "class %s dev %s parent 1:1 classid 1:%d0 htb rate %dkbit ceil %dkbit mpu 64 overhead 4",
			tc_act, ifname, entry->entryid, childRate, ceil);

		DOCMDARGVS(TC, DOWAIT, "qdisc %s dev %s parent 1:%d0 handle %d1: pfifo",
			tc_act, ifname, entry->entryid, entry->entryid);

		DOCMDARGVS(TC, DOWAIT, "filter %s dev %s parent 1: protocol ip prio 0 handle 0x%x fw flowid 1:%d0",
			tc_act, ifname, mark, entry->entryid);

		DOCMDARGVS(IPTABLES, DOWAIT,  "-t mangle %s qos_traffic %s %s %s %s %s %s -j MARK --set-mark 0x%x",
			fw_act, wanPort, proto1, saddr, daddr, sport, dport, mark);

		/*TCP/UDP?*/
		if(proto2)//setup the other protocol
		{
			DOCMDARGVS(IPTABLES, DOWAIT, "-t mangle %s qos_traffic %s %s %s %s %s %s -j MARK --set-mark 0x%x",
				fw_act, wanPort, proto2, saddr, daddr, sport, dport, mark);
		}
	}
	else
	{//if uprate=0, forbid traffic matching the rules
		DOCMDARGVS(IPTABLES, DOWAIT, "-t filter %s qos_filter %s %s %s %s %s %s -j DROP",
			fw_act, wanPort, proto1, saddr, daddr, sport, dport);

		/*TCP/UDP again*/
		if(proto2)
		{
			DOCMDARGVS(IPTABLES, DOWAIT, "-t filter %s qos_filter %s %s %s %s %s %s -j DROP",
				fw_act, wanPort, proto2, saddr, daddr, sport, dport);
		}
	}

	return 0;
error:
	return 1;
}


/**************************************************************************
 * NAME:    setup_wrr_queue
 * DESC:    Using the htb qdisc to implement the wrr qdisc(surprised?), not
 *          CBQ, because the CBQ qdisc is so complicated and not very accurate.
 *          The skeleton of wrr(htb):
 *                                     HTB(root qdisc,1:)
 *                                      |
 *                                     HTB(root class,1:1)
 *                  ____________________|________________
 *                 |            |            |           |
 *                HTB          HTB          HTB         HTB
 *         (sub-cls,1:10) (sub-cls,1:20)(sub-cls,1:30)(sub-cls,1:40)
 *
 *         for example, bandwidth is 1024Kbit/s, there are three queues with
 *         priority 3:2:1, then these queues are allocated rate and ceil is
 *         1/2, 1/3, 1/6 of total bandwidth.
 *         This function is called when dsl synchronization is completed.
 *ARGS:
 *RETURN:  0 success, 1 fail.
**************************************************************************/
static int setup_wrr_queue(void)
{
#if !defined(CONFIG_IMQ) && !defined(CONFIG_IMQ_MODULE)
	MIB_CE_ATM_VC_T vcEntry;
	int i, EntryNum;
	char ifname[IFNAMSIZ];
#endif
    int j, quantum;
	int rate = 0;
	unsigned int total_bandwidth = 0;
	DOCMDINIT;

	QOS_SETUP_PRINT_FUNCTION;

	total_bandwidth = getUpLinkRate();

#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
	//tc qdisc add dev $DEV root handle 1: htb default 400
	DOCMDARGVS(TC,DOWAIT, "qdisc add dev imq0 root handle 1: htb default 400");

	//tc class add dev $DEV parent 1: classid 1:1 htb rate $RATE ceil $CEIL
	DOCMDARGVS(TC, DOWAIT, "class add dev imq0 parent 1: classid 1:1 htb rate %uKbit ceil %uKbit burst 15k",
		total_bandwidth, total_bandwidth);

	for(j=1; j<=4; j++)
	{
		/*ql:20080821 START: when line rate is low than 1Mbps, rate should be smaller...*/
		//rate = 700 * (5-j)/10;
		if (total_bandwidth > 950)
			rate = 70 * (5-j);
		else if (total_bandwidth > 790)
			rate = 60 * (5-j);
		else if (total_bandwidth > 650)
			rate = 50 * (5-j);
		else if (total_bandwidth > 540)
			rate = 40 * (5-j);
		else if (total_bandwidth > 300)
			rate = 30 * (5-j);
		else
			rate = 10 * (5-j);
		/*ql:20080821 END*/
		quantum = 1250 *(5-j);

		//if total bandwidth is too small, then reduce rate value
		/*ql:20080821 START: modify rate according to ceil*/
		//rate = (rate>=ceil)?(10*(5-j)):rate;
		if (rate > total_bandwidth)
		{
			rate = total_bandwidth * (5-j)/10;
		}
		/*ql:20080821 END*/
		//tc class add dev $DEV parent 10:1 classid 10:$SUBID htb rate $RATE ceil $RATE prio $PRIO
		DOCMDARGVS(TC, DOWAIT, "class add dev imq0 parent 1:1 classid 1:%d00 htb rate %dKbit ceil %uKbit prio 0 quantum %d",
			j, rate, total_bandwidth, quantum);
	}

	//set queue len
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:100 handle 100: pfifo limit 12");
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:200 handle 200: pfifo limit 9");
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:300 handle 300: pfifo limit 6");
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:400 handle 400: pfifo limit 3");
#else
	EntryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<EntryNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vcEntry)||!vcEntry.enable)
			continue;

		//get the interface name(?)
		ifGetName(vcEntry.ifIndex, ifname, sizeof(ifname));

		//tc qdisc add dev $DEV root handle 1: htb default 400
		DOCMDARGVS(TC,DOWAIT, "qdisc add dev %s root handle 1: htb default 400",ifname);

		//tc class add dev $DEV parent 1: classid 1:1 htb rate $RATE ceil $CEIL
		DOCMDARGVS(TC, DOWAIT, "class add dev %s parent 1: classid 1:1 htb rate %uKbit ceil %uKbit burst 15k",
			ifname, total_bandwidth, total_bandwidth);

		for(j=1; j<=4; j++)
		{
			/*ql:20080821 START: when line rate is low than 1Mbps, rate should be smaller...*/
			//rate = 700 * (5-j)/10;
			if (total_bandwidth > 950)
				rate = 70 * (5-j);
			else if (total_bandwidth > 790)
				rate = 60 * (5-j);
			else if (total_bandwidth > 650)
				rate = 50 * (5-j);
			else if (total_bandwidth > 540)
				rate = 40 * (5-j);
			else if (total_bandwidth > 300)
				rate = 30 * (5-j);
			else
				rate = 10 * (5-j);
			/*ql:20080821 END*/
			quantum = 1250 *(5-j);

			//if total bandwidth is too small, then reduce rate value
			/*ql:20080821 START: modify rate according to ceil*/
			//rate = (rate>=ceil)?(10*(5-j)):rate;
			if (rate > total_bandwidth)
			{
				rate = total_bandwidth * (5-j)/10;
			}
			/*ql:20080821 END*/
			//tc class add dev $DEV parent 10:1 classid 10:$SUBID htb rate $RATE ceil $RATE prio $PRIO
			DOCMDARGVS(TC, DOWAIT, "class add dev %s parent 1:1 classid 1:%d00 htb rate %dKbit ceil %uKbit prio 0 quantum %d",
				ifname, j, rate, total_bandwidth, quantum);
		}

		//set queue len
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:100 handle 100: pfifo limit 12", ifname);
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:200 handle 200: pfifo limit 9", ifname);
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:300 handle 300: pfifo limit 6", ifname);
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:400 handle 400: pfifo limit 3", ifname);
	}
#endif

	//now, setup queue rules for wrr qdisc
	setup_filter_rule(PLY_WRR);

    return 0;
}

/*******************************************************************************
 *NAME:    setup_prio_queue
 *DESC:    if configurating policy to priority queue,
 *         create priority queues based on struct MIB_CE_IP_QUEUE_CFG_T setting,
 *         The default number of queue is four,1-4.
 *ARGS:    None
 *RETURN:  0 success, others fail
 *******************************************************************************/
static int setup_prio_queue(void)
{
#if !defined(CONFIG_IMQ) && !defined(CONFIG_IMQ_MODULE)
	MIB_CE_ATM_VC_T vcEntry;
    int i, EntryNum;
	char ifname[IFNAMSIZ];
#endif
	DOCMDINIT;

    QOS_SETUP_PRINT_FUNCTION;

#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
	//setup basic config for imq0
	DOCMDARGVS(TC,DOWAIT, "qdisc add dev imq0 root handle 1: prio bands 4 priomap 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3");

	//set queue len
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:1 handle 100: pfifo limit 10");
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:2 handle 200: pfifo limit 10");
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:3 handle 300: pfifo limit 10");
	DOCMDARGVS(TC, DOWAIT, "qdisc add dev imq0 parent 1:4 handle 400: pfifo limit 10");
#else
	EntryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<EntryNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vcEntry) || !vcEntry.enable)
			continue;

		//get the interface name(?)
		ifGetName(vcEntry.ifIndex, ifname, sizeof(ifname));

		DOCMDARGVS(TC,DOWAIT, "qdisc add dev %s root handle 1: prio bands 4 priomap 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3",ifname);

		//set queue len
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:1 handle 100: pfifo limit 10", ifname);
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:2 handle 200: pfifo limit 10", ifname);
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:3 handle 300: pfifo limit 10", ifname);
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:4 handle 400: pfifo limit 10", ifname);
	}
#endif

	//setup ip qos queue rules for pq
	setup_filter_rule(PLY_PRIO);

	return 0;
}

/*******************************************************************************
 * NAME:    setup_traffic_control
 * DESC:    main function to complte trafice controlling,
 *          setup the basic setting by calling setup_traffic_basic,
 *          and for every configuration by calling setup_traffic_cfg(),
 *          the basic setting includes one root qdisc and root
 *          class, the setting looks like below:
 *                              HTB(root qdisc, handle 10:)
 *                               |
 *                              HTB(root class, classid 10:1)
 *            ___________________|_____________________
 *            |         |        |          |          |
 *           HTB       HTB      HTB        HTB        HTB
 *(subclass id 10:10 rate Xkbit)........       (sub class id 10:N0 rate Ykbit)
 *ARGS:    none
 *RETURN:  0 success, others fail
 *******************************************************************************/
static int setup_traffic_control(void)
{
	MIB_CE_IP_TC_T  entry;
	MIB_CE_ATM_VC_T vcEntry;
	int i, entry_num =0, vcEntryNum = 0;
	char ifname[IFNAMSIZ];
	unsigned char totalBandWidthEn = 0;
	unsigned int bandwidth;
	unsigned short rate, ceil;
	DOCMDINIT;

	QOS_SETUP_PRINT_FUNCTION;

	mib_get(MIB_TOTAL_BANDWIDTH_LIMIT_EN, (void *)&totalBandWidthEn);
	entry_num = mib_chain_total(MIB_IP_QOS_TC_TBL);

	if (!totalBandWidthEn && (0==entry_num))
		return 1;

	if (totalBandWidthEn)
		mib_get(MIB_TOTAL_BANDWIDTH, (void *)&bandwidth);
	else
		bandwidth = getUpLinkRate();

	vcEntryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0;i<vcEntryNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vcEntry)||!vcEntry.enable)
			continue;

		//patch: actual bandwidth maybe a little greater than configured limit value, so I minish 7% of the configured limit value ahead.
		if (totalBandWidthEn)
			ceil = bandwidth/100 * 93;
		else
			ceil = bandwidth;

		ifGetName(vcEntry.ifIndex, ifname, sizeof(ifname));

		//tc qdisc add dev $DEV root handle 1: htb default 2
		DOCMDARGVS(TC,DOWAIT, "qdisc add dev %s root handle 1: htb default 2 r2q 1", ifname);

		//tc class add dev $DEV parent 1: classid 1:1 htb rate $RATE ceil $CEIL
		DOCMDARGVS(TC, DOWAIT, "class add dev %s parent 1: classid 1:1 htb rate %dKbit ceil %dKbit mpu 64 overhead 4 burst 15k",
			ifname, ceil, ceil);

		//patch with above
		rate = (ceil>10)?10:ceil;

		//tc class add dev $DEV parent 1:1 classid 1:2 htb rate $RATE ceil $CEIL
		DOCMDARGVS(TC, DOWAIT, "class add dev %s parent 1:1 classid 1:2 htb rate %dKbit ceil %dKbit mpu 64 overhead 4",
			ifname, rate, ceil);

		//DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:2 handle 2: tbf rate %ukbit latency 50ms burst 1540 mpu 64",
		//	ifname, total_bandwidth);
		DOCMDARGVS(TC, DOWAIT, "qdisc add dev %s parent 1:2 handle 2: pfifo limit 10", ifname);
	}

	for(i=0; i<entry_num; i++)
	{
		if(!mib_chain_get(MIB_IP_QOS_TC_TBL, i, (void*)&entry))
			continue;

		if (setup_traffic_rule(&entry))
			return 1;
	}

	return 0;
}

static void setup_default_rule(void)
{
#if !defined(CONFIG_IMQ) && !defined(CONFIG_IMQ_MODULE)
	MIB_CE_ATM_VC_T vcEntry;
	int i, vcnum;
	char ifname[IFNAMSIZ];
#endif
	int k;
	unsigned char vChar, policy;
	DOCMDINIT;

	QOS_SETUP_PRINT_FUNCTION;

	mib_get(MIB_QOS_DOMAIN, (void *)&vChar);
	mib_get(MIB_QOS_POLICY, (void*)&policy);

#if !defined(CONFIG_IMQ) && !defined(CONFIG_IMQ_MODULE)
	vcnum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<vcnum; i++) {
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vcEntry)||!vcEntry.enable)
			continue;

		//get the interface name(?)
		ifGetName(vcEntry.ifIndex, ifname, sizeof(ifname));

		if (vChar == (char)PRIO_IP) {
#ifdef CONFIG_8021P_PRIO
			unsigned char value[IPQOS_NUM_PKT_PRIO];
			if(mib_get(MIB_PRED_PRIO, (void *)value)== 0)
			{
				printf("Get 8021P_PROI  error!\n");
				return 0;
			}
#endif
			for (k=0; k<=(IPQOS_NUM_PKT_PRIO-1); k++) {
				char pattern[]="0x00";
				int prio, flowid;

				prio = k<<1;
				if (prio<=9)
					pattern[2] += prio; // highest 3 bits
				else
					pattern[2] = 'a'+(prio-10);

#ifdef CONFIG_8021P_PRIO
				flowid = value[k]+1;
#else
				flowid = priomap[k];
#endif

				// match ip tos PATTERN MASK
				if(PLY_WRR == policy)//weighted round robin
				{
					DOCMDARGVS(TC, DOWAIT, "filter add dev %s parent 1: prio 2 protocol ip u32 match ip tos %s 0xe0 flowid 1:%d00",
						ifname, pattern, flowid);
				}
				else if (PLY_PRIO == policy)//priority queue
				{
					DOCMDARGVS(TC, DOWAIT, "filter add dev %s parent 1: prio 5 protocol ip u32 match ip tos %s 0xe0 flowid 1:%d",
						ifname, pattern, flowid);
				}
			}
		}
		else if(vChar == (char)PRIO_802_1p){ // PRIO_802_1p
#ifdef CONFIG_8021P_PRIO
			unsigned char value[IPQOS_NUM_PKT_PRIO];
			if(mib_get(MIB_8021P_PRIO, (void *)value)== 0)
			{
				printf("Get 8021P_PRIO  error!\n");
				return 0;
			}
#endif
			for (k=0; k<=(IPQOS_NUM_PKT_PRIO-1); k++) {
				int flowid;

#ifdef CONFIG_8021P_PRIO
				flowid = value[k]+1;
#else
				flowid = priomap[k];
#endif

				if(PLY_WRR == policy)//weighted round robin
				{
					DOCMDARGVS(TC, DOWAIT, "filter add dev %s parent 1: prio 2 protocol ip handle %d fw flowid 1:%d00",
						ifname, k+1, flowid);
				}
				else if (PLY_PRIO == policy)//priority queue
				{
					DOCMDARGVS(TC, DOWAIT, "filter add dev %s parent 1: prio 5 protocol ip handle %d fw flowid 1:%d",
						ifname, k+1, flowid);
				}
			}
		}
	}
#else
	if (vChar == (char)PRIO_IP) {
#ifdef CONFIG_8021P_PRIO
		unsigned char value[IPQOS_NUM_PKT_PRIO];
		if(mib_get(MIB_PRED_PRIO, (void *)value)== 0)
		{
			printf("Get 8021P_PROI  error!\n");
			return 0;
		}
#endif
		for (k=0; k<=(IPQOS_NUM_PKT_PRIO-1); k++) {
			char pattern[]="0x00";
			int prio, flowid;

			prio = k<<1;
			if (prio<=9)
				pattern[2] += prio; // highest 3 bits
			else
				pattern[2] = 'a'+(prio-10);

#ifdef CONFIG_8021P_PRIO
			flowid = value[k]+1;
#else
			flowid = priomap[k];
#endif
			// match ip tos PATTERN MASK
			if(PLY_WRR == policy)//weighted round robin
			{
				DOCMDARGVS(TC, DOWAIT, "filter add dev imq0 parent 1: prio 2 protocol ip u32 match ip tos %s 0xe0 flowid 1:%d00",
					pattern, flowid);
			}
			else if (PLY_PRIO == policy)//priority queue
			{
				DOCMDARGVS(TC, DOWAIT, "filter add dev imq0 parent 1: prio 5 protocol ip u32 match ip tos %s 0xe0 flowid 1:%d",
					pattern, flowid);
			}
		}
	}
	else if(vChar == (char)PRIO_802_1p){ // PRIO_802_1p
#ifdef CONFIG_8021P_PRIO
		unsigned char value[IPQOS_NUM_PKT_PRIO];
		if(mib_get(MIB_8021P_PRIO, (void *)value)== 0)
		{
			printf("Get 8021P_PRIO  error!\n");
			return 0;
		}
#endif
		for (k=0; k<=(IPQOS_NUM_PKT_PRIO-1); k++) {
			int flowid;

#ifdef CONFIG_8021P_PRIO
			flowid = value[k]+1;
#else
			flowid = priomap[k];
#endif

			if(PLY_WRR == policy)//weighted round robin
			{
				DOCMDARGVS(TC, DOWAIT, "filter add dev imq0 parent 1: prio 2 protocol ip handle %d fw flowid 1:%d00",
					k+1, flowid);
			}
			else if (PLY_PRIO == policy)//priority queue
			{
				DOCMDARGVS(TC, DOWAIT, "filter add dev imq0 parent 1: prio 5 protocol ip handle %d fw flowid 1:%d",
					k+1, flowid);
			}
		}
	}
#endif
}

int setup_qos_setting(void)
{
	unsigned char policy;
	unsigned char vChar, qosmode;

	__dev_setupIPQoS(1);

	mib_get(MIB_MPMODE, (void *)&vChar);
	if (vChar & MP_IPQ_MASK)//qos priority
	{
		qosmode = QOS_RULE;

		//enable IP QoS on IMQ
		va_cmd("/bin/sarctl", 2, 1, "qos_imq", "1");

		mib_get(MIB_QOS_POLICY, (void *)&policy);

		setupQoSChain(1);

		if (policy == PLY_PRIO) {//for PRIO
			setup_prio_queue();
		}
		else if (policy == PLY_WRR) {//for WFQ
			setup_wrr_queue();
		}
		setup_default_rule();

#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
		enableIMQ();
#endif
	}//traffic shaping
	else
	{
		qosmode = QOS_TC;

		//disable IMQ
		va_cmd("/bin/sarctl", 2, 1, "qos_imq", "0");

		setupQosTcChain(1);

		if (setup_traffic_control()) {
			qosmode = QOS_NONE;
			setupQosTcChain(0);
			cleanupQdiscRule();
		}
	}
	mib_set(MIB_QOS_MODE, (void *)&qosmode);

	return 0;
}


/******************************************************
* NAME: stop_IPQoS
* DESC: when IP QoS stopped, traffic control will be effective.
******************************************************/
void stop_IPQoS(void)
{
	unsigned char mode=0;

	mib_get(MIB_MPMODE, (void *)&mode);
	mode &= ~MP_IPQ_MASK;
	mib_set(MIB_MPMODE, (void *)&mode);

	take_qos_effect();
}

#endif
/*ql: 20081114 END*/

#if defined(CONFIG_USER_PPTP_CLIENT_PPTP) || defined(CONFIG_USER_L2TPD_L2TPD)
/*
 *	generate the ifup_ppp(vpc)x script for WAN interface
 */
static int generate_ifup_script_vpn(unsigned int ifIndex)
{
	int ret;
	FILE *fp;
	char wanif[8], ifup_path[32];

	ret = 0;

	ifGetName(ifIndex, wanif, sizeof(wanif));

	if (PPP_INDEX(ifIndex) != DUMMY_PPP_INDEX) {
		// PPP interface

		snprintf(ifup_path, 32, "/var/ppp/ifup_%s", wanif);
		if (fp=fopen(ifup_path, "w+") ) {
			fprintf(fp, "#!/bin/sh\n\n");

			fclose(fp);
			chmod(ifup_path, 484);
		}
#ifdef CONFIG_IPV6_VPN
		snprintf(ifup_path, 32, "/var/ppp/ifupv6_%s", wanif);
		if (fp=fopen(ifup_path, "w+") ) {
			fprintf(fp, "#!/bin/sh\n\n");

			fclose(fp);
			chmod(ifup_path, 484);
		}
#endif
	}
	else {
		// not supported till now
		return -1;
	}

	return ret;
}

/*
 *	generate the ifdown_ppp(vpn)x script for WAN interface
 */
static int generate_ifdown_script_vpn(unsigned int ifIndex)
{
	int ret;
	FILE *fp;
	char wanif[6], ifdown_path[32];
	char devname[IFNAMSIZ];

	ret = 0;

	if (PPP_INDEX(ifIndex) != DUMMY_PPP_INDEX) {
		// PPP interface
		snprintf(wanif, 6, "ppp%u", PPP_INDEX(ifIndex));
		snprintf(ifdown_path, 32, "/var/ppp/ifdown_%s", wanif);
		if (fp=fopen(ifdown_path, "w+") ) {
			fprintf(fp, "#!/bin/sh\n\n");
			fclose(fp);
			chmod(ifdown_path, 484);
		}
#ifdef CONFIG_IPV6_VPN
		snprintf(ifdown_path, 32, "/var/ppp/ifdownv6_%s", wanif);
		if (fp=fopen(ifdown_path, "w+") ) {
			fprintf(fp, "#!/bin/sh\n\n");
			fclose(fp);
			chmod(ifdown_path, 484);
		}
#endif
	}
	else {
		// not supported till now
		return -1;
	}

	return ret;
}

/*
 *	remove the ifup_ppp(vpc)x script for WAN interface
 */
static int remove_ifup_script_vpn(unsigned int ifIndex)
{
	int ret;
	FILE *fp;
	char wanif[8], ifup_path[32];

	ret = 0;

	ifGetName(ifIndex, wanif, sizeof(wanif));

	if (PPP_INDEX(ifIndex) != DUMMY_PPP_INDEX) {
		// PPP interface

		snprintf(ifup_path, 32, "/var/ppp/ifup_%s", wanif);
		unlink(ifup_path);
#ifdef CONFIG_IPV6_VPN
		snprintf(ifup_path, 32, "/var/ppp/ifupv6_%s", wanif);
		unlink(ifup_path);
#endif
	}
	else {
		// not supported till now
		return -1;
	}

	return ret;
}

/*
 *	remove the ifdown_ppp(vpn)x script for WAN interface
 */
static int remove_ifdown_script_vpn(unsigned int ifIndex)
{
	int ret;
	FILE *fp;
	char wanif[6], ifdown_path[32];
	char devname[IFNAMSIZ];

	ret = 0;

	if (PPP_INDEX(ifIndex) != DUMMY_PPP_INDEX) {
		// PPP interface
		snprintf(wanif, 6, "ppp%u", PPP_INDEX(ifIndex));
		snprintf(ifdown_path, 32, "/var/ppp/ifdown_%s", wanif);
		unlink(ifdown_path);
#ifdef CONFIG_IPV6_VPN
		snprintf(ifdown_path, 32, "/var/ppp/ifdownv6_%s", wanif);
		unlink(ifdown_path);
#endif
	}
	else {
		// not supported till now
		return -1;
	}

	return ret;
}

int NF_Init_VPN_Policy_Route(unsigned char *tunnelName)
{
	unsigned char fw_mark[16], chain_name[MAX_NAME_LEN];;


	if(!tunnelName) {
		AUG_PRT("Null pointer !\n");
		return -1;
	}

	if(tunnelName[0] == '\0') {
		AUG_PRT("Null string !\n");
		return -1;
	}

	snprintf(chain_name, sizeof(chain_name), "%s", tunnelName);
	va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-N", (char *)chain_name);
	va_cmd(IPTABLES, 8, 1, "-t", "mangle", "-A", (char *)FW_PREROUTING, "-i", "br0", "-j", (char *)chain_name);
	snprintf(chain_name, sizeof(chain_name), "%s-url", tunnelName);
	va_cmd(IPTABLES, 4, 1, "-t", "mangle", "-N", (char *)chain_name);
	va_cmd(IPTABLES, 8, 1, "-t", "mangle", "-A", (char *)FW_PREROUTING, "-i", "br0", "-j", (char *)chain_name);
}

int VPN_Route_Policy_Get_Mark(char *mark, char *tunnelName)
{
	unsigned int EntryNum, i;
	MIB_PPTP_T pptp_entry;
	MIB_L2TP_T l2tp_entry;


	if(!mark || !tunnelName) {
		AUG_PRT("Null pointer !\n");
		return -1;
	}

	if(tunnelName[0] == '\0') {
		AUG_PRT("Null string !\n");
		return -1;
	}

	EntryNum = mib_chain_total(MIB_PPTP_TBL);
	for (i=0; i<EntryNum; i++)
	{
		if ( !mib_chain_get(MIB_PPTP_TBL, i, (void *)&pptp_entry) )
				continue;

		if(!strcmp(pptp_entry.tunnelName, tunnelName)) {
			sprintf(mark, VPN_ROUTE_POLICY_MARK[pptp_entry.idx]);
			return 0;
		}
	}

	EntryNum = mib_chain_total(MIB_L2TP_TBL);
	for (i=0; i<EntryNum; i++)
	{
		if ( !mib_chain_get(MIB_L2TP_TBL, i, (void *)&l2tp_entry) )
				continue;

		if(!strcmp(l2tp_entry.tunnelName, tunnelName)) {
			sprintf(mark, VPN_ROUTE_POLICY_MARK[l2tp_entry.idx+2]);
			return 0;
		}
	}

	AUG_PRT("Not VPN tunnel name(tunnelName=%s)\n", tunnelName);
	return -1;
}

int vpn_tunnel_name_to_table(unsigned char *tunnelName)
{
	unsigned int EntryNum, i;
	MIB_PPTP_T pptp_entry;
	MIB_L2TP_T l2tp_entry;
	int table_idx;


	if(!tunnelName) {
		AUG_PRT("Null pointer !\n");
		return -1;
	}

	if(tunnelName[0] == '\0') {
		AUG_PRT("Null string !\n");
		return -1;
	}

	EntryNum = mib_chain_total(MIB_PPTP_TBL);
	for (i=0; i<EntryNum; i++)
	{
		if ( !mib_chain_get(MIB_PPTP_TBL, i, (void *)&pptp_entry) )
				continue;

		if(!strcmp(pptp_entry.tunnelName, tunnelName))
			return 101 + pptp_entry.idx;
	}

	EntryNum = mib_chain_total(MIB_L2TP_TBL);
	for (i=0; i<EntryNum; i++)
	{
		if ( !mib_chain_get(MIB_L2TP_TBL, i, (void *)&l2tp_entry) )
				continue;

		if(!strcmp(l2tp_entry.tunnelName, tunnelName))
			return 103 + l2tp_entry.idx;
	}

	AUG_PRT("Not VPN tunnel name(tunnelName=%s)\n", tunnelName);
	return -1;
}
#endif

#ifdef CONFIG_XFRM
struct IPSEC_PROP_ST ikeProps[] = {
	{"------------------------", 0x00000000},
	{"des-md5-group1", 0x01010001},//dhGroup|Encryption|ahAuth|Auth
	{"des-sha1-group1", 0x01010002},
	{"3des-md5-group2", 0x02020001},
	{"3des-sha1-group2", 0x02020002}
};

struct IPSEC_PROP_ST saProps[] = {
	{"------------------------", 0x00000000},
	{"esp-des-md5", 0x01010001},
	{"esp-des-sha1", 0x01010002},
	{"esp-3des-md5", 0x02020001},
	{"esp-3des-sha1", 0x02020002}
};

static char *encryptArraySetkey[] = {
	"null",
	"des-cbc",
	"3des-cbc",
	"aes-cbc",
	"simple-cbc",
	"blowfish-cbc",
	"cast128-cbc",
	"twofish-cbc"
};

static char *authArraySetkey[] = {
	"null",
	"hmac-md5",
	"hmac-sha1",
	"keyed-md5",
	"keyed-sha1",
	"hmac-sha2-256",
	"hmac-sha256",
	"tcp-md5"
};

static char *encryptArrayRacoon[] = {
	"",
	"des",
	"3des",
	"blowfish",
	"twofish"
};

static char *authArrayRacoon[] = {
	"",
	"md5",
	"sha1",
	"hmac_md5",
	"hmac_sha1",
	"hmac_sha2-256",
	"hmac_sha256"
};

static char *dhArray[] = {
	"",
	"modp768",
	"modp1024",
	"modp1536"
};

/*
return
	0: failed
	1: succeed
*/
static int applyIPsec(MIB_IPSEC_T *pEntry)
{
	char *strVal;
	int intVal;
	char local[20], remote[20], homeAddr[20], gwAddr[20];
	char *saProtocol[2]={"esp", "ah"};
	char *transportMode[2]={"tunnel", "transport"};
	char *ikeMode[2]={"main", "aggressive"};
	char *filterProtocol[4]={"any", "tcp", "udp", "icmp"};
	struct in_addr ipAddr;
	char filterPort[10];
	FILE *fpPSK, *fpSetKey, *fpRacoon;
	/*
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	*/
	if ((fpSetKey = fopen(SETKEY_CONF, "a"))== NULL){
		printf("ERROR: open file %s error!\n", PSK_FILE);
		return 0;
	}

	strVal = inet_ntoa(*(struct in_addr*)pEntry->remoteIP);
	strncpy(remote, strVal, 20);

	strVal = inet_ntoa(*(struct in_addr*)pEntry->localIP);
	strncpy(local, strVal, 20);

	strVal = inet_ntoa(*(struct in_addr*)pEntry->remoteTunnel);
	strncpy(gwAddr, strVal, 20);

	strVal = inet_ntoa(*(struct in_addr*)pEntry->localTunnel);
	strncpy(homeAddr, strVal, 20);

	/*
	if (getInAddr(pEntry->localWAN, IP_ADDR, (void *)&ipAddr) == 1){
		strVal = inet_ntoa(ipAddr);
		snprintf(homeAddr, 20, "%s", strVal);
	}else{
		printf("ERROR: can't get address of %s!\n", pEntry->localWAN);
		return 0;
	}

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0; i<entryNum; i++){
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)){
			return -1;
		}
		getDisplayWanName((void *)&Entry, Entry.WanName);
		if(!strncmp(Entry.WanName, pEntry->localWAN, sizeof(pEntry->localWAN)))
			break;
	}

	if(i >= entryNum)
		return -1;
	*/
	if(pEntry->filterPort != 0)
		snprintf(filterPort, 10, "%d", pEntry->filterPort);
	else
		snprintf(filterPort, 10, "%s", "any");

	if(pEntry->negotiationType == 1){
		//manual mode
		if((pEntry->encapMode&0x1) != 0x0){
			fprintf(fpSetKey, "add %s %s esp 0x%x -m %s ", local,remote,
				pEntry->espOUTSPI, transportMode[pEntry->transportMode]);

			if(pEntry->espEncrypt != 0)
				fprintf(fpSetKey, "-E %s 0x%s ", encryptArraySetkey[pEntry->espEncrypt], pEntry->espEncryptKey);
			if(pEntry->espAuth != 0)
				fprintf(fpSetKey, "-A %s 0x%s ", authArraySetkey[pEntry->espAuth], pEntry->espAuthKey);

			fprintf(fpSetKey, ";\n\n");

			fprintf(fpSetKey, "add %s %s esp 0x%x -m %s ", remote,local,
				pEntry->espINSPI, transportMode[pEntry->transportMode]);

			if(pEntry->espEncrypt != 0)
				fprintf(fpSetKey, "-E %s 0x%s ", encryptArraySetkey[pEntry->espEncrypt], pEntry->espEncryptKey);
			if(pEntry->espAuth != 0)
				fprintf(fpSetKey, "-A %s 0x%s ", authArraySetkey[pEntry->espAuth], pEntry->espAuthKey);

			fprintf(fpSetKey, ";\n\n");
		}

		if((pEntry->encapMode&0x2) != 0x0){
			fprintf(fpSetKey, "add %s %s ah 0x%x -m %s -A %s 0x%s ;\n\n", local, remote,
				pEntry->ahOUTSPI, transportMode[pEntry->transportMode], authArraySetkey[pEntry->ahAuth], pEntry->ahAuthKey);

			fprintf(fpSetKey, "add %s %s ah 0x%x -m %s -A %s 0x%s ;\n\n", remote, local,
				pEntry->ahINSPI, transportMode[pEntry->transportMode], authArraySetkey[pEntry->ahAuth], pEntry->ahAuthKey);

		}
	}

	//direction: in
	fprintf(fpSetKey, "spdadd %s/%d[%s] %s/%d[%s] %s -P in ipsec", remote, pEntry->remoteMask, filterPort,
		local, pEntry->localMask, filterPort, filterProtocol[pEntry->filterProtocol]);

	if(pEntry->transportMode == 0){
		if((pEntry->encapMode&0x1) != 0x0)
			fprintf(fpSetKey, " esp/tunnel/%s-%s/use", gwAddr, homeAddr);
		if((pEntry->encapMode&0x2) != 0x0)
			fprintf(fpSetKey, " ah/tunnel/%s-%s/use", gwAddr, homeAddr);
	}else{
		if((pEntry->encapMode&0x1) != 0x0)
			fprintf(fpSetKey, " esp/transport//use");
		if((pEntry->encapMode&0x2) != 0x0)
			fprintf(fpSetKey, " ah/transport//use");
	}

	fprintf(fpSetKey, ";\n\n");

	//direction: out
	fprintf(fpSetKey, "spdadd %s/%d[%s] %s/%d[%s] %s -P out ipsec", local, pEntry->localMask, filterPort,
		remote, pEntry->remoteMask, filterPort, filterProtocol[pEntry->filterProtocol]);

	if(pEntry->transportMode == 0){
		if((pEntry->encapMode&0x1) != 0x0)
			fprintf(fpSetKey, " esp/tunnel/%s-%s/require", homeAddr, gwAddr);
		if((pEntry->encapMode&0x2) != 0x0)
			fprintf(fpSetKey, " ah/tunnel/%s-%s/require", homeAddr, gwAddr);
	}else{
		if((pEntry->encapMode&0x1) != 0x0)
			fprintf(fpSetKey, " esp/transport//require");
		if((pEntry->encapMode&0x2) != 0x0)
			fprintf(fpSetKey, " ah/transport//require");
	}

	fprintf(fpSetKey, ";\n\n");
	fclose(fpSetKey);

	if(pEntry->negotiationType == 0){
		//ike mode
		if ((fpPSK = fopen(PSK_FILE, "a"))== NULL){
			printf("ERROR: open file %s error!\n", PSK_FILE);
			return 0;
		}
		if(access(RACOON_CONF, 0)!=0){
			if ((fpRacoon = fopen(RACOON_CONF, "a"))== NULL){
				printf("ERROR: open file %s error!\n", RACOON_CONF);
				return 0;
			}
			fprintf(fpRacoon, "path pre_shared_key \"%s\" ;\n", PSK_FILE);
		}else{
			if ((fpRacoon = fopen(RACOON_CONF, "a"))== NULL){
				printf("ERROR: open file %s error!\n", RACOON_CONF);
				return 0;
			}
		}

		fprintf(fpPSK, "%s %s\n", inet_ntoa(*(struct in_addr*)pEntry->remoteIP), pEntry->psk);
		fclose(fpPSK);

		fprintf(fpRacoon, "remote %s {\n", remote);
		fprintf(fpRacoon, "\texchange_mode %s ;\n", ikeMode[pEntry->ikeMode]);
		fprintf(fpRacoon, "\tlifetime time %d second ;\n", pEntry->ikeAliveTime);
		for(intVal = 0; intVal<4; intVal++){
			if(pEntry->ikeProposal[intVal]==0)
				continue;
			fprintf(fpRacoon, "\tproposal {\n");
			fprintf(fpRacoon, "\t\tencryption_algorithm %s ;\n", encryptArrayRacoon[ENCRYPT_INDEX(ikeProps[pEntry->ikeProposal[intVal]].algorithm)]);
			fprintf(fpRacoon, "\t\thash_algorithm %s ;\n", authArrayRacoon[AUTH_INDEX(ikeProps[pEntry->ikeProposal[intVal]].algorithm)]);
			fprintf(fpRacoon, "\t\tauthentication_method pre_shared_key ;\n");
			fprintf(fpRacoon, "\t\tdh_group %d ;\n", DHGROUP_INDEX(ikeProps[pEntry->ikeProposal[intVal]].algorithm));
			fprintf(fpRacoon, "\t}\n\n");
		}
		fprintf(fpRacoon, "}\n\n");

		for(intVal = 0; intVal<4; intVal++){
			if(pEntry->saProposal[intVal]==0)
				continue;
			fprintf(fpRacoon, "sainfo address %s/%d[%s] %s address %s/%d[%s] %s{\n", pEntry->transportMode==0?homeAddr:local, pEntry->localMask, filterPort,
					filterProtocol[pEntry->filterProtocol], pEntry->transportMode==0?gwAddr:remote, pEntry->localMask, filterPort, filterProtocol[pEntry->filterProtocol]);
			fprintf(fpRacoon, "\tpfs_group %s ;\n", dhArray[DHGROUP_INDEX(ikeProps[pEntry->ikeProposal[intVal]].algorithm)]);
			fprintf(fpRacoon, "\tlifetime time %d second ;\n", pEntry->saAliveTime);
			fprintf(fpRacoon, "\tencryption_algorithm %s ;\n", encryptArrayRacoon[ENCRYPT_INDEX(ikeProps[pEntry->ikeProposal[intVal]].algorithm)]);
			fprintf(fpRacoon, "\tauthentication_algorithm %s ;\n", authArrayRacoon[AUTH_INDEX(ikeProps[pEntry->ikeProposal[intVal]].algorithm)+2]);
			fprintf(fpRacoon, "\tcompression_algorithm deflate ;\n");
			fprintf(fpRacoon, "}\n\n");
		}
		fclose(fpRacoon);

	}
	return 1;
}

void ipsec_take_effect(void)
{

	int entryNum, i, newState;
	MIB_IPSEC_T Entry;
	char gwAddr[20];
	FILE *fp;
	char pid[10];

	va_cmd("/bin/setkey", 1, 1, "-F");
	va_cmd("/bin/setkey", 1, 1, "-FP");

	if(access(RACOON_PID, 0)==0){
		if ((fp = fopen(RACOON_PID, "r"))== NULL){
			printf("ERROR: open file %s error!\n", RACOON_PID);
			return;
		}
		fscanf(fp, "%d\n", &i);
		snprintf(pid, 10, "%d", i);
		va_cmd("/bin/kill", 1, 1,  pid);
		va_cmd("/bin/rm", 1, 1,  RACOON_PID);
	}

	if(access(PSK_FILE, 0)==0){
		if(remove(PSK_FILE))
			printf("Could not delete the file &s \n", PSK_FILE);
	}

	entryNum = mib_chain_total(MIB_IPSEC_TBL);
	for(i = 0; i<entryNum; i++){
		mib_chain_get(MIB_IPSEC_TBL, i, (void *)&Entry);

		if(Entry.enable ==1){
			newState = applyIPsec(&Entry);
			if(newState != Entry.state){
				Entry.state = newState;
				mib_chain_update(MIB_IPSEC_TBL, &Entry, i);
			}
		}
	}

	if(access(PSK_FILE, 0)==0)
		va_cmd("/bin/chmod", 2, 1, "600", PSK_FILE);

	if(access(SETKEY_CONF, 0)==0){
		va_cmd("/bin/setkey", 2, 1, "-f", SETKEY_CONF);
		if(remove(SETKEY_CONF))
			printf("Could not delete the file &s \n", SETKEY_CONF);
	}

	if(access(RACOON_CONF, 0)==0){
		va_cmd("/bin/racoon", 2, 1, "-f", RACOON_CONF);
		if(remove(RACOON_CONF))
			printf("Could not delete the file &s \n", RACOON_CONF);
	}

	return;
}
#endif

#if defined(CONFIG_USER_PPTP_CLIENT_PPTP) && defined(CONFIG_USER_L2TPD_L2TPD)
extern void *VPNConnectionThread(void *arg);
VPN_STATUS_T WanVPNConnectStart
(
	gdbus_vpn_connection_info_t *vpn_connection_info,
	ATTACH_MODE_T attach_mode,
	unsigned char *reason
)
{
	pthread_t ntid = 0;
	int err = 0;

	err = pthread_create(&ntid, NULL, VPNConnectionThread, vpn_connection_info);
	if (err != 0) {
		printf("can't create thread: %s\n", strerror(err));
		sleep(1);
		return 0;
	}
	pthread_detach(ntid);
	return 0;
}

VPN_STATUS_T WanVPNConnection( gdbus_vpn_connection_info_t *vpn_connection_info, unsigned char *reason )
{
	unsigned char vpn_type = VPN_TYPE_NONE;
	unsigned char attach_mode = ATTACH_MODE_NONE;
	unsigned int vpn_port=0;
	int i;
	int status=0;
	int ret=0;


	if(vpn_connection_info==NULL || reason==NULL) {
		strcpy(reason, "some parameter(s) exist NULL pointer!");
		ret=-1;
	}

	WanVPNConnectStart(vpn_connection_info,
					attach_mode,
					reason);

	return ret;
}

void WanVPNConnectionStat( gdbus_vpn_connection_info_t *vpn_connection_info, unsigned char *status[] )
{
	int i, status_idx=0;
	unsigned char *ipDomainNameAddr[20] = {0};
	unsigned char *reason;


	if( vpn_connection_info==NULL ) {
		strcpy(reason, "some parameter(s) exist NULL pointer!");
		goto GetVPNConnectionStatDone;
	}

	//vpn_connection_info->attach_mode = ATTACH_MODE_DIP;
	if(get_attach_pattern_by_mode(vpn_connection_info, ipDomainNameAddr, reason))
		goto GetVPNConnectionStatDone;

	i=0;
	while(ipDomainNameAddr[i] != NULL)
	{
		unsigned char *ipaddr1,*ipaddr2,*netmask;
		unsigned char sMac[MAC_ADDR_LEN];
		unsigned int mask_inver;
		unsigned char ip[100], temp_ip[100];
		unsigned int mask;
		int ipv4_addr1,ipv4_addr2;
		unsigned char temp_status[128];
		unsigned int packet_count;
		int pptp_route_idx;
		int l2tp_route_idx;
		char *p;
		int c;


		AUG_PRT("%s-%d i=%d\n",__func__,__LINE__,i);
		strcpy(ip,ipDomainNameAddr[i]);
		sprintf(vpn_connection_info->vpn_tunnel_info.tunnelName, MAGIC_TUNNEL_NAME);
		if (strstr(ip,":")){

			sscanf(ip, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &sMac[0], &sMac[1], &sMac[2], &sMac[3], &sMac[4], &sMac[5]);

			pptp_route_idx=Check_PPTP_Route_SMAC(vpn_connection_info->vpn_tunnel_info.tunnelName,sMac);
			l2tp_route_idx=Check_L2TP_Route_SMAC(vpn_connection_info->vpn_tunnel_info.tunnelName,sMac);

			if(pptp_route_idx>=0)
			{
				packet_count = Get_Packet_Count_By_Route_Index(VPN_TYPE_PPTP, pptp_route_idx);
				memset(temp_status, 0, sizeof(temp_status));
				snprintf(temp_status, sizeof(temp_status), "%X%X%X%X%X%X@%d", sMac[0], sMac[1], sMac[2], sMac[3], sMac[4], sMac[5], packet_count);
				status[status_idx] = malloc(strlen(temp_status)+1);
				snprintf(status[status_idx], strlen(temp_status)+1, "%X%X%X%X%X%X@%d", sMac[0], sMac[1], sMac[2], sMac[3], sMac[4], sMac[5], packet_count);
				status_idx++;
			}
			else
			{
				AUG_PRT("sMAC=%s not founded in PPTP! \n",ip);
			}

			if(l2tp_route_idx>=0)
			{
				packet_count = Get_Packet_Count_By_Route_Index(VPN_TYPE_L2TP, l2tp_route_idx);
				memset(temp_status, 0, sizeof(temp_status));
				snprintf(temp_status, sizeof(temp_status), "%X%X%X%X%X%X@%d", sMac[0], sMac[1], sMac[2], sMac[3], sMac[4], sMac[5], packet_count);
				status[status_idx] = malloc(strlen(temp_status)+1);
				snprintf(status[status_idx], strlen(temp_status)+1, "%X%X%X%X%X%X@%d", sMac[0], sMac[1], sMac[2], sMac[3], sMac[4], sMac[5], packet_count);
				status_idx++;
			}
			else
			{
				AUG_PRT("sMAC=%s not founded in L2TP! \n",ip);
			}
		}
		else if(isIPAddr(ip) || strstr(ip,"/") || strstr(ip,"-"))
		{
			if(isIPAddr(ip)) {
				/*ip = 192.168.1.1*/
				ipaddr1 = ip;
				ipv4_addr1 = inet_addr(ipaddr1);
				if(ipv4_addr1==-1){
					printf("%s-%d set ip start error!\n",__func__,__LINE__);
					i++;
					continue;
				}
				ipv4_addr2 = ipv4_addr1;
			} else if(strstr(ip,"/")) {
				/*ip = 192.168.1.0/24*/
				snprintf(temp_ip, 100, "%s", ip);
				ipaddr1 = strtok(temp_ip,"/");
				//printf("ipaddr1=%s\n",ipaddr1);
				ipv4_addr1 = inet_addr(ipaddr1);
				if(ipv4_addr1==-1){
					printf("%s-%d set ip start error!\n",__func__,__LINE__);
					i++;
					continue;
				}
				netmask = strtok(NULL,"/");
				//printf("netmask=%s\n",netmask);
				c=atoi(netmask);
				mask_inver = 32 - c;
				mask = ~((1<<mask_inver)-1);
				ipv4_addr1 &= mask;
				ipv4_addr2 = (ipv4_addr1 | ~mask);
				if(ipv4_addr2==-1){
					printf("%s-%d set ip end error!\n",__func__,__LINE__);
					i++;
					continue;
				}
			} else {
				/*ip = 192.168.1.0-192.168.1.100*/
				snprintf(temp_ip, 100, "%s", ip);
				ipaddr1 = strtok(temp_ip,"-");
				ipv4_addr1 = inet_addr(ipaddr1);
				if(ipv4_addr1==-1){
					printf("%s-%d set ip start error!\n",__func__,__LINE__);
					i++;
					continue;
				}
				ipaddr2 = strtok(NULL,"-");
				ipv4_addr2 = inet_addr(ipaddr2);
				if(ipv4_addr2==-1){
					printf("%s-%d set ip end error!\n",__func__,__LINE__);
					i++;
					continue;
				}
			}

			pptp_route_idx=Check_PPTP_Route_DIP(vpn_connection_info->vpn_tunnel_info.tunnelName,ipv4_addr1,ipv4_addr2);
			l2tp_route_idx=Check_L2TP_Route_DIP(vpn_connection_info->vpn_tunnel_info.tunnelName,ipv4_addr1,ipv4_addr2);
			if(pptp_route_idx>=0)
			{
				packet_count = Get_Packet_Count_By_Route_Index(VPN_TYPE_PPTP, pptp_route_idx);
				memset(temp_status, 0, sizeof(temp_status));
				snprintf(temp_status, sizeof(temp_status), "%s@%d", ip, packet_count);
				status[status_idx] = malloc(strlen(temp_status)+1);
				snprintf(status[status_idx], strlen(temp_status)+1, "%s@%d", ip, packet_count);
				status_idx++;
			}
			else
			{
				AUG_PRT("ipv4_addr1=%x, ipv4_addr2=%x not founded in PPTP! \n",ipv4_addr1,ipv4_addr2);
			}

			if(l2tp_route_idx>=0)
			{
				packet_count = Get_Packet_Count_By_Route_Index(VPN_TYPE_L2TP, l2tp_route_idx);
				memset(temp_status, 0, sizeof(temp_status));
				snprintf(temp_status, sizeof(temp_status), "%s@%d", ip, packet_count);
				status[status_idx] = malloc(strlen(temp_status)+1);
				snprintf(status[status_idx], strlen(temp_status)+1, "%s@%d", ip, packet_count);
				status_idx++;
			}
			else
			{
				AUG_PRT("ipv4_addr1=%x, ipv4_addr2=%x not founded in L2TP! \n",ipv4_addr1,ipv4_addr2);
			}
		}
		else
		{
			pptp_route_idx=Check_PPTP_Route_URL(vpn_connection_info->vpn_tunnel_info.tunnelName,ip);
			l2tp_route_idx=Check_L2TP_Route_URL(vpn_connection_info->vpn_tunnel_info.tunnelName,ip);
			if(pptp_route_idx>=0)
			{
				packet_count = Get_Packet_Count_By_Route_Index(VPN_TYPE_PPTP, pptp_route_idx);
				memset(temp_status, 0, sizeof(temp_status));
				snprintf(temp_status, sizeof(temp_status), "%s@%d", ip, packet_count);
				status[status_idx] = malloc(strlen(temp_status)+1);
				snprintf(status[status_idx], strlen(temp_status)+1, "%s@%d", ip, packet_count);
				status_idx++;
			}
			else
			{
				AUG_PRT("domain=%s not founded in PPTP! \n", ip);
			}

			if(l2tp_route_idx>=0)
			{
				packet_count = Get_Packet_Count_By_Route_Index(VPN_TYPE_L2TP, l2tp_route_idx);
				memset(temp_status, 0, sizeof(temp_status));
				snprintf(temp_status, sizeof(temp_status), "%s@%d", ip, packet_count);
				status[status_idx] = malloc(strlen(temp_status)+1);
				snprintf(status[status_idx], strlen(temp_status)+1, "%s@%d", ip, packet_count);
				status_idx++;
			}
			else
			{
				AUG_PRT("domain=%s not founded in L2TP! \n", ip);
			}
		}

		i++;
	}

GetVPNConnectionStatDone:
	return;
}

int renew_vpn_accpw_from_accpxy (VPN_TYPE_T vpn_type, unsigned char *sppp_if_name, unsigned char *new_username, unsigned char *new_password)
{
	gdbus_vpn_tunnel_info_t vpn_tunnel_info;
	unsigned char reason[128];
	unsigned int EntryNum, i;
	unsigned char if_name[IFNAMSIZ];
	MIB_PPTP_T pptp_entry;
	MIB_L2TP_T l2tp_entry;


	if(vpn_type==VPN_TYPE_PPTP) {
		EntryNum = mib_chain_total(MIB_PPTP_TBL);
		for (i=0; i<EntryNum; i++)
		{
			if ( !mib_chain_get(MIB_PPTP_TBL, i, (void *)&pptp_entry) )
				continue;

			snprintf(if_name, sizeof(if_name), "ppp%d", 9+pptp_entry.idx);
			if( !strcmp(sppp_if_name, if_name) ) {
				if(pptp_entry.vpn_mode == VPN_MODE_RANDOM) {
					printf("%s: before: username=%s password=%s\n", if_name, pptp_entry.username, pptp_entry.password);
					snprintf(vpn_tunnel_info.account_proxy, sizeof(vpn_tunnel_info.account_proxy), "%s", pptp_entry.account_proxy);
					snprintf(vpn_tunnel_info.userID, sizeof(vpn_tunnel_info.userID), "%s", pptp_entry.userID);
					snprintf(vpn_tunnel_info.tunnelName, sizeof(vpn_tunnel_info.tunnelName), "%s", pptp_entry.tunnelName);
					if( request_vpn_accpxy_server(&vpn_tunnel_info, reason)!=-1 ) {
						if ( mib_chain_get(MIB_PPTP_TBL, i, (void *)&pptp_entry) ) {
							sprintf(pptp_entry.username, "%s", vpn_tunnel_info.userName);
							sprintf(pptp_entry.password, "%s", vpn_tunnel_info.passwd);
							mib_chain_update(MIB_PPTP_TBL, &pptp_entry, i);
							printf("%s: after: username=%s password=%s\n", if_name, pptp_entry.username, pptp_entry.password);
							sprintf(new_username, "%s", vpn_tunnel_info.userName);
							sprintf(new_password, "%s", vpn_tunnel_info.passwd);
						} else {
							printf("%s: after: get MIB fail !\n", if_name);
						}
					}
				}
			}
		}
	} else if(vpn_type==VPN_TYPE_L2TP) {
		EntryNum = mib_chain_total(MIB_L2TP_TBL);
		for (i=0; i<EntryNum; i++)
		{
			if ( !mib_chain_get(MIB_L2TP_TBL, i, (void *)&l2tp_entry) )
				continue;

			snprintf(if_name, sizeof(if_name), "ppp%d", 11+l2tp_entry.idx);
			if( !strcmp(sppp_if_name, if_name) ) {
				if(l2tp_entry.vpn_mode == VPN_MODE_RANDOM) {
					printf("%s: before: username=%s password=%s\n", if_name, l2tp_entry.username, l2tp_entry.password);
					snprintf(vpn_tunnel_info.account_proxy, sizeof(vpn_tunnel_info.account_proxy), "%s", l2tp_entry.account_proxy);
					snprintf(vpn_tunnel_info.userID, sizeof(vpn_tunnel_info.userID), "%s", l2tp_entry.userID);
					snprintf(vpn_tunnel_info.tunnelName, sizeof(vpn_tunnel_info.tunnelName), "%s", l2tp_entry.tunnelName);
					if( request_vpn_accpxy_server(&vpn_tunnel_info, reason)!=-1 ) {
						if ( mib_chain_get(MIB_L2TP_TBL, i, (void *)&l2tp_entry) ) {
							sprintf(l2tp_entry.username, "%s", vpn_tunnel_info.userName);
							sprintf(l2tp_entry.password, "%s", vpn_tunnel_info.passwd);
							mib_chain_update(MIB_L2TP_TBL, &l2tp_entry, i);
							printf("%s: after: username=%s password=%s\n", if_name, l2tp_entry.username, l2tp_entry.password);
							sprintf(new_username, "%s", vpn_tunnel_info.userName);
							sprintf(new_password, "%s", vpn_tunnel_info.passwd);
						} else {
							printf("%s: after: get MIB fail !\n", if_name);
						}
					}
				}
			}
		}
	}
}

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
void domain_to_regular_expression_cmcc(unsigned char *domain_name, unsigned char *regular_expression)
{
	int i=0;
	unsigned char *ptr;
	unsigned char tmp_domain_name[128];
	if(domain_name == NULL){
		return;
	}

	if(domain_name[0] == '\0'){
		return;
	}

	if(domain_name[0] != '*'){
		sprintf(tmp_domain_name, "*.");
		strcat(tmp_domain_name, domain_name);
	}
	ptr = regular_expression;
	while(i<=strlen(tmp_domain_name))
	{
		if(tmp_domain_name[i] == '*' && tmp_domain_name[i+1] == '.')
		{
			sprintf(ptr, "(.+\\.)*");
			ptr+=7;
			i+=2;
		}
		else if(tmp_domain_name[i] == '*' && tmp_domain_name[i+1] == '\0')
		{
			sprintf(ptr, "(.+)*");
			ptr+=5;
			i+=2;
		}
		else
		{
			sprintf(ptr, "%c", tmp_domain_name[i]);
			ptr+=1;
			i+=1;
		}
	}

	//AUG_PRT("regular_expression=%s \n", regular_expression);
}
#endif

void domain_to_regular_expression(unsigned char *domain_name, unsigned char *regular_expression)
{
	int i=0;
	unsigned char *ptr;


	if(domain_name == NULL){
		return;
	}

	if(domain_name[0] == '\0'){
		return;
	}

	ptr = regular_expression;
	while(i<=strlen(domain_name))
	{
		if(domain_name[i] == '*' && domain_name[i+1] == '.')
		{
			sprintf(ptr, "(.+\\.)*");
			ptr+=7;
			i+=2;
		}
		else if(domain_name[i] == '*' && domain_name[i+1] == '\0')
		{
			sprintf(ptr, "(.+)*");
			ptr+=5;
			i+=2;
		}
		else
		{
			sprintf(ptr, "%c", domain_name[i]);
			ptr+=1;
			i+=1;
		}
	}

	//AUG_PRT("regular_expression=%s \n", regular_expression);
}

int get_attach_pattern_by_mode
(
	gdbus_vpn_connection_info_t *vpn_connection_info,
	unsigned char *attach_pattern[],
	unsigned char *reason
)
{
	int i, j=0;
	int ret=0;
	unsigned char regular_expression[MAX_DOMAIN_LENGTH] = {0};

	switch( vpn_connection_info->attach_mode )
	{
		case ATTACH_MODE_DIP:
			i=0;
			while( vpn_connection_info->domains[i] != NULL) {
				sprintf(regular_expression, "");
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
				//We want to keep the original domain, we put the regular expression transform at AttachWanVPN()
				strcpy(regular_expression, vpn_connection_info->domains[i]);
#else
				domain_to_regular_expression(vpn_connection_info->domains[i], regular_expression);
#endif
				attach_pattern[j] = malloc(strlen(regular_expression)+1);
				snprintf(attach_pattern[j], strlen(regular_expression)+1, "%s", regular_expression);
				i++; j++;
			}
			i=0;
			while( vpn_connection_info->ips[i] != NULL) {
				attach_pattern[j] = malloc(strlen(vpn_connection_info->ips[i])+1);
				snprintf(attach_pattern[j], strlen(vpn_connection_info->ips[i])+1, "%s", vpn_connection_info->ips[i]);
				i++; j++;
			}
			break;

		case ATTACH_MODE_SMAC:
			i=0;
			while( vpn_connection_info->terminal_mac[i] != NULL) {
				attach_pattern[j] = malloc(strlen(vpn_connection_info->terminal_mac[i])+6);
				snprintf(attach_pattern[j], strlen(vpn_connection_info->terminal_mac[i])+6, "%.02s:%.02s:%.02s:%.02s:%.02s:%.02s"
					, &vpn_connection_info->terminal_mac[i][0], &vpn_connection_info->terminal_mac[i][2], &vpn_connection_info->terminal_mac[i][4]
					, &vpn_connection_info->terminal_mac[i][6], &vpn_connection_info->terminal_mac[i][8], &vpn_connection_info->terminal_mac[i][10]);
				i++; j++;
			}
			break;

		case ATTACH_MODE_NONE:
			ret=-1;
			break;
		default:
			ret=-1;
			strcpy(reason, "Invalid attach mode !");
	}

	return ret;
}
#endif

#ifdef CONFIG_USER_PPTP_CLIENT_PPTP
#ifdef CONFIG_USER_PPTPD_PPTPD
void applyPptpAccount(MIB_VPN_ACCOUNT_T *pentry, int enable)
{
	MIB_VPND_T server;
	int total, i;
	struct data_to_pass_st msg;
	char index[5];
	char auth[20];
	char enctype[20];
	char localip[20], peerip[20];

	if (1 == enable) {//add a pptp account

		if (0 == pentry->enable)
			return;

		//get server auth info
		total = mib_chain_total(MIB_VPN_SERVER_TBL);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_VPN_SERVER_TBL, i, &server))
				continue;

			if (VPN_PPTP == server.type)
				break;
		}

		if (i >= total) {
			printf("please configure pptp server info first.\n");
			return;
		}

		switch (server.authtype)
		{
		case 1://pap
			strcpy(auth, "pap");
			break;
		case 2://chap
			strcpy(auth, "chap");
			break;
		case 3://chapmsv2
			strcpy(auth, "chapms-v2");
			break;
		default:
			strcpy(auth, "auto");
			break;
		}

		switch (server.enctype)
		{
		case 1://MPPE
			strcpy(enctype, "+MPPE");
			break;
        case 2://MPPC
			strcpy(enctype, "+MPPC");
			break;
		case 3://MPPE&MPPC
			strcpy(enctype, "+BOTH");
			break;
		default:
			strcpy(enctype, "none");
			break;
		}

		snprintf(localip, 20, "%s", inet_ntoa(*(struct in_addr *)&server.localaddr));
		snprintf(peerip, 20, "%s", inet_ntoa(*(struct in_addr *)&server.peeraddr));

		snprintf(msg.data, BUF_SIZE, "spppctl addvpn %s type PPTP auth %s enctype %s username %s password %s localip %s peerip %s",
					pentry->name, auth, enctype, pentry->username, pentry->password, localip, peerip);

		printf("%s: %s\n", __func__, msg.data);

		write_to_pppd(&msg);
	}
	else {
		printf("/bin/spppctl delvpn %s\n", pentry->name);

		va_cmd("/bin/spppctl", 2, 1, "delvpn", pentry->name);
	}
}

void pptpd_take_effect(void)
{
	MIB_VPN_ACCOUNT_T entry;
	unsigned int entrynum, i;
	int enable;

	if ( !mib_get(MIB_PPTP_ENABLE, (void *)&enable) )
		return;

	entrynum = mib_chain_total(MIB_VPN_ACCOUNT_TBL);
	for (i=0; i<entrynum; i++)
	{
		if (!mib_chain_get(MIB_VPN_ACCOUNT_TBL, i, (void *)&entry))
			continue;
		if(VPN_PPTP == entry.type)
			applyPptpAccount(&entry, 0);
	}

	if (enable) {
		for (i=0; i<entrynum; i++)
		{
			if (!mib_chain_get(MIB_VPN_ACCOUNT_TBL, i, (void *)&entry))
				continue;
			if(VPN_PPTP == entry.type)
				applyPptpAccount(&entry, 1);
		}
	}
}
#endif

void applyPPtP(MIB_PPTP_T *pentry, int enable, int pptp_index)
{
	struct data_to_pass_st msg;
	char index[5];
	char auth[20];
	char enctype[20];

	if( pentry->vpn_enable==VPN_DISABLE ) {
		AUG_PRT("%s-%d VPN tunnel is disabled, don't make it work!\n", __func__, __LINE__);
		return;
	}

	// Mason Yu. Add VPN ifIndex
	// unit declarations for ppp  on if_sppp.h
	// (1) 0 ~ 7: pppoe/pppoa, (2) 8: 3G, (3) 9 ~ 10: PPTP, (4) 11 ~12: L2TP
	if (enable == 1 || enable == 2) {	// add(persistent) or new(Dial-on-demand)

		switch (pentry->authtype)
		{
		case 1://pap
			strcpy(auth, "pap");
			break;
		case 2://chap
			strcpy(auth, "chap");
			break;
		case 3://chapmsv2
			strcpy(auth, "chapms-v2");
			break;
		default:
			strcpy(auth, "auto");
			break;
		}

		switch (pentry->enctype)
		{
		case 1://MPPE
			strcpy(enctype, "+MPPE");
			break;
		case 2://MPPC
			strcpy(enctype, "+MPPC");
			break;
		case 3://MPPE&MPPC
			strcpy(enctype, "+BOTH");
			break;
		default:
			strcpy(enctype, "none");
			break;
		}

		if (pentry->dgw) {
			snprintf(msg.data, BUF_SIZE,
				"spppctl add %d pptp auth %s username %s password %s server %s gw %d enctype %s", pentry->idx+9,
				auth, pentry->username, pentry->password, pentry->server, pentry->dgw, enctype);
		}
		else {
			snprintf(msg.data, BUF_SIZE,
				"spppctl add %d pptp auth %s username %s password %s server %s enctype %s", pentry->idx+9,
				auth, pentry->username, pentry->password, pentry->server, enctype);
		}

		if (pentry->conntype == CONNECT_ON_DEMAND)
			snprintf(msg.data, BUF_SIZE, "%s timeout %d", msg.data, pentry->idletime);
		else if(pentry->conntype == CONNECT_ON_PKT_COUNT)			
			snprintf(msg.data, BUF_SIZE, "%s timeout_en 1 timeout %d", msg.data, pentry->idletime);

#ifdef CONFIG_IPV6_VPN
		snprintf(msg.data, BUF_SIZE, "%s ipt %u", msg.data, pEntry->IpProtocol - 1);
#endif

		printf("%s: %s\n", __func__, msg.data);

		generate_ifup_script_vpn(pentry->ifIndex);
		generate_ifdown_script_vpn(pentry->ifIndex);

		write_to_pppd(&msg);
#ifdef CONFIG_RTK_L34_ENABLE
		//RG add pptp wan!
		if(enable == 1)
			RG_add_pptp_wan(pentry,pptp_index);
#endif
	}
	else if(enable == 0 || enable == 3){
#ifdef CONFIG_RTK_L34_ENABLE
		//RG del pptp wan!
		if(!enable && pentry->rg_wan_idx>0){
			RG_WAN_Interface_Del(pentry->rg_wan_idx);
			pentry->rg_wan_idx=0;
			mib_chain_update(MIB_PPTP_TBL, pentry, pptp_index);
		}
#endif
		snprintf(index, 5, "%d", pentry->idx+9);
		va_cmd("/bin/spppctl", 4, 1, "del", index, "pptp", "0");
		remove_ifup_script_vpn(pentry->ifIndex);
		remove_ifdown_script_vpn(pentry->ifIndex);
	}
}

void pptp_take_effect(void)
{
	MIB_PPTP_T entry;
	unsigned int entrynum, i;
	int enable;

	if ( !mib_get(MIB_PPTP_ENABLE, (void *)&enable) )
		return;

	entrynum = mib_chain_total(MIB_PPTP_TBL);

	for (i=0; i<entrynum; i++)
	{
		if ( !mib_chain_get(MIB_PPTP_TBL, i, (void *)&entry) )
			return;

		applyPPtP(&entry, 3, i);
	}

	if (enable) {

		for (i=0; i<entrynum; i++)
		{
			if ( !mib_chain_get(MIB_PPTP_TBL, i, (void *)&entry) )
				return;

			applyPPtP(&entry, 2, i);
		}
	}
}

int Check_PPTP_Route_URL(unsigned char *tunnelName,char *url)
{
	int totalnum,i,checkIt=0;
	MIB_CE_PPTP_ROUTE_T entry;
	int cflags = REG_EXTENDED;
	regmatch_t pmatch[1];
	const size_t nmatch=1;
	regex_t reg;


	totalnum = mib_chain_total(MIB_PPTP_ROUTE_TBL); /* get chain record size */

	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) )
			continue;
		if(!strcmp(entry.tunnelName,tunnelName))
		{
			if(!strcmp(entry.url,url))
			{
				/*route list alredy exist!*/
				checkIt=1;
				return 1;
			}
		}
		else if(!strcmp(tunnelName, MAGIC_TUNNEL_NAME))
		{
			if(url[0] == '\0' || entry.url[0] == '\0')
				continue;

			if(regcomp(&reg, entry.url, cflags))
			{
				printf("failed to compile!\n");
				continue;
			}

			if(!regexec(&reg, url, nmatch, pmatch, 0) || !strcmp(entry.url,url)){
				regfree(&reg);
				return i;
			}

			regfree(&reg);
		}
	}

	if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
		return -1;
	else
		return 0;

}

int Check_PPTP_Route_DIP(unsigned char *tunnelName,unsigned int ipv4_addr1,unsigned int ipv4_addr2)
{
	int totalnum,i,checkIt=0;
	MIB_CE_PPTP_ROUTE_T entry;

	totalnum = mib_chain_total(MIB_PPTP_ROUTE_TBL); /* get chain record size */
	//AUG_PRT("%s-%d totalnum=%d ipv4_addr1=%x, ipv4_addr2=%x\n",__func__,__LINE__,totalnum,ipv4_addr1,ipv4_addr2);

	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) )
			continue;
		if(!strcmp(entry.tunnelName,tunnelName) || strstr(tunnelName, MAGIC_TUNNEL_NAME))
		{
			if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
			{
				if(ipv4_addr1>=entry.ipv4_src_start && ipv4_addr1<=entry.ipv4_src_end){
					//AUG_PRT("%s-%d i=%d\n",__func__,__LINE__,i);
					return i;
				}
			}
			else if((ipv4_addr1 == entry.ipv4_src_start) && (ipv4_addr2 == entry.ipv4_src_end))
			{
				//AUG_PRT("%s-%d totalnum=%d ipv4_addr1=%x, ipv4_addr2=%x\n",__func__,__LINE__,totalnum,ipv4_addr1,ipv4_addr2);
				/*route list alredy exist!*/
				checkIt=1;
				return 1;
			}
		}
	}

	if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
		return -1;
	else
		return 0;
}

int Check_PPTP_Route_SMAC(unsigned char *tunnelName, unsigned char* sMAC_addr)
{
	int totalnum,i,checkIt=0;
	MIB_CE_PPTP_ROUTE_T entry;
	unsigned char atta_sMAC_addr[20];
	unsigned char rtbl_sMAC_addr[20];

	totalnum = mib_chain_total(MIB_PPTP_ROUTE_TBL); /* get chain record size */

	//AUG_PRT("%s-%d totalnum=%d sMAC_addr=%X:%X:%X:%X:%X:%X \n",__func__,__LINE__,totalnum,sMAC_addr[0],sMAC_addr[1],sMAC_addr[2],sMAC_addr[3],sMAC_addr[4],sMAC_addr[5]);

	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) )
			continue;

		if(!strcmp(entry.tunnelName,tunnelName) || strstr(tunnelName, MAGIC_TUNNEL_NAME))
		{
			sprintf(atta_sMAC_addr, "%X:%X:%X:%X:%X:%X", sMAC_addr[0], sMAC_addr[1], sMAC_addr[2], sMAC_addr[3], sMAC_addr[4], sMAC_addr[5]);
			sprintf(rtbl_sMAC_addr, "%X:%X:%X:%X:%X:%X", entry.sMAC[0], entry.sMAC[1], entry.sMAC[2], entry.sMAC[3], entry.sMAC[4], entry.sMAC[5]);
			if(!strcmp(atta_sMAC_addr,rtbl_sMAC_addr))
			{
				//AUG_PRT("%s-%d totalnum=%d sMAC_addr=%s \n",__func__,__LINE__,totalnum,atta_sMAC_addr);
				/*route list alredy exist!*/
				checkIt=1;
				if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
					return i;
				else
					return 1;
			}
		}
	}

	if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
		return -1;
	else
		return 0;
}

int Del_PPTP_Route_URL(unsigned char *tunnelName,char *url)
{
	int totalnum,i,checkIt=0;
	MIB_CE_PPTP_ROUTE_T entry;

	totalnum = mib_chain_total(MIB_PPTP_ROUTE_TBL); /* get chain record size */
	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) )
			continue;
		if(!strcmp(entry.tunnelName,tunnelName))
		{
			if(!strcmp(entry.url,url))
			{
				/*match route list!*/
				mib_chain_delete(MIB_PPTP_ROUTE_TBL,i);
				return 1;
			}
		}
	}
	return 0;
}

int Del_PPTP_Route_DIP(unsigned char *tunnelName,unsigned int ipv4_addr1,unsigned int ipv4_addr2)
{
	int totalnum,i,checkIt=0;
	MIB_CE_PPTP_ROUTE_T entry;

	totalnum = mib_chain_total(MIB_PPTP_ROUTE_TBL); /* get chain record size */
	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) )
			continue;
		if(!strcmp(entry.tunnelName,tunnelName) || strstr(tunnelName, MAGIC_TUNNEL_NAME))
		{
			if((ipv4_addr1 == entry.ipv4_src_start) && (ipv4_addr2 == entry.ipv4_src_end))
			{

				/*match route list!*/
				mib_chain_delete(MIB_PPTP_ROUTE_TBL,i);
				return 1;
			}
		}
	}
	return 0;
}

int Del_PPTP_Route_SMAC(unsigned char *tunnelName, unsigned char* sMAC_addr)
{
	int totalnum,i,checkIt=0;
	MIB_CE_PPTP_ROUTE_T entry;
	unsigned char atta_sMAC_addr[20];
	unsigned char rtbl_sMAC_addr[20];


	totalnum = mib_chain_total(MIB_PPTP_ROUTE_TBL); /* get chain record size */
	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) )
			continue;

		if(!strcmp(entry.tunnelName,tunnelName) || strstr(tunnelName, MAGIC_TUNNEL_NAME))
		{
			sprintf(atta_sMAC_addr, "%X:%X:%X:%X:%X:%X", sMAC_addr[0], sMAC_addr[1], sMAC_addr[2], sMAC_addr[3], sMAC_addr[4], sMAC_addr[5]);
			sprintf(rtbl_sMAC_addr, "%X:%X:%X:%X:%X:%X", entry.sMAC[0], entry.sMAC[1], entry.sMAC[2], entry.sMAC[3], entry.sMAC[4], entry.sMAC[5]);
			if(!strcmp(atta_sMAC_addr,rtbl_sMAC_addr))
			{
				/*match route list!*/
				mib_chain_delete(MIB_PPTP_ROUTE_TBL,i);
				return 1;

			}
		}
	}
	return 0;
}

int NF_Flush_PPTP_Dynamic_URL_Route(unsigned char *tunnelName)
{
	unsigned char chain_name[16];


	if(!tunnelName) {
		AUG_PRT("Null pointer !\n");
		return -1;
	}

	if(tunnelName[0] == '\0') {
		AUG_PRT("Null string !\n");
		return -1;
	}

	snprintf(chain_name, sizeof(chain_name), "%s-url", tunnelName);
	AUG_PRT("iptables -t mangle -F %s\n", chain_name);
	va_cmd(IPTABLES, 8, 1, "-t", "mangle", "-F", (char *)chain_name);
}

int NF_Set_PPTP_Dynamic_URL_Route(char *name, struct in_addr addr)
{
	MIB_CE_PPTP_ROUTE_T entry;
	int total_entry,i,enable,status;
	int cflags = REG_EXTENDED;
	regmatch_t pmatch[1];
	const size_t nmatch=1;
	regex_t reg;
	int aclIdx, naptIdx, ret;
	int flags, flags_found, isPPTPup=0;
	char ifname[IFNAMSIZ];
	unsigned char fw_mark[16], dip_str[20];
	unsigned char chain_name[16];
	char ip_route_idx_str[10];
	int ip_route_idx;


	if ( !mib_get(MIB_PPTP_ENABLE, (void *)&enable) ){
		printf("MIB_PPTP_ENABLE is not exist!");
		return -1;
	}

	if(!enable){
		printf("MIB_PPTP_ENABLE is not enable!");
		return 0;
	}

	total_entry = mib_chain_total(MIB_PPTP_ROUTE_TBL);
	for(i=0;i<total_entry;i++)
	{
		if(mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) == 0)
			continue;
		if((entry.url[0] != '\0') && (entry.ipv4_src_start==0) && (entry.ipv4_src_end==0))
		{
			AUG_PRT("%s-%d URL=%s name=%s\n",__func__,__LINE__,entry.url, name);
			if(regcomp(&reg, entry.url, cflags))
			{
				printf("failed to compile!\n");
				continue;
			}
			status = regexec(&reg, name, nmatch, pmatch, 0);
			if(status == REG_NOMATCH){
				printf("No match!\n");
			}
			else if(status==0)
			{
				printf("match:%s\n",name);
				printf("addr=0x%x\n",addr.s_addr);
				ifGetName(entry.ifIndex, ifname, sizeof(ifname));
				AUG_PRT("%s-%d entry.ifIndex=%x, ifname=%s\n",__func__,__LINE__,entry.ifIndex,ifname);
				flags_found = getInFlags(ifname, &flags);
				AUG_PRT("%s-%d flags_found=%d\n",__func__,__LINE__,flags_found);
				if (flags_found)
				{
					if (flags & IFF_UP)
					{
					#if 0//def CONFIG_GPON_FEATURE
						if (onu == 5)
							isPPTPup = 1;
					#else
							isPPTPup = 1;
					#endif
					}
				}

				if(isPPTPup)
				{
					memset(fw_mark, 0, sizeof(fw_mark));
					if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
						snprintf(dip_str, sizeof(dip_str), "%s", inet_ntoa(addr));
						snprintf(chain_name, sizeof(chain_name), "%s-url", entry.tunnelName);
						if(va_cmd(IPTABLES, 10, 1, "-t", "mangle", "-C", (char *)chain_name, "-d", dip_str, "-j", "MARK", "--set-mark", fw_mark)) {
							AUG_PRT("iptables -t mangle -A %s -d %s -j MARK --set-mark %s\n", chain_name, dip_str, fw_mark);
							va_cmd(IPTABLES, 10, 1, "-t", "mangle", "-A", (char *)chain_name, "-d", dip_str, "-j", "MARK", "--set-mark", fw_mark);
						} else {
							AUG_PRT("%s has exist in -t mangle %s chain\n", dip_str, chain_name);
						}
					}
				}

				memset(fw_mark, 0, sizeof(fw_mark));
				if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
					ip_route_idx=vpn_tunnel_name_to_table(entry.tunnelName);
					if(ip_route_idx != -1){
						snprintf(ip_route_idx_str, 10, "%d", ip_route_idx);
						AUG_PRT("ip route del default dev %s table %s\n", ifname, ip_route_idx_str);
						va_cmd("/bin/ip", 7, 1, "route", "del", "default", "dev", ifname, "table", ip_route_idx_str);
						AUG_PRT("ip route add default dev %s table %s\n", ifname, ip_route_idx_str);
						va_cmd("/bin/ip", 7, 1, "route", "add", "default", "dev", ifname, "table", ip_route_idx_str);
						AUG_PRT("ip rule del fwmark %s table %s\n", fw_mark, ip_route_idx_str);
						va_cmd("/bin/ip", 6, 1, "rule", "del", "fwmark", fw_mark, "table", ip_route_idx_str);
						AUG_PRT("ip rule add fwmark %s table %s\n", fw_mark, ip_route_idx_str);
						va_cmd("/bin/ip", 6, 1, "rule", "add", "fwmark", fw_mark, "table", ip_route_idx_str);
					}
				}
			}
			regfree(&reg);
		}
	}
}

int NF_Flush_PPTP_Route(unsigned char *tunnelName)
{
	if(!tunnelName) {
		AUG_PRT("Null pointer !\n");
		return -1;
	}

	if(tunnelName[0] == '\0') {
		AUG_PRT("Null string !\n");
		return -1;
	}

	AUG_PRT("iptables -t mangle -F %s\n", tunnelName);
	va_cmd(IPTABLES, 8, 1, "-t", "mangle", "-F", (char *)tunnelName);
}

int NF_Set_PPTP_Policy_Route(unsigned char *tunnelName, ATTACH_MODE_T attach_mode)
{
	MIB_CE_PPTP_ROUTE_T entry;
	int total_entry,i,enable;
	int flags, flags_found, isPPTPup=0;
	char ifname[IFNAMSIZ];
	unsigned char sMAC_mask[MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	unsigned char fw_mark[16], sMAC[20], dip_start_str[20], dip_end_str[20], dip_range[40];
	struct in_addr dip_start, dip_end;
	char ip_route_idx_str[10];
	int ip_route_idx;


	if ( !mib_get(MIB_PPTP_ENABLE, (void *)&enable) ){
		printf("MIB_PPTP_ENABLE is not exist!");
		return -1;
	}

	if(!enable){
		printf("MIB_PPTP_ENABLE is not enable!");
		return 0;
	}

	total_entry = mib_chain_total(MIB_PPTP_ROUTE_TBL);
	for(i=0;i<total_entry;i++)
	{
		if(mib_chain_get(MIB_PPTP_ROUTE_TBL, i, (void *)&entry) == 0)
			continue;

		if(!strcmp(entry.tunnelName,tunnelName))
		{
			if(entry.ipv4_src_start == 0 && entry.ipv4_src_end == 0 && !(entry.sMAC[0]|entry.sMAC[1]|entry.sMAC[2]|entry.sMAC[3]|entry.sMAC[4]|entry.sMAC[5]))/*route by URL*/
				continue;

			//check interface is up or not!
			ifGetName(entry.ifIndex, ifname, sizeof(ifname));
			flags_found = getInFlags(ifname, &flags);
			if (flags_found)
			{
				if (flags & IFF_UP)
				{
					isPPTPup = 1;
				}
			}
			//check interface up or not, if up we set acl rules.
			if(isPPTPup)
			{
				if(entry.ipv4_src_start || entry.ipv4_src_end)
				{
					if(ATTACH_MODE_DIP!=attach_mode)
						continue;

					memset(fw_mark, 0, sizeof(fw_mark));
					if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
						dip_start.s_addr = entry.ipv4_src_start;
						dip_end.s_addr = entry.ipv4_src_end;
						snprintf(dip_start_str, sizeof(dip_start_str), "%s", inet_ntoa(dip_start));
						snprintf(dip_end_str, sizeof(dip_end_str),"%s", inet_ntoa(dip_end));
						snprintf(dip_range, sizeof(dip_range), "%s-%s", dip_start_str, dip_end_str);
						if(va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-C", (char *)tunnelName, "-m", "iprange", "--dst-range", dip_range, "-j", "MARK", "--set-mark", fw_mark)) {
							AUG_PRT("iptables -t mangle -A %s -m iprange --dst-range %s -j MARK --set-mark %s\n", tunnelName, dip_range, fw_mark);
							va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-A", (char *)tunnelName, "-m", "iprange", "--dst-range", dip_range, "-j", "MARK", "--set-mark", fw_mark);
						} else {
							AUG_PRT("%s has exist in -t mangle %s chain\n", dip_range, tunnelName);
						}
					}
				}
				else
				{
					if(ATTACH_MODE_SMAC!=attach_mode)
						continue;

					memset(fw_mark, 0, sizeof(fw_mark));
					if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
						memset(sMAC, 0, sizeof(sMAC));

						snprintf(sMAC, sizeof(sMAC), "%02x:%02x:%02x:%02x:%02x:%02x", entry.sMAC[0], entry.sMAC[1], entry.sMAC[2], entry.sMAC[3], entry.sMAC[4], entry.sMAC[5]);
						if(va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-C", (char *)tunnelName, "-m", "mac", "--mac-source", sMAC, "-j", "MARK", "--set-mark", fw_mark)) {
							AUG_PRT("iptables -t mangle -A %s -m mac --mac-source %s -j MARK --set-mark %s\n", tunnelName, sMAC, fw_mark);
							va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-A", (char *)tunnelName, "-m", "mac", "--mac-source", sMAC, "-j", "MARK", "--set-mark", fw_mark);
						} else {
							AUG_PRT("%s has exist in -t mangle %s chain\n", sMAC, tunnelName);
						}
					}
				}
			}

			memset(fw_mark, 0, sizeof(fw_mark));
			if(!VPN_Route_Policy_Get_Mark(fw_mark, tunnelName)) {
				ip_route_idx=vpn_tunnel_name_to_table(tunnelName);
				if(ip_route_idx != -1){
					snprintf(ip_route_idx_str, 10, "%d", ip_route_idx);
					AUG_PRT("ip route del default dev %s table %s\n", ifname, ip_route_idx_str);
					va_cmd("/bin/ip", 7, 1, "route", "del", "default", "dev", ifname, "table", ip_route_idx_str);
					AUG_PRT("ip route add default dev %s table %s\n", ifname, ip_route_idx_str);
					va_cmd("/bin/ip", 7, 1, "route", "add", "default", "dev", ifname, "table", ip_route_idx_str);
					AUG_PRT("ip rule del fwmark %s table %s\n", fw_mark, ip_route_idx_str);
					va_cmd("/bin/ip", 6, 1, "rule", "del", "fwmark", fw_mark, "table", ip_route_idx_str);
					AUG_PRT("ip rule add fwmark %s table %s\n", fw_mark, ip_route_idx_str);
					va_cmd("/bin/ip", 6, 1, "rule", "add", "fwmark", fw_mark, "table", ip_route_idx_str);
				}
			}
		}
	}

	return 0;
}

int NF_Update_PPTP_Ip_Route_Table(unsigned char *tunnelName, unsigned int ifIndex)
{
	char ip_route_idx_str[10];
	unsigned char fw_mark[16];
	char ifname[IFNAMSIZ];
	int ip_route_idx;
	int total_num, i;


	ifGetName(ifIndex, ifname, sizeof(ifname));
	memset(fw_mark, 0, sizeof(fw_mark));
	if(!VPN_Route_Policy_Get_Mark(fw_mark, tunnelName)) {
		ip_route_idx=vpn_tunnel_name_to_table(tunnelName);
		if(ip_route_idx != -1){
			snprintf(ip_route_idx_str, 10, "%d", ip_route_idx);
			AUG_PRT("ip route del default dev %s table %s\n", ifname, ip_route_idx_str);
			va_cmd("/bin/ip", 7, 1, "route", "del", "default", "dev", ifname, "table", ip_route_idx_str);
			AUG_PRT("ip route add default dev %s table %s\n", ifname, ip_route_idx_str);
			va_cmd("/bin/ip", 7, 1, "route", "add", "default", "dev", ifname, "table", ip_route_idx_str);
		}
	}
}

MIB_PPTP_T *getPPTPEntryByIfIndex(unsigned int ifIndex, MIB_PPTP_T *p)
{
	unsigned int i,num;
	if( (p==NULL) || (ifIndex==DUMMY_IFINDEX) ) return NULL;
	num = mib_chain_total( MIB_PPTP_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_PPTP_TBL, i, (void*)p ))
			continue;
		if( p->ifIndex==ifIndex )
		{
			printf("%s-%d ifIndex=%d\n",__func__,__LINE__,ifIndex);
			return p;
		}
	}
	return NULL;
}

int getIfIndexByPPTPName(char *pIfname)
{
	unsigned int entryNum, i;
	MIB_PPTP_T Entry;
	char ifname[IFNAMSIZ];
	entryNum = mib_chain_total(MIB_PPTP_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_PPTP_TBL, i, (void *)&Entry))
		{
  			printf("Get chain record error!\n");
			return -1;
		}
		ifGetName(Entry.ifIndex,ifname,sizeof(ifname));
		if(!strcmp(ifname,pIfname)){
			break;
		}
	}
	if(i>= entryNum){
		printf("not find this interface!\n");
		return -1;
	}
	return(Entry.ifIndex);
}

int NF_pptp_ip_chagne(char *ifname, struct in_addr *new_ip, struct in_addr *ifa_local)
{
	int wan_ifIndex;
	MIB_PPTP_T pptp_entry = {0};
	unsigned int entrynum, i;
	int enable, ret;


	wan_ifIndex = getIfIndexByPPTPName(ifname);
	if (wan_ifIndex == -1) return 0;
	ret = (intptr_t)getPPTPEntryByIfIndex(wan_ifIndex, &pptp_entry);
	if (!ret) return 0;
	/* Two addresses are the same means we have not get remote IP yet.*/
	if(ifa_local->s_addr == new_ip->s_addr)
		return 0;

	NF_Flush_PPTP_Dynamic_URL_Route(pptp_entry.tunnelName);
	NF_Flush_PPTP_Route(pptp_entry.tunnelName);
	NF_Set_PPTP_Policy_Route(pptp_entry.tunnelName, pptp_entry.attach_mode);
	return 0;
}
#endif

#if defined(CONFIG_USER_L2TPD_LNS) || defined(CONFIG_USER_L2TPD_L2TPD)
static const char *tunnel_auth[2] = {"none", "challenge"};
#endif

#ifdef CONFIG_USER_L2TPD_LNS
void applyL2tpAccount(MIB_VPN_ACCOUNT_T *pentry, int enable)
{
	MIB_VPND_T server;
	int total, i;
	struct data_to_pass_st msg;
	char index[5];
	char auth[20];
	char enctype[20];
	char localip[20], peerip[20];

	if (1 == enable) {//add a pptp account

		if (0 == pentry->enable)
			return;

		//get server auth info
		total = mib_chain_total(MIB_VPN_SERVER_TBL);
		for (i=0; i<total; i++) {
			if (!mib_chain_get(MIB_VPN_SERVER_TBL, i, &server))
				continue;

			if (VPN_L2TP == server.type)
				break;
		}

		if (i >= total) {
			printf("please configure l2tp server info first.\n");
			return;
		}

		switch (server.authtype)
		{
		case 1://pap
			strcpy(auth, "pap");
			break;
		case 2://chap
			strcpy(auth, "chap");
			break;
		case 3://chapmsv2
			strcpy(auth, "chapms-v2");
			break;
		default:
			strcpy(auth, "auto");
			break;
		}

		switch (server.enctype)
		{
		case 1://MPPE
			strcpy(enctype, "+MPPE");
			break;
        case 2://MPPC
			strcpy(enctype, "+MPPC");
			break;
		case 3://MPPE&MPPC
			strcpy(enctype, "+BOTH");
			break;
		default:
			strcpy(enctype, "none");
			break;
		}

		snprintf(localip, 20, "%s", inet_ntoa(*(struct in_addr *)&server.localaddr));
		snprintf(peerip, 20, "%s", inet_ntoa(*(struct in_addr *)&server.peeraddr));

		snprintf(msg.data, BUF_SIZE, "spppctl addvpn %s type L2TP auth %s enctype %s username %s password %s localip %s peerip %s",
					pentry->name, auth, enctype, pentry->username, pentry->password, localip, peerip);

		snprintf(msg.data, BUF_SIZE, "%s tunnel_auth %s", msg.data, tunnel_auth[server.tunnel_auth]);
		if (server.tunnel_auth) {
			snprintf(msg.data, BUF_SIZE, "%s secret %s", msg.data, server.tunnel_key);
		}

		printf("%s: %s\n", __func__, msg.data);

		write_to_pppd(&msg);
	}
	else {
		printf("/bin/spppctl delvpn %s\n", pentry->name);

		va_cmd("/bin/spppctl", 2, 1, "delvpn", pentry->name);
	}
}

void l2tpd_take_effect(void)
{
	MIB_VPN_ACCOUNT_T entry;
	unsigned int entrynum, i;
	int enable;

	if ( !mib_get(MIB_L2TP_ENABLE, (void *)&enable) )
		return;

	entrynum = mib_chain_total(MIB_VPN_ACCOUNT_TBL);
	for (i=0; i<entrynum; i++)
	{
		if (!mib_chain_get(MIB_VPN_ACCOUNT_TBL, i, (void *)&entry))
			continue;
		if(VPN_L2TP == entry.type)
			applyL2tpAccount(&entry, 0);
	}

	if (enable) {
		for (i=0; i<entrynum; i++)
		{
			if (!mib_chain_get(MIB_VPN_ACCOUNT_TBL, i, (void *)&entry))
				continue;
			if(VPN_L2TP == entry.type)
				applyL2tpAccount(&entry, 1);
		}
	}
}
#endif

#ifdef CONFIG_USER_L2TPD_L2TPD
static const char *l2tp_auth[] = {"auto", "pap", "chap", "chapms-v2"};
static const char *l2tp_encryt[] = {"none", "+MPPE", "+MPPC", "+BOTH"};
int applyL2TP(MIB_L2TP_T *pentry, int enable, int l2tp_index)
{
	struct data_to_pass_st msg;
	char index[5];

	if( pentry->vpn_enable==VPN_DISABLE ) {
		AUG_PRT("%s-%d VPN tunnel is disabled, don't make it work!\n", __func__, __LINE__);
		return -1;
	}

	// Mason Yu. Add VPN ifIndex
	// unit declarations for ppp  on if_sppp.h
	// (1) 0 ~ 7: pppoe/pppoa, (2) 8: 3G, (3) 9 ~ 10: PPTP, (4) 11 ~12: L2TP
	if (enable == 1 || enable == 4) {	// add(persistent) or new(Dial-on-demand)
		if (pentry->conntype != MANUAL) {
			snprintf(msg.data, BUF_SIZE,
				"spppctl add %d l2tp username %s password %s gw %d mru %d", pentry->idx+11,
				pentry->username, pentry->password, pentry->dgw, pentry->mtu);
		}
		else {
			snprintf(msg.data, BUF_SIZE,
				"spppctl new %d l2tp username %s password %s gw %d mru %d", pentry->idx+11,
				pentry->username, pentry->password, pentry->dgw, pentry->mtu);
		}

		snprintf(msg.data, BUF_SIZE, "%s auth %s", msg.data, l2tp_auth[pentry->authtype]);

		snprintf(msg.data, BUF_SIZE, "%s enctype %s", msg.data, l2tp_encryt[pentry->enctype]);

		snprintf(msg.data, BUF_SIZE, "%s server %s", msg.data, pentry->server);

		snprintf(msg.data, BUF_SIZE, "%s tunnel_auth %s", msg.data, tunnel_auth[pentry->tunnel_auth]);
		if (pentry->tunnel_auth) {
			snprintf(msg.data, BUF_SIZE, "%s secret %s", msg.data, pentry->secret);
		}

		if (pentry->conntype == CONNECT_ON_DEMAND)
			snprintf(msg.data, BUF_SIZE, "%s timeout %d", msg.data, pentry->idletime);
		else if(pentry->conntype == CONNECT_ON_PKT_COUNT)
			snprintf(msg.data, BUF_SIZE, "%s timeout_en 1 timeout %d", msg.data, pentry->idletime);

#ifdef CONFIG_IPV6_VPN
		snprintf(msg.data, BUF_SIZE, "%s ipt %u", msg.data, pEntry->IpProtocol - 1);
#endif

		printf("%s: %s\n", __func__, msg.data);

		generate_ifup_script_vpn(pentry->ifIndex);
		generate_ifdown_script_vpn(pentry->ifIndex);
#ifdef CONFIG_RTK_L34_ENABLE
		//RG add l2tp wan!
		if(enable == 1)
			RG_add_l2tp_wan(pentry,l2tp_index);
#endif

		write_to_pppd(&msg);
	}
	else if (enable == 2) { 	// connect(up) for dial on-demand
		snprintf(msg.data, BUF_SIZE, "spppctl up %d", pentry->idx+11);
#ifdef CONFIG_RTK_L34_ENABLE
		//RG add l2tp wan!
		RG_add_l2tp_wan(pentry,l2tp_index);
#endif
		write_to_pppd(&msg);
	}
	else if (enable == 3) { 	// disconnect(down) for dial on-demand
		snprintf(msg.data, BUF_SIZE, "spppctl down %d", pentry->idx+11);
#ifdef CONFIG_RTK_L34_ENABLE
		//RG add l2tp wan!
		RG_add_l2tp_wan(pentry,l2tp_index);
#endif
		write_to_pppd(&msg);
	}
	else if(enable == 0 || enable == 5){
#ifdef CONFIG_RTK_L34_ENABLE
		//RG del l2tp wan!
		if(!enable && pentry->rg_wan_idx>0){
			RG_WAN_Interface_Del(pentry->rg_wan_idx);
			pentry->rg_wan_idx=0;
			mib_chain_update(MIB_L2TP_TBL, pentry, l2tp_index);
		}
#endif
		snprintf(index, 5, "%d", pentry->idx+11);
		va_cmd("/bin/spppctl", 4, 1, "del", index, "l2tp", "0");
		remove_ifup_script_vpn(pentry->ifIndex);
		remove_ifdown_script_vpn(pentry->ifIndex);
	}

	return 1;
}

void l2tp_take_effect(void)
{
	MIB_L2TP_T entry;
	unsigned int entrynum, i;//, j;
	int enable;

	if ( !mib_get(MIB_L2TP_ENABLE, (void *)&enable) )
		return;

	entrynum = mib_chain_total(MIB_L2TP_TBL);


	//delete all firstly
	for (i=0; i<entrynum; i++)
	{
		if ( !mib_chain_get(MIB_L2TP_TBL, i, (void *)&entry) )
			return;

		applyL2TP(&entry, 0, i);
	}

	if (enable) {
		for (i=0; i<entrynum; i++)
		{
			if ( !mib_chain_get(MIB_L2TP_TBL, i, (void *)&entry) )
				return;

			applyL2TP(&entry, 1, i);
		}
	}
}

void dump_l2tp_table( void )
{
	MIB_L2TP_T entry;
	unsigned int entrynum, i;

	entrynum = mib_chain_total(MIB_L2TP_TBL);
	for (i=0; i<entrynum; i++)
	{
		if ( !mib_chain_get(MIB_L2TP_TBL, i, (void *)&entry) )
			return;

		printf(" ============================%s========================== \n", __func__);

		printf("  server=%s \n", entry.server);
		printf("  username=%s \n", entry.username);
		printf("  password=%s \n", entry.password);
		printf("  tunnelName=%s \n", entry.tunnelName);
		printf("  userID=%s \n", entry.userID);
	}
}

int Check_L2TP_Route_DIP(unsigned char *tunnelName,unsigned int ipv4_addr1,unsigned int ipv4_addr2)
{
	int totalnum,i,checkIt=0;
	MIB_CE_L2TP_ROUTE_T entry;

	totalnum = mib_chain_total(MIB_L2TP_ROUTE_TBL); /* get chain record size */
	//AUG_PRT("%s-%d totalnum=%d ipv4_addr1=%x, ipv4_addr2=%x\n",__func__,__LINE__,totalnum,ipv4_addr1,ipv4_addr2);

	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) )
			continue;
		if(!strcmp(entry.tunnelName,tunnelName) || strstr(tunnelName, MAGIC_TUNNEL_NAME))
		{
			if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
			{
				if(ipv4_addr1>=entry.ipv4_src_start && ipv4_addr1<=entry.ipv4_src_end){
					//AUG_PRT("%s-%d i=%d\n",__func__,__LINE__, i);
					return i;
				}
			}
			else if((ipv4_addr1 == entry.ipv4_src_start) && (ipv4_addr2 == entry.ipv4_src_end))
			{
				//AUG_PRT("%s-%d totalnum=%d ipv4_addr1=%x, ipv4_addr2=%x\n",__func__,__LINE__,totalnum,ipv4_addr1,ipv4_addr2);
				/*route list alredy exist!*/
				checkIt=1;
				return 1;
			}
		}
	}

	if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
		return -1;
	else
		return 0;
}

int Check_L2TP_Route_SMAC(unsigned char *tunnelName, unsigned char* sMAC_addr)
{
	int totalnum,i,checkIt=0;
	MIB_CE_L2TP_ROUTE_T entry;
	unsigned char atta_sMAC_addr[20];
	unsigned char rtbl_sMAC_addr[20];

	totalnum = mib_chain_total(MIB_L2TP_ROUTE_TBL); /* get chain record size */

	//AUG_PRT("%s-%d totalnum=%d sMAC_addr=%X:%X:%X:%X:%X:%X \n",__func__,__LINE__,totalnum,sMAC_addr[0],sMAC_addr[1],sMAC_addr[2],sMAC_addr[3],sMAC_addr[4],sMAC_addr[5]);

	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) )
			continue;

		if(!strcmp(entry.tunnelName,tunnelName) || strstr(tunnelName, MAGIC_TUNNEL_NAME))
		{
			sprintf(atta_sMAC_addr, "%X:%X:%X:%X:%X:%X", sMAC_addr[0], sMAC_addr[1], sMAC_addr[2], sMAC_addr[3], sMAC_addr[4], sMAC_addr[5]);
			sprintf(rtbl_sMAC_addr, "%X:%X:%X:%X:%X:%X", entry.sMAC[0], entry.sMAC[1], entry.sMAC[2], entry.sMAC[3], entry.sMAC[4], entry.sMAC[5]);
			if(!strcmp(atta_sMAC_addr,rtbl_sMAC_addr))
			{
				//AUG_PRT("%s-%d totalnum=%d sMAC_addr=%s\n",__func__,__LINE__,totalnum,atta_sMAC_addr);
				/*route list alredy exist!*/
				checkIt=1;
				if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
					return i;
				else
					return 1;
			}
		}
	}

	if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
		return -1;
	else
		return 0;
}

int Check_L2TP_Route_URL(unsigned char *tunnelName,char *url)
{
	int totalnum,i,checkIt=0;
	MIB_CE_L2TP_ROUTE_T entry;
	int cflags = REG_EXTENDED;
	regmatch_t pmatch[1];
	const size_t nmatch=1;
	regex_t reg;


	totalnum = mib_chain_total(MIB_L2TP_ROUTE_TBL); /* get chain record size */

	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) )
			continue;

		if(!strcmp(entry.tunnelName,tunnelName))
		{
			if(!strcmp(entry.url,url))
			{
				/*route list alredy exist!*/
				checkIt=1;
				return 1;
			}
		}
		else if(!strcmp(tunnelName,MAGIC_TUNNEL_NAME))
		{
			if(url[0] == '\0' || entry.url[0] == '\0')
				continue;

			if(regcomp(&reg, entry.url, cflags))
			{
				printf("failed to compile!\n");
				continue;
			}

			if(!regexec(&reg, url, nmatch, pmatch, 0) || !strcmp(entry.url,url)){
				regfree(&reg);
				return i;
			}

			regfree(&reg);
		}
	}

	if(strstr(tunnelName, MAGIC_TUNNEL_NAME))
		return -1;
	else
		return 0;

}

int Del_LT2P_Route_URL(unsigned char *tunnelName,char *url)
{
	int totalnum,i,checkIt=0;
	MIB_CE_L2TP_ROUTE_T entry;

	totalnum = mib_chain_total(MIB_L2TP_ROUTE_TBL); /* get chain record size */
	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) )
			continue;
		if(!strcmp(entry.tunnelName,tunnelName))
		{
			if(!strcmp(entry.url,url))
			{
				/*match route list!*/
				mib_chain_delete(MIB_L2TP_ROUTE_TBL,i);
				return 1;
			}
		}
	}
	return 0;
}

int Del_L2TP_Route_DIP(unsigned char *tunnelName,unsigned int ipv4_addr1,unsigned int ipv4_addr2)
{
	int totalnum,i,checkIt=0;
	MIB_CE_L2TP_ROUTE_T entry;

	totalnum = mib_chain_total(MIB_L2TP_ROUTE_TBL); /* get chain record size */
	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) )
			continue;
		if(!strcmp(entry.tunnelName,tunnelName))
		{
			if((ipv4_addr1 == entry.ipv4_src_start) && (ipv4_addr2 == entry.ipv4_src_end))
			{

				/*match route list!*/
				mib_chain_delete(MIB_L2TP_ROUTE_TBL,i);
				return 1;
			}
		}
	}
	return 0;
}

int Del_L2TP_Route_SMAC(unsigned char *tunnelName, unsigned char* sMAC_addr)
{
	int totalnum,i,checkIt=0;
	MIB_CE_L2TP_ROUTE_T entry;
	unsigned char atta_sMAC_addr[20];
	unsigned char rtbl_sMAC_addr[20];

	totalnum = mib_chain_total(MIB_L2TP_ROUTE_TBL); /* get chain record size */
	for(i=0;i<totalnum;i++)
	{
		if ( !mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) )
			continue;

		if(!strcmp(entry.tunnelName,tunnelName))
		{
			sprintf(atta_sMAC_addr, "%X:%X:%X:%X:%X:%X", sMAC_addr[0], sMAC_addr[1], sMAC_addr[2], sMAC_addr[3], sMAC_addr[4], sMAC_addr[5]);
			sprintf(rtbl_sMAC_addr, "%X:%X:%X:%X:%X:%X", entry.sMAC[0], entry.sMAC[1], entry.sMAC[2], entry.sMAC[3], entry.sMAC[4], entry.sMAC[5]);
			if(!strcmp(atta_sMAC_addr,rtbl_sMAC_addr))
			{
				/*match route list!*/
				mib_chain_delete(MIB_L2TP_ROUTE_TBL,i);
				return 1;

			}
		}
	}
	return 0;
}

int NF_Flush_L2TP_Dynamic_URL_Route(unsigned char *tunnelName)
{
	unsigned char chain_name[16];


	return 0;

	if(!tunnelName) {
		AUG_PRT("Null pointer !\n");
		return -1;
	}

	if(tunnelName[0] == '\0') {
		AUG_PRT("Null string !\n");
		return -1;
	}

	snprintf(chain_name, sizeof(chain_name), "%s-url", tunnelName);
	AUG_PRT("iptables -t mangle -F %s\n", chain_name);
	va_cmd(IPTABLES, 8, 1, "-t", "mangle", "-F", (char *)chain_name);
}

int NF_Set_L2TP_Dynamic_URL_Route(char *name, struct in_addr addr)
{
	MIB_CE_L2TP_ROUTE_T entry;
	int total_entry,i,enable,status;
	int cflags = REG_EXTENDED;
	regmatch_t pmatch[1];
	const size_t nmatch=1;
	regex_t reg;
	int aclIdx, naptIdx, ret;
	int flags, flags_found, isL2TPup=0;
	char ifname[IFNAMSIZ];
	unsigned char fw_mark[16], dip_str[20];
	unsigned char chain_name[16];
	char ip_route_idx_str[10];
	int ip_route_idx;


	return 0;

	if ( !mib_get(MIB_L2TP_ENABLE, (void *)&enable) ){
		printf("MIB_L2TP_ENABLE is not exist!");
		return -1;
	}

	if(!enable){
		printf("MIB_L2TP_ENABLE is not enable!");
		return 0;
	}

	total_entry = mib_chain_total(MIB_L2TP_ROUTE_TBL);
	for(i=0;i<total_entry;i++)
	{
		if(mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) == 0)
			continue;
		if((entry.url[0] != '\0') && (entry.ipv4_src_start==0) && (entry.ipv4_src_end==0))
		{
			AUG_PRT("%s-%d URL=%s name=%s\n",__func__,__LINE__,entry.url, name);
			if(regcomp(&reg, entry.url, cflags))
			{
				printf("failed to compile!\n");
				continue;
			}
			status = regexec(&reg, name, nmatch, pmatch,  0);
			if(status == REG_NOMATCH){
				printf("No match!\n");
			}
			else if(status==0)
			{
				printf("match:%s\n",name);
				//for(i=pmatch[0].rm_so;i<pmatch[0].rm_eo;++i)
				//	printf("%s",name);
					//putchar(buf[i]);
				//printf("\n");
				printf("addr=0x%x\n",addr.s_addr);
				ifGetName(entry.ifIndex, ifname, sizeof(ifname));
				AUG_PRT("%s-%d entry.ifIndex=%x, ifname=%s\n",__func__,__LINE__,entry.ifIndex,ifname);
				flags_found = getInFlags(ifname, &flags);
				AUG_PRT("%s-%d flags_found=%d\n",__func__,__LINE__,flags_found);
				if (flags_found)
				{
					if (flags & IFF_UP)
					{
					#if 0//def CONFIG_GPON_FEATURE
						if (onu == 5)
							isL2TPup = 1;
					#else
							isL2TPup = 1;
					#endif
					}
				}

				if(isL2TPup)
				{
					memset(fw_mark, 0, sizeof(fw_mark));
					if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
						snprintf(dip_str, sizeof(dip_str), "%s", inet_ntoa(addr));
						snprintf(chain_name, sizeof(chain_name), "%s-url", entry.tunnelName);
						if(va_cmd(IPTABLES, 10, 1, "-t", "mangle", "-C", (char *)chain_name, "-d", dip_str, "-j", "MARK", "--set-mark", fw_mark)) {
							AUG_PRT("iptables -t mangle -A %s -d %s -j MARK --set-mark %s\n", chain_name, dip_str, fw_mark);
							va_cmd(IPTABLES, 10, 1, "-t", "mangle", "-A", (char *)chain_name, "-d", dip_str, "-j", "MARK", "--set-mark", fw_mark);
						} else {
							AUG_PRT("%s has exist in -t mangle %s chain\n", dip_str, chain_name);
						}
					}
				}

				memset(fw_mark, 0, sizeof(fw_mark));
				if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
					ip_route_idx=vpn_tunnel_name_to_table(entry.tunnelName);
					if(ip_route_idx != -1){
						snprintf(ip_route_idx_str, 10, "%d", ip_route_idx);
						AUG_PRT("ip route del default dev %s table %s\n", ifname, ip_route_idx_str);
						va_cmd("/bin/ip", 7, 1, "route", "del", "default", "dev", ifname, "table", ip_route_idx_str);
						AUG_PRT("ip route add default dev %s table %s\n", ifname, ip_route_idx_str);
						va_cmd("/bin/ip", 7, 1, "route", "add", "default", "dev", ifname, "table", ip_route_idx_str);
						AUG_PRT("ip rule del fwmark %s table %s\n", fw_mark, ip_route_idx_str);
						va_cmd("/bin/ip", 6, 1, "rule", "del", "fwmark", fw_mark, "table", ip_route_idx_str);
						AUG_PRT("ip rule add fwmark %s table %s\n", fw_mark, ip_route_idx_str);
						va_cmd("/bin/ip", 6, 1, "rule", "add", "fwmark", fw_mark, "table", ip_route_idx_str);
					}
				}
			}
			regfree(&reg);
		}
	}
}

int NF_Flush_L2TP_Route(unsigned char *tunnelName)
{
	return 0;

	if(!tunnelName) {
		AUG_PRT("Null pointer !\n");
		return -1;
	}

	if(tunnelName[0] == '\0') {
		AUG_PRT("Null string !\n");
		return -1;
	}

	AUG_PRT("iptables -t mangle -F %s\n", tunnelName);
	va_cmd(IPTABLES, 8, 1, "-t", "mangle", "-F", (char *)tunnelName);
}

int NF_Set_L2TP_Policy_Route(unsigned char *tunnelName, ATTACH_MODE_T attach_mode)
{
	MIB_CE_L2TP_ROUTE_T entry;
	int total_entry,i,enable;
	int flags, flags_found, isL2TPup=0;
	char ifname[IFNAMSIZ];
	unsigned char sMAC_mask[MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	unsigned char fw_mark[16], sMAC[20], dip_start_str[20], dip_end_str[20], dip_range[40];
	struct in_addr dip_start, dip_end;
	char ip_route_idx_str[10];
	int ip_route_idx;


	return 0;

	if ( !mib_get(MIB_L2TP_ENABLE, (void *)&enable) ){
		printf("MIB_L2TP_ENABLE is not exist!");
		return -1;
	}

	if(!enable){
		printf("MIB_L2TP_ENABLE is not enable!");
		return 0;
	}

	total_entry = mib_chain_total(MIB_L2TP_ROUTE_TBL);
	for(i=0;i<total_entry;i++)
	{
		if(mib_chain_get(MIB_L2TP_ROUTE_TBL, i, (void *)&entry) == 0)
			continue;

		if(!strcmp(entry.tunnelName,tunnelName))
		{
			if(entry.ipv4_src_start == 0 && entry.ipv4_src_end == 0 && !(entry.sMAC[0]|entry.sMAC[1]|entry.sMAC[2]|entry.sMAC[3]|entry.sMAC[4]|entry.sMAC[5]))/*route by URL*/
				continue;

			//check interface is up or not!
			ifGetName(entry.ifIndex, ifname, sizeof(ifname));
			flags_found = getInFlags(ifname, &flags);
			if (flags_found)
			{
				if (flags & IFF_UP)
				{
					isL2TPup = 1;
				}
			}
			//check interface up or not, if up we set acl rules.
			if(isL2TPup)
			{
				if(entry.ipv4_src_start || entry.ipv4_src_end)
				{
					if(ATTACH_MODE_DIP!=attach_mode)
						continue;

					memset(fw_mark, 0, sizeof(fw_mark));
					if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
						dip_start.s_addr = entry.ipv4_src_start;
						dip_end.s_addr = entry.ipv4_src_end;
						snprintf(dip_start_str, sizeof(dip_start_str), "%s", inet_ntoa(dip_start));
						snprintf(dip_end_str, sizeof(dip_end_str), "%s", inet_ntoa(dip_end));
						snprintf(dip_range, sizeof(dip_range), "%s-%s", dip_start_str, dip_end_str);
						if(va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-C", (char *)tunnelName, "-m", "iprange", "--dst-range", dip_range, "-j", "MARK", "--set-mark", fw_mark)) {
							AUG_PRT("iptables -t mangle -A %s -m iprange --dst-range %s -j MARK --set-mark %s\n", tunnelName, dip_range, fw_mark);
							va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-A", (char *)tunnelName, "-m", "iprange", "--dst-range", dip_range, "-j", "MARK", "--set-mark", fw_mark);
						} else {
							AUG_PRT("%s has exist in -t mangle %s chain\n", dip_range, tunnelName);
						}
					}
				}
				else
				{
					if(ATTACH_MODE_SMAC!=attach_mode)
						continue;

					memset(fw_mark, 0, sizeof(fw_mark));
					if(!VPN_Route_Policy_Get_Mark(fw_mark, entry.tunnelName)) {
						memset(sMAC, 0, sizeof(sMAC));

						snprintf(sMAC, sizeof(sMAC), "%02x:%02x:%02x:%02x:%02x:%02x", entry.sMAC[0], entry.sMAC[1], entry.sMAC[2], entry.sMAC[3], entry.sMAC[4], entry.sMAC[5]);
						if(va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-C", (char *)tunnelName, "-m", "mac", "--mac-source", sMAC, "-j", "MARK", "--set-mark", fw_mark)) {
							AUG_PRT("iptables -t mangle -A %s -m mac --mac-source %s -j MARK --set-mark %s\n", tunnelName, sMAC, fw_mark);
							va_cmd(IPTABLES, 12, 1, "-t", "mangle", "-A", (char *)tunnelName, "-m", "mac", "--mac-source", sMAC, "-j", "MARK", "--set-mark", fw_mark);
						} else {
							AUG_PRT("%s has exist in -t mangle %s chain\n", sMAC, tunnelName);
						}
					}
				}
			}

			memset(fw_mark, 0, sizeof(fw_mark));
			if(!VPN_Route_Policy_Get_Mark(fw_mark, tunnelName)) {
				ip_route_idx=vpn_tunnel_name_to_table(tunnelName);
				if(ip_route_idx != -1){
					snprintf(ip_route_idx_str, 10, "%d", ip_route_idx);
					AUG_PRT("ip route del default dev %s table %s\n", ifname, ip_route_idx_str);
					va_cmd("/bin/ip", 7, 1, "route", "del", "default", "dev", ifname, "table", ip_route_idx_str);
					AUG_PRT("ip route add default dev %s table %s\n", ifname, ip_route_idx_str);
					va_cmd("/bin/ip", 7, 1, "route", "add", "default", "dev", ifname, "table", ip_route_idx_str);
					AUG_PRT("ip rule del fwmark %s table %s\n", fw_mark, ip_route_idx_str);
					va_cmd("/bin/ip", 6, 1, "rule", "del", "fwmark", fw_mark, "table", ip_route_idx_str);
					AUG_PRT("ip rule add fwmark %s table %s\n", fw_mark, ip_route_idx_str);
					va_cmd("/bin/ip", 6, 1, "rule", "add", "fwmark", fw_mark, "table", ip_route_idx_str);
				}
			}
		}
	}

	return 0;
}

MIB_L2TP_T *getL2TPEntryByIfIndex(unsigned int ifIndex, MIB_L2TP_T *p)
{
	unsigned int i,num;
	if( (p==NULL) || (ifIndex==DUMMY_IFINDEX) ) return NULL;
	num = mib_chain_total( MIB_L2TP_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_L2TP_TBL, i, (void*)p ))
			continue;
		if( p->ifIndex==ifIndex )
		{
			printf("%s-%d ifIndex=%d\n",__func__,__LINE__,ifIndex);
			return p;
		}
	}
	return NULL;
}
int getIfIndexByL2TPName(char *pIfname)
{
	unsigned int entryNum, i;
	MIB_L2TP_T Entry;
	char ifname[IFNAMSIZ];
	entryNum = mib_chain_total(MIB_L2TP_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_L2TP_TBL, i, (void *)&Entry))
		{
  			printf("Get chain record error!\n");
			return -1;
		}
		ifGetName(Entry.ifIndex,ifname,sizeof(ifname));
		if(!strcmp(ifname,pIfname)){
			break;
		}
	}
	if(i>= entryNum){
		printf("not find this interface!\n");
		return -1;
	}
	return(Entry.ifIndex);
}

int NF_l2tp_ip_chagne(char *ifname, struct in_addr *new_ip, struct in_addr *ifa_local)
{
	int wan_ifIndex;
	MIB_L2TP_T l2tp_entry = {0};
	unsigned int entrynum, i;
	int enable, ret;


	wan_ifIndex = getIfIndexByL2TPName(ifname);
	if (wan_ifIndex == -1) return 0;
	ret = (intptr_t)getL2TPEntryByIfIndex(wan_ifIndex, &l2tp_entry);
	if (!ret) return 0;
	/* Two addresses are the same means we have not get remote IP yet.*/
	if(ifa_local->s_addr == new_ip->s_addr)
		return 0;

	NF_Flush_L2TP_Route(l2tp_entry.tunnelName);
	NF_Set_L2TP_Policy_Route(l2tp_entry.tunnelName, l2tp_entry.attach_mode);
	return 0;
}
#endif

#ifdef _PRMT_X_CT_COM_PORTALMNT_
static const char *avoid_force_portal_list[]= 
{
	"detectportal.firefox.com",
	"clients1.google.com",
	"login.live.com",
	"ocsp.digicert.com",
	"ocsp2.globalsign.com",
	NULL
};
void setPortalMNT(void)
{
	char tmpstr[MAX_URL_LEN];
	char urlstr[MAX_URL_LEN + 16];
	unsigned char vChar;
	FILE *fp;
#ifdef CONFIG_RTK_L34_ENABLE
	int i, j, mib_id;
#endif

	mib_get(CWMP_CT_PM_ENABLE, &vChar);
	fp = fopen(TR069_FILE_PORTALMNT, "w");
	if(fp)
	{
		if (vChar == 1)
			fwrite("on", 2, 1, fp);
		else{
			fwrite("off", 3, 1, fp);
		}
		fclose(fp);
	}

#ifdef CONFIG_RTK_L34_ENABLE
	mib_id = CWMP_CT_PM_URL4PC;
	for(i=0; i<3; i++){
		/*
		/proc/rg/redirect_first_http_req_set_url
		command:
		a device_type url: add redirect url for specific device type, e.g. for PC (device type = 0) use "a 0 www.google.com"
		d device_type: delete redirect url for specific device type e.g. for STB (device type = 1) use "d 1"
		*/
		if(vChar == 1){
			mib_get(mib_id + i, tmpstr);
			if (tmpstr[0]){
				fp = fopen("/proc/rg/redirect_first_http_req_set_url", "w");
				fprintf(fp, "a %d %s", i, tmpstr);
				fclose(fp);
			}else{
				fp = fopen("/proc/rg/redirect_first_http_req_set_url", "w");
				fprintf(fp, "d %d", i);
				fclose(fp);
			}
		}
		else{
			fp = fopen("/proc/rg/redirect_first_http_req_set_url", "w");
			fprintf(fp, "d %d", i);
			fclose(fp);
		}
		
		for(j=0; avoid_force_portal_list[j]; j++) {
			fp = fopen("/proc/rg/avoid_force_portal_set_url", "w");
			if(fp) {
				fprintf(fp, "%s", avoid_force_portal_list[j]);
				fclose(fp);
			}
		}
		
	}
#endif

	fp = fopen(TR069_FILE_PORTALMNT, "w");
	if(fp)
	{
		mib_get(CWMP_CT_PM_URL4PC, tmpstr);
		if (tmpstr[0]) {
			sprintf(urlstr, "PC_addr:%s", tmpstr);
			fwrite(urlstr, strlen(urlstr), 1, fp);
		}

		mib_get(CWMP_CT_PM_URL4STB, tmpstr);
		if (tmpstr[0]) {
			sprintf(urlstr, "STB_addr:%s", tmpstr);
			fwrite(urlstr, strlen(urlstr), 1, fp);
		}

		mib_get(CWMP_CT_PM_URL4MOBILE, tmpstr);
		if (tmpstr[0]) {
			sprintf(urlstr, "MOB_addr:%s", tmpstr);
			fwrite(urlstr, strlen(urlstr), 1, fp);
		}

		fclose(fp);
	}

}
#endif

#ifdef CONFIG_USER_SNMPD_SNMPD_V2CTRAP
// Added by Mason Yu for ILMI(PVC) community string
static const char PVCREADSTR[] = "ADSL";
static const char PVCWRITESTR[] = "ADSL";
// Added by Mason Yu for write community string
static const char SNMPCOMMSTR[] = "/var/snmpComStr.conf";
// return value:
// 1  : successful
// -1 : startup failed
int startSnmp(void)
{
	unsigned char value[16];
	unsigned char trapip[16];
	unsigned char commRW[100], commRO[100], enterOID[100];
	FILE 	      *fp;

	// Get SNMP Trap Host IP Address
	if(!mib_get( MIB_SNMP_TRAP_IP,  (void *)value)){
		printf("Can no read MIB_SNMP_TRAP_IP\n");
	}

	if (((struct in_addr *)value)->s_addr != 0)
	{
		strncpy(trapip, inet_ntoa(*((struct in_addr *)value)), 16);
		trapip[15] = '\0';
	}
	else
		trapip[0] = '\0';
	//printf("***** trapip = %s\n", trapip);

	// Get CommunityRO String
	if(!mib_get( MIB_SNMP_COMM_RO,  (void *)commRO)) {
		printf("Can no read MIB_SNMP_COMM_RO\n");
	}
	//printf("*****buffer = %s\n", commRO);


	// Get CommunityRW String
	if(!mib_get( MIB_SNMP_COMM_RW,  (void *)commRW)) {
		printf("Can no read MIB_SNMP_COMM_RW\n");
	}
	//printf("*****commRW = %s\n", commRW);


	// Get Enterprise OID
	if(!mib_get( MIB_SNMP_SYS_OID,  (void *)enterOID)) {
		printf("Can no read MIB_SNMP_SYS_OID\n");
	}
	//printf("*****enterOID = %s\n", enterOID);


	// Write community string to file
	if ((fp = fopen(SNMPCOMMSTR, "w")) == NULL)
	{
		printf("Open file %s failed !\n", SNMPCOMMSTR);
		return -1;
	}

	if (commRO[0])
		fprintf(fp, "readStr %s\n", commRO);
	if (commRW[0])
		fprintf(fp, "writeStr %s\n", commRW);

	// Add ILMI(PVC) community string
	fprintf(fp, "PvcReadStr %s\n", PVCREADSTR);
	fprintf(fp, "PvcWriteStr %s\n", PVCWRITESTR);
	fclose(fp);

	// Mason Yu
	// ZyXEL Remote management does not verify the comm string, so we can limit the comm string as "ADSL"
	if (va_niced_cmd("/bin/snmpd", 8, 0, "-p", "161", "-c", PVCREADSTR, "-th", trapip, "-te", enterOID))
	    return -1;
	return 1;

}

#define SNMPPID  "/var/run/snmpd.pid"

int restart_snmp(int flag)
{
	unsigned char value[32];
	int snmppid=0;
	int status=0;

	snmppid = read_pid((char*)SNMPPID);

	//printf("\nsnmppid=%d\n",snmppid);

	if(snmppid > 0) {
		kill(snmppid, 9);
		unlink(SNMPPID);
	}

	if(flag==1){
		status = startSnmp();
	}
	return status;
}
#endif

#define CWMPPID  "/var/run/cwmp.pid"
#if defined(CONFIG_USER_CWMP_TR069) || defined(APPLY_CHANGE)
void off_tr069(void)
{
	int cwmppid=0;
	int status;

#ifdef CONFIG_MIDDLEWARE
	int midware_intf_pid = 0;
	mwSetFirewall(0);
	midware_intf_pid = read_pid((char*)MWINTF_MAIN_RUNFILE);
	if(midware_intf_pid > 0)
		kill(midware_intf_pid, SIGTERM);
#endif	//end of CONFIG_MIDDLEWARE

	cwmppid = read_pid((char*)CWMPPID);

	printf("\ncwmppid=%d\n",cwmppid);

	if(cwmppid > 0)
		kill(cwmppid, 15);

}
#endif

#if defined(IP_ACL) || defined(APPLY_CHANGE)
int restart_acl(void)
{
	unsigned char aclEnable;

	//va_cmd(IPTABLES, 2, 1, "-F", "aclblock");
	mib_get(MIB_ACL_CAPABILITY, (void *)&aclEnable);
	if (aclEnable == 1)  // ACL Capability is enabled
	{
		filter_set_acl(0);
		filter_set_acl(1);
	}
	else
		filter_set_acl(0);

	return 0;
}
#endif

//DNSRELAY

int restart_dnsrelay(void)
{
	unsigned char value[32];
	int dnsrelaypid=0, i, retry = 0;

#ifdef CONFIG_USER_MONITORD
	update_monitor_list_file(basename(DNSRELAY), 0);
#endif

	dnsrelaypid = read_pid((char*)DNSRELAYPID);

	//printf("\ndnsrelaypid=%d\n",dnsrelaypid);

	if(dnsrelaypid > 0)
	{
		kill(dnsrelaypid, SIGTERM);

		// Kaohj -- wait for process termination
		i = 0;
		while (read_pid((char*)DNSRELAYPID) > 0 && i < 10) {
			usleep(100000); i++;
		}
		
		if(i >= 10 )
			kill(dnsrelaypid, SIGKILL);
	}
	
retry:
	if (startDnsRelay() == -1)
	{
		printf("restart DNS relay failed !\n");
		return -1;
	}

	// Mason Yu. We should exit this function until dnsmasq process is created.
	// in order to prevent double run dnsmasq. (dnsmasq: failed to create listening socket: Address already in use)
	i=0;
	while (read_pid((char*)DNSRELAYPID) < 0 && i < 5) {
		usleep(100000); i++;
	}
	if(i >= 5 && retry < 3){
		retry++;
		goto retry;
	}

#ifdef CONFIG_USER_MONITORD
	update_monitor_list_file(basename(DNSRELAY), 1);
#endif

	return 0;

}

int restart_dhcp(void)
{
	unsigned char value[32];
	unsigned int uInt;
	int dhcpserverpid=0,dhcprelaypid=0;
	int tmp_status, status=0, i;
	int lockfd = -1;

	if (mib_get(MIB_DHCP_MODE, (void *)value) != 0)
	{
		uInt = (unsigned int)(*(unsigned char *)value);
//		if (uInt != 0 && uInt !=1 && uInt != 2 )
//			return -1;
	}

	dhcpserverpid = read_pid((char*)DHCPSERVERPID);
	dhcprelaypid = read_pid((char*)DHCPRELAYPID);

	//printf("\ndhcpserverpid=%d,dhcprelaypid=%d\n",dhcpserverpid,dhcprelaypid);
	if(dhcpserverpid > 0) kill(dhcpserverpid, SIGTERM);
	if(dhcprelaypid > 0) kill(dhcprelaypid, SIGTERM);
	
	if(dhcpserverpid > 0)
	{
		i = 0;
		while (kill(dhcpserverpid, 0) == 0 && i < 20) {
			usleep(100000); i++;
		}
		if(i >= 20 )
			kill(dhcpserverpid, SIGKILL);
		
		if(!access(DHCPSERVERPID, F_OK)) unlink(DHCPSERVERPID);
	}
	
	if(dhcprelaypid > 0)
	{
		i = 0;
		while (kill(dhcprelaypid, 0) == 0 && i < 20) {
			usleep(100000); i++;
		}
		if(i >= 20 )
			kill(dhcprelaypid, SIGKILL);
		
		if(!access(DHCPRELAYPID, F_OK)) unlink(DHCPRELAYPID);
	}
	
	if(uInt != DHCP_LAN_SERVER)
	{
		FILE *fp;
		//star:clean the lease file
		if ((lockfd = lock_file_by_flock(DHCPSERVERPID, 1)) == -1)//write file should wait
		{
			printf("%s, the file have been locked\n", __FUNCTION__);
			return -1;
		}

		if ((fp = fopen(DHCPD_LEASE, "w")) == NULL)
		{
			printf("Open file %s failed !\n", DHCPD_LEASE);
			unlock_file_by_flock(lockfd);
			return -1;
		}
		fprintf(fp, "\n");
		fclose(fp);

		unlock_file_by_flock(lockfd);
	}


	if(uInt == DHCP_LAN_SERVER)
	{
		tmp_status = setupDhcpd();
		if (tmp_status == 1)
		{
			//printf("\nrestart dhcpserver!\n");
#ifdef COMBINE_DHCPD_DHCRELAY
			status = va_niced_cmd(DHCPD, 2, 0, "-S", DHCPD_CONF);
#else
			status = va_niced_cmd(DHCPD, 1, 0, DHCPD_CONF);
#endif

			while(read_pid((char*)DHCPSERVERPID) < 0)
				usleep(250000);

			restart_dnsrelay();
		}
		else if (tmp_status == -1)
	   	 	status = -1;
		return status;
	}
	else if(uInt == DHCP_LAN_RELAY)
	{
		startDhcpRelay();
		restart_dnsrelay();
		status=(status==-1)?-1:0;

		return status;
	}
	else
	{
		restart_dnsrelay();
		return 0;
	}



	return -1;
}

//Ip interface
int restart_lanip(void)
{
	char vChar=0;
	unsigned char ipaddr[32]="";
	unsigned char subnet[32]="";
	unsigned char value[6];
	int vInt;
	int status=0;
	FILE * fp;
#ifdef IP_PASSTHROUGH
	unsigned char ippt_addr[32]="";
	unsigned int ippt_itf;
	unsigned long myipaddr,hisipaddr;
	int ippt_flag = 0;
#endif
#ifdef CONFIG_YUEME
	unsigned char cmd_buf[64];

	memset(cmd_buf, 0x0, sizeof(cmd_buf));
#endif

	itfcfg((char *)LANIF, 0);
#ifdef CONFIG_SECONDARY_IP
	itfcfg((char *)LAN_ALIAS, 0);
#endif
#ifdef IP_PASSTHROUGH
	itfcfg((char *)LAN_IPPT, 0);
	if (mib_get(MIB_IPPT_ITF, (void *)&ippt_itf) != 0) {
		if (ippt_itf != DUMMY_IFINDEX) {	// IP passthrough
			fp = fopen ("/tmp/PPPHalfBridge", "r");
			if (fp) {
				fread(&myipaddr, 4, 1, fp);
				// Added by Mason Yu. Access internet fail.
				fclose(fp);
				myipaddr+=1;
				strncpy(ippt_addr, inet_ntoa(*((struct in_addr *)(&myipaddr))), 16);
				ippt_addr[15] = '\0';
				ippt_flag =1;
			}

		}
	}
#endif

#ifdef _CWMP_MIB_
	mib_get(CWMP_LAN_IPIFENABLE, (void *)&vChar);
	if (vChar != 0)
#endif
	{
		if (mib_get(MIB_ADSL_LAN_IP, (void *)value) != 0)
		{
			strncpy(ipaddr, inet_ntoa(*((struct in_addr *)value)), 16);
			ipaddr[15] = '\0';
#ifdef CONFIG_YUEME
			snprintf(cmd_buf, 46, "echo sip %s > /proc/smbshortcut\n", ipaddr);
			system(cmd_buf);
#endif
		}
		if (mib_get(MIB_ADSL_LAN_SUBNET, (void *)value) != 0)
		{
			strncpy(subnet, inet_ntoa(*((struct in_addr *)value)), 16);
			subnet[15] = '\0';
		}

		vInt = 1500;
		snprintf(value, 6, "%d", vInt);
		// set LAN-side MRU
		status|=va_cmd(IFCONFIG, 6, 1, (char*)LANIF, ipaddr, "netmask", subnet, "mtu", value);


#ifdef CONFIG_SECONDARY_IP
		mib_get(MIB_ADSL_LAN_ENABLE_IP2, (void *)value);
		if (value[0] == 1) {
			// ifconfig LANIF LAN_IP netmask LAN_SUBNET
			if (mib_get(MIB_ADSL_LAN_IP2, (void *)value) != 0)
			{
				strncpy(ipaddr, inet_ntoa(*((struct in_addr *)value)), 16);
				ipaddr[15] = '\0';
			}
			if (mib_get(MIB_ADSL_LAN_SUBNET2, (void *)value) != 0)
			{
				strncpy(subnet, inet_ntoa(*((struct in_addr *)value)), 16);
				subnet[15] = '\0';
			}
			snprintf(value, 6, "%d", vInt);
			// set LAN-side MRU
			status|=va_cmd(IFCONFIG, 6, 1, (char*)LAN_ALIAS, ipaddr, "netmask", subnet, "mtu", value);
		}
#endif




#ifdef IP_PASSTHROUGH
               if(ippt_flag)
			   status|=va_cmd(IFCONFIG, 2, 1, (char*)LAN_IPPT,ippt_addr);
#endif

#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
		RG_reset_LAN();
#endif
		status|=restart_dhcp();

// Trigger igmpproxy to update interface info.
#ifdef CONFIG_USER_IGMPPROXY
		vInt = read_pid("/var/run/igmp_pid");
		if (vInt >= 1) {
			// Kick to sync the multicast virtual interfaces
			kill(vInt, SIGUSR1);
		}
#endif
#ifdef CONFIG_CT_AWIFI_JITUAN_SMARTWIFI
    unsigned char functype=0;
    mib_get(AWIFI_PROVINCE_CODE, &functype);
    if(functype == AWIFI_ZJ){
		awifiAddFwRuleChain();
    }
#endif
		// Kaohj -- Disconnect network connection when LAN IP changes
		usleep(250000);
		cmd_killproc(PID_SHIFT(PID_TELNETD));
		return status;
	}
	return -1;
}

//DHCP

#ifdef EMBED
int getOneDhcpClient(char **ppStart, unsigned long *size, char *ip, char *mac, char *liveTime)
{
	struct dhcpOfferedAddr {
	u_int8_t chaddr[16];
	u_int32_t yiaddr;       /* network order */
	u_int32_t expires;      /* host order */
	u_int32_t interfaceType;
	u_int8_t hostName[64];
#ifdef _PRMT_X_CT_SUPPER_DHCP_LEASE_SC
	int category;
	int isCtcVendor;
	char szVendor[36];
	char szModel[36];
	char szFQDN[64];
#endif
	};

	struct dhcpOfferedAddr entry;

	if ( *size < sizeof(entry) )
		return -1;

	entry = *((struct dhcpOfferedAddr *)*ppStart);
	*ppStart = *ppStart + sizeof(entry);
	*size = *size - sizeof(entry);

	if (entry.expires == 0)
		return 0;
//star: conflict ip addr will not be displayed on web
	if(entry.chaddr[0]==0&&entry.chaddr[1]==0&&entry.chaddr[2]==0&&entry.chaddr[3]==0&&entry.chaddr[4]==0&&entry.chaddr[5]==0)
		return 0;

	strcpy(ip, inet_ntoa(*((struct in_addr *)&entry.yiaddr)) );
	snprintf(mac, 20, "%02x:%02x:%02x:%02x:%02x:%02x",
			entry.chaddr[0],entry.chaddr[1],entry.chaddr[2],entry.chaddr[3],
			entry.chaddr[4], entry.chaddr[5]);

#ifdef CONFIG
	// convert liveTime
	u_int32_t time = entry.expires;
	liveTime[0] = '\0';
	if(time > 86400)
	{
		snprintf(liveTime, 80, "%d", time/86400);
		time %= 86400;
	}
	if(time > 3600)
	{
		snprintf(liveTime, 80, "%s%d", liveTime, time/3600);
		time %= 3600;
	}
	if(time > 60)
	{
		snprintf(liveTime, 80, "%s%d", liveTime, time/60);
		time %= 60;
	}
	snprintf(liveTime, 80, "%s%d", liveTime, time);
#else
	snprintf(liveTime, 80, "%lu", (unsigned long)ntohl(entry.expires));
#endif
	return 1;
}
#endif

int delPortForwarding( unsigned int ifindex )
{
	int total,i;

	total = mib_chain_total( MIB_PORT_FW_TBL );
	//for( i=0;i<total;i++ )
	for( i=total-1;i>=0;i-- )
	{
		MIB_CE_PORT_FW_T *c, port_entity;
		c = &port_entity;
		if( !mib_chain_get( MIB_PORT_FW_TBL, i, (void*)c ) )
			continue;

		if(c->ifIndex==ifindex)
			mib_chain_delete( MIB_PORT_FW_TBL, i );
	}
	return 0;
}

int updatePortForwarding( unsigned int old_id, unsigned int new_id )
{
	unsigned int total,i;

	total = mib_chain_total( MIB_PORT_FW_TBL );
	for( i=0;i<total;i++ )
	{
		MIB_CE_PORT_FW_T *c, port_entity;
		c = &port_entity;
		if( !mib_chain_get( MIB_PORT_FW_TBL, i, (void*)c ) )
			continue;

		if(c->ifIndex==old_id)
		{
			c->ifIndex = new_id;
			mib_chain_update( MIB_PORT_FW_TBL, (unsigned char*)c, i );
		}
	}
	return 0;
}

#ifdef CONFIG_USER_ROUTED_ROUTED
int delRipTable(unsigned int ifindex)
{
	int total,i;
	MIB_CE_RIP_T Entry;

	total=mib_chain_total(MIB_RIP_TBL);

	for(i=total-1;i>=0;i--)	{
		mib_chain_get(MIB_RIP_TBL,i,&Entry);
		if (Entry.ifIndex!=ifindex) continue;
		mib_chain_delete(MIB_RIP_TBL,i);
	}
}
#endif

int delRoutingTable( unsigned int ifindex )
{
	int total,i;

	total = mib_chain_total( MIB_IP_ROUTE_TBL );
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
	Flush_RG_static_route_per_WAN(ifindex);
#endif
	//for( i=0;i<total;i++ )
	for( i=total-1;i>=0;i-- )
	{
		MIB_CE_IP_ROUTE_T *c, entity;
		c = &entity;
		if( !mib_chain_get( MIB_IP_ROUTE_TBL, i, (void*)c ) )
			continue;

		if(c->ifIndex==ifindex)
			mib_chain_delete( MIB_IP_ROUTE_TBL, i );
	}
	return 0;
}

int delPPPoESession(unsigned int ifindex)
{
	int totalEntry, i;
	MIB_CE_PPPOE_SESSION_T Entry;

	totalEntry = mib_chain_total(MIB_PPPOE_SESSION_TBL);
	for (i = totalEntry - 1; i >= 0; i--) {
		if (!mib_chain_get(MIB_PPPOE_SESSION_TBL, i, &Entry)) {
			printf("Get chain record error!\n");
			continue;
		}

		if (Entry.uifno == ifindex) {
			mib_chain_delete(MIB_PPPOE_SESSION_TBL, i);
		}
	}
	return 0;
}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
char* ip_qos_classficationtype_str[IP_QOS_CLASSFICATIONTYPE_MAX]={"SMAC","DMAC","8021P","SIP","DIP","SPORT","DPORT","TOS","DSCP",
#ifdef CONFIG_IPV6
				"SIP6","DIP6","SPORT6","DPORT6","TrafficClass",
#endif
				"WANInterface","LANInterface","EtherType"};
unsigned int getQosClassficationType(char *type){
	int  i =0;
	for(i=0;i<IP_QOS_CLASSFICATIONTYPE_MAX;i++){
		if(!strcmp(ip_qos_classficationtype_str[i],type)){
			return (i);
		}
	}
	return IP_QOS_PROTOCOL_MAX;
}

char* ip_qos_protocol_str[IP_QOS_PROTOCOL_MAX]={"TCP","UDP","TCP,UDP","ICMP","ICMP6","RTP","ALL"};
int getProtoType(char *proto){
	int  i =0;
	for(i=0;i<IP_QOS_PROTOCOL_MAX;i++){
		if(!strcmp(ip_qos_protocol_str[i],proto)){
			return i;
		}
	}
	return IP_QOS_PROTOCOL_MAX;
}
int getBitPos(unsigned int bits){
	int i = 0;
	while(i<(sizeof(int)*8)){
		if((1<<i)&bits)
			return i;
		i++;
	}
}

unsigned char getValidClsID(){
	MIB_CE_IP_QOS_CLASSFICATION_T entry;
	unsigned char id=IP_QOS_CLASSFICATION_ID_START;
	int totalClsNums = mib_chain_total(MIB_IP_QOS_CLASSFICATION_TBL);
	int i = 0;
refind:
	i=0;
	for(i=0;i<totalClsNums;i++){
		if(mib_chain_get(MIB_IP_QOS_CLASSFICATION_TBL,i, &entry)){
			if(id==entry.cls_id){
				id++;
				goto refind;
			}
		}
	}
	return id;
}
int getClsPostionInMib(int cls_id){
	MIB_CE_IP_QOS_CLASSFICATION_T entry;
	unsigned char id=0;
	int totalClsNums = mib_chain_total(MIB_IP_QOS_CLASSFICATION_TBL);
	int i = 0;
	for(i=0;i<totalClsNums;i++){
		if(mib_chain_get(MIB_IP_QOS_CLASSFICATION_TBL,i, &entry)){
			if(cls_id==entry.cls_id){
				return i;
			}
		}
	}
	return -1;
}
int getClsIDInMib(int pos){
	MIB_CE_IP_QOS_CLASSFICATION_T entry;
	unsigned char id=0;
	int totalClsNums = mib_chain_total(MIB_IP_QOS_CLASSFICATION_TBL);
	int i = 0;
	for(i=0;i<totalClsNums;i++){
		if(mib_chain_get(MIB_IP_QOS_CLASSFICATION_TBL,i, &entry)){
			if(i==pos){
				return entry.cls_id;
			}
		}
	}
	return -1;
}


int clsTypeProtoToIPQosProto(int clsTypeProto){
	switch(clsTypeProto){
		case IP_QOS_PROTOCOL_TCP:
			return PROTO_TCP;
		case IP_QOS_PROTOCOL_UDP:
			return PROTO_UDP;
		case IP_QOS_PROTOCOL_TCPUDP:
			return PROTO_UDPTCP;
		case IP_QOS_PROTOCOL_ICMP:
			return PROTO_ICMP;
		case IP_QOS_PROTOCOL_ICMP6:
			return PROTO_ICMP;
		case IP_QOS_PROTOCOL_RTP:
			return PROTO_RTP;
		case IP_QOS_PROTOCOL_ALL:
			return PROTO_NONE;
	}
}
int getQosQueueEnable(int prio){
	int totalQosQueueNum = mib_chain_total(MIB_IP_QOS_QUEUE_TBL);
	int i = 0;
	MIB_CE_IP_QOS_QUEUE_T qEntry;
	for (i = 0; i < totalQosQueueNum; i++) {
			if (mib_chain_get(MIB_IP_QOS_QUEUE_TBL, i, &qEntry)) {
				if(qEntry.prior==prio){										
					return qEntry.enable;
				}
			}
	}
	return 0;
}

void QosClassficationToQosRule(int action,int cls_id){
	MIB_CE_IP_QOS_T qosentry;
	MIB_CE_IP_QOS_CLASSFICATION_T clsEntry;
	MIB_CE_IP_QOS_CLASSFICATIONTYPE_T clsTypeEntry;

	int entryNum = mib_chain_total(MIB_IP_QOS_TBL);
	int i=0;
	printf("%s %d cls_id=%d\n",__FUNCTION__,__LINE__,cls_id);
	switch (action){
			case QOSCLASSFICATION_TO_QOSRULE_ACTION_DEL:
				{			
					for (i = 0; i < entryNum; i++) {
						if (mib_chain_get(MIB_IP_QOS_TBL, i, &qosentry)) {
							if((qosentry.cls_id-IP_QOS_CLASSFICATION_QOS_ID_OFFSET)==cls_id){
								printf("%s %d delete MIB_IP_QOS_TBL %d\n",__FUNCTION__,__LINE__,i);
								mib_chain_delete(MIB_IP_QOS_TBL, i);		
								break;
							}
						}
					}
				}
			break;
			case QOSCLASSFICATION_TO_QOSRULE_ACTION_ADD:
			break;
			case QOSCLASSFICATION_TO_QOSRULE_ACTION_MODIFY:
				{
					//delete the old qos rule
					for (i = 0; i < entryNum; i++) {
						if (mib_chain_get(MIB_IP_QOS_TBL, i, &qosentry)) {
							if((qosentry.cls_id-IP_QOS_CLASSFICATION_QOS_ID_OFFSET)==cls_id){
								printf("%s %d delete MIB_IP_QOS_TBL %d\n",__FUNCTION__,__LINE__,i);
								mib_chain_delete(MIB_IP_QOS_TBL, i);		
								break;
							}
						}
					}
					//get clsEntry
					int totalClsNum = mib_chain_total(MIB_IP_QOS_CLASSFICATION_TBL);
					for (i = 0; i < totalClsNum; i++) {
						if (mib_chain_get(MIB_IP_QOS_CLASSFICATION_TBL, i, &clsEntry)) {
							if(clsEntry.cls_id==cls_id){										
								break;
							}
						}
					}
					//add new qos rule
					int totalClsTypeNum = mib_chain_total(MIB_IP_QOS_CLASSFICATIONTYPE_TBL);
					printf("%s %d totalClsTypeNum %d\n",__FUNCTION__,__LINE__,totalClsTypeNum);
					int addQosRuleFlag = 0;
					memset(&qosentry,0,sizeof(qosentry));
					if(clsEntry.m_dscp)
						qosentry.m_dscp=clsEntry.m_dscp<<2;
					qosentry.prior=clsEntry.queue;
					if(clsEntry.m_1p)
						qosentry.m_1p=clsEntry.m_1p+1;
					qosentry.cls_id=clsEntry.cls_id+IP_QOS_CLASSFICATION_QOS_ID_OFFSET;
					qosentry.outif = DUMMY_IFINDEX;
					qosentry.enable = getQosQueueEnable(clsEntry.queue);
					for(i=0;i<totalClsTypeNum;i++){
						if (!mib_chain_get(MIB_IP_QOS_CLASSFICATIONTYPE_TBL, i, &clsTypeEntry)||clsTypeEntry.cls_id!=cls_id)
							continue;
						qosentry.classficationType|=clsTypeEntry.classficationType;
						addQosRuleFlag = 1;
						qosentry.protoType=clsTypeProtoToIPQosProto(clsTypeEntry.protoType);
						printf("qosentry.protoType=%d clsTypeEntry.protoType=%d\n",qosentry.protoType,clsTypeEntry.protoType);
						//Assign the ICMPv6 protocol type to IPv6
						if(clsTypeEntry.protoType == IP_QOS_PROTOCOL_ICMP6)
							qosentry.IpProtocol = IPVER_IPV6;						
						switch(clsTypeEntry.classficationType){
							case (1<<IP_QOS_CLASSFICATIONTYPE_SMAC):								
								memcpy(qosentry.smac,clsTypeEntry.smac,sizeof(qosentry.smac));
								memcpy(qosentry.smac_end,clsTypeEntry.smac_end,sizeof(qosentry.smac_end));
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_DMAC):
								memcpy(qosentry.dmac,clsTypeEntry.dmac,sizeof(qosentry.dmac));
								memcpy(qosentry.dmac_end,clsTypeEntry.dmac_end,sizeof(qosentry.dmac_end));
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_8021P):
								qosentry.vlan1p = clsTypeEntry.vlan1p+1;
								qosentry.vlan1p_end = clsTypeEntry.vlan1p_end+1;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_SIP):
								qosentry.IpProtocol = IPVER_IPV4;
								memcpy(qosentry.sip,clsTypeEntry.sip,sizeof(qosentry.sip));
								memcpy(qosentry.sip_end,clsTypeEntry.sip_end,sizeof(qosentry.sip_end));
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_DIP):								
								qosentry.IpProtocol = IPVER_IPV4;
								memcpy(qosentry.dip,clsTypeEntry.dip,sizeof(qosentry.dip));
								memcpy(qosentry.dip_end,clsTypeEntry.dip_end,sizeof(qosentry.dip_end));
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_SPORT):
								qosentry.IpProtocol = IPVER_IPV4;
								qosentry.sPort = clsTypeEntry.sPort;
								qosentry.sPortRangeMax = clsTypeEntry.sPortRangeMax;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_DPORT):
								qosentry.IpProtocol = IPVER_IPV4;
								qosentry.dPort = clsTypeEntry.dPort;
								qosentry.dPortRangeMax = clsTypeEntry.dPortRangeMax;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_TOS):
								qosentry.IpProtocol = IPVER_IPV4;
								qosentry.tos = clsTypeEntry.tos;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_DSCP):
								qosentry.IpProtocol = IPVER_IPV4;
								qosentry.qosDscp = clsTypeEntry.qosDscp;
								qosentry.qosDscp_end = clsTypeEntry.qosDscp_end;
								break;
#ifdef CONFIG_IPV6
							case (1<<IP_QOS_CLASSFICATIONTYPE_SIP6):
								qosentry.IpProtocol = IPVER_IPV6;
								memcpy(qosentry.sip6,clsTypeEntry.sip6,sizeof(qosentry.sip6));
								qosentry.sip6PrefixLen = 128;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_DIP6):								
								qosentry.IpProtocol = IPVER_IPV6;
								memcpy(qosentry.dip6,clsTypeEntry.dip6,sizeof(qosentry.dip6));
								qosentry.dip6PrefixLen = 128;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_SPORT6):
								qosentry.IpProtocol = IPVER_IPV6;
								qosentry.sPort = clsTypeEntry.sPort6;
								qosentry.sPortRangeMax = clsTypeEntry.sPort6RangeMax;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_DPORT6):
								qosentry.IpProtocol = IPVER_IPV6;
								qosentry.dPort = clsTypeEntry.dPort6;
								qosentry.dPortRangeMax = clsTypeEntry.dPort6RangeMax;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_TrafficClass):
								qosentry.IpProtocol = IPVER_IPV6;
								qosentry.qosDscp = clsTypeEntry.tc;
								qosentry.qosDscp_end = clsTypeEntry.tc_end;
								break;
#endif
							case (1<<IP_QOS_CLASSFICATIONTYPE_WANINTERFACE):
								qosentry.outif = clsTypeEntry.wanitf;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_LANINTERFACE):
								qosentry.phyPort= clsTypeEntry.phyPort;
								qosentry.phyPort_end = clsTypeEntry.phyPort_end;
								break;
							case (1<<IP_QOS_CLASSFICATIONTYPE_ETHERTYPE):
								qosentry.ethType = clsTypeEntry.ethType;	
								if (qosentry.ethType == 0x0800)
									qosentry.IpProtocol = IPVER_IPV4;
								else if (qosentry.ethType == 0x86dd)
									qosentry.IpProtocol = IPVER_IPV6;
								break;
							}
					}
					if(addQosRuleFlag){
						printf("%s %d add MIB_IP_QOS_TBL \n",__FUNCTION__,__LINE__);
						mib_chain_add(MIB_IP_QOS_TBL, &qosentry);
					}
				}
			break;
			default:
			break;
	}
	
}


int delQosClassficationTypeRule(int ifIndex){
	int totalClsTypeRuleNums=mib_chain_total(MIB_IP_QOS_CLASSFICATIONTYPE_TBL);
	int clsTypeRuleIdx = 0;
	for(clsTypeRuleIdx=(totalClsTypeRuleNums-1);clsTypeRuleIdx>=0;clsTypeRuleIdx--){
			MIB_CE_IP_QOS_CLASSFICATIONTYPE_T clsTypeEntry;
			mib_chain_get(MIB_IP_QOS_CLASSFICATIONTYPE_TBL,clsTypeRuleIdx,&clsTypeEntry);
			printf("clsTypeEntry.classficationType=%d clsTypeEntry.wanitf=%d ifIndex=%d\n",clsTypeEntry.classficationType,clsTypeEntry.wanitf,ifIndex);
			if((clsTypeEntry.classficationType==(1<<IP_QOS_CLASSFICATIONTYPE_WANINTERFACE))&&clsTypeEntry.wanitf==ifIndex){
				mib_chain_delete(MIB_IP_QOS_CLASSFICATIONTYPE_TBL,clsTypeRuleIdx);
				QosClassficationToQosRule(QOSCLASSFICATION_TO_QOSRULE_ACTION_MODIFY,clsTypeEntry.cls_id);
			}
		
	}			
	
}
#endif
/*ql:20080926 END*/
#ifdef NEW_IP_QOS_SUPPORT
int delIpQosTcRule(MIB_CE_ATM_VC_Tp pEntry)
{
	int total, i;
	MIB_CE_IP_TC_T entry;

	total = mib_chain_total(MIB_IP_QOS_TC_TBL);
	for (i=total-1; i>=0; i--)
	{
		mib_chain_get(MIB_IP_QOS_TC_TBL, i, &entry);
		if (entry.ifIndex != pEntry->ifIndex)
			continue;

		mib_chain_delete(MIB_IP_QOS_TC_TBL, i);
	}

	return(1);
}
#endif

int updateRoutingTable( unsigned int old_id, unsigned int new_id )
{
	unsigned int total,i;

	total = mib_chain_total( MIB_IP_ROUTE_TBL );
	for( i=0;i<total;i++ )
	{
		MIB_CE_IP_ROUTE_T *c, entity;
		c = &entity;
		if( !mib_chain_get( MIB_IP_ROUTE_TBL, i, (void*)c ) )
			continue;

		if(c->ifIndex==old_id)
		{
			c->ifIndex = new_id;
			mib_chain_update( MIB_IP_ROUTE_TBL, (unsigned char*)c, i );
		}
	}
	return 0;
}

MIB_CE_ATM_VC_T *getATMVCEntryByIfIndex(unsigned int ifIndex, MIB_CE_ATM_VC_T *p)
{
	unsigned int i,num;

	if( (p==NULL) || (ifIndex==DUMMY_IFINDEX) ) return NULL;

	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)p ))
			continue;

		if( p->ifIndex==ifIndex )
		{
			return p;
		}
	}

	return NULL;
}

MIB_CE_ATM_VC_T *getATMVCEntryByIfName(char* ifname, MIB_CE_ATM_VC_T *p)
{
	unsigned int i,num;
	char vcname[IFNAMSIZ];

	if( (p==NULL) || (ifname==NULL) ) return NULL;

	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)p ))
			continue;
		if(ifGetName(p->ifIndex, vcname, sizeof(vcname)) && !strcmp(ifname, vcname))
		{
			return p;
		}
	}

	return NULL;
}

#ifdef _CWMP_MIB_

unsigned int findMaxConDevInstNum(MEDIA_TYPE_T mType)
{
	unsigned int ret=0, i,num;
	MIB_CE_ATM_VC_T *p,vc_entity;

	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		p = &vc_entity;
		if( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)p ))
			continue;
		if (MEDIA_INDEX(p->ifIndex) != mType)
			continue;
		if( p->ConDevInstNum > ret )
			ret = p->ConDevInstNum;
	}

	return ret;
}

unsigned int findConDevInstNumByPVC(unsigned char vpi, unsigned short vci)
{
	unsigned int ret=0, i,num;
	MIB_CE_ATM_VC_T *p,vc_entity;

	if( (vpi==0) && (vci==0) ) return ret;

	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		p = &vc_entity;
		if( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)p ))
			continue;
		if( p->vpi==vpi && p->vci==vci )
		{
			ret = p->ConDevInstNum;
			break;
		}
	}

	return ret;
}

unsigned int findMaxPPPConInstNum(MEDIA_TYPE_T mType, unsigned int condev_inst)
{
	unsigned int ret=0, i,num;
	MIB_CE_ATM_VC_T *p,vc_entity;

	if(condev_inst==0) return ret;

	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		p = &vc_entity;
		if( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)p ))
			continue;
		if (MEDIA_INDEX(p->ifIndex) != mType)
			continue;
		if( p->ConDevInstNum == condev_inst )
		{
			if( (p->cmode==CHANNEL_MODE_PPPOE) ||
#ifdef PPPOE_PASSTHROUGH
			    ((p->cmode==CHANNEL_MODE_BRIDGE)&&(p->brmode==BRIDGE_PPPOE)) ||
#endif
			    (p->cmode==CHANNEL_MODE_PPPOA) )
			{
				if( p->ConPPPInstNum > ret )
					ret = p->ConPPPInstNum;
			}
		}
	}

	return ret;
}

unsigned int findMaxIPConInstNum(MEDIA_TYPE_T mType, unsigned int condev_inst)
{
	unsigned int ret=0, i,num;
	MIB_CE_ATM_VC_T *p,vc_entity;

	if(condev_inst==0) return ret;

	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		p = &vc_entity;
		if( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)p ))
			continue;
		if (MEDIA_INDEX(p->ifIndex) != mType)
			continue;
		if( p->ConDevInstNum==condev_inst )
		{
			if( (p->cmode == CHANNEL_MODE_IPOE) ||
#ifdef PPPOE_PASSTHROUGH
			    ((p->cmode==CHANNEL_MODE_BRIDGE)&&(p->brmode!=BRIDGE_PPPOE)) ||
#else
			    (p->cmode == CHANNEL_MODE_BRIDGE) ||
#endif
			    (p->cmode == CHANNEL_MODE_RT1483) )
			{
				if( p->ConIPInstNum > ret )
					ret = p->ConIPInstNum;
			}
		}
	}

	return ret;
}


/*start use_fun_call_for_wan_instnum*/
int resetWanInstNum(MIB_CE_ATM_VC_Tp entry)
{
	if(entry==NULL) return -1;

	entry->connDisable=0;/*0: always for web/cli*/
	entry->ConDevInstNum=0;
	entry->ConIPInstNum=0;
	entry->ConPPPInstNum=0;
	return 0;
}

int updateWanInstNum(MIB_CE_ATM_VC_Tp entry)
{
	if(entry==NULL) return -1;

#if defined(CONFIG_CMCC) && !defined(CONFIG_CU)
	//CMCC PON always use WANConnectionDevice.1.
	entry->ConDevInstNum = 1;
#else
	if(entry->ConDevInstNum==0)
		entry->ConDevInstNum = 1 + findMaxConDevInstNum(MEDIA_INDEX(entry->ifIndex));
#endif

	if( (entry->cmode==CHANNEL_MODE_PPPOE) ||
#ifdef PPPOE_PASSTHROUGH
	    ((entry->cmode==CHANNEL_MODE_BRIDGE)&&(entry->brmode==BRIDGE_PPPOE)) ||
#endif
	    (entry->cmode==CHANNEL_MODE_PPPOA) )
	{
		if(entry->ConPPPInstNum==0)
			entry->ConPPPInstNum = 1 + findMaxPPPConInstNum(MEDIA_INDEX(entry->ifIndex), entry->ConDevInstNum );

		entry->ConIPInstNum = 0;
	}else{
		entry->ConPPPInstNum = 0;

		if(entry->ConIPInstNum==0)
			entry->ConIPInstNum = 1 + findMaxIPConInstNum(MEDIA_INDEX(entry->ifIndex), entry->ConDevInstNum);
	}

	return 0;
}
/*end use_fun_call_for_wan_instnum*/


/*ping_zhang:20080919 START:add for new telefonica tr069 request: dhcp option*/
#ifdef _PRMT_X_TELEFONICA_ES_DHCPOPTION_
unsigned int findMaxDHCPOptionInstNum( unsigned int usedFor, unsigned int dhcpConSPInstNum)
{
	unsigned int ret=0, i,num;
	MIB_CE_DHCP_OPTION_T *p,DHCPOption_entity;

	num = mib_chain_total( MIB_DHCP_SERVER_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPOption_entity;
		if( !mib_chain_get( MIB_DHCP_SERVER_OPTION_TBL, i, (void*)p ))
			continue;
		if(p->usedFor!=usedFor || dhcpConSPInstNum != p->dhcpConSPInstNum)
			continue;
		if(p->dhcpOptInstNum>ret)
			ret=p->dhcpOptInstNum;
	}

	return ret;
}

int getDHCPOptionByOptInstNum( unsigned int dhcpOptNum, unsigned int dhcpSPNum, unsigned int usedFor, MIB_CE_DHCP_OPTION_T *p, unsigned int *id )
{
	int ret=-1;
	unsigned int i,num;

	if( (dhcpOptNum==0) || (p==NULL) || (id==NULL) )
		return ret;

	num = mib_chain_total( MIB_DHCP_SERVER_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_DHCP_SERVER_OPTION_TBL, i, (void*)p ) )
			continue;

		if( (p->usedFor==usedFor) && (p->dhcpOptInstNum==dhcpOptNum) && (p->dhcpConSPInstNum==dhcpSPNum) )
		{
			*id = i;
			ret = 0;
			break;
		}
	}
	return ret;
}

int getDHCPClientOptionByOptInstNum( unsigned int dhcpOptNum, unsigned int ifIndex, unsigned int usedFor, MIB_CE_DHCP_OPTION_T *p, unsigned int *id )
{
	int ret=-1;
	unsigned int i,num;

	if( (dhcpOptNum==0) || (p==NULL) || (id==NULL) )
		return ret;

	num = mib_chain_total( MIB_DHCP_CLIENT_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_DHCP_CLIENT_OPTION_TBL, i, (void*)p ) )
			continue;

		if( (p->usedFor==usedFor) && (p->dhcpOptInstNum==dhcpOptNum) &&(p->ifIndex==ifIndex) )
		{
			*id = i;
			ret = 0;
			break;
		}
	}
	return ret;
}

unsigned int findMaxDHCPClientOptionInstNum(int usedFor, unsigned int ifIndex)
{
	unsigned int ret=0, i,num;
	MIB_CE_DHCP_OPTION_T *p,DHCPOption_entity;

	num = mib_chain_total( MIB_DHCP_CLIENT_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPOption_entity;
		if( !mib_chain_get( MIB_DHCP_CLIENT_OPTION_TBL, i, (void*)p ))
			continue;
		if(p->usedFor!=usedFor||p->ifIndex!=ifIndex)
			continue;
		if(p->dhcpOptInstNum>ret)
			ret=p->dhcpOptInstNum;
	}

	return ret;

}

unsigned int findDHCPOptionNum(int usedFor, unsigned int ifIndex)
{
	unsigned int ret=0, i,num;
	MIB_CE_DHCP_OPTION_T *p,DHCPOption_entity;

	num = mib_chain_total( MIB_DHCP_CLIENT_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPOption_entity;
		if( !mib_chain_get( MIB_DHCP_CLIENT_OPTION_TBL, i, (void*)p ))
			continue;
		if(p->usedFor==usedFor && p->ifIndex==ifIndex)
			ret++;
	}

	return ret;

}

unsigned int findMaxDHCPReqOptionOrder(unsigned int ifIndex)
{
	unsigned int ret=0, i,num;
	MIB_CE_DHCP_OPTION_T *p,DHCPSP_entity;

	num = mib_chain_total( MIB_DHCP_CLIENT_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPSP_entity;
		if( !mib_chain_get( MIB_DHCP_CLIENT_OPTION_TBL, i, (void*)p ))
			continue;
		if(p->usedFor!=eUsedFor_DHCPClient_Req)
			continue;
#ifdef _PRMT_X_CT_COM_IPoEDiagnostics_
		if(!isSimuInterface&&(p->ifIndex != ifIndex))
			continue;
		if(isSimuInterface&&((p->ifIndex-SIMU_INTERFACE_OFFSET) != ifIndex))
			continue;
#else
		if(p->ifIndex != ifIndex)
			continue;
#endif			
		if(p->order>ret)
			ret=p->order;
	}

	return ret;
}

unsigned int findMaxDHCPConSPInsNum(void )
{
	unsigned int ret=0, i,num;
	DHCPS_SERVING_POOL_T *p,DHCPSP_entity;

	num = mib_chain_total( MIB_DHCPS_SERVING_POOL_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPSP_entity;
		if( !mib_chain_get( MIB_DHCPS_SERVING_POOL_TBL, i, (void*)p ))
			continue;
		if(p->InstanceNum>ret)
			ret=p->InstanceNum;
	}

	return ret;
}

unsigned int findMaxDHCPConSPOrder(void )
{
	unsigned int ret=0, i,num;
	DHCPS_SERVING_POOL_T *p,DHCPSP_entity;

	num = mib_chain_total( MIB_DHCPS_SERVING_POOL_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPSP_entity;
		if( !mib_chain_get( MIB_DHCPS_SERVING_POOL_TBL, i, (void*)p ))
			continue;
		if(p->poolorder>ret)
			ret=p->poolorder;
	}

	return ret;
}

int getDHCPConSPByInstNum( unsigned int dhcpspNum,  DHCPS_SERVING_POOL_T *p, unsigned int *id )
{
	int ret=-1;
	unsigned int i,num;

	if( (dhcpspNum==0) || (p==NULL) || (id==NULL) )
		return ret;

	num = mib_chain_total( MIB_DHCPS_SERVING_POOL_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_DHCPS_SERVING_POOL_TBL, i, (void*)p ) )
			continue;

		if( p->InstanceNum==dhcpspNum)
		{
			*id = i;
			ret = 0;
			break;
		}
	}
	return ret;
}

/*ping_zhang:20090319 START:replace ip range with serving pool of tr069*/
void clearOptTbl(unsigned int instnum)
{
	unsigned int  i,num,found;
	MIB_CE_DHCP_OPTION_T *p,DHCPOption_entity;

delOpt:
	num = mib_chain_total( MIB_DHCP_SERVER_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPOption_entity;
		if( !mib_chain_get( MIB_DHCP_SERVER_OPTION_TBL, i, (void*)p ))
			continue;
		if(p->usedFor!=eUsedFor_DHCPServer_ServingPool)
			continue;
		if(p->dhcpConSPInstNum==instnum){
			mib_chain_delete(MIB_DHCP_SERVER_OPTION_TBL,i);
			break;
		}
	}
	if(i<num)
		goto delOpt;
	return;

}

unsigned int getSPDHCPOptEntryNum(unsigned int usedFor, unsigned int instnum)
{
	unsigned int ret=0, i,num;
	MIB_CE_DHCP_OPTION_T *p,DHCPOPT_entity;

	num = mib_chain_total( MIB_DHCP_SERVER_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		p = &DHCPOPT_entity;
		if( !mib_chain_get( MIB_DHCP_SERVER_OPTION_TBL, i, (void*)p ))
			continue;
		if(p->usedFor==usedFor && p->dhcpConSPInstNum==instnum)
			ret++;
	}

	return ret;
}

int getSPDHCPRsvOptEntryByCode(unsigned int instnum, unsigned char optCode, MIB_CE_DHCP_OPTION_T *optEntry ,int *id)
{
	unsigned int ret=-1, i,num;

	if(!optEntry)	return ret;

	num = mib_chain_total( MIB_DHCP_SERVER_OPTION_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_DHCP_SERVER_OPTION_TBL, i, (void*)optEntry ))
			continue;
		if(optEntry->usedFor==eUsedFor_DHCPServer_ServingPool
			&& optEntry->dhcpConSPInstNum==instnum
			&& optEntry->tag==optCode)
		{
			*id = i;
			ret = 0;
			break;
		}
	}

	return ret;
}

void initSPDHCPOptEntry(DHCPS_SERVING_POOL_T *p)
{
	char origstr[GENERAL_LEN];
	char *origstrDomain=origstr;

	if(!p)
		return;

	memset( p, 0, sizeof( DHCPS_SERVING_POOL_T ) );
	p->enable = 1;
	p->poolorder = findMaxDHCPConSPOrder() + 1;
	strncpy(p->vendorclassmode,"Substring",MODE_LEN-1);
	p->vendorclassmode[MODE_LEN-1]=0;
	p->InstanceNum = findMaxDHCPConSPInsNum() +1;
	p->leasetime=86400;
	p->localserved = 1;//default: locallyserved=true;
	memset(p->chaddrmask,0xff,MAC_ADDR_LEN);//default to all 0xff
	mib_get(MIB_ADSL_LAN_DHCP_DOMAIN, (void *)origstrDomain);
	strncpy(p->domainname,origstrDomain,GENERAL_LEN-1);
	p->domainname[GENERAL_LEN-1]=0;
	mib_get(MIB_ADSL_LAN_DHCP_GATEWAY, (void *)p->iprouter);
#ifdef DHCPS_POOL_COMPLETE_IP
	mib_get(MIB_DHCP_SUBNET_MASK, (void *)p->subnetmask);
#else
	mib_get(MIB_ADSL_LAN_SUBNET, (void *)p->subnetmask);
#endif
}

int delDhcpcOption( unsigned int ifindex )
{
	MIB_CE_DHCP_OPTION_T entry;
	int i, entrynum;

	entrynum = mib_chain_total(MIB_DHCP_CLIENT_OPTION_TBL);
	for (i=entrynum-1; i>=0; i--)
	{
		if (!mib_chain_get(MIB_DHCP_CLIENT_OPTION_TBL, i, (void *)&entry))
			continue;

		if (entry.ifIndex == ifindex)
			mib_chain_delete(MIB_DHCP_CLIENT_OPTION_TBL, i);
	}
	return 0;
}
#ifdef _PRMT_X_CT_COM_IPoEDiagnostics_
int isSimuInterface = 0;
//delete the simlate interface
extern int simu_debug;
int ipoeSimulationStop(int wanIfIndex){
	 int dhcpc_pid;
	 int totalNum;
	 int i=0;
	 MIB_CE_ATM_VC_T sEntry;
	 char ifname[IFNAMSIZ];
	 char ifname_simu[IFNAMSIZ];
	 char devname[IFNAMSIZ];
	 int autosimu = 0;
	 if(ifGetName(PHY_INTF(wanIfIndex), devname, sizeof(devname)) == NULL){
	 	return -1;
	 }
	 snprintf(ifname_simu, IFNAMSIZ,  "%s_%d", devname, autosimu);
     printf("Release DHCPClient ifname=%s\n",ifname_simu);
            // DHCP Client
            char dhcpc_pid_filename[32+1];
            snprintf(dhcpc_pid_filename, 32, "%s.%s", (char*)DHCPC_PID, ifname_simu);
            dhcpc_pid = read_pid((char*)dhcpc_pid_filename);
            if (dhcpc_pid > 0) {
                   kill(dhcpc_pid, SIGUSR2); // force release
                   kill(dhcpc_pid, SIGTERM);
            }         
			va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
			//if(simu_debug)
			
#ifdef CONFIG_USER_IP_QOS_3
            restore_hw_queue();
#endif
			//delete all dhcp option table
			fprintf(stderr,"%s %d sEntry.ifIndex =%d\n",__FUNCTION__,__LINE__,wanIfIndex);
			delDhcpcOption(wanIfIndex+SIMU_INTERFACE_OFFSET);
				
			totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
			for(i = 0; i < totalNum; i++)
			{
				if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&sEntry))
					return -2;

				if(sEntry.ifIndex==wanIfIndex)
				{
					RG_Del_Simu_Trap_ACL(sEntry.cdvt);
					RG_WAN_Interface_Del(sEntry.rg_wan_idx);
					printf("[%s %d][SIMU]DEL, ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, sEntry.rg_wan_idx, sEntry.cdvt);
					mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);
					break;
				}
			}
			
}

/*
	Manual start the ipoe simulation.

return :
	  0 : - start success
	-1 : - parameter invalid, null point.
	-2 : - mib operator failed
	-3 : - devname invalid, no such wan
*/
int ipoeSimulationStart(char* devname,char* macAddr,char* vendorClassID)
{
	int i;
	int totalNum;
	MIB_CE_ATM_VC_T Entry;
	MIB_CE_ATM_VC_T simuEntry;
	unsigned char ipt = 0;
	char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
	char buff[256];
	struct data_to_pass_st msg;
	struct sysinfo info;
	int simStartTime = 0;
	int autosimu = 0;

	//if(simu_debug)
		printf("[SIMU]ipoeSimulationStart\n");
	if(NULL == devname)
		return -1;

	//ipv6AddrMode = 0;
	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
				return -2;

		if(Entry.enable == 0)
			continue;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(Entry.ifIndex), ifname, sizeof(ifname));
		if(!strncmp(devname, ifname, IFNAMSIZ))
		{
			ipt = Entry.IpProtocol - 1;
			/*
			if((Entry.cmode != CHANNEL_MODE_BRIDGE)&&(ipt>0))
			{
				// 1 - SLAAC; 2 - DHCPv6
				ipv6AddrMode = (Entry.AddrMode&0x1)?1:2;
			}
			*/
			break;
		}
	}

	if(i == totalNum)
	{
		if(simu_debug)
			printf("[%s %d][SIMU]dev(%s) not found in ATM_VC_TBL\n", __func__, __LINE__, devname);
		return -3;
	}

	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			return -2;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(simuEntry.ifIndex), ifname, sizeof(ifname));
		if((!strncmp(devname, ifname, IFNAMSIZ))&&(1 == simuEntry.mbs))
		{
			//duplicate...
			break;
		}
	}

	memcpy(&simuEntry, &Entry, sizeof(MIB_CE_ATM_VC_T));
	simuEntry.applicationtype = X_CT_SRV_INTERNET;
	simuEntry.cmode = CHANNEL_MODE_IPOE;
	simuEntry.ipDhcp =DHCP_CLIENT;
	simuEntry.mbs = 1;
	memcpy(simuEntry.MacAddr,macAddr,MAC_ADDR_LEN);	
#if defined(ITF_GROUP) || defined(NEW_PORTMAPPING)
    simuEntry.itfGroup = 0;     //simu connection, no need to bind with any lan dev
#endif
	memset(&simuEntry.dhcpv6_opt16_enable[0],0,(&simuEntry.dhcp_opt125_value[0][0]-&simuEntry.dhcpv6_opt16_enable[0]));
	fprintf(stderr,"(&simuEntry.dhcp_opt125_value-&simuEntry.dhcpv6_opt16_enable[0])=%d\n",(&simuEntry.dhcp_opt125_value[0][0]-&simuEntry.dhcpv6_opt16_enable[0]));
	if(vendorClassID&&strlen(vendorClassID)){
		simuEntry.dhcp_opt60_enable[0]=1;
		simuEntry.dhcp_opt60_value_mode[0]=0;
		simuEntry.dhcp_opt60_type[0]=60;
		memcpy(simuEntry.dhcp_opt60_value[0],vendorClassID,strlen(vendorClassID));
	}
	//add all dhcp options
	
	if(i != totalNum)
	{
		mib_chain_update(MIB_SIMU_ATM_VC_TBL, &simuEntry, i);
	}
	else
	{
		fprintf(stderr,"add MIB_SIMU_ATM_VC_TBL chain simuEntry.wanifindex %d\n",simuEntry);
		mib_chain_add(MIB_SIMU_ATM_VC_TBL, &simuEntry);
	}

	//generate Simulation WAN
	snprintf(ifname_simu, IFNAMSIZ,  "%s_%d", devname, autosimu);
#ifdef CONFIG_RTK_L34_ENABLE
	RG_Add_Simu_Trap_ACL(simuEntry.MacAddr, &simuEntry.cdvt);
	RG_add_simu_wan(&simuEntry, i);
	if(simu_debug)
		printf("[%s %d][SIMU]ADD ifname=%s, wan_idx=%d, acl_idx=%d\n", __func__, __LINE__, ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#endif
	addSimuEthWANdev(&simuEntry, autosimu);
	setup_simu_ethernet_config(&simuEntry, ifname_simu);
		
	startIP(ifname_simu, &simuEntry, CHANNEL_MODE_IPOE); 
	sysinfo(&info);
	simStartTime = (int)info.uptime;

	mib_set(MIB_AUTO_DIAG_STARTTIME, (void *)&simStartTime);
	return 0;
}
void parseIPOEPingResult(ipoe_diag_t* ipoeemu){
	
	FILE *fp=NULL;
	char line[1024+1];
	unsigned int transmittedPackets=0;
	unsigned int receivedPackets=0;
	float MinimumResponseTime;
	float AverageResponseTime;
	float MaximumResponseTime;
	ipoeemu->SuccessCount = 0;
	ipoeemu->FailureCount = ipoeemu->PingNumberOfRepetitions;
	ipoeemu->MinimumResponseTime=0;
	ipoeemu->AverageResponseTime=0;
	ipoeemu->MaximumResponseTime=0;
   	if ((fp = fopen(IPOE_EMU_PING_DIAG_OUTPUT_FILENAME, "r")) == NULL){			
			memcpy(ipoeemu->result.result, "DestinationPingFail", strlen("DestinationPingFail"));
			return;
	}
	while(fgets(line,sizeof(line)-1,fp)){
		if(strstr(line,"packets transmitted")){
			if(sscanf(line,"%u packets transmitted, %u packets received,%*s\n",&ipoeemu->FailureCount,&ipoeemu->SuccessCount)==2){
				ipoeemu->FailureCount = ipoeemu->PingNumberOfRepetitions-ipoeemu->SuccessCount;
				if(simu_debug)
					printf("SuccessCount=%d,FailureCount=%d\n",ipoeemu->SuccessCount,ipoeemu->FailureCount);
			}
		}else if(strstr(line,"round-trip")){
			if(sscanf(line,"round-trip min/avg/max = %f/%f/%f ms\n",&MinimumResponseTime,&AverageResponseTime,&MaximumResponseTime)==3){
				ipoeemu->MinimumResponseTime=(uint)MinimumResponseTime;
				ipoeemu->AverageResponseTime=(uint)AverageResponseTime;
				ipoeemu->MaximumResponseTime=(uint)MaximumResponseTime;
				memcpy(ipoeemu->result.result, "Success", strlen("Success"));
				if(simu_debug)
					printf("MinimumResponseTime=%f,AverageResponseTime=%f MaximumResponseTime=%f\n",MinimumResponseTime,AverageResponseTime,MaximumResponseTime);
			}
		}	
	}	
	
	if(fp){
		fclose(fp);
	}	
}
/*
return :
	 0 : - get success
	-1 : - devname invalid(null or not exist)
	-2 : - mib operator failed
	-3 : - time-out!
	-4 : - result file not exist.
	-5 : - inprocess.
*/
int getIpoeSimulationResult(char* devname, ipoe_diag_t* ipoeemu)
{
	long queryTime = 0;
	struct sysinfo info;
	int i, totalNum;
	int if_unit=-1, resultNum=-1;
	MIB_CE_ATM_VC_T simuEntry;
	unsigned char ipt = 0;
	char ifname[IFNAMSIZ];
	char ifname_simu[IFNAMSIZ];
	char filename[64];
	unsigned char buf[300];
	char dhcpState[1024];
	unsigned char strName[16];
	unsigned char strVal[256];
	FILE *fp=NULL;
	int simStartTime = 0;
	int autosimu = 0;
	unsigned int pid;
	int flags, flags_found;
	struct in_addr inAddr;
	char ipoe_dhcpc_state_filename[32]={0};
	FILE* ipoe_dhcpc_state_filename_f=NULL;
	fprintf(stderr, "[SIMU]getSimulationResult\n");
	if((NULL == devname)||(NULL == ipoeemu))
		return -1;

	sysinfo(&info);
	queryTime = (int)info.uptime;
	memset(&ipoeemu->result, 0, sizeof(struct DIAG_RESULT_T));
	mib_get(MIB_AUTO_DIAG_STARTTIME, (void *)&simStartTime);

	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			return -2;

		memset(ifname, 0, IFNAMSIZ);
		ifGetName(PHY_INTF(simuEntry.ifIndex), ifname, sizeof(ifname));
		if((!strncmp(devname, ifname, IFNAMSIZ))&&(1 == simuEntry.mbs))
		{
			//exist
			ipt = simuEntry.IpProtocol - 1;
			break;
		}
	}

	if(i == totalNum)
	{
		if(simu_debug)
			printf("[SIMU]No simulation on dev %s\n", devname);
		return -1;
	}

	snprintf(ifname_simu, IFNAMSIZ,  "%s_%d", devname, autosimu);
	sprintf(ipoe_dhcpc_state_filename, "%s.%s", DEFAULT_STATE_FILE, ifname_simu);
	ipoe_dhcpc_state_filename_f = fopen (ipoe_dhcpc_state_filename,"r");
	if (ipoe_dhcpc_state_filename_f!=NULL){
		memset(dhcpState,0,sizeof(dhcpState));
		fscanf(ipoe_dhcpc_state_filename_f,"%s",dhcpState);
		fclose (ipoe_dhcpc_state_filename_f);
	}
	fprintf(stderr,"[SIMU]dhcpState=%s\n", dhcpState);
	if(strcmp(dhcpState,"BOUND")){
			//result file not exist.
		if((queryTime-simStartTime)>=30)	//time-out
		{
			if(simu_debug)			
				printf("[SIMU]TimeOut and File(%s) not exist, dev=%s\n", ifname_simu, devname);				  
			int dhcperr = getDHCPError(ifname_simu);
			switch(dhcperr){
				case 1:
					strncpy(ipoeemu->result.result,"SendDHCPMsgError",sizeof(ipoeemu->result.result));
					break;
				case 2:
					strncpy(ipoeemu->result.result,"ServerNotFound",sizeof(ipoeemu->result.result));
					break;
				case 3:
					strncpy(ipoeemu->result.result,"ServerDeny",sizeof(ipoeemu->result.result));
					break;
				default:
					strncpy(ipoeemu->result.result,"GetIPAddressTimeout",sizeof(ipoeemu->result.result));
					break;
			}			
			return -3;
		}else{		
			return -5;
		}
	}else{
		flags_found = getInFlags(ifname_simu, &flags);
		if(flags_found){	
#ifdef EMBED
			if (getInAddr(ifname_simu, IP_ADDR, &inAddr) == 1) {	
				strcpy(ipoeemu->result.ipAddr, inet_ntoa(inAddr));
			}else
				return -4;
#endif

			if ( getInAddr(ifname_simu, SUBNET_MASK, &inAddr) == 1) {
				strcpy(ipoeemu->result.netmask, inet_ntoa(inAddr));
			}else
				return -4;

			FILE *fp = NULL;
			char fname[128] = {0};
			sprintf(fname, "%s.%s", MER_GWINFO, ifname_simu);
			if(fp = fopen(fname, "r"))
			{
				fscanf(fp, "%s", ipoeemu->result.gateWay);
				fclose(fp);
			}else
				return -4;
			if(simu_debug){
				printf("%s %d state.ipAddr=%s\n",__FUNCTION__,__LINE__,ipoeemu->result.ipAddr);
				printf("%s %d state.netmask=%s\n",__FUNCTION__,__LINE__,ipoeemu->result.netmask);
				printf("%s %d state.gateWay=%s\n",__FUNCTION__,__LINE__,ipoeemu->result.gateWay);
				printf("%s %d PingDestIPAddress=%s\n",__FUNCTION__,__LINE__,ipoeemu->PingDestIPAddress);
				printf("%s %d PingNumberOfRepetitions=%d\n",__FUNCTION__,__LINE__,ipoeemu->PingNumberOfRepetitions);
			}
			//start ping
			if(strlen(ipoeemu->PingDestIPAddress)&&ipoeemu->PingNumberOfRepetitions){
				char * argv[14];
				int idx = 0;
				char ifname[16], repetitions[16], timeout[16];
				pid_t wpid;
				int status = -1;
				argv[idx++] = "/bin/ping";				
	
				// interface
				if(ifname_simu && strlen(ifname_simu) > 0)
				{
					argv[idx++] = "-I";
					argv[idx++] = ifname_simu;
				}

				//repetitions
				if(ipoeemu->PingNumberOfRepetitions > 0)
				{
					argv[idx++] = "-c";
					sprintf(repetitions, "%d", ipoeemu->PingNumberOfRepetitions);
					argv[idx++] = repetitions;
				}

				//timeout
				argv[idx++] = "-W";
				sprintf(timeout, "%d", ipoeemu->Timeout/1000);
				argv[idx++] = timeout;
				//host
				argv[idx++] = ipoeemu->PingDestIPAddress;
				argv[idx++] = "-q";

				argv[idx] = NULL;
				while(i<idx){
					fprintf(stderr,"%s ",argv[i]);
					i++;
				}
				pid_t ping_pid = fork();
				if(ping_pid == 0)
				{
					int pingout = open(IPOE_EMU_PING_DIAG_OUTPUT_FILENAME, O_RDWR|O_CREAT|O_TRUNC, 0600);
					if (-1 == pingout) { 
						exit(-1);
					}
					if (-1 == dup2(pingout, fileno(stdout))) {
						exit(-1);
					}
					execv("/bin/ping", argv);
					fflush(stdout);
					close(pingout);
					exit(-1);
				}
				else if(ping_pid > 0)
				{
					/* parent, wait till ping process end */
					while ((wpid = wait(&status)) != ping_pid)
					{
						if (wpid == -1 && errno == ECHILD)	/* see wait(2) manpage */
							break;
					}

					if(WIFSIGNALED(status))
						status = 0;
					else
						status = WEXITSTATUS(status);
					parseIPOEPingResult(ipoeemu);
				}
			}

		}
	}
	
	return 0;
}


#endif


void compact_reqoption_order(unsigned int ifIndex)
{
	//int ret=-1;
	int num,i,j;
	int maxorder;
	MIB_CE_DHCP_OPTION_T *p,pentry;
	char *orderflag;

	while(1){
		p=&pentry;
		maxorder=findMaxDHCPReqOptionOrder(ifIndex);
		orderflag=(char*)malloc(maxorder+1);
		if(orderflag==NULL) return;
		memset(orderflag,0,maxorder+1);

		num = mib_chain_total( MIB_DHCP_CLIENT_OPTION_TBL );
		for( i=0; i<num;i++ )
		{

				if( !mib_chain_get( MIB_DHCP_CLIENT_OPTION_TBL, i, (void*)p ))
					continue;
				if(p->usedFor!=eUsedFor_DHCPClient_Req)
					continue;
#ifdef _PRMT_X_CT_COM_IPoEDiagnostics_
				if (!isSimuInterface&&p->ifIndex != ifIndex)
					continue;
				if (isSimuInterface&&(p->ifIndex -SIMU_INTERFACE_OFFSET)!= ifIndex)
					continue;
#else				
				if(p->ifIndex != ifIndex)
					continue;
#endif				
				orderflag[p->order]=1;
		}
		for(j=1;j<=maxorder;j++){
			if(orderflag[j]==0)
				break;
		} //star: there only one 0 in orderflag array
		if(j==(maxorder+1))
		{
			if(orderflag)
			{
				free(orderflag);
				orderflag=NULL;
			}
			break;
		}
		for( i=0; i<num;i++ )
		{

				if( !mib_chain_get( MIB_DHCP_CLIENT_OPTION_TBL, i, (void*)p ))
					continue;
				if(p->usedFor!=eUsedFor_DHCPClient_Req)
					continue;
#ifdef _PRMT_X_CT_COM_IPoEDiagnostics_
				if (!isSimuInterface&&p->ifIndex != ifIndex)
					continue;
				if (isSimuInterface&&(p->ifIndex -SIMU_INTERFACE_OFFSET)!= ifIndex)
					continue;
#else				
				if(p->ifIndex != ifIndex)
					continue;
#endif				
				if(p->order>j){
					(p->order)--;
					mib_chain_update(MIB_DHCP_CLIENT_OPTION_TBL,(void*)p,i);
				}
		}

		if(orderflag)
		{
			free(orderflag);
			orderflag=NULL;
		}
	}

}
/*ping_zhang:20090319 END*/
#endif
/*ping_zhang:20080919 END*/

MIB_CE_ATM_VC_T *getATMVCByInstNum( unsigned int devnum, unsigned int ipnum, unsigned int pppnum, MIB_CE_ATM_VC_T *p, unsigned int *chainid )
{
	unsigned int i,num;

	if( (p==NULL) || (chainid==NULL) ) return NULL;

	num = mib_chain_total( MIB_ATM_VC_TBL );
	for( i=0; i<num;i++ )
	{
		if( !mib_chain_get( MIB_ATM_VC_TBL, i, (void*)p ))
			continue;

		if( (p->ConDevInstNum==devnum) &&
		    (p->ConIPInstNum==ipnum) &&
		    (p->ConPPPInstNum==pppnum) )
		{
			*chainid=i;
			return p;
		}
	}

	return NULL;
}

#if defined(IP_QOS) || defined(CONFIG_USER_IP_QOS_3)
unsigned int getQoSQueueNum(void)
{
	unsigned int i,entryNum,num=0;
	MIB_CE_IP_QOS_QUEUE_T entry;

	entryNum = mib_chain_total(MIB_IP_QOS_QUEUE_TBL);
	for(i=0; i<entryNum; i++)
	{
		if( !mib_chain_get( MIB_IP_QOS_QUEUE_TBL, i, (void*)&entry ))
			continue;

		num++;
	}
	return num;
}
#endif

#ifdef _PRMT_TR143_
static const char gUDPEchoServerName[] = "/bin/udpechoserver";
static const char gUDPEchoServerPid[] = "/var/run/udpechoserver.pid";

void UDPEchoConfigSave(struct TR143_UDPEchoConfig *p)
{
	if(p)
	{
		unsigned char itftype;
		mib_get( TR143_UDPECHO_ENABLE, (void *)&p->Enable );
		mib_get( TR143_UDPECHO_SRCIP, (void *)p->SourceIPAddress );
		mib_get( TR143_UDPECHO_PORT, (void *)&p->UDPPort );
		mib_get( TR143_UDPECHO_PLUS, (void *)&p->EchoPlusEnabled );

		mib_get( TR143_UDPECHO_ITFTYPE, (void *)&itftype );
		if(itftype==ITF_WAN)
		{
			int total,i;
			MIB_CE_ATM_VC_T *pEntry, vc_entity;

			p->Interface[0]=0;
			total = mib_chain_total(MIB_ATM_VC_TBL);
			for( i=0; i<total; i++ )
			{
				pEntry = &vc_entity;
				if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)pEntry ) )
					continue;
				if(pEntry->TR143UDPEchoItf)
				{
					ifGetName(pEntry->ifIndex, p->Interface, sizeof(p->Interface));
				}
			}
		}else if(itftype<ITF_END)
		{
			strcpy( p->Interface, strItf[itftype] );
			LANDEVNAME2BR0(p->Interface);
		}else
			p->Interface[0]=0;

	}
	return;
}

int UDPEchoConfigStart( struct TR143_UDPEchoConfig *p )
{
	if(!p) return -1;

	if( p->Enable )
	{
		char strPort[16], strAddr[32];
		char *argv[10];
		int  i;

		if(p->UDPPort==0)
		{
			fprintf( stderr, "UDPEchoConfigStart> error p->UDPPort=0\n" );
			return -1;
		}
		sprintf( strPort, "%u", p->UDPPort );
		va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", FW_ADD, (char *)FW_PREROUTING,
			 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
			(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);


		i=0;
		argv[i]=(char *)gUDPEchoServerName;
		i++;
		argv[i]="-port";
		i++;
		argv[i]=strPort;
		i++;
		if( strlen(p->Interface) > 0 )
		{
			argv[i]="-i";
			i++;
			argv[i]=p->Interface;
			i++;
		}
		if( p->SourceIPAddress[0]!=0 ||
			p->SourceIPAddress[1]!=0 ||
			p->SourceIPAddress[2]!=0 ||
			p->SourceIPAddress[3]!=0  )
		{
			struct in_addr *pSIP = (struct in_addr *)p->SourceIPAddress;
			argv[i]="-addr";
			i++;
			sprintf( strAddr, "%s", inet_ntoa( *pSIP ) );
			argv[i]=strAddr;
			i++;
		}
		if( p->EchoPlusEnabled )
		{
			argv[i]="-plus";
			i++;
		}

		argv[i]=NULL;
		do_nice_cmd( gUDPEchoServerName, argv, 0 );

	}

	return 0;
}

int UDPEchoConfigStop( struct TR143_UDPEchoConfig *p )
{
	char strPort[16];
	int pid;
	int status;

	if(!p) return -1;

	sprintf( strPort, "%u", p->UDPPort );
	va_cmd(IPTABLES, 15, 1, ARG_T, "mangle", FW_DEL, (char *)FW_PREROUTING,
		 "!", (char *)ARG_I, (char *)LANIF, "-p", (char *)ARG_UDP,
		(char *)FW_DPORT, strPort, "-j", (char *)"MARK", "--set-mark", RMACC_MARK);


	pid = read_pid((char *)gUDPEchoServerPid);
	if (pid >= 1)
	{
		status = kill(pid, SIGTERM);
		if (status != 0)
		{
			printf("Could not kill UDPEchoServer's pid '%d'\n", pid);
			return -1;
		}
	}

	return 0;
}
#endif //_PRMT_TR143_

#ifdef CONFIG_CTC_E8_CLIENT_LIMIT
static const char PROCFS_NAME[] = "/proc/ClientsMonitor";

#ifdef _PRMT_X_CT_COM_MWBAND_
int proc_write_for_mwband()
{
	FILE *fp;
	unsigned int vInt;
	unsigned char Value;
	unsigned char curbuffer[1024];
	unsigned char *curptr = curbuffer;
	int len =0;

#if !defined(CONFIG_LUNA)
	if ((fp = fopen(PROCFS_NAME, "w")) == NULL)
	{
		printf("Open file %s failed !\n", PROCFS_NAME);
		return -1;
	}
#endif


	memset(curbuffer, 0, 1024);

	len=sprintf(curptr, "flagLimitOnAll "); // set ip to detect...
	 if(len < 0)
	  goto err;
	 curptr+=len;
	 mib_get( CWMP_CT_MWBAND_MODE, (void *)&vInt);
//	 printf("\nflagLimitOnAll=%d\n",vInt);
	 len=sprintf(curptr, "%d\n", vInt);
	 curptr+=len;

	 len=sprintf(curptr, "limitOnAll "); // set ip to detect...
	 if(len < 0)
	  goto err;
	 curptr+=len;
	 mib_get( CWMP_CT_MWBAND_NUMBER, (void *)&vInt);
//	 printf("\nlimitOnAll=%d\n",vInt);
	 len=sprintf(curptr, "%d\n", vInt);
	 curptr+=len;

	 len=sprintf(curptr, "computerLimitEnable "); // set ip to detect...
	 if(len < 0)
	  goto err;
	 curptr+=len;
	 mib_get( CWMP_CT_MWBAND_PC_ENABLE, (void *)&Value);
//	 printf("\ncomputerLimitEnable=%d\n",Value);
	 len=sprintf(curptr, "%d\n", Value);
	 curptr+=len;

	 len=sprintf(curptr, "limitOnComputer "); // set ip to detect...
	 if(len < 0)
	  goto err;
	 curptr+=len;
	 mib_get( CWMP_CT_MWBAND_PC_NUM, (void *)&vInt);
//	 printf("\nlimitOnComputer=%d\n",vInt);
	 len=sprintf(curptr, "%d\n", vInt);
	 curptr+=len;

	 len=sprintf(curptr, "cameraLimitEnable "); // set ip to detect...
	 if(len < 0)
	  goto err;
	 curptr+=len;
	 mib_get( CWMP_CT_MWBAND_CMR_ENABLE, (void *)&Value);
//	 printf("\ncameraLimitEnable=%d\n",Value);
	 len=sprintf(curptr, "%d\n", Value);
	 curptr+=len;

	 len=sprintf(curptr, "limitOnCamera "); // set ip to detect...
	 if(len < 0)
	  goto err;
	 curptr+=len;
	 mib_get( CWMP_CT_MWBAND_CMR_NUM, (void *)&vInt);
//	 printf("\nlimitOnCamera=%d\n",vInt);
	 len=sprintf(curptr, "%d\n", vInt);
	 curptr+=len;

    // set stb to detect...
    len = sprintf(curptr, "stbLimitEnable ");
    if (len < 0)
    {
        goto err;
    }
    curptr += len;
    mib_get(CWMP_CT_MWBAND_STB_ENABLE, (void *)&Value);
    len = sprintf(curptr, "%d\n", Value);
    curptr += len;

    len = sprintf(curptr, "limitOnStb ");
    if (len < 0)
    {
        goto err;
    }
    curptr += len;
    mib_get(CWMP_CT_MWBAND_STB_NUM, (void *)&vInt);
    len = sprintf(curptr, "%d\n", vInt);
    curptr += len;

    // set phone to detect...
    len = sprintf(curptr, "phnLimitEnable ");
    if (len < 0)
    {
        goto err;
    }
    curptr += len;
    mib_get(CWMP_CT_MWBAND_PHN_ENABLE, (void *)&Value);
    len = sprintf(curptr, "%d\n", Value);
    curptr += len;

    len = sprintf(curptr, "limitOnPhn ");
    if (len < 0)
    {
        goto err;
    }
    curptr += len;
    mib_get(CWMP_CT_MWBAND_PHN_NUM, (void *)&vInt);
    len = sprintf(curptr, "%d\n", vInt);
    curptr += len;
#if !defined(CONFIG_LUNA)
	fwrite(curbuffer, 1024, 1, fp);
	fclose(fp);
#endif
#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_CTC_E8_CLIENT_LIMIT)
	RTK_RG_AccessWanLimit_Set();
#endif
	return 0;
err:
#if !defined(CONFIG_LUNA)
	fclose(fp);
#endif
	return -1;

}
#endif
#endif //CONFIG_CTC_E8_CLIENT_LIMIT
#endif //_CWMP_MIB_

int getDisplayWanName(MIB_CE_ATM_VC_T *pEntry, char* name)
{
	MEDIA_TYPE_T mType;

	if(pEntry==NULL || name==NULL)
		return 0;

	name[0] = '\0';
	mType = MEDIA_INDEX(pEntry->ifIndex);
	if (pEntry->cmode == CHANNEL_MODE_PPPOA) { // ppp0, ...
		snprintf(name, 6, "ppp%u", PPP_INDEX(pEntry->ifIndex));
	}
	else if (pEntry->cmode == CHANNEL_MODE_PPPOE) { // ppp0_vc0, ...
		if (mType == MEDIA_ATM)

			snprintf(name, 16, "ppp%u_vc%u", PPP_INDEX(pEntry->ifIndex), VC_INDEX(pEntry->ifIndex));
		else if (mType == MEDIA_ETH)
#ifdef CONFIG_RTL_MULTI_ETH_WAN
			snprintf(name, 16, "ppp%u_%s%u", PPP_INDEX(pEntry->ifIndex), ALIASNAME_MWNAS, ETH_INDEX(pEntry->ifIndex));
#else
			snprintf(name, 16, "ppp%u_%s%u", PPP_INDEX(pEntry->ifIndex), ALIASNAME_NAS, ETH_INDEX(pEntry->ifIndex));
#endif
		else
			return 0;
	}
	else { // vc0 ...
		if (mType == MEDIA_ATM)
			snprintf(name, 5, "vc%u", VC_INDEX(pEntry->ifIndex));
		else if (mType == MEDIA_ETH)
#ifdef CONFIG_RTL_MULTI_ETH_WAN
			snprintf(name, 7, "%s%u", ALIASNAME_MWNAS, ETH_INDEX(pEntry->ifIndex));
#else
			snprintf(name, 5, "%s%u", ALIASNAME_NAS, ETH_INDEX(pEntry->ifIndex));
#endif

		else
			return 0;
	}
	return 1;
}

//jim: to get wan MIB by index... this index is combined index for ppp or vc...
int getWanEntrybyindex(MIB_CE_ATM_VC_T *pEntry, unsigned int ifIndex)
{
	if(pEntry==NULL)
		return -1;
	int mibtotal,i,num=0,totalnum=0;
	MIB_CE_ATM_VC_T Entry;
	mibtotal = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0;i<mibtotal;i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;
		if(Entry.ifIndex == ifIndex)
			break;
	}
	if(i==mibtotal)
		return -1;
	memcpy(pEntry, &Entry, sizeof(Entry));
	return 0;
}

unsigned int getWanIfMapbyMedia(MEDIA_TYPE_T mType)
{
	int mibtotal,i;
	MIB_CE_ATM_VC_T Entry;
	unsigned int ifMap; // high half for PPP bitmap, low half for vc bitmap

	ifMap=0;//init
	mibtotal = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0;i<mibtotal;i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;
		if (Entry.cmode == CHANNEL_MODE_PPPOE)
			ifMap |= (1 << 16) << PPP_INDEX(Entry.ifIndex);	// PPP map
		if(MEDIA_INDEX(Entry.ifIndex) == mType)
			ifMap |= 1 << VC_INDEX(Entry.ifIndex);
	}

	return ifMap;
}

// Kaohj --- first entry
int getWanEntrybyMedia(MIB_CE_ATM_VC_T *pEntry, MEDIA_TYPE_T mType)
{
	if(pEntry==NULL)
		return -1;
	int mibtotal,i,num=0,totalnum=0;
	MIB_CE_ATM_VC_T Entry;
	mibtotal = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0;i<mibtotal;i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;
		if(MEDIA_INDEX(Entry.ifIndex) == mType)
			break;
	}
	if(i==mibtotal)
		return -1;
	memcpy(pEntry, &Entry, sizeof(Entry));
	return i;
}

static const char IF_UP[] = "up";
static const char IF_DOWN[] = "down";
static const char IF_NA[] = "n/a";
#ifdef EMBED
static const char PROC_NET_ATM_BR[] = "/proc/net/atm/br2684";
const char PPPOE_CONF[] = "/var/ppp/pppoe.conf";
const char PPPOA_CONF[] = "/var/ppp/pppoa.conf";
const char PPP_PID[] = "/var/run/spppd.pid";
#endif
#undef FILE_LOCK
int getWanStatus(struct wstatus_info *sEntry, int max)
{
	unsigned int data, data2;
	char	buff[256], tmp1[20], tmp2[20], tmp3[20], tmp4[20];
	char	*temp;
	int in_turn=0, vccount=0, ifcount=0;
	int linkState, dslState=0, ethState=0;
	int i, ifindices[256], br_socket_fd, spid;
	FILE *fp;
#ifdef FILE_LOCK
	struct flock flpoe, flpoa;
	int fdpoe, fdpoa;
#endif
	int entryNum;
	MIB_CE_ATM_VC_T tEntry;
	struct wstatus_info vcEntry[MAX_VC_NUM];

	memset(sEntry, 0, sizeof(struct wstatus_info)*max);
#ifdef EMBED
	// get spppd pid
	spid = 0;
	if ((fp = fopen(PPP_PID, "r"))) {
		fscanf(fp, "%d\n", &spid);
		fclose(fp);
	}
	else
		printf("spppd pidfile not exists\n");

	if (spid) {
		struct data_to_pass_st msg;
		snprintf(msg.data, BUF_SIZE, "spppctl pppstatus %d", spid);
		TRACE(STA_SCRIPT, "%s\n", msg.data);
		write_to_pppd(&msg);
	}
#endif
	in_turn = 0;
#ifdef EMBED

#ifdef CONFIG_ETHWAN
	if( WAN_MODE & MODE_Ethernet )
	{
#ifndef CONFIG_RTL_MULTI_ETH_WAN
		entryNum = getWanEntrybyMedia(&tEntry, MEDIA_ETH);
		if (entryNum>=0) {
			vcEntry[vccount].ifIndex = tEntry.ifIndex;
			ifGetName(tEntry.ifIndex, vcEntry[vccount].ifname, IFNAMSIZ);
			ifGetName(PHY_INTF(tEntry.ifIndex), vcEntry[vccount].devname, IFNAMSIZ);
			strcpy(vcEntry[vccount].encaps, "---");
			switch(tEntry.cmode) {
				case CHANNEL_MODE_IPOE:
					memset(vcEntry[vccount].protocol, 0, 10);
					strcpy(vcEntry[vccount].protocol, "IPoE");
					break;
				case CHANNEL_MODE_BRIDGE:
					memset(vcEntry[vccount].protocol, 0, 10);
					strcpy(vcEntry[vccount].protocol, "Bridged");
					break;
				case CHANNEL_MODE_PPPOE:
					strcpy(vcEntry[vccount].protocol, "PPPoE");
					break;
				default:
					break;
			}
			strcpy(vcEntry[vccount].vpivci, "---");
			vccount++;
		}
#else
		entryNum = mib_chain_total(MIB_ATM_VC_TBL);
		for (i=0; i<entryNum; i++)
		{
			if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&tEntry))
				continue;

			if(MEDIA_INDEX(tEntry.ifIndex) == MEDIA_ATM)
				continue;
			//czpinging, skipped the entry with Disabled Admin status
			if(tEntry.enable==0)
				continue;

			vcEntry[vccount].ifIndex = tEntry.ifIndex;
			ifGetName(tEntry.ifIndex, vcEntry[vccount].ifname, IFNAMSIZ);
			ifGetName(PHY_INTF(tEntry.ifIndex), vcEntry[vccount].devname, IFNAMSIZ);
			strcpy(vcEntry[vccount].encaps, "---");
			switch(tEntry.cmode) {
				case CHANNEL_MODE_IPOE:
					memset(vcEntry[vccount].protocol, 0, 10);
					strcpy(vcEntry[vccount].protocol, "IPoE");
					break;
				case CHANNEL_MODE_BRIDGE:
					memset(vcEntry[vccount].protocol, 0, 10);
					strcpy(vcEntry[vccount].protocol, "Bridged");
					break;
				case CHANNEL_MODE_PPPOE:
					strcpy(vcEntry[vccount].protocol, "PPPoE");
					break;
				default:
					break;
			}
			strcpy(vcEntry[vccount].vpivci, "---");
			vccount++;
		}
#endif
	}
#endif // CONFIG_ETHWAN

#ifdef FILE_LOCK
	// file locking
	fdpoe = open(PPPOE_CONF, O_RDWR);
	fdpoa = open(PPPOA_CONF, O_RDWR);
	if ((fdpoe != -1) && (fdpoa != -1)) {
		flpoe.l_type = flpoa.l_type = F_RDLCK;
		flpoe.l_whence = flpoa.l_whence = SEEK_SET;
		flpoe.l_start = flpoa.l_start = 0;
		flpoe.l_len = flpoa.l_len = 0;
		flpoe.l_pid = flpoa.l_pid = getpid();
		if (fcntl(fdpoe, F_SETLKW, &flpoe) == -1)
			printf("pppoe read lock failed\n");
		if (fcntl(fdpoa, F_SETLKW, &flpoa) == -1)
			printf("pppoa read lock failed\n");
	}
#endif
	if (!(fp=fopen(PPPOA_CONF, "r")))
		printf("%s not exists.\n", PPPOA_CONF);
	else {
		fgets(buff, sizeof(buff), fp);
		while ( fgets(buff, sizeof(buff), fp) != NULL )
			if (sscanf(buff, "%s%u%u%*s%s%*s%*d%*d%*d%s%s", tmp1, &data, &data2, tmp2, tmp3, tmp4) != 6) {
				printf("Unsuported pppoa configuration format\n");
				break;
			}
			else {
				ifcount ++;
				// ifIndex --- ppp index(no vc index)
				sEntry[ifcount-1].ifIndex = TO_IFINDEX(MEDIA_ATM, tmp1[3]-'0', DUMMY_VC_INDEX);
				strcpy(sEntry[ifcount-1].ifname, tmp1);
				strcpy(sEntry[ifcount-1].encaps, tmp2);
				strcpy(sEntry[ifcount-1].protocol, "PPPoA");
				sEntry[ifcount-1].tvpi = data;
				sEntry[ifcount-1].tvci = data2;
				sprintf(sEntry[ifcount-1].vpivci, "%u/%u", sEntry[ifcount-1].tvpi, sEntry[ifcount-1].tvci);
				strcpy(sEntry[ifcount-1].uptime, tmp3);
				strcpy(sEntry[ifcount-1].totaluptime, tmp4);
			}
		fclose(fp);
	}

	if (!(fp=fopen(PPPOE_CONF, "r")))
		printf("%s not exists.\n", PPPOE_CONF);
	else {
		fgets(buff, sizeof(buff), fp);
		while ( fgets(buff, sizeof(buff), fp) != NULL )
			if(sscanf(buff, "%s%s%*s%*s%*s%s%s", tmp1, tmp2, tmp3, tmp4) != 4) {
				printf("Unsuported pppoe configuration format\n");
				break;
			}
			else
				for (i=0; i<vccount; i++)
					if (strcmp(vcEntry[i].devname, tmp2) == 0)
					{
						ifcount ++;
						// ifIndex --- ppp index + vc index
						if (!strncmp(vcEntry[i].devname,"vc",2))
						{
							sEntry[ifcount-1].ifIndex = TO_IFINDEX(MEDIA_ATM, tmp1[3]-'0', vcEntry[i].devname[2]-'0');
							sEntry[ifcount-1].tvpi = vcEntry[i].tvpi;
							sEntry[ifcount-1].tvci = vcEntry[i].tvci;
							sprintf(sEntry[ifcount-1].vpivci, "%u/%u", sEntry[ifcount-1].tvpi, sEntry[ifcount-1].tvci);
							//printf("***** sEntry[ifcount-1].ifIndex=0x%x\n", sEntry[ifcount-1].ifIndex);
						}
#if defined(CONFIG_ETHWAN) 
						else {
							sEntry[ifcount-1].ifIndex = vcEntry[i].ifIndex;
							strcpy(sEntry[ifcount-1].vpivci, "---");
						}
#endif
						strcpy(sEntry[ifcount-1].ifname, tmp1);
						strcpy(sEntry[ifcount-1].devname, vcEntry[i].devname);
						strcpy(sEntry[ifcount-1].encaps, vcEntry[i].encaps);
						strcpy(sEntry[ifcount-1].protocol, "PPPoE");
						strcpy(sEntry[ifcount-1].uptime, tmp3);
						strcpy(sEntry[ifcount-1].totaluptime, tmp4);
					}
		fclose(fp);
	}
#ifdef FILE_LOCK
	// file unlocking
	if ((fdpoe != -1) && (fdpoa != -1)) {
		flpoe.l_type = flpoa.l_type = F_UNLCK;
		if (fcntl(fdpoe, F_SETLK, &flpoe) == -1)
			printf("pppoe read unlock failed\n");
		if (fcntl(fdpoa, F_SETLK, &flpoa) == -1)
			printf("pppoa read unlock failed\n");
		close(fdpoe);
		close(fdpoa);
	}
#endif
	for (i=0; i<vccount; i++) {
		int j, vcfound=0;
		for (j=0; j<ifcount; j++) {
			if (strcmp(vcEntry[i].devname, sEntry[j].devname) == 0)  // PPPoE-used device
			{
				vcfound = 1;
				break;
			}
		}
		if (!vcfound) {	// VC not used for PPPoE, add to list
			ifcount ++;
			// ifIndex --- vc index (no ppp index)
			if (!strncmp(vcEntry[i].devname,"vc",2)) {
				sEntry[ifcount-1].ifIndex = TO_IFINDEX(MEDIA_ATM, DUMMY_PPP_INDEX, vcEntry[i].ifname[2]-'0');
				sEntry[ifcount-1].tvpi = vcEntry[i].tvpi;
				sEntry[ifcount-1].tvci = vcEntry[i].tvci;
				sprintf(sEntry[ifcount-1].vpivci, "%u/%u", sEntry[ifcount-1].tvpi, sEntry[ifcount-1].tvci);
			}
#if defined(CONFIG_ETHWAN)
			else {
				sEntry[ifcount-1].ifIndex = vcEntry[i].ifIndex;
				strcpy(sEntry[ifcount-1].vpivci, "---");
			}
#endif
			strcpy(sEntry[ifcount-1].ifname, vcEntry[i].ifname);
			strcpy(sEntry[ifcount-1].encaps, vcEntry[i].encaps);
			strcpy(sEntry[ifcount-1].protocol, vcEntry[i].protocol);
		}
	}

#endif

#if defined(CONFIG_ETHWAN)
	// todo
	ethState = 1;
#endif

	if (ifcount > max)
		printf("WARNNING! status list overflow(%d).\n", ifcount);


	for (i=0; i<ifcount; i++) {
		struct in_addr inAddr;
		int flags;
		int totalNum, k;
		MIB_CE_ATM_VC_T entry;
		MEDIA_TYPE_T mType;

#ifdef EMBED
		// Kaohj --- interface name to be displayed
		totalNum = mib_chain_total(MIB_ATM_VC_TBL);

		for(k=0; k<totalNum; k++)
		{
			mib_chain_get(MIB_ATM_VC_TBL, k, (void *)&entry);

			if (sEntry[i].ifIndex == entry.ifIndex) {
				getDisplayWanName(&entry, sEntry[i].ifDisplayName);
				sEntry[i].cmode = entry.cmode;
#ifdef CONFIG_IPV6
				sEntry[i].ipver = entry.IpProtocol;
#endif
				break;
			}

		}
		if (getInAddr( sEntry[i].ifname, IP_ADDR, (void *)&inAddr) == 1)
		{
			temp = inet_ntoa(inAddr);
			if (getInFlags( sEntry[i].ifname, &flags) == 1)
				if ((strcmp(temp, "10.0.0.1") == 0) && flags & IFF_POINTOPOINT)	// IP Passthrough or IP unnumbered
					strcpy(sEntry[i].ipAddr, STR_UNNUMBERED);
				else if (strcmp(temp, "64.64.64.64") == 0)
					strcpy(sEntry[i].ipAddr, "");
				else
					strcpy(sEntry[i].ipAddr, temp);
		}
		else
#endif
			strcpy(sEntry[i].ipAddr, "");

#ifdef EMBED
		if (getInAddr( sEntry[i].ifname, DST_IP_ADDR, (void *)&inAddr) == 1)
		{
			temp = inet_ntoa(inAddr);
			if (strcmp(temp, "10.0.0.2") == 0)
				strcpy(sEntry[i].remoteIp, STR_UNNUMBERED);
			else if (strcmp(temp, "64.64.64.64") == 0)
				strcpy(sEntry[i].remoteIp, "");
			else
				strcpy(sEntry[i].remoteIp, temp);
			if (getInFlags( sEntry[i].ifname, &flags) == 1)
				if (flags & IFF_BROADCAST) {
					unsigned char value[32];
					snprintf(value, 32, "%s.%s", (char *)MER_GWINFO, sEntry[i].ifname);
					if (fp = fopen(value, "r")) {
						fscanf(fp, "%s\n", sEntry[i].remoteIp);
						//strcpy(sEntry[i].protocol, "mer1483");
						fclose(fp);
					}
					else
						strcpy(sEntry[i].remoteIp, "");
				}
		}
		else
#endif
			strcpy(sEntry[i].remoteIp, "");

		if (!strcmp(sEntry[i].protocol, ""))
		{
			//get channel mode
			switch(sEntry[i].cmode) {
			case CHANNEL_MODE_IPOE:
				memset(sEntry[i].protocol, 0, 10);
				strcpy(sEntry[i].protocol, "mer1483");
				break;
			case CHANNEL_MODE_BRIDGE:
				memset(sEntry[i].protocol, 0, 10);
				strcpy(sEntry[i].protocol, "br1483");
				break;
			default:
				break;
			}
		}

		mType = MEDIA_INDEX(sEntry[i].ifIndex);
		if (mType == MEDIA_ATM)
			linkState = dslState;
		else if (mType == MEDIA_ETH)
			linkState = ethState;
		else
			linkState = 0;
		sEntry[i].link_state = linkState;
		// set status flag
		if (getInFlags( sEntry[i].ifname, &flags) == 1)
		{
			if (flags & IFF_UP) {
				if (!linkState) {
					sEntry[i].strStatus = (char *)IF_DOWN;
					sEntry[i].itf_state = 0;
				}
				else {
					if (sEntry[i].cmode == CHANNEL_MODE_BRIDGE) {
						sEntry[i].strStatus = (char *)IF_UP;
						sEntry[i].itf_state = 1;
					}
					else
						if (getInAddr(sEntry[i].ifname, IP_ADDR, (void *)&inAddr) == 1) {
							temp = inet_ntoa(inAddr);
							if (strcmp(temp, "64.64.64.64")) {
								sEntry[i].strStatus = (char *)IF_UP;
								sEntry[i].itf_state = 1;															}
							else {
								sEntry[i].strStatus = (char *)IF_DOWN;
								sEntry[i].itf_state = 0;
							}
						}
						else {
							sEntry[i].strStatus = (char *)IF_DOWN;
							sEntry[i].itf_state = 0;
						}
				}
			}
			else {
				sEntry[i].strStatus = (char *)IF_DOWN;
				sEntry[i].itf_state = 0;
			}
		}
		else {
			sEntry[i].strStatus = (char *)IF_NA;
			sEntry[i].itf_state = -1;
		}

		if (sEntry[i].cmode == CHANNEL_MODE_PPPOE || sEntry[i].cmode == CHANNEL_MODE_PPPOA) {
			if (sEntry[i].itf_state <= 0) {
				sEntry[i].ipAddr[0] = '\0';
				sEntry[i].remoteIp[0] = '\0';
			}
			if (entry.pppCtype == CONNECT_ON_DEMAND && entry.pppIdleTime != 0)
				sEntry[i].pppDoD = 1;
			else
				sEntry[i].pppDoD = 0;
		}

	}
	return ifcount;
}

int isValidMedia(unsigned int ifIndex)
{
	MEDIA_TYPE_T mType;

	mType = MEDIA_INDEX(ifIndex);
	if (1
	#ifdef CONFIG_ETHWAN
		&& mType!=MEDIA_ETH
	#endif
	)
		return 0;
	return 1;
}

// Kaohj -- specific for pvc channel
// map: bit map of used interface, ppp index (0~15) is mapped into high 16 bits,
// while vc index (0~15) is mapped into low 16 bits.
// while major vc index (8 ~ 15) is mapped into hight 8 bits of vc index.
// while minor vc index (0 ~ 7) is mapped into low 8 bits of vc index.
// return: interface index, byte1 for PPP index and byte0 for vc index.
//		0xefff(NA_PPP): PPP not available
//		0xffff(NA_VC) : vc not available
unsigned int if_find_index(int cmode, unsigned int map)
{
	int i;
	unsigned int index, vc_idx, ppp_idx;

	// find the first available vc index (mpoa interface)
	i = 0;
	for (i=0; i<MAX_VC_NUM; i++)
	{
		if (!((map>>i) & 1))
			break;
	}


	if (i != MAX_VC_NUM)
		vc_idx = i;
	else
		return NA_VC;

	if (cmode == CHANNEL_MODE_PPPOE || cmode == CHANNEL_MODE_PPPOA)
	{
		// find an available PPP index
		map >>= 16;
		i = 0;
		while (map & 1)
		{
			map >>= 1;
			i++;
		}
		ppp_idx = i;
		if (ppp_idx<=(MAX_PPP_NUM-1))
			index = TO_IFINDEX(MEDIA_ATM, ppp_idx, vc_idx);
		else
			return NA_PPP;

		if (cmode == CHANNEL_MODE_PPPOA)
			//index |= 0x0f;	// PPPoA doesn't use mpoa interface, set to 0x0f (don't care)
			index = TO_IFINDEX(MEDIA_ATM, ppp_idx, DUMMY_VC_INDEX);
	}
	else
	{
		// don't care the PPP index
		//index |= 0xf0;
		index = TO_IFINDEX(MEDIA_ATM, DUMMY_PPP_INDEX, vc_idx);
	}
	return index;
}

#ifdef CONFIG_ETHWAN
int init_ethwan_config(MIB_CE_ATM_VC_T *pEntry)
{
	if (!pEntry)
		return 0;
	memset(pEntry, 0, sizeof(MIB_CE_ATM_VC_T));
	pEntry->ifIndex = TO_IFINDEX(MEDIA_ETH, DUMMY_PPP_INDEX, 0);
	pEntry->cmode = CHANNEL_MODE_BRIDGE;
	pEntry->enable = 1;
	return 1;
}
#endif

//star: to get ppp index for wanname
static int getpppindex(MIB_CE_ATM_VC_T * pEntry)
{
	int ret = -1;
	int mibtotal, i, num = 0, totalnum = 0;
	unsigned int pppindex, tmpindex;
	MIB_CE_ATM_VC_T Entry;

	if (pEntry->cmode != CHANNEL_MODE_PPPOE && pEntry->cmode != CHANNEL_MODE_PPPOA)
		return ret;

	pppindex = PPP_INDEX(pEntry->ifIndex);
	if (pppindex == DUMMY_PPP_INDEX)
		return ret;

	mibtotal = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < mibtotal; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;
		if (Entry.cmode != CHANNEL_MODE_PPPOE && Entry.cmode != CHANNEL_MODE_PPPOA)
			continue;
		tmpindex = PPP_INDEX(Entry.ifIndex);
		if (tmpindex == DUMMY_PPP_INDEX)
			continue;
		if (Entry.vpi == pEntry->vpi && Entry.vci == pEntry->vci) {
			totalnum++;
			if (tmpindex < pppindex)
				num++;
		}
	}

	if (totalnum > 1)
		ret = num;

	return ret;

}

int generateWanName(MIB_CE_ATM_VC_T *entry, char* wanname)
{
	char vpistr[6];
	char vcistr[6];
	char vid[16];
	int i, mibtotal;
	MIB_CE_ATM_VC_T tmpEntry;
	MEDIA_TYPE_T mType;

	mibtotal = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0; i< mibtotal; i++)
	{
		mib_chain_get(MIB_ATM_VC_TBL, i, &tmpEntry);
		if(tmpEntry.ifIndex == entry->ifIndex
		#ifdef BR_ROUTE_ONEPVC
			&&tmpEntry.cmode == entry->cmode
		#endif
			)
			break;
	}
	if(i==mibtotal)
		return -1;
	i++;

	mType = MEDIA_INDEX(entry->ifIndex);
	sprintf(wanname, "%d_", i);
	if(entry==NULL || wanname ==NULL)
		return -1;
	memset(vpistr, 0, sizeof(vpistr));
	memset(vcistr, 0, sizeof(vcistr));
	if (entry->applicationtype&X_CT_SRV_TR069)
		strcat(wanname, "TR069_");
#ifdef CONFIG_USER_RTK_VOIP
	if (entry->applicationtype&X_CT_SRV_VOICE)
		strcat(wanname, WAN_VOIP_VOICE_NAME_CONN);
#endif
	if (entry->applicationtype&X_CT_SRV_INTERNET)
		strcat(wanname, "INTERNET_");
	if (entry->applicationtype&X_CT_SRV_OTHER)
	{
#ifdef CONFIG_SUPPORT_IPTV_APPLICATIONTYPE
		if(entry->othertype == OTHER_IPTV_TYPE)
			strcat(wanname, "IPTV_");
		else		
#endif
		strcat(wanname, "Other_");
	}
#ifdef CONFIG_YUEME
	if (entry->applicationtype&X_CT_SRV_SPECIAL_SERVICE_1)
		strcat(wanname, "SPECIAL_SERVICE_1_");
	if (entry->applicationtype&X_CT_SRV_SPECIAL_SERVICE_2)
		strcat(wanname, "SPECIAL_SERVICE_2_");
	if (entry->applicationtype&X_CT_SRV_SPECIAL_SERVICE_3)
		strcat(wanname, "SPECIAL_SERVICE_3_");
	if (entry->applicationtype&X_CT_SRV_SPECIAL_SERVICE_4)
		strcat(wanname, "SPECIAL_SERVICE_4_");
#endif
	if(entry->cmode == CHANNEL_MODE_BRIDGE)
		strcat(wanname, "B_");
	else
		strcat(wanname, "R_");
	if ((mType == MEDIA_ETH) || (mType == MEDIA_PTM)) {
		strcat(wanname, "VID_");
		if(entry->vlan==1){
			sprintf(vid, "%d", entry->vid);
			strcat(wanname, vid);
		}
	}
	else if (mType == MEDIA_ATM) {
		sprintf(vpistr, "%d", entry->vpi);
		sprintf(vcistr, "%d", entry->vci);
		strcat(wanname, vpistr);
		strcat(wanname, "_");
		strcat(wanname, vcistr);
	}
	return 0;
}

int setWanName(char* str, int applicationtype)
{
	if (applicationtype&X_CT_SRV_TR069)
		strcat(str, "TR069_");
#ifdef CONFIG_USER_RTK_VOIP
	if (applicationtype&X_CT_SRV_VOICE)
		strcat(str, WAN_VOIP_VOICE_NAME_CONN);
#endif
	if (applicationtype&X_CT_SRV_INTERNET)
		strcat(str, "INTERNET_");
	if (applicationtype&X_CT_SRV_OTHER)
		strcat(str, "Other_");
#ifdef CONFIG_YUEME
	if (applicationtype&X_CT_SRV_SPECIAL_SERVICE_1)
		strcat(str, "SPECIAL_SERVICE_1_");
	if (applicationtype&X_CT_SRV_SPECIAL_SERVICE_2)
		strcat(str, "SPECIAL_SERVICE_2_");
	if (applicationtype&X_CT_SRV_SPECIAL_SERVICE_3)
		strcat(str, "SPECIAL_SERVICE_3_");
	if (applicationtype&X_CT_SRV_SPECIAL_SERVICE_4)
		strcat(str, "SPECIAL_SERVICE_4_");
#endif
	if (strlen(str)) // remove tailing '_'
		str[strlen(str)-1]='\0';
}

int getWanName(MIB_CE_ATM_VC_T * pEntry, char *name)
{
	if (pEntry == NULL || name == NULL)
		return 0;
#ifdef _CWMP_MIB_
	if (*(pEntry->WanName))
		strcpy(name, pEntry->WanName);
	else
#endif
	{			//if not set by ACS. then generate automaticly.
		generateWanName(pEntry, name);
	}
	return 1;
}

#define DEFDATALEN	56
#define PINGCOUNT 3
#define PINGINTERVAL	1	/* second */
#define MAXWAIT		5

static struct sockaddr_in pingaddr;
static int pingsock = -1;
static long ntransmitted = 0, nreceived = 0, nrepeats = 0;
static int myid = 0;
static int finished = 0;

int create_icmp_socket(void)
{
	struct protoent *proto;
	int sock;

	proto = getprotobyname("icmp");
	/* if getprotobyname failed, just silently force
	 * proto->p_proto to have the correct value for "icmp" */
	if ((sock = socket(AF_INET, SOCK_RAW,
			(proto ? proto->p_proto : 1))) < 0) {        /* 1 == ICMP */
		printf("cannot create raw socket\n");
	}

	return sock;
}

int in_cksum(unsigned short *buf, int sz)
{
	int nleft = sz;
	int sum = 0;
	unsigned short *w = buf;
	unsigned short ans = 0;

	while (nleft > 1) {
		sum += *w++;
		nleft -= 2;
	}

	if (nleft == 1) {
		*(unsigned char *) (&ans) = *(unsigned char *) w;
		sum += ans;
	}

	sum = (sum >> 16) + (sum & 0xFFFF);
	sum += (sum >> 16);
	ans = ~sum;
	return (ans);
}

static void pingfinal()
{
	finished = 1;
}

static void sendping()
{
	struct icmp *pkt;
	int c;
	char packet[DEFDATALEN + 8];

	pkt = (struct icmp *) packet;
	pkt->icmp_type = ICMP_ECHO;
	pkt->icmp_code = 0;
	pkt->icmp_cksum = 0;
	pkt->icmp_seq = ntransmitted++;
	pkt->icmp_id = myid;
	pkt->icmp_cksum = in_cksum((unsigned short *) pkt, sizeof(packet));

	c = sendto(pingsock, packet, sizeof(packet), 0,
			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in));

	if (c < 0 || c != sizeof(packet)) {
		ntransmitted--;
		finished = 1;
		printf("sock: sendto fail !");
		return;
	}

	signal(SIGALRM, sendping);
	if (ntransmitted < PINGCOUNT) {	/* schedule next in 1s */
		alarm(PINGINTERVAL);
	} else {	/* done, wait for the last ping to come back */
		signal(SIGALRM, pingfinal);
		alarm(MAXWAIT);
	}
}

int utilping(char *str)
{
//	char *submitUrl;
	char tmpBuf[100];
	int c;
	struct hostent *h;
	struct icmp *pkt;
	struct iphdr *iphdr;
	char packet[DEFDATALEN + 8];
	int rcvdseq, ret=0;
	fd_set rset;
	struct timeval tv;

	if (str[0]) {
		if ((pingsock = create_icmp_socket()) < 0) {
			perror("socket");
			snprintf(tmpBuf, 100, "ping: socket create error");
			goto setErr_ping;
		}

		memset(&pingaddr, 0, sizeof(struct sockaddr_in));
		pingaddr.sin_family = AF_INET;

		if ((h = gethostbyname(str)) == NULL) {
			//herror("ping: ");
			//snprintf(tmpBuf, 100, "ping: %s: %s", str, hstrerror(h_errno));
			goto setErr_ping;
		}

		if (h->h_addrtype != AF_INET) {
			//strcpy(tmpBuf, "unknown address type; only AF_INET is currently supported.");
			goto setErr_ping;
		}

		memcpy(&pingaddr.sin_addr, h->h_addr, sizeof(pingaddr.sin_addr));

		printf("PING %s (%s): %d data bytes\n",
		   h->h_name,inet_ntoa(*(struct in_addr *) &pingaddr.sin_addr.s_addr),DEFDATALEN);

		myid = getpid() & 0xFFFF;
		ntransmitted = nreceived = nrepeats = 0;
		finished = 0;
		rcvdseq=ntransmitted-1;
		FD_ZERO(&rset);
		FD_SET(pingsock, &rset);
		/* start the ping's going ... */
		sendping();

		/* listen for replies */
		while (1) {
			struct sockaddr_in from;
			socklen_t fromlen = (socklen_t) sizeof(from);
			int c, hlen, dupflag;

			if (finished)
				break;

			tv.tv_sec = 1;
			tv.tv_usec = 0;

			if (select(pingsock+1, &rset, NULL, NULL, &tv) > 0) {
				if ((c = recvfrom(pingsock, packet, sizeof(packet), 0,
								  (struct sockaddr *) &from, &fromlen)) < 0) {

					printf("sock: recvfrom fail !");
					continue;
				}
			}
			else // timeout or error
				continue;

			if (c < DEFDATALEN+ICMP_MINLEN)
				continue;

			iphdr = (struct iphdr *) packet;
			hlen = iphdr->ihl << 2;
			pkt = (struct icmp *) (packet + hlen);	/* skip ip hdr */
			if (pkt->icmp_id != myid) {
//				printf("not myid\n");
				continue;
			}
			if (pkt->icmp_type == ICMP_ECHOREPLY) {
				++nreceived;
				if (pkt->icmp_seq == rcvdseq) {
					// duplicate
					++nrepeats;
					--nreceived;
					dupflag = 1;
				} else {
					rcvdseq = pkt->icmp_seq;
					dupflag = 0;
					if (nreceived < PINGCOUNT)
					// reply received, send another immediately
						sendping();
				}
				printf("%d bytes from %s: icmp_seq=%u", c,
					   inet_ntoa(*(struct in_addr *) &from.sin_addr.s_addr),
					   pkt->icmp_seq);
				if (dupflag) {
					printf(" (DUP!)");
				}
				printf("\n");
			}
			if (nreceived >= PINGCOUNT) {
				ret = 1;
				break;
			}
		}
		FD_CLR(pingsock, &rset);
		close(pingsock);
		pingsock = -1;
	}
	printf("\n--- ping statistics ---\n");
	printf("%ld packets transmitted, ", ntransmitted);
	printf("%ld packets received\n\n", nreceived);
	if (nrepeats)
		printf("%ld duplicates, ", nrepeats);
	printf("\n");
	return ret;
setErr_ping:
	if (pingsock >= 0) {
		close(pingsock);
		pingsock = -1;
	}
	printf("Ping error!!\n\n");
	return ret;
}


int defaultGWAddr(char *gwaddr)
{
	char buff[256], ifname[16];
	int flgs;
	//unsigned long int g;
	//struct in_addr gw;
	struct in_addr gw, dest, mask;
	FILE *fp;

	if (!(fp=fopen("/proc/net/route", "r"))) {
		printf("Error: cannot open /proc/net/route - continuing...\n");
		return -1;
	}

	fgets(buff, sizeof(buff), fp);
	while (fgets(buff, sizeof(buff), fp) != NULL) {
		//if (sscanf(buff, "%s%lx%*lx%X%", ifname, &g, &flgs) != 3) {
		if (sscanf(buff, "%s%x%x%x%*d%*d%*d%x", ifname, &dest, &gw, &flgs, &mask) != 5) {
			printf("Unsupported kernel route format\n");
			fclose(fp);
			return -1;
		}
		if(flgs & RTF_UP) {
			// default gateway
			if (dest.s_addr == 0 && mask.s_addr == 0) {
				if (gw.s_addr != 0) {
					sprintf(gwaddr, "%s", inet_ntoa(gw));
					fclose(fp);
					return 0;
				}
				else {
					if (getInAddr(ifname, DST_IP_ADDR, (void *)&gw) == 1)
						if (gw.s_addr != 0) {
							sprintf(gwaddr, "%s", inet_ntoa(gw));
							fclose(fp);
							return 0;
						}
				}
			}
		}
		/*if((g == 0) && (flgs & RTF_UP)) {
			if (getInAddr(ifname, DST_IP_ADDR, (void *)&gw) == 1)
				if (gw.s_addr != 0) {
					sprintf(gwaddr, "%s", inet_ntoa(gw));
					fclose(fp);
					return 0;
				}
		}
		if (sscanf(buff, "%*s%*lx%lx%X%", &g, &flgs) != 2) {
			printf("Unsupported kernel route format\n");
			fclose(fp);
			return -1;
		}
		if(flgs & RTF_UP) {
			gw.s_addr = g;
			if (gw.s_addr != 0) {
				sprintf(gwaddr, "%s", inet_ntoa(gw));
				fclose(fp);
				return 0;
			}
		}*/
	}
	fclose(fp);
	return -1;
}

int pdnsAddr(char *dnsaddr)
{

	FILE *fp;
	char buff[256];
	if ( (fp = fopen("/var/resolv.conf", "r")) == NULL ) {
		printf("Unable to open resolver file\n");
		return -1;
	}

	fgets(buff, sizeof(buff), fp);
	if (sscanf(buff, "nameserver %s", dnsaddr) != 1) {
		printf("Unsupported kernel route format\n");
		fclose(fp);
		return -1;
	}
	fclose(fp);
	return 0;
}

int getNameServers(char *buf)
{
	FILE *fp;
	char line[128], addr[64];
	int count = 0;

	buf[0] = '\0';
	if ((fp = fopen(RESOLV, "r")) == NULL)
		return -1;

	while (fgets(line, sizeof(line), fp) != NULL) {
		if (sscanf(line, "nameserver %s", addr) != 1)
			continue;

		if (count == 0) {
			sprintf(buf, "%s", addr);
		} else {
			sprintf(line, ", %s", addr);
			strcat(buf, line);
		}
		count++;
	}

	fclose(fp);

	return 0;
}

int setNameServers(char *buf)
{
	FILE *fp;
	char line[128], *ptr;

	if ((fp = fopen(RESOLV, "w")) == NULL)
		return -1;

	ptr = strtok(buf, ", ");

	do {
		if (snprintf(line, sizeof(line), "nameserver %s\n", ptr) == 0)
			continue;
		fputs(line, fp);
	} while (ptr = strtok(NULL, ", "));

	fclose(fp);

	return 0;
}

#ifdef ACCOUNT_CONFIG
//Jenny, get user account privilege
int getAccPriv(char *user)
{
	int totalEntry, i;
	MIB_CE_ACCOUNT_CONFIG_T Entry;
	char suName[MAX_NAME_LEN], usName[MAX_NAME_LEN];

	mib_get(MIB_SUSER_NAME, (void *)suName);
	mib_get(MIB_USER_NAME, (void *)usName);
	if (strcmp(suName, user) == 0)
		return (int)PRIV_ROOT;
	else if (strcmp(usName, user) == 0)
		return (int)PRIV_USER;
	totalEntry = mib_chain_total(MIB_ACCOUNT_CONFIG_TBL);
	for (i=0; i<totalEntry; i++)
	{
		if (!mib_chain_get(MIB_ACCOUNT_CONFIG_TBL, i, (void *)&Entry))
			continue;
		if (strcmp(Entry.userName, user) == 0)
			return Entry.privilege;
	}
	return -1;
}
#endif

//jim support dsl disconnection when firmware upgrade from Local Side.....
//retrun value: 1-local        0 - wan         -1 - error
static int isAccessFromLocal(unsigned int ip)
{
	unsigned int uLanIp;
	unsigned int uLanMask;
	char secondIpEn;
	unsigned int uSecondIp;
	unsigned int uSecondMask;

	if (!mib_get( MIB_ADSL_LAN_IP, (void *)&uLanIp ))
		return -1;
	if (!mib_get( MIB_ADSL_LAN_SUBNET, (void *)&uLanMask ))
		return -1;

	if ( (ip & uLanMask) == (uLanIp & uLanMask) ) {//in the same subnet with LAN port
		return 1;
	} else {
		if (!mib_get( MIB_ADSL_LAN_ENABLE_IP2, (void *)&secondIpEn ))
			return -1;

		if (secondIpEn == 1) {//second IP is enabled
			if (!mib_get( MIB_ADSL_LAN_IP2, (void *)&uSecondIp))
				return -1;
			if (!mib_get( MIB_ADSL_LAN_SUBNET2, (void *)&uSecondMask))
				return -1;

			if ( (ip & uSecondMask) == (uSecondIp & uSecondMask) )//in the same subnet with LAN port
				return 1;
		}
	}

	return 0;
}

// Jenny, for checking duplicated destination address
int checkRoute(MIB_CE_IP_ROUTE_T rtEntry, int idx)
{
	//unsigned char destNet[4];
	unsigned long destID, netMask, nextHop;
	unsigned int totalEntry = mib_chain_total(MIB_IP_ROUTE_TBL); /* get chain record size */
	MIB_CE_IP_ROUTE_T Entry;
	int i;

	/*destNet[0] = rtEntry.destID[0] & rtEntry.netMask[0];
	destNet[1] = rtEntry.destID[1] & rtEntry.netMask[1];
	destNet[2] = rtEntry.destID[2] & rtEntry.netMask[2];
	destNet[3] = rtEntry.destID[3] & rtEntry.netMask[3];*/
	destID = *((unsigned long *)&rtEntry.destID);
	netMask = *((unsigned long *)&rtEntry.netMask);
	nextHop = *((unsigned long *)&rtEntry.nextHop);

	// check if route exists
	for (i=0; i<totalEntry; i++) {
		long pdestID, pnetMask, pnextHop;
		unsigned char pdID[4];
		char *temp;
		if (i == idx)
			continue;
		if (!mib_chain_get(MIB_IP_ROUTE_TBL, i, (void *)&Entry))
			return 0;

		pdID[0] = Entry.destID[0] & Entry.netMask[0];
		pdID[1] = Entry.destID[1] & Entry.netMask[1];
		pdID[2] = Entry.destID[2] & Entry.netMask[2];
		pdID[3] = Entry.destID[3] & Entry.netMask[3];
		temp = inet_ntoa(*((struct in_addr *)pdID));
		pdestID = ntohl(inet_addr(temp));
		pnetMask = *((unsigned long *)&Entry.netMask);
		pnextHop = *((unsigned long *)&Entry.nextHop);
		if (pdestID == destID && pnetMask == netMask && pnextHop == nextHop && rtEntry.ifIndex == Entry.ifIndex)
			return 0;
	}
	return 1;
}

int isValidIpAddr(char *ipAddr)
{
	long field[4];

	if (sscanf(ipAddr, "%ld.%ld.%ld.%ld", &field[0], &field[1], &field[2], &field[3]) != 4)
		return 0;

	if (field[0] < 1 || field[0] > 223 || field[0] == 127 || field[1] < 0 || field[1] > 255 || field[2] < 0 || field[2] > 255 || field[3] < 0 || field[3] > 254)
		return 0;

	if (inet_addr(ipAddr) == -1)
		return 0;

	return 1;
}

int isValidHostID(char *ip, char *mask)
{
	long hostIp, netMask, hid, mbit;
	int i, bit, bitcount = 0;

	inet_aton(mask, (struct in_addr *)&netMask);
	hostIp = ntohl(inet_addr(ip));

	hid = ~netMask & hostIp;
	if (hid == 0x0)
		return 0;
	mbit = 0;
	while (1) {
		if (netMask & 0x80000000) {
			mbit++;
			netMask <<= 1;
		}
		else
			break;
	}
	mbit = 32 - mbit;
	for (i=0; i<mbit; i++) {
		bit = hid & 1L;
		if (bit)
			bitcount ++;
		hid >>= 1;
	}
	if (bitcount == mbit)
		return 0;
	return 1;
}

int isValidNetmask(char *mask, int checkbyte)
{
	long netMask;
	int i, bit, isChanged = 0;

	netMask = ntohl(inet_addr(mask));

	// Check most byte (must be 255) and least significant bit (must be 0)
	if (checkbyte) {
		bit = (netMask & 0xFF000000L) >> 24;
		if (bit != 255)
			return 0;
	}

//	bit = netMask & 1L;
//	if (bit)
//		return 0;

	// make sure the bit pattern changes from 0 to 1 only once
	for (i=1; i<31; i++) {
		netMask >>= 1;
		bit = netMask & 1L;

		if (bit) {
			if (!isChanged)
				isChanged = 1;
		}
		else {
			if (isChanged)
				return 0;
		}
	}

	return 1;
}

// check whether an IP address is in the same subnet
int isSameSubnet(char *ipAddr1, char *ipAddr2, char *mask)
{
	long netAddr1, netAddr2, netMask;

	netAddr1 = inet_addr(ipAddr1);
	netAddr2 = inet_addr(ipAddr2);
	netMask = inet_addr(mask);

	if ((netAddr1 & netMask) != (netAddr2 & netMask))
		return 0;

	return 1;
}

int isValidMacString(char *MacStr)
{
	int i;

	if(strlen(MacStr) != 17){
		return 0;
	}

	for(i=0;i<17;i++){
		if((i+1)%3 == 0){
			if(MacStr[i] != ':')
				return 0;
		}else{
			if(!((MacStr[i] >= '0' && MacStr[i] <= '9')
				|| (MacStr[i] >= 'a' && MacStr[i] <= 'f')
				|| (MacStr[i] >= 'A' && MacStr[i] <= 'F'))){
				return 0;
			}
		}
	}
	return 1;
}

int isValidMacAddr(unsigned char *macAddr)
{
	// Check for bad, multicast, broadcast, or null address
	if ((macAddr[0] & 1) || (macAddr[0] & macAddr[1] & macAddr[2] & macAddr[3] & macAddr[4] & macAddr[5]) == 0xff
		|| (macAddr[0] | macAddr[1] | macAddr[2] | macAddr[3] | macAddr[4] | macAddr[5]) == 0x00)
		return 0;

	return 1;
}

#ifdef QOS_SPEED_LIMIT_SUPPORT
//return -1 --not existed
int mib_qos_speed_limit_existed(int speed,int prior)
{
	int entryTotalNum=mib_chain_total(MIB_QOS_SPEED_LIMIT);
	int i=0;
	MIB_CE_IP_QOS_SPEEDRANK_T entry;
	for(i=0;i<entryTotalNum;i++)
		{
		    mib_chain_get(MIB_QOS_SPEED_LIMIT, i, &entry);
		   if(entry.speed==speed&&entry.prior==prior)
		   	return entry.index;
		}
	return -1;
}
#endif

//Ethernet
#if defined(ELAN_LINK_MODE)
#include <linux/sockios.h>
struct mii_ioctl_data {
	unsigned short	phy_id;
	unsigned short	reg_num;
	unsigned short	val_in;
	unsigned short	val_out;
};
#endif

#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_RTL_MULTI_LAN_DEV)
int restart_ethernet(int instnum)
{
	MIB_CE_SW_PORT_T Entry;
	rtk_port_t port = -1;
	rtk_port_phy_ability_t ability;
	int uni_capability = 0;
	static unsigned char link[2][3];

	if (instnum > SW_PORT_NUM)
		return -1;

	port = RG_get_lan_phyPortId((instnum - 1));
	if (port == -1)
		return -1;

	if (!mib_chain_get(MIB_SW_PORT_TBL, (instnum - 1), &Entry))
		return -1;

	rtk_port_phyAutoNegoAbility_get(port, &ability);

	memset(link, 0, sizeof(link));
	uni_capability = getUniPortCapability((instnum - 1));
	#if 0
	printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### %s:%d  port %d duplex %d speed %d \033[m\n", __FUNCTION__, __LINE__, 
			port,
			Entry.duplex,
			Entry.speed);
	#endif
	if (Entry.enable)
	{
		int flags = 0;
		if (getInFlags((char *)SW_LAN_PORT_IF[instnum - 1], &flags) == 1)
		{
			if(!(flags & IFF_UP))
			{
				fprintf(stderr, "[%s@%d] %s is down \n", __FUNCTION__, __LINE__, SW_LAN_PORT_IF[instnum - 1]);
				va_cmd(IFCONFIG, 2, 1, SW_LAN_PORT_IF[instnum - 1], "up");
			}
			else
			{
				fprintf(stderr, "[%s@%d] %s is up \n", __FUNCTION__, __LINE__, SW_LAN_PORT_IF[instnum - 1]);
			}
		}
		else
		{
			va_cmd(IFCONFIG, 2, 1, SW_LAN_PORT_IF[instnum - 1], "up");
		}

		if (uni_capability >= 0 && uni_capability != UNI_PORT_NONE)
		{
			if (Entry.duplex != DUPLEX_TYPE_AUTO && Entry.speed != SPEED_AUTO)
			{
				//printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### %s:%d  !DUPLEX_AUTO !SPEED_AUTO 033[m\n", __FUNCTION__, __LINE__);
				link[Entry.duplex][Entry.speed] = 1;
				if (uni_capability == UNI_PORT_FE && Entry.speed == SPEED_1000M)
				{
					//speed chage to auto
					link[Entry.duplex][SPEED_10M] = 1;
					link[Entry.duplex][SPEED_100M] = 1;
				}
				if (Entry.duplex == DUPLEX_TYPE_HALF && Entry.speed == SPEED_1000M)
				{
					//speed = 1000 && duplex=half, port can not initial, we set duplex as full
					link[DUPLEX_TYPE_FULL][Entry.speed] = 1;
					Entry.duplex = DUPLEX_TYPE_FULL;
					mib_chain_update(MIB_SW_PORT_TBL, &Entry, instnum - 1);
					Commit();
				}
			}

			if (Entry.duplex == DUPLEX_TYPE_AUTO && Entry.speed != SPEED_AUTO)
			{
				//printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### %s:%d  DUPLEX_AUTO !SPEED_AUTO \033[m\n\n", __FUNCTION__, __LINE__);
				link[DUPLEX_TYPE_HALF][Entry.speed] = 1;
				link[DUPLEX_TYPE_FULL][Entry.speed] = 1;
				if (uni_capability == UNI_PORT_FE && Entry.speed == SPEED_1000M)
				{
					//speed chage to auto
					link[DUPLEX_TYPE_HALF][SPEED_10M] = 1;
					link[DUPLEX_TYPE_FULL][SPEED_10M] = 1;
					link[DUPLEX_TYPE_HALF][SPEED_100M] = 1;
					link[DUPLEX_TYPE_FULL][SPEED_100M] = 1;
				}
			}

			if (Entry.duplex != DUPLEX_TYPE_AUTO && Entry.speed == SPEED_AUTO)
			{
				//printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### %s:%d  !DUPLEX_AUTO SPEED_AUTO \033[m\n", __FUNCTION__, __LINE__);
				link[Entry.duplex][SPEED_10M] = 1;
				link[Entry.duplex][SPEED_100M] = 1;
				if (uni_capability == UNI_PORT_GE)
				{
					link[Entry.duplex][SPEED_1000M] = 1;
					if (Entry.duplex == DUPLEX_TYPE_HALF)
					{
						//speed = 1000 && duplex=half, port can not initial, we set duplex as full
						link[DUPLEX_TYPE_FULL][SPEED_1000M] = 1;
						Entry.duplex = DUPLEX_TYPE_FULL;
						mib_chain_update(MIB_SW_PORT_TBL, &Entry, instnum - 1);
						Commit();
					}
				}
			}

			if (Entry.duplex == DUPLEX_TYPE_AUTO && Entry.speed == SPEED_AUTO)
			{
				//printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### %s:%d  DUPLEX_AUTO SPEED_AUTO \033[m\n", __FUNCTION__, __LINE__);
				link[DUPLEX_TYPE_HALF][SPEED_10M] = 1;
				link[DUPLEX_TYPE_FULL][SPEED_10M] = 1;
				link[DUPLEX_TYPE_HALF][SPEED_100M] = 1;
				link[DUPLEX_TYPE_FULL][SPEED_100M] = 1;
				if (uni_capability == UNI_PORT_GE)
				{
					link[DUPLEX_TYPE_HALF][SPEED_1000M] = 1;
					link[DUPLEX_TYPE_FULL][SPEED_1000M] = 1;
				}
			}
			ability.Half_10 = link[DUPLEX_TYPE_HALF][SPEED_10M];
			ability.Half_100 = link[DUPLEX_TYPE_HALF][SPEED_100M];
			ability.Half_1000 = link[DUPLEX_TYPE_HALF][SPEED_100M];
			ability.Full_10 = link[DUPLEX_TYPE_FULL][SPEED_10M];
			ability.Full_100 = link[DUPLEX_TYPE_FULL][SPEED_100M];
			ability.Full_1000 = link[DUPLEX_TYPE_FULL][SPEED_1000M];
		}
		#if 0
		int i = 0, j = 0;
		for(i=0 ; i < 2; i++){
			for(j=0; j < 3; j++){
				printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### %s:%d link[%d][%d] = %d \033[m\n", __FUNCTION__, __LINE__, i , j, link[i][j]);
			}
		}
		printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### %s:%d  port %d duplex %d speed %d ability.Half_10 %d, ability.Half_100 %d, ability.Half_1000 %d, ability.Full_10 %d, ability.Full_100 %d, ability.Full_1000 %d, ability.FC %d, ability.AsyFC %d \033[m\n", __FUNCTION__, __LINE__, 
			port,
			Entry.duplex,
			Entry.speed,
			ability.Half_10,
			ability.Half_100,
			ability.Half_1000,
			ability.Full_10,
			ability.Full_100,
			ability.Full_1000,
			ability.FC,
			ability.AsyFC);
		#endif
		rtk_port_phyAutoNegoAbility_set(port, &ability);
	}
	else
	{
		va_cmd(IFCONFIG, 2, 1, SW_LAN_PORT_IF[instnum - 1], "down");
	}
	return 0;
}
#else
int restart_ethernet(int instnum)
{
	char vChar=0;
	int status=0;

#ifdef _CWMP_MIB_
	//eth0 interface enable or disable
	mib_get(CWMP_LAN_ETHIFENABLE, (void *)&vChar);

	if(vChar==0)
	{
		va_cmd(IFCONFIG, 2, 1, ELANIF, "down");
		printf("Disable eth0 interface\n");
		return 0;
	}
	else
	{
#endif
		va_cmd(IFCONFIG, 2, 1, ELANIF, "up");
		printf("Enable eth0 interface\n");

#ifdef ELAN_LINK_MODE_INTRENAL_PHY
		int skfd;
		struct ifreq ifr;
		unsigned char mode;
		//struct mii_ioctl_data *mii = (struct mii_data *)&ifr.ifr_data;
		//MIB_CE_SW_PORT_T Port;
		//int i, k, total;
		struct ethtool_cmd ecmd;


		strcpy(ifr.ifr_name, ELANIF);
		ifr.ifr_data = &ecmd;


		if (!mib_get(MIB_ETH_MODE, (void *)&mode))
			return -1;

		skfd = socket(AF_INET, SOCK_DGRAM, 0);
		if(skfd == -1)
		{
			fprintf(stderr, "Socket Open failed Error\n");
			return -1;
		}
		ecmd.cmd = ETHTOOL_GSET;
		if (ioctl(skfd, SIOCETHTOOL, &ifr) < 0) {
			fprintf(stderr, "ETHTOOL_GSET on %s failed: %s\n", ifr.ifr_name,
				strerror(errno));
			status=-1;
			goto error;
		}

		ecmd.autoneg = AUTONEG_DISABLE;
		switch(mode) {
		case LINK_10HALF:
			ecmd.speed = SPEED_10;
			ecmd.duplex = DUPLEX_HALF;
			break;
		case LINK_10FULL:
			ecmd.speed = SPEED_10;
			ecmd.duplex = DUPLEX_FULL;
			break;
		case LINK_100HALF:
			ecmd.speed = SPEED_100;
			ecmd.duplex = DUPLEX_HALF;
			break;
		case LINK_100FULL:
			ecmd.speed = SPEED_100;
			ecmd.duplex = DUPLEX_FULL;
			break;
		default:
			ecmd.autoneg = AUTONEG_ENABLE;
		}

		ecmd.cmd = ETHTOOL_SSET;
		if (ioctl(skfd, SIOCETHTOOL, &ifr) < 0) {
			fprintf(stderr, "ETHTOOL_SSET on %s failed: %s\n", ifr.ifr_name,
				strerror(errno));
			status=-1;
			goto error;
		}
		/*
		ecmd.cmd = ETHTOOL_NWAY_RST;
		if (ioctl(skfd, SIOCETHTOOL, &ifr) < 0) {
			fprintf(stderr, "ETHTOOL_SSET on %s failed: %s\n", ifr.ifr_name,
				strerror(errno));
			status=-1;
		}
		*/

		error:

		close(skfd);
#endif
		return status;
#ifdef _CWMP_MIB_
	}
#endif

	return -1;

}
#endif	//CONFIG_RTK_L34_ENABLE

#ifdef ELAN_LINK_MODE
// return value:
// 0  : successful
// -1 : failed
int setupLinkMode(void)
{
	int skfd;
	struct ifreq ifr;
	struct mii_ioctl_data *mii = (struct mii_data *)&ifr.ifr_data;
	//MIB_CE_SW_PORT_Tp pPort;
	MIB_CE_SW_PORT_T Port;
	int i, k, total;
	int status=0;

	strcpy(ifr.ifr_name, ELANIF);
	skfd = socket(AF_INET, SOCK_DGRAM, 0);
	total = mib_chain_total(MIB_SW_PORT_TBL);

	for (i=0; i<total; i++) {
		if (!mib_chain_get(MIB_SW_PORT_TBL, i, (void *)&Port))
			continue;
		mii->phy_id = i; // phy i
		mii->reg_num = 4; // register 4
		// set NWAY advertisement
		mii->val_in = 0x0401; // enable flow control capability and IEEE802.3
		if (Port.linkMode == LINK_10HALF || Port.linkMode == LINK_AUTO)
			mii->val_in |= (1<<(5+LINK_10HALF));
		if (Port.linkMode == LINK_10FULL || Port.linkMode == LINK_AUTO)
			mii->val_in |= (1<<(5+LINK_10FULL));
		if (Port.linkMode == LINK_100HALF || Port.linkMode == LINK_AUTO)
			mii->val_in |= (1<<(5+LINK_100HALF));
		if (Port.linkMode == LINK_100FULL || Port.linkMode == LINK_AUTO)
			mii->val_in |= (1<<(5+LINK_100FULL));

		if (ioctl(skfd, SIOCSMIIREG, &ifr) < 0) {
			fprintf(stderr, "SIOCSMIIREG on %s failed: %s\n", ifr.ifr_name,
				strerror(errno));
			status=-1;
		}

		// restart
		mii->reg_num = 0; // register 0
		mii->val_in = 0x1200; // enable auto-negotiation and restart it
		if (ioctl(skfd, SIOCSMIIREG, &ifr) < 0) {
			fprintf(stderr, "SIOCSMIIREG on %s failed: %s\n", ifr.ifr_name,
				strerror(errno));
			status=-1;
		};
	}
	if(skfd!=-1) close(skfd);
	return status;
}
#endif // of ELAN_LINK_MODE

//piyajee_chen, 'struct	webserver_webserver_callout' move to boa_timer.h

//void timeout(void (*func) __P((void *)), void *arg, int time, struct webserver_callout *handle);
void mtimeout(void (*func) __P((void *)), void *arg, int time, struct webserver_callout *handle);
//void untimeout(struct webserver_callout *handle);
static struct webserver_callout *webserver_callout = NULL;	/* Callout list */
static struct timeval timenow;		/* Current time */

/*
 * timeout - Schedule a timeout.
 *
 * Note that this timeout takes the number of seconds, NOT hz (as in
 * the kernel).
 */
void
timeout_utility(func, arg, time, handle)
    void (*func) __P((void *));
    void *arg;
    int time;
    struct webserver_callout *handle;
{
    struct webserver_callout *p, **pp;

    untimeout_utility(handle);

    handle->c_arg = arg;
    handle->c_func = func;
    gettimeofday(&timenow, NULL);
    handle->c_time.tv_sec = timenow.tv_sec + time;
    handle->c_time.tv_usec = timenow.tv_usec;

    /*
     * Find correct place and link it in.
     */
    for (pp = &webserver_callout; (p = *pp); pp = &p->c_next)
	if (handle->c_time.tv_sec < p->c_time.tv_sec
	    || (handle->c_time.tv_sec == p->c_time.tv_sec
		&& handle->c_time.tv_usec < p->c_time.tv_usec))
	    break;
    handle->c_next = p;
    *pp = handle;
}


/*
 * untimeout - Unschedule a timeout.
 */
void
untimeout_utility(handle)
struct webserver_callout *handle;
{
    struct webserver_callout **copp, *freep;

    /*
     * Find first matching timeout and remove it from the list.
     */
    for (copp = &webserver_callout; (freep = *copp); copp = &freep->c_next)
	if (freep == handle) {
	    *copp = freep->c_next;
	    break;
	}
}


/*
 * calltimeout - Call any timeout routines which are now due.
 */
void
calltimeout()
{
    struct webserver_callout *p;

    while (webserver_callout != NULL) {
		p = webserver_callout;
		if (gettimeofday(&timenow, NULL) < 0)
		    //fatal("Failed to get time of day: %m");
	    	printf("Failed to get time of day: %m");
		if (!(p->c_time.tv_sec < timenow.tv_sec
		      || (p->c_time.tv_sec == timenow.tv_sec
			  && p->c_time.tv_usec <= timenow.tv_usec)))
	    	break;		/* no, it's not time yet */
		webserver_callout = p->c_next;
		(*p->c_func)(p->c_arg);
    }
}


/*
 * timeleft - return the length of time until the next timeout is due.
 */
static struct timeval *
timeleft(tvp)
    struct timeval *tvp;
{
    if (webserver_callout == NULL)
	return NULL;

    gettimeofday(&timenow, NULL);
    tvp->tv_sec = webserver_callout->c_time.tv_sec - timenow.tv_sec;
    tvp->tv_usec = webserver_callout->c_time.tv_usec - timenow.tv_usec;
    if (tvp->tv_usec < 0) {
	tvp->tv_usec += 1000000;
	tvp->tv_sec -= 1;
    }
    if (tvp->tv_sec < 0)
	tvp->tv_sec = tvp->tv_usec = 0;

    return tvp;
}


#ifdef WEB_REDIRECT_BY_MAC
struct webserver_callout landingPage_ch;
void clearLandingPageRule(void *dummy)
{
	int status=0;
	char ipaddr[16], ip_port[32];
	char tmpbuf[MAX_URL_LEN];
	int  def_port=WEB_REDIR_BY_MAC_PORT;
	unsigned int uLTime;

	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-F", "WebRedirectByMAC");

	ipaddr[0]='\0'; ip_port[0]='\0';

	if (mib_get(MIB_ADSL_LAN_IP, (void *)tmpbuf) != 0)
	{
		strncpy(ipaddr, inet_ntoa(*((struct in_addr *)tmpbuf)), 16);
		ipaddr[15] = '\0';
		sprintf(ip_port,"%s:%d",ipaddr,def_port);
	}

	//iptables -t nat -A WebRedirectByMAC -d 192.168.1.1 -j RETURN
	status|=va_cmd(IPTABLES, 8, 1, "-t", "nat","-A","WebRedirectByMAC",
		"-d", ipaddr, "-j", (char *)FW_RETURN);

	//iptables -t nat -A WebRedirectByMAC -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080
	status|=va_cmd(IPTABLES, 12, 1, "-t", "nat","-A","WebRedirectByMAC",
		"-p", "tcp", "--dport", "80", "-j", "DNAT",
		"--to-destination", ip_port);

	mib_chain_clear(MIB_WEB_REDIR_BY_MAC_TBL);

	//update to the flash
	#if 0
	itfcfg("sar", 0);
	itfcfg(ELANIF, 0);
	#endif
	mib_update(CURRENT_SETTING, CONFIG_MIB_ALL);
	#if 0
	itfcfg("sar", 1);
	itfcfg(ELANIF, 1);
	#endif

        mib_get(MIB_WEB_REDIR_BY_MAC_INTERVAL, (void *)&uLTime);
	TIMEOUT(clearLandingPageRule, 0, uLTime, landingPage_ch);
}
#endif

#ifdef AUTO_DETECT_DMZ
#define AUTO_DMZ_INTERVAL 30
static int getDhcpClientIP(char **ppStart, unsigned long *size, char *ip)
{
	struct dhcpOfferedAddr {
        	u_int8_t chaddr[16];
        	u_int32_t yiaddr;       /* network order */
        	u_int32_t expires;      /* host order */
			u_int32_t interfaceType;
			u_int8_t hostName[64];
#ifdef _PRMT_X_CT_SUPPER_DHCP_LEASE_SC
			int category;
			int isCtcVendor;
			char szVendor[36];
			char szModel[36];
			char szFQDN[64];
#endif
	};
	struct dhcpOfferedAddr entry;
	if (*size < sizeof(entry))
		return -1;
	entry = *((struct dhcpOfferedAddr *)*ppStart);
	*ppStart = *ppStart + sizeof(entry);
	*size = *size - sizeof(entry);
	if (entry.expires == 0)
		return 0;
	if (entry.chaddr[0]==0&&entry.chaddr[1]==0&&entry.chaddr[2]==0&&entry.chaddr[3]==0&&entry.chaddr[4]==0&&entry.chaddr[5]==0)
		return 0;
	strcpy(ip, inet_ntoa(*((struct in_addr *)&entry.yiaddr)));
	return 1;
}

static int Get1stArp(char *dmzIP)
{
	FILE *fp;
	char  buf[256];
	char tmp0[32],tmp1[32],tmp2[32];
	int dmzFlags;
	dmzIP[0] = 0; // "" empty
	fp = fopen("/proc/net/arp", "r");
	if (fp == NULL)
		printf("read arp file fail!\n");
	else {
		fgets(buf, 256, fp);//first line!?
		while(fgets(buf, 256, fp) >0) {
			//sscanf(buf, "%s", dmzIP);
			sscanf(buf,"%s	%*s	0x%x %s %s %s ", dmzIP, &dmzFlags,tmp0,tmp1,tmp2);
			if ((dmzFlags == 0) || (strncmp(tmp2,"br",2)!=0))
				continue;
			return 1;
		}
		fclose(fp);
		return 0;
	}
	return 0;
}

struct webserver_callout autoDMZ_ch;

void poll_autoDMZ(void *dummy)
{
	static char autoDMZ = 0;
	// signal dhcp client to renew
	struct stat status;
	char dhcpIP[40], *buffer = NULL, *ptr;
	FILE *fp;
	char dmz_ip_str[20];
	int lockfd = -1;

	if (autoDMZ == 0) // search 1st arp
	{
		unsigned long ulDmz, ulDhcp;
		unsigned char ucPreStat;
		int entryNum, ret;
		char s_entryNum[8], ip[32];
		struct in_addr ipAddr, dmzIp;

		fflush(stdout);
		if (Get1stArp(dmz_ip_str) == 1)
		{
			if (strlen(dmz_ip_str) == 0)
				goto end; // error

			autoDMZ = 1;
			mib_get(MIB_DMZ_ENABLE, (void *)&ucPreStat);
			mib_get(MIB_DMZ_IP, (void *)&dmzIp);
			ulDmz = *((unsigned long *)&dmzIp);
			strncpy(ip, inet_ntoa(dmzIp), 16); // ip -> old dmz
			if (strcmp(ip,dmz_ip_str) == 0)
				goto end; // no changed!

			inet_aton(dmz_ip_str, &ipAddr);
			ip[15] = '\0';
			entryNum = mib_chain_total (MIB_IP_PORT_FILTER_TBL) + 3;
			snprintf(s_entryNum, 8, "%d", entryNum);
			if (ucPreStat && ulDmz != 0)
				clearDMZ();

			if (mib_set(MIB_DMZ_IP, (void *)&ipAddr) == 0)
				printf("Set DMZ MIB error!\n");

				if (!mib_set(MIB_DMZ_ENABLE, (void *)&autoDMZ))
					printf("Set DMZ Capability error!\n");
				setDMZ(dmz_ip_str);
				goto end;

		}

	}
	else  // check dhcp and then arp
	{
		unsigned long ulDmz, ulDhcp;
		unsigned char ucPreStat;
		struct in_addr ipAddr, dmzIp;
		int entryNum, ret;
		char s_entryNum[8], ip[32];
		// siganl DHCP server to update lease file
		int pid = read_pid(DHCPSERVERPID);

		if (pid > 0)	// renew
			kill(pid, SIGUSR1);
		usleep(1000);

		if ((lockfd = lock_file_by_flock(DHCPSERVERPID, 0)) == -1)
		{
			printf("%s, the file have been locked\n", __FUNCTION__);
			goto end;
		}		

		if (stat(DHCPD_LEASE, &status) < 0)
			goto end;

		// read DHCP server lease file
		buffer = malloc(status.st_size);
		if (buffer == NULL)
			goto end;
		fp = fopen(DHCPD_LEASE, "r");
		if (fp == NULL)
			goto end;
		fread(buffer, 1, status.st_size, fp);
		fclose(fp);
		ptr = buffer;

		while (1) {
			if (getDhcpClientIP(&ptr, &status.st_size, dhcpIP) == 1)
			{
				mib_get(MIB_DMZ_ENABLE, (void *)&ucPreStat);
				mib_get(MIB_DMZ_IP, (void *)&dmzIp);
				ulDmz = *((unsigned long *)&dmzIp);
				strncpy(ip, inet_ntoa(dmzIp), 16);
				if (strcmp(ip, dhcpIP) ==0 )	//dhcp still in using..
				{
					goto end;
				}
			}
			else // find the 1st arp
			{
				// uses the 1st entry
				if (Get1stArp(dmz_ip_str) == 1)
				{
					if (strlen(dmz_ip_str) == 0)
						goto end; // error

					autoDMZ = 1;
					mib_get(MIB_DMZ_ENABLE, (void *)&ucPreStat);
					mib_get(MIB_DMZ_IP, (void *)&dmzIp);
					ulDmz = *((unsigned long *)&dmzIp);
					strncpy(ip, inet_ntoa(dmzIp), 16); // ip -> old dmz
					inet_aton(dmz_ip_str, &ipAddr);
					ip[15] = '\0';
					if (strcmp(ip,dmz_ip_str) == 0)
						goto end; // still the same one

					entryNum = mib_chain_total (MIB_IP_PORT_FILTER_TBL) + 3;
					snprintf(s_entryNum, 8, "%d", entryNum);
					if (ucPreStat && ulDmz != 0)
						clearDMZ();

					if (mib_set(MIB_DMZ_IP, (void *)&ipAddr) == 0)
						printf("Set DMZ MIB error!\n");

						if (!mib_set(MIB_DMZ_ENABLE, (void *)&autoDMZ))
							printf("Set DMZ Capability error!\n");
						setDMZ(dmz_ip_str);
						goto end;

				}
				else
				{
					// clear rules
					mib_get(MIB_DMZ_IP, (void *)&dmzIp);
					strncpy(ip, inet_ntoa(dmzIp), 16); // ip -> old dmz
					ip[15] = '\0';

					clearDMZ();
					*((unsigned long *)&dmzIp) = 0;
					autoDMZ = 0;
					mib_set(MIB_DMZ_ENABLE, (void *)&autoDMZ);
					mib_set(MIB_DMZ_IP, (void *)&dmzIp);
				}
				goto end;
			}
		}
	}


end:
	if (buffer)
		free(buffer);

	if(-1 != lockfd)
		unlock_file_by_flock(lockfd);
	
	TIMEOUT(poll_autoDMZ, 0, AUTO_DMZ_INTERVAL, autoDMZ_ch);
}
#endif



/* Martin zhu add for bridge WAN support ipv4/ipv6 Filter 2015.6.29 */
#ifdef CONFIG_IPV6
void setupBridgeIPv4IPv6Filter( MIB_CE_ATM_VC_Tp pEntry, unsigned char isadd )
{
	int ret;

	if ( CHANNEL_MODE_BRIDGE == (CHANNEL_MODE_T)pEntry->cmode )
	{
		if ( isadd ) {// add ACL Rules
		#ifdef CONFIG_RTK_L34_ENABLE
			ret = AddRTK_RG_ACL_Bridge_IPv4IPv6_Filters( pEntry );
		#endif
		} else {// delete ACL Rules
		#ifdef CONFIG_RTK_L34_ENABLE
			ret = FlushRTK_RG_ACL_Bridge_IPv4IPv6_Filters( pEntry );
		#endif
		}
	}

	return;
}
#endif

void startSNAT()
{
	int vcTotal, i;
	MIB_CE_ATM_VC_T Entry;
	char wanif[IFNAMSIZ];

	vcTotal = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < vcTotal; i++)
	{
		/* get the specified chain record */
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return;

		if (Entry.enable == 0)
			continue;

		ifGetName(Entry.ifIndex,wanif,sizeof(wanif));
		if (((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_IPOE)  ||
		  ((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_RT1483) ||
		  ((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_RT1577) )
		{
#ifdef CONFIG_IPV6
			if (Entry.IpProtocol & IPVER_IPV4) {
#endif
				if ((DHCP_T)Entry.ipDhcp == DHCP_DISABLED)
				{
					if (Entry.napt == 1)
					{
						// Setup one NAT Rule for the specfic interface
						startAddressMap(&Entry);
					}
				}
				else
				{
					if (Entry.napt == 1)
					{	// Enable NAPT
						va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_ADD, "POSTROUTING",
							ARG_O, wanif, "-j", "MASQUERADE");
					}
				}
#ifdef CONFIG_IPV6
			}
#endif
		}
		else if (((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_PPPOE) ||
		      ((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_PPPOA))
		{
#ifdef CONFIG_IPV6
			if (Entry.IpProtocol & IPVER_IPV4) {
#endif
				if (Entry.napt == 1)
				{	// Enable NAPT
					va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_ADD, "POSTROUTING",
						"-o", wanif, "-j", "MASQUERADE");
				}
#ifdef CONFIG_IPV6
			}
#endif
		}

	}
}
//disable wan limit access when bridge wan only.
void disable_wan_limit_access(void)
{
	int route_wan=0;
	//int bridge_wan=0;
	int vcTotal=-1,i;
	MIB_CE_ATM_VC_T Entry;

	vcTotal = mib_chain_total(MIB_ATM_VC_TBL);
	if(vcTotal<0)
		return;
	for (i = 0; i < vcTotal; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;
		//VCentry existed an internet and routing WAN
		if(Entry.cmode > 0){
			route_wan=1;
		}
	}
	if(!route_wan){
		//VCentry existed an internet and bridge WAN
		AUG_PRT("%s-%d bridge wan only, disable wan limit access\n",__func__,__LINE__);
#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_CTC_E8_CLIENT_LIMIT)
		RTK_RG_disable_AccessWanLimit();
#endif
	}else
	{
		//re-check wan limit access
		AUG_PRT("%s-%d routing wan existed, check wan limit access again\n",__func__,__LINE__);
#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_CTC_E8_CLIENT_LIMIT)
		RTK_RG_AccessWanLimit_Set();
#endif
	}

}

// configAll = CONFIGALL,  pEntry = NULL  : restart all WAN connections(include VC, ETHWAN, PTMWAN, VPN, 3g).
//									  It means that we add or modify all VC, ETHWAN, PTMWAN channel.
// configAll = CONFIGONE, pEntry != NULL : restart specified VC, ETHWAN, PTMWAN connection and VPN, 3g connections.
// 									  It means that we add or modify a VC, ETHWAN, PTMWAN channel.
// configAll = CONFIGONE, pEntry = NULL  : restart VPN, 3g connections. It means that we delete a VC, ETHWAN, PTMWAN channel.
void restartWAN(int configAll, MIB_CE_ATM_VC_Tp pEntry)
{
	int dhcrelay_pid, i;
	char vChar;
	unsigned char tmpBuf[64];

#if defined(CONFIG_RTK_L34_ENABLE)
	/* When delete the wan entry , burst pkts will trap into CPU causing system hang, limit the CPU bandwidth */
	RG_set_CPU_port_egress_bandwidth_control(1024);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	set_vlan_cfg_action(0, 0);
#endif
#endif


#if !defined(CONFIG_RTK_L34_ENABLE)
//eason path for pvc add/del and conntrack killall
// Mason Yu. Before flush all the conntrack table, we should close the eth0 and br0 interface.
// In order to into a loop in ip_conntrack_flush();
#if	!defined(CONFIG_RTL_MULTI_LAN_DEV) && !defined(CONFIG_RTL8686)
	va_cmd(IFCONFIG, 2, 1, ELANIF, "down");
#endif
	va_cmd(IFCONFIG, 2, 1, BRIF, "down");
	va_cmd("/bin/ethctl", 2, 1, "conntrack", "killall");
#if	!defined(CONFIG_RTL_MULTI_LAN_DEV) && !defined(CONFIG_RTL8686)
	va_cmd(IFCONFIG, 2, 1, ELANIF, "up");
#endif
	va_cmd(IFCONFIG, 2, 1, BRIF, "up");
#endif

	cleanAllFirewallRule();

#if defined(CONFIG_RTK_L34_ENABLE)
	/* Turn switch WAN port down */
	//RG_wan_phy_force_power_down(1);
#endif

// reconfigure RG LAN interface
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
//	Init_RG_ELan(UntagCPort, RoutingWan);
#endif

#ifdef CONFIG_RTK_L34_ENABLE
{
	int EntryID, ret;
	MIB_CE_ATM_VC_T tmp;
	ret = RG_check_Droute(configAll,pEntry,&EntryID);
	
	fprintf(stderr, "[%s@%d] RG_check_Droute ret = %d \n", __FUNCTION__, __LINE__, ret);
	if(ret == 3 && configAll != CONFIGCWMP){
	/*remove, modify D route case!!!!*/
//AUG_PRT("%s-%d EntryID=%d\n",__func__,__LINE__,EntryID);
		if (!mib_chain_get(MIB_ATM_VC_TBL, EntryID, (void*)&tmp))
			return;
//AUG_PRT("%s-%d tmp.enable=%d\n",__func__,__LINE__,tmp.enable);
		deleteConnection(CONFIGONE, &tmp);// Modify or remove D route
		startWan(CONFIGONE, &tmp, 0);
	}
//AUG_PRT("%s-%d\n",__func__,__LINE__);
}
#endif
	if (configAll == CONFIGALL)
		startWan(CONFIGALL, NULL, 0);
	else if (configAll == CONFIGONE)
		startWan(CONFIGONE, pEntry, 0);
	else if (configAll == CONFIGCWMP)
		startWan(CONFIGCWMP, NULL, 0);

#if defined(CONFIG_RTK_L34_ENABLE)
	/* Turn switch WAN port up */
	//RG_wan_phy_force_power_down(0);
#endif

	mib_get(MIB_MPMODE, (void *)&vChar);

#ifdef NEW_PORTMAPPING
	setupnewEth2pvc();
#endif

	// setup IP QoS
#ifdef IP_QOS
	if (vChar&MP_IPQ_MASK) {
		stopIPQ();
		setupIPQ();
	}
#endif

// Mason Yu. SIGRTMIN for DHCP Relay.catch SIGRTMIN(090605)
#ifdef COMBINE_DHCPD_DHCRELAY
	dhcrelay_pid = read_pid(DHCPSERVERPID);
#else
	dhcrelay_pid = read_pid("/var/run/dhcrelay.pid");
#endif
	if (dhcrelay_pid > 0) {
		printf("restartWAN1: kick dhcrelay(%d) to Re-discover all network interface\n", dhcrelay_pid);
		// Mason Yu. catch SIGRTMIN(It is a real time signal and number is 32) for re-sync all interface on DHCP Relay
		// Kaohj -- SIGRTMIN is not constant, so we use 32.
		//kill(dhcrelay_pid, SIGRTMIN);
		kill(dhcrelay_pid, 32);
	}

	// Mason Yu.
#ifdef CONFIG_IPV6

	if (mib_get(MIB_IPV6_LAN_IP_ADDR, (void *)tmpBuf) != 0)
	{
		char cmdBuf[100]={0};
		sprintf(cmdBuf, "%s/%d", tmpBuf, 64);
		va_cmd(IFCONFIG, 3, 1, LANIF, ARG_ADD, cmdBuf);
	}

#ifdef CONFIG_USER_DHCPV6_ISC_DHCP411
	if(configAll || ( pEntry && (pEntry->IpProtocol & IPVER_IPV6)))
	{
#ifdef SUPPORT_DHCPV6_RELAY
		unsigned char vChar;
		mib_get(MIB_DHCPV6_MODE, (void *)&vChar);
		if(vChar == DHCP_LAN_RELAY)
		{
			startDhcpv6Relay();
		}
		else
#endif
			restartDHCPV6Server();
	}
#endif
#endif

#ifdef IP_QOS
	update_qos_tbl();
#endif

	//ql 20081118 START restart IP QoS
#ifdef NEW_IP_QOS_SUPPORT
	take_qos_effect();
#endif
#ifdef CONFIG_USER_IP_QOS_3
	take_qos_effect_v3();
#endif

#ifdef CONFIG_USER_XFRM
	ipsec_take_effect();
#endif

#ifdef CONFIG_USER_PPTP_CLIENT_PPTP
#ifdef CONFIG_USER_PPTPD_PPTPD
	pptpd_take_effect();
#endif
#endif

#ifdef CONFIG_USER_L2TPD_LNS
	l2tpd_take_effect();
#endif

#ifndef MAC_FILTER_SRC_ONLY
	setupMacFilterEbtables();
#endif
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
{
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE) || defined(CONFIG_FIBER_FEATURE)
	int pon_mode=0, acl_default=0;
	if (mib_get(MIB_PON_MODE, (void *)&pon_mode) != 0)
	{
#ifdef CONFIG_RTL9602C_SERIES
		acl_default = 1;
#endif
		if ((pon_mode != GPON_MODE) || acl_default == 1)
		{
			RG_del_All_default_Acl();
			RG_add_default_Acl_Qos();
		}
	}
#else
	/*use for 8696*/
	RG_del_All_default_Acl();
	RG_add_default_Acl_Qos();
#endif
#if !defined(CONFIG_CMCC) && !defined(CONFIG_CU)
	RTK_RG_USER_APP_ACL_Rule_Flush();
	RTK_RG_USER_APP_ACL_Rule_Set();
#endif
}
#endif
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
	Flush_RTK_RG_IPv4_IPv6_Vid_Binding_ACL();
	RTK_RG_Set_IPv4_IPv6_Vid_Binding_ACL();
	RG_del_PPPoE_Acl();
	RG_add_PPPoE_RB_passthrough_Acl();
	RTK_RG_FLUSH_Bridge_DHCP_ACL_FILE();
	RTK_RG_Set_ACL_Bridge_DHCP_Filter();
	RTK_RG_add_acl_rule_for_v6_icmp();
 	//RTK_RG_FLUSH_Route_V6_RA_NS_ACL_FILE();
 	//RTK_RG_Set_ACL_Route_V6_RA_NS_Filter();
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)	
	RG_Flush_Handle_Priority_Tag0_ACL_FILE();
	RG_Handle_Priority_Tag0_By_Port();
	//set unbinded port to vlan 9, to make unbinded port can access other binded port
	RG_set_unbinded_port_vlan();
	RGSyncIPv4_IPv6_Dual_WAN();
#endif	

#if defined(CONFIG_EPON_FEATURE) && defined(CONFIG_RTL9600_SERIES)
	//for EPON none binding lan port 
	unsigned int pon_mode;
	mib_get(MIB_PON_MODE, (void *)&pon_mode);
	if(pon_mode == EPON_MODE)
	{	
		Flush_RTK_RG_Bridge_from_Lan_ACL();
		RTK_RG_Set_ACL_Bridge_from_Lan();
	}
#endif	
#endif
	setupMacFilterTables();
#ifndef CONFIG_RTL9600_SERIES
        check_port_based_vlan_of_binding_bridge_inet_wan();
#endif
        disable_wan_limit_access();

	
#ifdef CONFIG_RTK_L34_ENABLE
	RG_set_CPU_port_egress_bandwidth_control(0);
#endif
}

/*
 *	Deal with configuration dependency when a WAN channel has been deleted.
 */
void resolveServiceDependency(unsigned int idx)
{
	MIB_CE_ATM_VC_T Entry;
#ifdef CONFIG_USER_IGMPPROXY
	unsigned int igmp_proxy_itf;
	unsigned char igmp_enable;
#endif
#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_ECMH
	unsigned int mld_proxy_itf;
	unsigned char mld_proxy_enable;
#endif
#endif
#ifdef IP_PASSTHROUGH
	unsigned int ippt_itf;
	unsigned int ippt_lease;
#endif
#ifdef CONFIG_USER_MINIUPNPD
	unsigned char upnpdEnable;
	unsigned int upnpItf;
#endif
	struct data_to_pass_st msg;
	int k;
#ifdef TIME_ZONE
	unsigned int if_wan = DUMMY_IFINDEX;
#endif

	/* get the specified chain record */
	if (!mib_chain_get(MIB_ATM_VC_TBL, idx, (void *)&Entry))
	{
		return;
	}

#ifdef CONFIG_USER_IGMPPROXY
	// resolve IGMP proxy dependency
	if(!mib_get( MIB_IGMP_PROXY_ITF,  (void *)&igmp_proxy_itf))
		return;
	if (Entry.ifIndex == igmp_proxy_itf)
	{ // This interface is IGMP proxy interface
		igmp_proxy_itf = DUMMY_IFINDEX;	// set to default
		mib_set(MIB_IGMP_PROXY_ITF, (void *)&igmp_proxy_itf);
		igmp_enable = 0;	// disable IGMP proxy
		mib_set(MIB_IGMP_PROXY, (void *)&igmp_enable);
	}
#endif

#ifdef CONFIG_IPV6
#ifdef CONFIG_USER_ECMH
	if(!mib_get(MIB_MLD_PROXY_EXT_ITF,  (void *)&mld_proxy_itf))
		return;
	if (Entry.ifIndex == mld_proxy_itf)
	{ // This interface is MLD proxy interface
		mld_proxy_itf = DUMMY_IFINDEX; // set to default
		mib_set(MIB_MLD_PROXY_EXT_ITF, (void *)&mld_proxy_itf);
		mld_proxy_enable = 0;	// disable MLD proxy
		mib_set(MIB_MLD_PROXY_DAEMON, (void *)&mld_proxy_enable);
	}
#endif
#endif

#ifdef IP_PASSTHROUGH
	// resolve IP passthrough dependency
	if(!mib_get( MIB_IPPT_ITF,  (void *)&ippt_itf))
		return;
	if (Entry.ifIndex == ippt_itf)
	{ // This interface is IP passthrough interface
		ippt_itf = DUMMY_IFINDEX;	// set to default
		mib_set(MIB_IPPT_ITF, (void *)&ippt_itf);
		ippt_lease = 600;	// default to 10 min.
		mib_set(MIB_IPPT_LEASE, (void *)&ippt_lease);
	}
#endif

#ifdef CONFIG_USER_MINIUPNPD
	if (mib_get(MIB_UPNP_DAEMON, &upnpdEnable) && upnpdEnable) {
		if (mib_get(MIB_UPNP_EXT_ITF, &upnpItf)
				&& upnpItf == Entry.ifIndex) {
			upnpdEnable = 0;
			mib_set(MIB_UPNP_DAEMON, &upnpdEnable);
		}
	}
#endif

	delPortForwarding( Entry.ifIndex );
	delRoutingTable( Entry.ifIndex );
#ifdef CONFIG_USER_ROUTED_ROUTED
	delRipTable(Entry.ifIndex);
#endif
#ifdef TIME_ZONE
	mib_get(MIB_NTP_IF_WAN, &if_wan);
	if (if_wan == Entry.ifIndex) {
		stopNTP();
		if_wan = DUMMY_IFINDEX;
		mib_set(MIB_NTP_IF_WAN, &if_wan);
	}
#endif
	delPPPoESession(Entry.ifIndex);
#ifdef CONFIG_MIDDLEWARE
	//setapplicationtype_mw(&Entry,1,NULL); // star: del route rule for tr069 type wan connection
#endif
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	delQosClassficationTypeRule(Entry.ifIndex);
#endif

}

#ifdef IP_PASSTHROUGH
static void set_IPPT_LAN_access()
{
	unsigned int ippt_itf;
	unsigned char value[32];

	// IP Passthrough, LAN access
	if (mib_get(MIB_IPPT_ITF, (void *)&ippt_itf) != 0)
		if (ippt_itf != DUMMY_IFINDEX) {	// IP passthrough
			mib_get(MIB_IPPT_LANACC, (void *)value);
			if (value[0] == 0)	// disable LAN access
				// iptables -A FORWARD -i $LAN_IF -o $LAN_IF -j DROP
				va_cmd(IPTABLES, 8, 1, (char *)FW_ADD,
					(char *)FW_FORWARD, (char *)ARG_I,
					(char *)LANIF, (char *)ARG_O,
					(char *)LANIF, "-j", (char *)FW_DROP);
		}
}

static void clean_IPPT_LAN_access()
{
	// iptables -D FORWARD -i $LAN_IF -o $LAN_IF -j DROP
	va_cmd(IPTABLES, 8, 1, (char *)FW_DEL,
		(char *)FW_FORWARD, (char *)ARG_I,
		(char *)LANIF, (char *)ARG_O,
		(char *)LANIF, "-j", (char *)FW_DROP);
}

// Mason Yu
void restartIPPT(struct ippt_para para)
{
	unsigned int entryNum, i, idx, vcIndex, selected;
	MIB_CE_ATM_VC_T Entry;
	FILE *fp;
	int restar_dhcpd_flag=0, isPPPoE=0;
	unsigned long myipaddr, hisipaddr;
	char pppif[6], globalIP_str[16];
	MEDIA_TYPE_T mType;

	//printf("Take effect for IPPT and old_ippt_itf=%d new_ippt_itf=%d\n", para.old_ippt_itf, para.new_ippt_itf);
	//printf("Take effect for IPPT and old_ippt_lease=%d new_ippt_lease=%d\n", para.old_ippt_lease, para.new_ippt_lease);
	//printf("Take effect for IPPT and old_ippt_lanacc=%d new_ippt_lanacc=%d\n", para.old_ippt_lanacc, para.new_ippt_lanacc);

       	// Stop IPPT
       	// If old_ippt_itf != 255 and new_ippt_itf != old_ippt_itf, it is that the IPPT is enabled. We should clear some configurations.
	if ( para.old_ippt_itf != DUMMY_IFINDEX  && para.new_ippt_itf != para.old_ippt_itf) {
		// (1)  set restart DHCP server flag with 1.
		restar_dhcpd_flag = 1;  // on restart DHCP server flag

		// (2) Delete /tmp/PPPHalfBridge file for DHCP Server
       		fp = fopen("/tmp/PPPHalfBridge", "r");
       		if (fp) {
       			fread(&myipaddr, 4, 1, fp);
	 	       	fread(&hisipaddr, 4, 1, fp);
       			unlink("/tmp/PPPHalfBridge");
       			fclose(fp);
       		}

       		// (3) Delete /tmp/IPoAHalfBridge file for DHCP Server
       		fp = fopen("/tmp/IPoAHalfBridge", "r");
       		if (fp) {
       			fread(&myipaddr, 4, 1, fp);
	 	       	fread(&hisipaddr, 4, 1, fp);
       			unlink("/tmp/IPoAHalfBridge");
       			fclose(fp);
       		}

		// Change Public IP to string
		snprintf(globalIP_str, 16, "%d.%d.%d.%d", (int)(myipaddr>>24)&0xff, (int)(myipaddr>>16)&0xff, (int)(myipaddr>>8)&0xff, (int)(myipaddr)&0xff);

		// (4) Delete LAN IPPT interface
		va_cmd(IFCONFIG, 2, 1, (char*)LAN_IPPT,"down");

		// (5) Delete a public IP's route
               	va_cmd(ROUTE, 5, 1, ARG_DEL, "-host", globalIP_str, "dev", LANIF);

		// (6) Restart the previous IPPT WAN connection.
		entryNum = mib_chain_total(MIB_ATM_VC_TBL);
		for (i = 0; i < entryNum; i++) {
			/* Retrieve entry */
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
				printf("restartIPPT: cannot get ATM_VC_TBL-1(ch=%d) entry\n", i);
				return;
			}

			/* remove connection on driver*/
			if (para.old_ippt_itf == Entry.ifIndex) {
				stopConnection(&Entry);

				// If this connection is PPPoE/oA, we should kill the old NAPT rule in POSTROUTING chain.
				// When channel mode is rt1483, NAPT rule will be deleted by stopConnection().
				if (Entry.cmode == CHANNEL_MODE_PPPOE || Entry.cmode == CHANNEL_MODE_PPPOA) {
					snprintf(pppif, 6, "ppp%u", PPP_INDEX(Entry.ifIndex));
        				va_cmd(IPTABLES, 10, 1, "-t", "nat", FW_DEL, "POSTROUTING",
			 			"-o", pppif, "-j", "SNAT", "--to-source", globalIP_str);
				}

				if (Entry.cmode == CHANNEL_MODE_PPPOE) {
					isPPPoE = 1;
					vcIndex = VC_INDEX(Entry.ifIndex);
					mType = MEDIA_INDEX(Entry.ifIndex);
					selected = i;
				}

#if defined(CONFIG_RTL_MULTI_ETH_WAN)
				addEthWANdev(&Entry);
#endif
				startConnection(&Entry, i);
				break;
			}
		}
	}

	if (isPPPoE) {
		for (i=0; i<entryNum; i++) {
			if (i == selected)
				continue;
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
				printf("restartIPPT: cannot get ATM_VC_TBL-1(ch=%d) entry\n", i);
				return;
			}
			if (mType == MEDIA_INDEX(Entry.ifIndex) && vcIndex == VC_INDEX(Entry.ifIndex)) {	// Jenny, for multisession PPPoE support
				startConnection(&Entry, i);
			}
		}
	}

	// Start New IPPT
	if ( para.new_ippt_itf != DUMMY_IFINDEX && para.new_ippt_itf != para.old_ippt_itf) {
		// (1)  set restart DHCP server flag with 1.
		restar_dhcpd_flag = 1;  // on restart DHCP server flag

		// (2) Config WAN interface and reconnect to DSL.
		entryNum = mib_chain_total(MIB_ATM_VC_TBL);
		for (i = 0; i < entryNum; i++) {
			/* Retrieve entry */
			if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
				printf("restartIPPT: cannot get ATM_VC_TBL-2(ch=%d) entry\n", i);
				return;
			}

			if (para.new_ippt_itf == Entry.ifIndex) {
				// If this connection is PPPoE/oA, we should kill the old NAPT rule in POSTROUTING chain.
				// When channel mode is rt1483, NAPT rule will be deleted by stopConnection().
				if ( (Entry.cmode == CHANNEL_MODE_PPPOE || Entry.cmode == CHANNEL_MODE_PPPOA)) {
					snprintf(pppif, 6, "ppp%u", PPP_INDEX(Entry.ifIndex));
					va_cmd(IPTABLES, 8, 1, "-t", "nat", FW_DEL, "POSTROUTING",
			 			"-o", pppif, "-j", "MASQUERADE");
				}
				stopConnection(&Entry);
				if (Entry.cmode == CHANNEL_MODE_PPPOE) {
					isPPPoE = 1;
					vcIndex = VC_INDEX(Entry.ifIndex);
					mType = MEDIA_INDEX(Entry.ifIndex);
					selected = i;
				}
#if defined(CONFIG_RTL_MULTI_ETH_WAN)
				addEthWANdev(&Entry);
#endif
				startConnection(&Entry, i);
				break;
			}
		}
		if (isPPPoE) {
			for (i=0; i<entryNum; i++) {
				if (i == selected)
					continue;
				if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
					printf("restartIPPT: cannot get ATM_VC_TBL-1(ch=%d) entry\n", i);
					return;
				}
				if (mType == MEDIA_INDEX(Entry.ifIndex) && vcIndex == VC_INDEX(Entry.ifIndex)) { // Jenny, for multisession PPPoE support
					startConnection(&Entry, i);
				}
			}
		}

	}  //  if ( new_ippt_itf != 255 )

	// Check IPPT Lease Time
	// Here we just concern about IPPT is enable.
	if ( para.old_ippt_lease != para.new_ippt_lease && para.new_ippt_itf != DUMMY_IFINDEX) {
		restar_dhcpd_flag = 1;  // on restart DHCP server flag
		//printf("change IPPT Lease Time\n");
	}

	// Check IPPT LAN Access
	if ( para.new_ippt_itf != DUMMY_IFINDEX || para.old_ippt_itf != DUMMY_IFINDEX) {
		if ( para.old_ippt_lanacc == 0 && para.old_ippt_itf != DUMMY_IFINDEX)
			clean_IPPT_LAN_access();
		set_IPPT_LAN_access();
	}

	// Restart DHCP Server
	if ( restar_dhcpd_flag == 1 ) {
		restar_dhcpd_flag = 0;  // off restart DHCP server flag
		restart_dhcp();
	}

}
#endif

#ifdef DOS_SUPPORT
void setup_dos_protection(void)
{
	unsigned int dos_enable;
	unsigned int dos_syssyn_flood;
	unsigned int dos_sysfin_flood;
	unsigned int dos_sysudp_flood;
	unsigned int dos_sysicmp_flood;
	unsigned int dos_pipsyn_flood;
	unsigned int dos_pipfin_flood;
	unsigned int dos_pipudp_flood;
	unsigned int dos_pipicmp_flood;
	unsigned int dos_block_time;
	unsigned char buffer[256],dosstr[256];
	int dostmpip[4],dostmpmask[4];
	int dosip,dosmask;
	FILE *dosfp;

	if (!mib_get( MIB_DOS_ENABLED,  (void *)&dos_enable)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_SYSSYN_FLOOD,  (void *)&dos_syssyn_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_SYSFIN_FLOOD,  (void *)&dos_sysfin_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_SYSUDP_FLOOD,  (void *)&dos_sysudp_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_SYSICMP_FLOOD,  (void *)&dos_sysicmp_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_PIPSYN_FLOOD,  (void *)&dos_pipsyn_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_PIPFIN_FLOOD,  (void *)&dos_pipfin_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_PIPUDP_FLOOD,  (void *)&dos_pipudp_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_PIPICMP_FLOOD,  (void *)&dos_pipicmp_flood)){
		printf("DOS parameter failed!\n");
	}
	if (!mib_get( MIB_DOS_BLOCK_TIME,  (void *)&dos_block_time)){
		printf("DOS parameter failed!\n");
	}

	//get ip
	if(!mib_get( MIB_ADSL_LAN_IP, (void *)buffer))
		return -1;
	sscanf(inet_ntoa(*((struct in_addr *)buffer)),"%d.%d.%d.%d",&dostmpip[0],&dostmpip[1],&dostmpip[2],&dostmpip[3]);
	dosip= dostmpip[0]<<24 | dostmpip[1]<<16 | dostmpip[2]<<8 | dostmpip[3];
	//get mask
	if(!mib_get( MIB_ADSL_LAN_SUBNET, (void *)buffer))
		return -1;
	sscanf(inet_ntoa(*((struct in_addr *)buffer)),"%d.%d.%d.%d",&dostmpmask[0],&dostmpmask[1],&dostmpmask[2],&dostmpmask[3]);
	dosmask= dostmpmask[0]<<24 | dostmpmask[1]<<16 | dostmpmask[2]<<8 | dostmpmask[3];
	dosip &= dosmask;
	sprintf(dosstr,"1 %x %x %d %d %d %d %d %d %d %d %d %d\n",
		dosip,dosmask,dos_enable,dos_syssyn_flood,dos_sysfin_flood,dos_sysudp_flood,
		dos_sysicmp_flood,dos_pipsyn_flood,dos_pipfin_flood,dos_pipudp_flood,
		dos_pipicmp_flood,dos_block_time);
	//printf("dosstr:%s\n\n",dosstr);
	dosstr[strlen(dosstr)]=NULL;
	if (dosfp = fopen("/proc/enable_dos", "w"))
	{
			fprintf(dosfp, "%s",dosstr);
			fclose(dosfp);
	}
}
#endif

int pppdbg_get(int unit)
{
	char buff[256];
	FILE *fp;
	int pppinf, pppdbg = 0;

	if (fp = fopen(PPP_DEBUG_LOG, "r")) {
		while (fgets(buff, sizeof(buff), fp) != NULL) {
			if (sscanf(buff, "%d:%d", &pppinf, &pppdbg) != 2)
				break;
			else {
				if (pppinf == unit)
					break;
			}
		}
		fclose(fp);
	}
	return pppdbg;
}

//cathy, update pvc link time
struct sysinfo * updateLinkTime(unsigned char update)
{
	static struct sysinfo info;

	if(update) {	// down --> up
		sysinfo(&info);
	}

	return &info;
}



// Magician: Commit immediately
#ifdef COMMIT_IMMEDIATELY
void Commit()
{
	mib_update(CURRENT_SETTING, CONFIG_MIB_ALL);
}
#endif // of #if COMMIT_IMMEDIATELY

#ifdef CONFIG_USER_SAMBA
#ifdef CONFIG_YUEME
int startSamba(void)
{
	unsigned char samba_enable;
	char *argv[10],
#ifdef CONFIG_USER_NMBD
	     nbn[MAX_SAMBA_NETBIOS_NAME_LEN], nbn_opt[MAX_SAMBA_NETBIOS_NAME_LEN + 32],
#endif
	     ss[MAX_SAMBA_SERVER_STRING_LEN], ss_opt[MAX_SAMBA_SERVER_STRING_LEN + 32];
	int i = -1, ret = 0;

	mib_get(MIB_SMB_SERVER_ENABLE, &samba_enable);
/*	if (!samba_enable) {
		return -1;
	}
*/
#ifdef CONFIG_USER_NMBD
	mib_get(MIB_SAMBA_NETBIOS_NAME, nbn);
#endif
	mib_get(MIB_SAMBA_SERVER_STRING, ss);

	/* set NetBIOS Name and Server String via command line arguments */
#ifdef CONFIG_USER_NMBD
	sprintf(nbn_opt, "--option=netbios name=%s", nbn);
#endif
	sprintf(ss_opt, "--option=server string=%s", ss);

	argv[++i] = "/bin/nmbd";
#ifdef CONFIG_USER_NMBD
	argv[++i] = nbn_opt;
#endif
	argv[++i] = ss_opt;
	argv[++i] = NULL;

#ifdef CONFIG_USER_NMBD
	ret = do_nice_cmd(argv[0], argv, 0);
#endif

	argv[0] = "/bin/smbd";
	printf("%s %d\n", __func__, __LINE__);
//	ret |= do_cmd(argv[0], argv, 0);
//	if (samba_enable != 0)
//	va_niced_cmd("/bin/smbd -D", 0, 0);


	return ret;
}
#else
int startSamba(void)
{
	unsigned char samba_enable;
#ifdef CONFIG_MULTI_SMBD_ACCOUNT
	char devName[MAX_NAME_LEN];
	char cmdStr[200];
#endif
	char *argv[10],
#ifdef CONFIG_USER_NMBD
	     nbn[MAX_SAMBA_NETBIOS_NAME_LEN], nbn_opt[MAX_SAMBA_NETBIOS_NAME_LEN + 32],
#endif
	     ss[MAX_SAMBA_SERVER_STRING_LEN], ss_opt[MAX_SAMBA_SERVER_STRING_LEN + 32];
	int i = -1, ret = 0;

	mib_get(MIB_SAMBA_ENABLE, &samba_enable);
	if (!samba_enable) {
		return -1;
	}

	//QL 20160127: set hostname for samba daemon
#ifdef CONFIG_MULTI_SMBD_ACCOUNT
	mib_get(MIB_DEVICE_NAME, (void *)devName);
	snprintf(cmdStr, 200, "echo %s > /proc/sys/kernel/hostname", devName);
	va_cmd("/bin/sh", 2, 1, "-c", cmdStr);
#endif//end of CONFIG_MULTI_SMBD_ACCOUNT

#ifdef CONFIG_USER_NMBD
	mib_get(MIB_SAMBA_NETBIOS_NAME, nbn);
#endif
	mib_get(MIB_SAMBA_SERVER_STRING, ss);

	/* set NetBIOS Name and Server String via command line arguments */
#ifdef CONFIG_USER_NMBD
	sprintf(nbn_opt, "--option=netbios name=%s", nbn);
#endif
	sprintf(ss_opt, "--option=server string=%s", ss);

	argv[++i] = "/bin/nmbd";
#ifdef CONFIG_USER_NMBD
	argv[++i] = nbn_opt;
#endif
	argv[++i] = ss_opt;
	argv[++i] = NULL;

#ifdef CONFIG_USER_NMBD
	ret = do_nice_cmd(argv[0], argv, 0);
#endif

	argv[0] = "/bin/smbd";
	printf("%s %d\n", __func__, __LINE__);
	ret |= do_nice_cmd(argv[0], argv, 0);

	return ret;
}
#endif
int stopSamba(void)
{
	pid_t pid;

#ifdef CONFIG_USER_NMBD
	pid = read_pid(NMBDPID);
	if (pid > 0) {
		/* nmbd is running */
		kill(pid, 9);
		unlink(NMBDPID);
	}
#endif

	pid = read_pid(SMBDPID);
	if (pid > 0) {
		/* smbd is running */
		/* using -pid would kill all processes whose process group ID is pid */
		kill(-pid, 9);
		unlink(SMBDPID);
	}

	return 0;
}
#endif // CONFIG_USER_SAMBA

#ifdef CONFIG_USER_CUPS
int getPrinterList(char *str, size_t size)
{
	char strbuf[BUF_SIZE], serverIP[INET_ADDRSTRLEN], *substr, *chr;
	FILE *fp;
	int offset;
	struct in_addr inAddr;

	if (getInAddr((char *)LANIF, IP_ADDR, &inAddr) == 1) {
		strncpy(serverIP, inet_ntoa(inAddr), sizeof(serverIP));
	} else {
		getMIB2Str(MIB_ADSL_LAN_IP, serverIP);
	}

	offset = 0;
	fp = fopen(CUPSDPRINTERCONF, "r");

	while (fgets(strbuf, sizeof(strbuf), fp)) {
		chr = strchr(strbuf, '#');

		/* search the pattern '<DefaultPrinter lp0>' or '<Printer lp0>' */
		if (substr = strstr(strbuf, "Printer ")) {
			if (chr && chr < substr) {
				/* in comment */
				continue;
			}

			/*
			 * the length of "Printer " is 8,
			 * now substr points to the start of the printer name
			 */
			substr += 8;

			if (chr = strchr(substr, '>'))
				*chr = '\0';

			offset += snprintf(str + offset, size - offset,
					"http://%s:631/printers/%s\n",
					serverIP, substr);
		}
	}

	fclose(fp);

	return offset;
}
#endif // CONFIG_USER_CUPS

#ifdef CONFIG_USER_MINIDLNA
// success: return 1;
// fail: return 0;
int get_dlna_db_dir(char *db_dir)
{
	FILE *fp;
	char buf[256]="";
	int ret=0;

	fp = fopen("/proc/mounts", "r");
	if (fp) {
		while (fgets(buf, sizeof(buf), fp)) {
			if (strstr(buf, "/dev/sd")) {
				sscanf(buf,"%*s %s", db_dir);
				sprintf(db_dir, "%s/minidlna", db_dir);
				//warn("get_db_dir: db_dir=%s\n", db_dir);
				// Format is : /dev/sdb /var/mnt/sdb vfat .....................
				ret = 1;
				break;
			}
		}
		fclose(fp);
	}

	return ret;
}

static void createMiniDLNAconf(char *name, char *directory)
{
	FILE *fp;

	fp = fopen(name, "w");
	if(fp) {
		fputs("port=8200\n",fp);
		fputs("network_interface=br0\n", fp);
		fprintf(fp, "media_dir=/mnt\n");
		fprintf(fp, "db_dir=%s\n",directory);
		fputs("friendly_name=My DLNA Server\n", fp);
		fputs("album_art_names=Cover.jpg/cover.jpg/AlbumArtSmall.jpg/albumartsmall.jpg/AlbumArt.jpg/albumart.jpg/Album.jpg/album.jpg/Folder.jpg/folder.jpg/Thumb.jpg/thumb.jpg\n", fp);
		fputs("inotify=yes\n", fp);
		fputs("enable_tivo=no\n", fp);
		fputs("strict_dlna=no\n", fp);
		fputs("notify_interval=10\n", fp);	// 900
		fputs("serial=12345678\n", fp);
		fputs("model_number=1\n", fp);
		fclose(fp);
	}
	return;
}

void startMiniDLNA(void)
{
	char *argv[10];
	int i = 0, pid = 0, retry = 0;
	//MIB_DMS_T entry,*p;
	unsigned int enable;
	char db_dir[32]="";

	if(read_pid((char *)MINIDLNAPID)>0){
		printf( "%s: already start, line=%d\n", __FUNCTION__, __LINE__ );
		return;
	}

	if (!get_dlna_db_dir(db_dir))
		return;;

	// Mason Yu. use table not chain
	mib_get(MIB_DMS_ENABLE, (void *)&enable);
	if(!enable) {
		printf( "%s: is diaabled, line=%d\n", __FUNCTION__, __LINE__ );
		return;
	}
	createMiniDLNAconf("/var/minidlna.conf", db_dir);
	
retry:
	stopMiniDLNA();
	i = 0;
	argv[i++]="/bin/minidlna";
//	argv[i++]="-d";
	argv[i++]="-R";
	argv[i++]="-f";
	argv[i++]="/var/minidlna.conf";
	argv[i]=NULL;
	do_nice_cmd( argv[0], argv, 0 );

	i=0;
	while ((pid = read_pid((char*)MINIDLNAPID) < 0) && i < 20) {
		usleep(100000); i++;
	}
	if((i >= 20 || kill(pid, 0)) && retry < 3){
		retry++;
		goto retry;
	}
}

void stopMiniDLNA(void)
{
	int i, pid = 0;
	char cmd[64];
	pid = read_pid((char *)MINIDLNAPID);
	
	if(pid > 0)
	{
		kill(pid, SIGTERM);
		// Kaohj -- wait for process termination
		i = 0;
		while (kill(pid, 0) == 0 && i < 20) {
			usleep(100000); i++;
		}
		if(i >= 20 )
			kill(pid, SIGKILL);
		
		if(!access(MINIDLNAPID, F_OK)) unlink(MINIDLNAPID);
	}
	
	sprintf(cmd, "pidof -s %s > %s", "minidlna", MINIDLNAPID);
	system(cmd);
	if(!access(MINIDLNAPID, F_OK)){
		if(read_pid((char*)MINIDLNAPID) > 0){
			printf(">> Force stop %s <<\n", "minidlna");
			sprintf(cmd, "killall -SIGKILL %s", "minidlna");
			system(cmd);
		}
		unlink(MINIDLNAPID);
	}
}
#endif

#ifdef CONFIG_IPV6

int ifPrefixUsingPD()
{
	unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;

	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
  			printf("Get chain record error!\n");
			return 0;
		}

		if ((Entry.Ipv6DhcpRequest&0x2) == 0x2){
			printf("Will request IPv6 prefix, 0x%x\n",Entry.ifIndex);
			return 1;
		}
	}

	return 0;
}

int ifIPv6LanPrefixConfigured()
{
	unsigned char str[MAX_RADVD_CONF_PREFIX_LEN];
	unsigned char vChar;

	if ( !mib_get(MIB_IPV6_LAN_PREFIX, (void *)str)) {
		return 0;
	}
	if ( !mib_get(MIB_IPV6_LAN_PREFIX_LEN, (void *)&vChar)) {
		return 0;
	}

	if(str[0] && (vChar!=0))
		return 1;

	return 0;
}

#ifdef CONFIG_USER_RADVD

// Added by Mason Yu for p2r_test
void init_radvd_conf_mib(void)
{
	unsigned char vChar;

	// MaxRtrAdvIntervalAct
	mib_set(MIB_V6_MAXRTRADVINTERVAL, "");

	// MinRtrAdvIntervalAct
	mib_set(MIB_V6_MINRTRADVINTERVAL, "");

	// AdvCurHopLimitAct
	mib_set(MIB_V6_ADVCURHOPLIMIT, "");

	// AdvDefaultLifetime
	mib_set(MIB_V6_ADVDEFAULTLIFETIME, "");

	// AdvReachableTime
	mib_set(MIB_V6_ADVREACHABLETIME, "");

	// AdvRetransTimer
	mib_set(MIB_V6_ADVRETRANSTIMER, "");

	// AdvLinkMTU
	mib_set(MIB_V6_ADVLINKMTU, "");

	// AdvSendAdvert
	vChar = 1;
	mib_set( MIB_V6_SENDADVERT, (void *)&vChar);      // on

	// AdvManagedFlag
	vChar = 2;
	mib_set( MIB_V6_MANAGEDFLAG, (void *)&vChar );     // ignore

	// AdvOtherConfigFlag
	vChar = 2;
	mib_set( MIB_V6_OTHERCONFIGFLAG, (void *)&vChar ); // ignore

    // RDNSS
	mib_set(MIB_V6_RDNSS1, "");
	mib_set(MIB_V6_RDNSS2, "");

	// Prefix
	mib_set( MIB_V6_PREFIX_MODE, "1");    // It must have Prefix IP

	mib_set(MIB_V6_PREFIX_IP, "3ffe:501:ffff:100::");
	mib_set(MIB_V6_PREFIX_LEN, "64");

	// AdvValidLifetime
	mib_set(MIB_V6_VALIDLIFETIME, "2592000");

	// AdvPreferredLifetime
	mib_set(MIB_V6_PREFERREDLIFETIME, "604800");

	// AdvOnLink
	vChar = 2;
	mib_set( MIB_V6_ONLINK, (void *)&vChar );    // ignore

	// AdvAutonomous
	vChar = 2;
	mib_set( MIB_V6_AUTONOMOUS, (void *)&vChar ); // ignore
}


int setup_radvd_conf()
{
	DNS_V6_INFO_T dnsV6Info={0};
	PREFIX_V6_INFO_T prefixInfo={0};
	FILE *fp;
	unsigned char str[MAX_RADVD_CONF_PREFIX_LEN];
	unsigned char str2[MAX_RADVD_CONF_PREFIX_LEN];
	unsigned char vChar,vChar2;
	int radvdpid;

	get_dnsv6_info(&dnsV6Info);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	get_prefixv6_info_radvd(&prefixInfo);
#else
	get_prefixv6_info(&prefixInfo);
#endif
#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
	flush_old_ip6sec_prefix(RADVD_CONF,&prefixInfo);
#endif
	if ((fp = fopen(RADVD_CONF, "w")) == NULL)
	{
		printf("Open file %s failed !\n", RADVD_CONF);
		return -1;
	}

	fprintf(fp, "interface br0\n");
	fprintf(fp, "{\n");

	// AdvSendAdvert
	if ( !mib_get( MIB_V6_SENDADVERT, (void *)&vChar) )
		printf("Get MIB_V6_SENDADVERT error!");
	if (0 == vChar)
		fprintf(fp, "\tAdvSendAdvert off;\n");
	else if (1 == vChar)
		fprintf(fp, "\tAdvSendAdvert on;\n");

	// MaxRtrAdvIntervalAct
	if ( !mib_get(MIB_V6_MAXRTRADVINTERVAL, (void *)str)) {
		printf("Get MaxRtrAdvIntervalAct mib error!");
	}
	if (str[0]) {
		fprintf(fp, "\tMaxRtrAdvInterval %s;\n", str);
	}

	// MinRtrAdvIntervalAct
	if ( !mib_get(MIB_V6_MINRTRADVINTERVAL, (void *)str)) {
		printf("Get MinRtrAdvIntervalAct mib error!");
	}
	if (str[0]) {
		fprintf(fp, "\tMinRtrAdvInterval %s;\n", str);
	}

	// AdvCurHopLimitAct
	if ( !mib_get(MIB_V6_ADVCURHOPLIMIT, (void *)str)) {
		printf("Get AdvCurHopLimitAct mib error!");
	}
	if (str[0]) {
		fprintf(fp, "\tAdvCurHopLimit %s;\n", str);
	}

	// AdvDefaultLifetime
	if ( !mib_get(MIB_V6_ADVDEFAULTLIFETIME, (void *)str)) {
		printf("Get AdvDefaultLifetime mib error!");
	}
	if (str[0]) {
		fprintf(fp, "\tAdvDefaultLifetime %s;\n", str);
	}

	// AdvReachableTime
	if ( !mib_get(MIB_V6_ADVREACHABLETIME, (void *)str)) {
		printf("Get AdvReachableTime mib error!");
	}
	if (str[0]) {
		fprintf(fp, "\tAdvReachableTime %s;\n", str);
	}

	// AdvRetransTimer
	if ( !mib_get(MIB_V6_ADVRETRANSTIMER, (void *)str)) {
		printf("Get AdvRetransTimer mib error!");
	}
	if (str[0]) {
		fprintf(fp, "\tAdvRetransTimer %s;\n", str);
	}

	// AdvLinkMTU
	if ( !mib_get(MIB_V6_ADVLINKMTU, (void *)str)) {
		printf("Get AdvLinkMTU mib error!");
	}
	if (str[0]) {
		int mtu = atoi(str);
		//Modify due to e8 Avalanche test , if MTU is specified (Like 1492), throughput will be bad.
		//But if there is PPPoE WAN, LAN PC should set the MTU, to prevent packet too big in IPv6.
		if( mtu>0 && isAnyPPPoEWan())
		fprintf(fp, "\tAdvLinkMTU %s;\n", str);
		else
			fprintf(fp, "\tAdvLinkMTU 0;\n");

	}

	// AdvManagedFlag
	if ( !mib_get( MIB_V6_MANAGEDFLAG, (void *)&vChar) )
		printf("Get MIB_V6_MANAGEDFLAG error!");
	if (0 == vChar)
		fprintf(fp, "\tAdvManagedFlag off;\n");
	else if (1 == vChar)
		fprintf(fp, "\tAdvManagedFlag on;\n");

	// AdvOtherConfigFlag
	if ( !mib_get( MIB_V6_OTHERCONFIGFLAG, (void *)&vChar) )
		printf("Get MIB_V6_OTHERCONFIGFLAG error!");
	if (0 == vChar)
		fprintf(fp, "\tAdvOtherConfigFlag off;\n");
	else if (1 == vChar)
		fprintf(fp, "\tAdvOtherConfigFlag on;\n");

	//NOTE: in radvd.conf
	//      Prefix/clients/route/RDNSS configurations must be given in exactly this order.
	// ULA Prefix
	mib_get (MIB_V6_ULAPREFIX_ENABLE, (void *)&vChar);
	if (vChar!=0) {
		unsigned char validtime[MAX_RADVD_CONF_PREFIX_LEN];
		unsigned char preferedtime[MAX_RADVD_CONF_PREFIX_LEN];

		if ( !mib_get(MIB_V6_ULAPREFIX, (void *)str)       ||
				!mib_get(MIB_V6_ULAPREFIX_LEN, (void *)str2)  ||
				!mib_get(MIB_V6_ULAPREFIX_VALID_TIME, (void *)validtime)  ||
				!mib_get(MIB_V6_ULAPREFIX_PREFER_TIME, (void *)preferedtime)
		   )
		{
			printf("Get ULAPREFIX mib error!");
		}
		else
		{
			unsigned char ip6Addr[IP6_ADDR_LEN];
			unsigned char devAddr[MAC_ADDR_LEN];
			unsigned char meui64[8];
			unsigned char value[64];
			int i;
#ifdef CONFIG_RTK_L34_ENABLE
			struct ipv6_ifaddr ip6_addr[6];
			char cur_ip6_addr[64];
#endif

			fprintf(fp, "\t\n");
			fprintf(fp, "\tprefix %s/%s\n", str, str2);
			fprintf(fp, "\t{\n");
			fprintf(fp, "\t\tAdvOnLink on;\n");
			fprintf(fp, "\t\tAdvAutonomous on;\n");
			fprintf(fp, "\t\tAdvValidLifetime %s;\n",validtime);
			fprintf(fp, "\t\tAdvPreferredLifetime %s;\n",preferedtime);
			fprintf(fp, "\t};\n");

#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
			va_cmd(IP6SECCTRL,7,1,"-A","-a",str,"-l",str2,"-t",preferedtime);
#endif
#ifdef CONFIG_RTK_L34_ENABLE
			mib_get(MIB_LAN_IPV6_MODE1, (void *)&vChar);
			if(vChar == 0 ) // LAN IPv6 address mode is auto.
			{
#endif
				inet_pton(PF_INET6, str, (void *)ip6Addr);

				//setup LAN ULA v6 IP address according the ULA prefix + EUI64.
				mib_get(MIB_ELAN_MAC_ADDR, (void *)devAddr);
				mac_meui64(devAddr, meui64);
				for (i=0; i<8; i++)
					ip6Addr[i+8] = meui64[i];
				inet_ntop(PF_INET6, &ip6Addr, value, sizeof(value));
				sprintf(value, "%s/%s", value, str2);
				printf("Set LAN ULA %s\n",value);
#ifdef CONFIG_RTK_L34_ENABLE
			}
			else
			{
				mib_get(MIB_LAN_IPV6_ADDR1, (void *)ip6Addr);
				inet_ntop(PF_INET6, ip6Addr, value, sizeof(value));
				mib_get(MIB_LAN_IPV6_PREFIX_LEN1, (void *)&vChar2);
				sprintf(value, "%s/%d", value, vChar2);
			}

			getifip6((char *)LANIF, IPV6_ADDR_UNICAST, ip6_addr, 6);
			inet_ntop(PF_INET6, &ip6_addr[0].addr, cur_ip6_addr, sizeof(cur_ip6_addr));
			sprintf(cur_ip6_addr, "%s/%d", cur_ip6_addr, ip6_addr[0].prefix_len);

			va_cmd(IFCONFIG, 3, 1, LANIF, "del", cur_ip6_addr);
			va_cmd(IFCONFIG, 3, 1, LANIF, "add", value);
#else
			va_cmd(IFCONFIG, 3, 1, LANIF, "del", value);
			va_cmd(IFCONFIG, 3, 1, LANIF, "add", value);
#endif
		}
	}

	// Prefix
	if(prefixInfo.prefixIP[0] && prefixInfo.prefixLen)
	{
		struct  in6_addr ip6Addr;
		unsigned char devAddr[MAC_ADDR_LEN];
		unsigned char meui64[8];
		unsigned char value[64];
		unsigned char prefixBuf[100]={0};
		int i;

		inet_ntop(PF_INET6,prefixInfo.prefixIP, prefixBuf, sizeof(prefixBuf));
		fprintf(fp, "\t\n");
		fprintf(fp, "\tprefix %s/%d\n", prefixBuf, prefixInfo.prefixLen);
		fprintf(fp, "\t{\n");

		memcpy(ip6Addr.s6_addr,prefixInfo.prefixIP,8);
		mib_get(MIB_ELAN_MAC_ADDR, (void *)devAddr);
		mac_meui64(devAddr, meui64);
		for (i=0; i<8; i++)
			ip6Addr.s6_addr[i+8] = meui64[i];
		inet_ntop(PF_INET6, &ip6Addr, value, sizeof(value));
		sprintf(value, "%s/%d", value, prefixInfo.prefixLen);
		va_cmd(IFCONFIG, 3, 1, LANIF, "del", value);
		va_cmd(IFCONFIG, 3, 1, LANIF, "add", value);

		// AdvOnLink
		if ( !mib_get( MIB_V6_ONLINK, (void *)&vChar) )
			printf("Get MIB_V6_ONLINK error!");
		if (0 == vChar)
			fprintf(fp, "\t\tAdvOnLink off;\n");
		else if (1 == vChar)
			fprintf(fp, "\t\tAdvOnLink on;\n");

		// AdvAutonomous
		if ( !mib_get( MIB_V6_AUTONOMOUS, (void *)&vChar) )
			printf("Get MIB_V6_AUTONOMOUS error!");
		if (0 == vChar)
			fprintf(fp, "\t\tAdvAutonomous off;\n");
		else if (1 == vChar)
			fprintf(fp, "\t\tAdvAutonomous on;\n");

		// AdvValidLifetime
		if ( !mib_get(MIB_V6_VALIDLIFETIME, (void *)str)) {
			printf("Get AdvValidLifetime mib error!");
		}
		if (str[0]) {
			fprintf(fp, "\t\tAdvValidLifetime %s;\n", str);
		}

		// AdvPreferredLifetime
		if ( !mib_get(MIB_V6_PREFERREDLIFETIME, (void *)str)) {
			printf("Get AdvPreferredLifetime mib error!");
		}
		if (str[0]) {
			fprintf(fp, "\t\tAdvPreferredLifetime %s;\n", str);
		}

		fprintf(fp, "\t\tDeprecatePrefix on;\n");
		fprintf(fp, "\t};\n");
#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
		sprintf(value,"%d",prefixInfo.prefixLen);
		va_cmd(IP6SECCTRL,7,1,"-A","-a",prefixBuf,"-l", value ,"-t", str);
#endif
	}

	//set RDNSS according to DNSv6 server setting
	if(strlen(dnsV6Info.nameServer)){
		char *ptr=NULL;
		unsigned char nameServer[IPV6_BUF_SIZE_256];

		memcpy(nameServer,dnsV6Info.nameServer,sizeof(nameServer));

		// Alan, Modify all ',' in string for RADVD CONF format
		//  Replace ',' in string to meet RADVD CONF format
		//	RDNSS ip [ip] [ip] {    list of rdnss specific options
		//	};
		ptr=nameServer;
		while(ptr=strchr(ptr,',')){
			*ptr++=' ';
		}

		fprintf(fp, "\n\tRDNSS %s\n", nameServer);
		fprintf(fp, "\t{\n");
		fprintf(fp, "\t\tAdvRDNSSPreference 8;\n");
		fprintf(fp, "\t\tAdvRDNSSOpen off;\n");
		fprintf(fp, "\t};\n");
	}

	fprintf(fp, "};\n");
	fclose(fp);
	return 0;

}

#endif // of CONFIG_USER_RADVD
#endif // of CONFIG_IPV6

#ifdef _CWMP_MIB_
void set_endpoint(char *newurl, char *acsurl) //star: remove "http://" from acs url string
{
	register const char *s;
	register size_t i, n;
	newurl[0] = '\0';

	if (!acsurl || !*acsurl)
	  return;
	s = strchr(acsurl, ':');
	if (s && s[1] == '/' && s[2] == '/')
	  s += 3;
	else
	  s = acsurl;
	n = strlen(s);
	if(n>256)
		n=256;

	for (i = 0; i < n; i++)
	{ newurl[i] = s[i];
	  if (s[i] == '/' || s[i] == ':')
	    break;
	}

	newurl[i] = '\0';
}

#if defined(IP_QOS) || defined(NEW_IP_QOS_SUPPORT)
/*star:20100305 START add qos rule to set tr069 packets to the first priority queue*/
void setQosfortr069(int mode, char *urlvalue)
{
	char vStr[256+1];
	char acsurl[256+1];
	struct hostent *host;
	struct in_addr acsaddr;
	char classId[]="0x00:0x00";
	char* argv[15];
	char *operationMode[2]={"add","del"};
	char *iptablesopt[2]={"-A","-D"};

	{
		set_endpoint(acsurl,urlvalue);
		host=gethostbyname(acsurl);
		if(host==NULL)
			return;
		memcpy((char *) &(acsaddr.s_addr), host->h_addr_list[0], host->h_length);

		{
			char interfaceName[8]={0};
			char DstIp[20]={0};
			int k;
			//iptables -t mangle -A OUTPUT -d 172.21.146.44 -p tcp -j CLASSIFY --set-class 0x00:0x06
			argv[1]="-t";
			argv[2]="mangle";
			argv[3]=iptablesopt[mode];
			argv[4]="OUTPUT";
			argv[5]="-d";
			strcpy(DstIp,inet_ntoa(acsaddr));
			argv[6]=DstIp;
			argv[7]="-p";
			argv[8]="tcp";
			argv[9]="-j";
			argv[10]="CLASSIFY";
			argv[11]="--set-class";
			for (k=0; k<8; k++) {
				if (priomap[k] == 1) {
					classId[8]+=k;
					break;
				}
			}
			argv[12]=classId;
			argv[13]=NULL;
			printf("\niptables");
			int i;
			for(i=1;i<12;i++){
				printf(" %s",argv[i]);
			}
			printf("\n");
			do_cmd("/bin/iptables",argv,1);

			//telefonica requests to add this rule to chain "INPUT" and "FORWARD", for possible tr069 Device in Lan side
			//Magician: Setting this rule in INPUT is useless, this is just for Telefonica's demand.
			//argv[4]="INPUT";
			//do_cmd("/bin/iptables",argv,1);

			argv[4]="FORWARD";
			do_cmd("/bin/iptables",argv,1);
		}
	}
	return;

}

static int SetcwmpQosflag = 0;

void setTr069QosFlag(int var)
{
	SetcwmpQosflag = var;
}

int getTr069QosFlag(void)
{
	return SetcwmpQosflag;
}
#endif

static const char OLDACSFILE[] = "/var/oldacs";
static const char OLDACSFILE_FOR_WAN[] = "/var/oldacs_wan";  // Magician: Used for TR-069 WAN interface.

void storeOldACS(void)
{
	FILE* fp;
	char acsurl[256+1]={0};

#ifdef CONFIG_TR142_MODULE
	mib_get(RS_CWMP_USED_ACS_URL, acsurl);
#else
	mib_get(CWMP_ACS_URL, acsurl);
#endif
	if(strlen(acsurl))
	{
		if(fp = fopen(OLDACSFILE, "w"))
		{
			fprintf(fp, "%s",acsurl);
			fclose(fp);
		}

		if(fp = fopen(OLDACSFILE_FOR_WAN, "w"))
		{
			fprintf(fp, "%s",acsurl);
			fclose(fp);
		}
	}
}

int getOldACS(char *acsurl)
{
	FILE* fp;

	acsurl[0]=0;
	fp=fopen(OLDACSFILE,"r");
	if(fp){
		fscanf(fp,"%s",acsurl);
		fclose(fp);
		unlink(OLDACSFILE);
	}
	if(strlen(acsurl))
		return 1;
	else
		return 0;
}
/*star:20100305 END*/

static int getOldACSforWAN(char *acsurl)
{
	FILE* fp;

	acsurl[0]=0;
	fp=fopen(OLDACSFILE_FOR_WAN,"r");
	if(fp){
		fscanf(fp,"%s",acsurl);
		fclose(fp);
		unlink(OLDACSFILE_FOR_WAN);
	}
	if(strlen(acsurl))
		return 1;
	else
		return 0;
}
#endif

char *trim_white_space(char *str)
{
	char *end;

	// Trim leading space
	while (isspace(*str)) str++;

	if(*str == 0)  // All spaces?
		return str;

	// Trim trailing space
	end = str + strlen(str) - 1;
	while (end >= str && isspace(*end)) end--;

	// Write new null terminator
	*(end+1) = 0;

	return str;
}

// Magician: This function is for checking the validation of whole config file.
/*
 *	Check the validation of config file.
 *	Return:
 *		0 for failed or Config file type (CONFIG_DATA_T) if successful.
 */
int checkConfigFile(const char *config_file)
{
	FILE *fp;
	char strbuf[1024], *pbuf, *pstr;
	int linenum = 1, len;
	char inChain = 0, isEnd = 0;
	int chainLevel=0;
	int status;

	if(!(fp = fopen(config_file, "r")))
	{
		printf("Open config file failed: %s\n", strerror(errno));
		return 0;
	}

	len = strlen(fgets(strbuf, 1024, fp));
	if(strbuf[len-1] != '\n')
	{
		printf("Miss a newline at line %d!\n", linenum);
		fclose(fp);
		return 0;
	}

	if(strbuf[len-2] == '\r' && strbuf[len-1] == '\n') // Remove the CRLF(0x0D0A) which is at the last of a line.
		strbuf[len-2] = 0;
	else if(strbuf[len-1] == '\n') // Remove the LF(0x0A) which is at the last of a line.
		strbuf[len-1] = 0;

	pbuf = trim_white_space(strbuf);
	if(!strcmp(pbuf, CONFIG_HEADER))
		status = CURRENT_SETTING;
	else if(!strcmp(pbuf, CONFIG_HEADER_HS))
		status = HW_SETTING;
	else
	{
		printf("Invalid header: %s\n", strbuf);
		fclose(fp);
		return 0;
	}

	while(fgets(strbuf, 1024, fp))
	{
		linenum++;  // The counter of current line on handling.
		len = strlen(strbuf);
		//printf("%d: %d: %s", linenum, len, strbuf);

		if(strbuf[len-1] != '\n')   // If this line does not end with a newline, return an error.
		{
			printf("Miss a newline at line %d!\n", linenum);
			status = 0;
			break;
		}

		if(strbuf[len-2] == '\r' && strbuf[len-1] == '\n') // Remove the CRLF(0x0D0A) which is at the last of a line.
			strbuf[len-2] = 0;
		else if(strbuf[len-1] == '\n') // Remove the LF(0x0A) which is at the last of a line.
			strbuf[len-1] = 0;

		if(isEnd)  // It should be at the end of this config file.
		{
			printf("Invalid end of config file at line %d\n", linenum);
			status = 0;
			break;
		}

		pbuf = trim_white_space(strbuf);
		if (strlen(pbuf)==0)
			continue;

		if(!strncmp(pbuf, "<Value Name=\"", 13))  // Check the validation of common <Value Name.... line.
		{
			if(!(pstr = strchr(pbuf+13, '\"')))
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			pstr++;

			if(strncmp(pstr, " Value=\"", 8))
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			if(!(pstr = strchr(pstr+8, '\"')))
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			pstr++;

			if(strncmp(pstr, "/>", 2))
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			pstr += 2;

			if(*pstr != '\0')
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			continue;
		}

		if(!strncmp(pbuf, "<chain chainName=\"", 18))  // Enter in a chain table.
		{
			if(!(pstr = strchr(pbuf+18, '\"')))
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			pstr++;

			if(*pstr != '>')
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			pstr++;

			if(*pstr != '\0')
			{
				printf("Invalid format at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			chainLevel++;
			continue;
		}

		if(!strncmp(pbuf, "</chain>", 8))  // Leave from a chain table.
		{
			if (chainLevel <=0)
			{
				printf("Invalid structure at line %d: %s\n", linenum, strbuf);
				status = 0;
				break;
			}

			chainLevel--;
			continue;
		}

		if(!strcmp(pbuf, CONFIG_TRAILER) || !strcmp(pbuf, CONFIG_TRAILER_HS))  // Reach the end of config file.
		{
			isEnd = 1;
			continue;
		}

		printf("Unknown format at line %d: %s\n", linenum, strbuf);
		status = 0;
		break;
	}

	fclose(fp);
	return status;
}

// Magician: This function is used for memory changing watch. You can put it anywhere to detect if memory usage changes.
// Be sure you assign all these functions in THE SAME process.
#if DEBUG_MEMORY_CHANGE
char last_memsize[128], last_file[32], last_func[32]; // Use to indicate last position where you put ShowMemChange().
int last_line;  // Use to indicate last position where you put ShowMemChange().
int ShowMemChange(char *file, char *func, int line)
{
	FILE *fp, *logfp;
	char buf[128];
	int i;
	char isPntOnChg = 1;  // Print message when memory size changed.
	char isLog = 1;  // Log results in /tmp/memlog
	char status = 0;  // return 1 when memory usage does change or otherwise return 0.

	if(isLog && !(logfp = fopen("/tmp/memlog", "a")))
	{
		perror("/tmp/memlog");
		return -1;
	}

	sprintf(buf, "/proc/%d/status", getpid());

	if(fp = fopen(buf, "r"))
	{
		for( i = 0; i < 11; i++ )
			fgets(buf, 128, fp);

		fclose(fp);

		if(!isPntOnChg || strcmp(buf, last_memsize))
		{
			putchar('\n');

			if(isPntOnChg)
			{
				printf("===== Last Memory size info (%s:%s:%d) =====\n", last_file, last_func, last_line);
				printf(last_memsize);

				if(isLog)
				{
					fprintf(logfp, "===== Last Memory size info (%s:%s:%d) =====\n", last_file, last_func, last_line);
					fprintf(logfp, last_memsize);
				}
			}

			printf("===== Memory size info (%s:%s:%d) =====\n", file, func, line);
			printf(buf);

			if(isLog)
			{
				fprintf(logfp, "===== Memory size info (%s:%s:%d) =====\n", file, func, line);
				fprintf(logfp, "%s\n", buf);
			}

			status = 1;
		}

		strncpy(last_memsize, buf, 128);
		strncpy(last_file, file, 32);
		strncpy(last_func, func, 32);
		last_line = line;
	}

	fclose(logfp);
	return status;
}
#endif
//Kevin:Check whether to enable/disable upstream ip fastpath
void UpdateIpFastpathStatus(void)
{
    /* If any one of the folllowing functions is enabled,
           we have to disable upstream ip fastpath.
               (1) IP Qos
               (2) URL blocking
               (3) Domain blocking
           Otherwise, keep ip fastpath up/downstream both to enhance throughput.
       */

    unsigned char mode=0;
#ifdef IP_QOS
	mib_get(MIB_MPMODE, (void *)&mode);
	if (mode & MP_IPQ_MASK)
	{
		//printf("(%s)IP Qos V1!\n",__func__);
		system("/bin/echo 1 > /proc/FastPath");
		return;
	}
#endif

#if defined(CONFIG_USER_IP_QOS_3) || defined(NEW_IP_QOS_SUPPORT)
	unsigned int qosEnable;
	unsigned int qosRuleNum, carRuleNum;
	unsigned char totalBandWidthEn;

	qosEnable = getQosEnable();
	qosRuleNum = getQosRuleNum();
	mib_get(MIB_TOTAL_BANDWIDTH_LIMIT_EN, (void *)&totalBandWidthEn);
	carRuleNum = mib_chain_total(MIB_IP_QOS_TC_TBL);
	//if ((qosEnable && qosRuleNum) || totalBandWidthEn || carRuleNum) {
	if ((qosEnable && qosRuleNum)) {
		system("/bin/echo 1 > /proc/FastPath");
		system("/bin/echo 0 > /proc/fastbridge");
		return;
	}
	else if (totalBandWidthEn || carRuleNum) {
		system("/bin/echo 1 > /proc/FastPath");
		return;
	}
#endif

	mode=0;
	mib_get(MIB_URL_CAPABILITY, (void *)&mode);
	if (mode)
	{
		//printf("(%s)URL blocking!\n",__func__);
		system("/bin/echo 1 > /proc/FastPath");
		return;
	}

	mode=0;
	mib_get(MIB_DOMAINBLK_CAPABILITY, (void *)&mode);
	if (mode)
	{
		//printf("(%s)Domain blocking!\n",__func__);
		system("/bin/echo 1 > /proc/FastPath");
		return;
	}

	//printf("(%s)none!\n",__func__);
	system("/bin/echo 2 > /proc/FastPath");
}

#ifdef RESERVE_KEY_SETTING
/*
 * flag
 * 0: for short reset
 * 1: for long reset
 * 2: TR-069 FactoryReset
 * 3: reset all like "flash default cs"
 */
static int reserve_critical_setting(int flag)
{
	MIB_CE_ATM_VC_T tr069_wan;
	int tr069_wan_found = 0;
	int total;
	int i = 0;
	unsigned char functype=0;
	unsigned char cwmp_do_factory_reset = 0;

	mib_get(PROVINCE_CWMP_RESET_AS_FACTORY_RESET, &cwmp_do_factory_reset);

	fprintf(stderr, "Reset flag = %d\n", flag);

	//first backup current setting
	mib_backup(CONFIG_MIB_ALL);

	// Backup TR-069 WAN
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_ATM_VC_TBL, i, &tr069_wan) == 0)
			continue;

		if(tr069_wan.applicationtype & X_CT_SRV_TR069)
		{
			tr069_wan_found = 1;
			break;
		}
	}

	// restore current to default
#ifdef CONFIG_USER_XMLCONFIG
	va_cmd("/bin/sh",2,1, "/etc/scripts/config_xmlconfig.sh", "-d");
#else
	mib_sys_to_default(CURRENT_SETTING);
#endif

	//always retrieve restore status
#ifdef CONFIG_YUEME
	mib_retrive_table(MIB_RESTORE_STATUS_TBL);
#endif

	if(flag == 3)
		return 0;

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	if(flag == 1 || (flag == 2 && cwmp_do_factory_reset))	//Reset to factory default
		return 0;
#endif

#if 0 //def CONFIG_YUEME
	if(flag == 1)
	{
		//restore framework configuration
		system("dbus-send --system --print-reply --dest=com.ctc.saf1 /com/ctc/saf1 com.ctc.saf1.framework.Restore");
	}
#endif

	//now retrieve the key parameters.
	mib_retrive_table(MIB_LOID);
	mib_retrive_table(MIB_LOID_OLD);
	mib_retrive_table(MIB_LOID_PASSWD);
	mib_retrive_table(MIB_LOID_PASSWD_OLD);

#ifdef CONFIG_USER_CTMANAGEDEAMON
	mib_retrive_table(MIB_BUCPE_A_LOCATION_OK);
	mib_retrive_table(MIB_BUCPE_A_LOCATION_LONGITUDE);
	mib_retrive_table(MIB_BUCPE_A_LOCATION_LATITUDE);
	mib_retrive_table(MIB_BUCPE_A_LOCATION_ALTITUDE);
	mib_retrive_table(MIB_BUCPE_A_LOCATION_HORIZONTALERROR);
	mib_retrive_table(MIB_BUCPE_A_LOCATION_ALTITUDEERROR);
	mib_retrive_table(MIB_BUCPE_A_AREACODE);
	mib_retrive_table(MIB_BUCPE_A_GISLOCKTIME);
	mib_retrive_table(MIB_BUCPE_A_GISDIGEST);
	mib_retrive_table(MIB_BUCPE_B_LOCATION_OK);
	mib_retrive_table(MIB_BUCPE_B_LOCATION_LONGITUDE);
	mib_retrive_table(MIB_BUCPE_B_LOCATION_LATITUDE);
	mib_retrive_table(MIB_BUCPE_B_LOCATION_ALTITUDE);
	mib_retrive_table(MIB_BUCPE_B_LOCATION_HORIZONTALERROR);
	mib_retrive_table(MIB_BUCPE_B_LOCATION_ALTITUDEERROR);
	mib_retrive_table(MIB_BUCPE_B_AREACODE);
	mib_retrive_table(MIB_BUCPE_B_GISLOCKTIME);
	mib_retrive_table(MIB_BUCPE_B_GISDIGEST);
	mib_retrive_table(MIB_BUCPE_REGID);
	mib_retrive_table(MIB_BUCPE_UUID);
	mib_retrive_table(MIB_BUCPE_SPEED_URL);
	mib_retrive_table(MIB_BUCPE_SPEED_URL_BAK);
#endif
#if defined(CONFIG_GPON_FEATURE)
	mib_retrive_table(MIB_GPON_PLOAM_PASSWD);
#endif
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	//TR-069 Factory Reset & short reset
	mib_retrive_table(CWMP_GUI_PASSWORD_ENABLE);
#endif

#if defined(CONFIG_EPON_FEATURE)
	mib_retrive_chain(MIB_EPON_LLID_TBL);
#endif

	if(flag == 2){
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		mib_retrive_table(CWMP_ACS_URL);
		mib_retrive_table(CWMP_ACS_URL_OLD);
		mib_retrive_table(CWMP_ACS_USERNAME);
		mib_retrive_table(CWMP_ACS_PASSWORD);
		mib_retrive_table(CWMP_CONREQ_USERNAME);
		mib_retrive_table(CWMP_CONREQ_PASSWORD);
#endif

#ifdef CONFIG_CU
		if(tr069_wan_found)
		{
			// Reserve old TR-069 WAN
			MIB_CE_ATM_VC_T entry;
			total = mib_chain_total(MIB_ATM_VC_TBL);

			for(i=0 ; i < total ; i++)
			{
				mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&entry);

				if(entry.applicationtype & X_CT_SRV_TR069)
				{	
					mib_chain_update(MIB_ATM_VC_TBL, &tr069_wan, i);
					break;
				}
			}
		}
#endif

#ifdef CONFIG_YUEME
		mib_retrive_chain(MIB_INTERNET_GATEWAY_DEVICE_TBL);
#ifdef CONFIG_USER_L2TPD_L2TPD
		mib_retrive_table(MIB_L2TP_ENABLE);
		mib_retrive_chain(MIB_L2TP_TBL);
		mib_retrive_chain(MIB_L2TP_ROUTE_TBL);
#endif
#ifdef CONFIG_USER_PPTP_CLIENT_PPTP
		mib_retrive_table(MIB_PPTP_ENABLE);
		mib_retrive_chain(MIB_PPTP_TBL);
		mib_retrive_chain(MIB_PPTP_ROUTE_TBL);
#endif
		mib_retrive_table(MIB_CWMP_MGT_URL);
		mib_retrive_table(MIB_CWMP_MGT_PORT);
		mib_retrive_table(MIB_CWMP_MGT_HEARTBEAT);
		mib_retrive_table(MIB_CWMP_MGT_ABILITY);
		mib_retrive_table(MIB_CWMP_MGT_LOCATEPORT);
		mib_retrive_table(MIB_CWMP_MGT_VERSION);
		mib_retrive_table(MIB_CWMP_MGT_APPMODEL);
		mib_retrive_table(MIB_CWMP_MGT_SSN);
		mib_retrive_table(MIB_PLATFORM_BSSADDR_TBL);
#ifdef WLAN_SUPPORT
#ifdef WIFI_TIMER_SCHEDULE
		mib_retrive_chain(MIB_WIFI_TIMER_EX_TBL);
		mib_retrive_chain(MIB_WIFI_TIMER_TBL);
#endif
#endif
#ifdef CONFIG_LED_INDICATOR_TIMER
		mib_retrive_chain(MIB_LED_INDICATOR_TIMER_TBL);
#endif
		mib_retrive_table(MIB_LED_STATUS);
#ifdef CONFIG_RG_SLEEPMODE_TIMER
		mib_retrive_chain(MIB_SLEEP_MODE_SCHED_TBL);
#endif
		mib_retrive_table(MIB_HTTPDOWNLOAD_TBL);

#ifdef FTP_SERVER_INTERGRATION
		mib_retrive_table(MIB_FTP_ENABLE);
		mib_retrive_table(MIB_FTP_ANNONYMOUS);
#else
		mib_retrive_chain(MIB_VSFTP_ACCOUNT_TBL);
		mib_retrive_table(MIB_VSFTP_ENABLE);
		mib_retrive_table(MIB_VSFTP_ANNONYMOUS);
#endif
#ifdef CONFIG_MULTI_FTPD_ACCOUNT
		mib_retrive_chain(MIB_FTP_ACCOUNT_TBL);
#endif

		mib_retrive_table(MIB_SMB_SERVER_ENABLE);
		mib_retrive_table(MIB_SMB_ANNONYMOUS);
#ifdef CONFIG_MULTI_SMBD_ACCOUNT
		mib_retrive_chain(MIB_SMBD_ACCOUNT_TBL);
#endif
#ifdef SUPPORT_WEB_REDIRECT
		mib_retrive_table(MIB_REDIRECT_IP);
		mib_retrive_table(MIB_ITMS_ADDR);
		mib_retrive_table(MIB_404_REDIRECT_URL);
		mib_retrive_table(MIB_404_REDIRECT_ENABLE);
#endif
#endif

		// TR-069 FactoryReset should not sent LONGRESET
		unsigned int ch = 0;
		mib_get(CWMP_FLAG2, (void *)&ch);
		ch |= CWMP_FLAG2_HAD_SENT_LONGRESET;
		mib_set(CWMP_FLAG2, (void *)&ch);

		unsigned char province_reserve = 0;
		mib_get(PROVINCE_RESERVE_KEY_SETTING, &province_reserve);
		fprintf(stderr, "[%s:%s@%d] province_reserve=%d \n", __FILE__, __FUNCTION__, __LINE__, province_reserve);
		if (province_reserve == RESERVE_KEY_SETTING_JSU_1)
		{
#ifdef _CWMP_MIB_
			mib_retrive_table(CWMP_ACS_USERNAME);
			mib_retrive_table(CWMP_ACS_PASSWORD);
			mib_retrive_table(CWMP_CONREQ_USERNAME);
			mib_retrive_table(CWMP_CONREQ_PASSWORD);
			mib_retrive_table(CWMP_INFORM_ENABLE);
			mib_retrive_table(CWMP_INFORM_INTERVAL);
			mib_retrive_table(CWMP_INFORM_TIME);
#endif

#if defined(_PRMT_X_CT_COM_USERINFO_) && defined(E8B_NEW_DIAGNOSE)
			if(flag != 1)
			{
				/* Not long reset, remember register result for GUI presentation */
				mib_retrive_table(CWMP_USERINFO_RESULT);
				mib_retrive_table(CWMP_USERINFO_STATUS);
			}
#endif
		}

		return 0;
	}

#ifdef _CWMP_MIB_
	mib_retrive_table(CWMP_ACS_URL);
	mib_retrive_table(CWMP_ACS_URL_OLD);
	mib_retrive_table(CWMP_ACS_USERNAME);
	mib_retrive_table(CWMP_ACS_PASSWORD);
	mib_retrive_table(CWMP_CONREQ_USERNAME);
	mib_retrive_table(CWMP_CONREQ_PASSWORD);
#endif

	mib_retrive_table(MIB_SUSER_NAME);

	mib_get(PROVINCE_MISCFUNC_TYPE, &functype);
	if (functype != 1) // Anhui have to restore telecomadmin password
	{
		mib_retrive_table(MIB_SUSER_PASSWORD);
	}
#if defined(CONFIG_YUEME) || defined(CONFIG_CU)
	mib_retrive_chain(MIB_IP_ROUTE_TBL);
#endif

	if(flag == 1)
	{
		if(tr069_wan_found)
		{
			// Reserve old TR-069 WAN
			MIB_CE_ATM_VC_T entry;
			total = mib_chain_total(MIB_ATM_VC_TBL);

			for(i=0 ; i < total ; i++)
			{
				mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&entry);

				if(entry.applicationtype & X_CT_SRV_TR069)
				{
					mib_chain_update(MIB_ATM_VC_TBL, &tr069_wan, i);
					break;
				}
			}
		}
	}
	else
	{
		mib_retrive_chain(MIB_ATM_VC_TBL);
#ifndef CONFIG_CU
#ifdef _CWMP_MIB_
		mib_retrive_table(CWMP_FLAG2);
#endif
#endif
#if defined(CONFIG_RTL867X_VLAN_MAPPING) || defined(CONFIG_APOLLO_ROMEDRIVER)
		mib_retrive_chain(MIB_PORT_BINDING_TBL);
#endif


#ifdef WLAN_SUPPORT
		MIB_CE_MBSSIB_T Entry;
#ifdef WLAN_DUALBAND_CONCURRENT
		wlan_idx = 0;
#endif
		mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry);
		mib_retrive_chain(MIB_MBSSIB_TBL);
		mib_chain_update(MIB_MBSSIB_TBL,(void *)&Entry, 0); //reset to default for SSID-1
#ifdef WLAN_DUALBAND_CONCURRENT
		mib_chain_get(MIB_WLAN1_MBSSIB_TBL, 0, (void *)&Entry);
		mib_retrive_chain(MIB_WLAN1_MBSSIB_TBL);
		mib_chain_update(MIB_WLAN1_MBSSIB_TBL,(void *)&Entry, 0); //reset to default for SSID-5
#endif
#endif

#ifdef VOIP_SUPPORT
		mib_retrive_chain(MIB_VOIP_CFG_TBL);
#endif

#ifndef CONFIG_CU
#ifdef _PRMT_X_CT_COM_USERINFO_
		mib_retrive_table(CWMP_USERINFO_STATUS);
		mib_retrive_table(CWMP_USERINFO_LIMIT);
		mib_retrive_table(CWMP_USERINFO_TIMES);
		mib_retrive_table(CWMP_USERINFO_RESULT);
#endif
#ifdef _PRMT_X_CT_COM_PING_
		mib_retrive_table(CWMP_CT_PING_ENABLE);
		mib_retrive_chain(CWMP_CT_PING_TBL);
#endif
#ifdef TIME_ZONE
		mib_retrive_table(MIB_NTP_ENABLED);
		mib_retrive_table(MIB_NTP_TIMEZONE_DB_INDEX);
		mib_retrive_table(MIB_DST_ENABLED);
		mib_retrive_table(MIB_NTP_SERVER_HOST1);
		mib_retrive_table(MIB_NTP_SERVER_HOST2);
#ifdef COMFIG_CMCC
		mib_retrive_table(MIB_NTP_SERVER_HOST3);
		mib_retrive_table(MIB_NTP_SERVER_HOST4);
		mib_retrive_table(MIB_NTP_SERVER_HOST5);
#endif
		mib_retrive_table(MIB_NTP_IF_TYPE);
		mib_retrive_table(MIB_NTP_IF_WAN);
		mib_retrive_table(MIB_NTP_INTERVAL);
#endif
#ifdef VIRTUAL_SERVER_SUPPORT
		mib_retrive_chain(MIB_VIRTUAL_SVR_TBL);
#endif
#ifdef _PRMT_X_CT_COM_MWBAND_
		mib_retrive_table(CWMP_CT_MWBAND_MODE);
		mib_retrive_table(CWMP_CT_MWBAND_STB_ENABLE);
		mib_retrive_table(CWMP_CT_MWBAND_CMR_ENABLE);
		mib_retrive_table(CWMP_CT_MWBAND_PC_ENABLE);
		mib_retrive_table(CWMP_CT_MWBAND_PHN_ENABLE);
		mib_retrive_table(CWMP_CT_MWBAND_NUMBER);
		mib_retrive_table(CWMP_CT_MWBAND_STB_NUM);
		mib_retrive_table(CWMP_CT_MWBAND_CMR_NUM);
		mib_retrive_table(CWMP_CT_MWBAND_PC_NUM);
		mib_retrive_table(CWMP_CT_MWBAND_PHN_NUM);
#endif

#ifdef CONFIG_YUEME
		//mib_retrive_table(MIB_RESTORE_STATUS_TBL);
		mib_retrive_chain(MIB_INTERNET_GATEWAY_DEVICE_TBL);
		mib_retrive_chain(MIB_DHCPS_SERVING_POOL_TBL);
#ifdef CONFIG_USER_L2TPD_L2TPD
		mib_retrive_table(MIB_L2TP_ENABLE);
		mib_retrive_chain(MIB_L2TP_TBL);
		mib_retrive_chain(MIB_L2TP_ROUTE_TBL);
#endif

#ifdef CONFIG_USER_PPTP_CLIENT_PPTP
		mib_retrive_table(MIB_PPTP_ENABLE);
		mib_retrive_chain(MIB_PPTP_TBL);
		mib_retrive_chain(MIB_PPTP_ROUTE_TBL);
#endif
		mib_retrive_table(MIB_CWMP_MGT_URL);
		mib_retrive_table(MIB_CWMP_MGT_PORT);
		mib_retrive_table(MIB_CWMP_MGT_HEARTBEAT);
		mib_retrive_table(MIB_CWMP_MGT_ABILITY);
		mib_retrive_table(MIB_CWMP_MGT_LOCATEPORT);
		mib_retrive_table(MIB_CWMP_MGT_VERSION);
		mib_retrive_table(MIB_CWMP_MGT_APPMODEL);
		mib_retrive_table(MIB_CWMP_MGT_SSN);
		mib_retrive_table(MIB_PLATFORM_BSSADDR_TBL);
#endif

#ifdef FTP_SERVER_INTERGRATION
		mib_retrive_table(MIB_FTP_ENABLE);
		mib_retrive_table(MIB_FTP_ANNONYMOUS);
#else
		mib_retrive_chain(MIB_VSFTP_ACCOUNT_TBL);
		mib_retrive_table(MIB_VSFTP_ENABLE);
		mib_retrive_table(MIB_VSFTP_ANNONYMOUS);
#endif
#ifdef CONFIG_MULTI_FTPD_ACCOUNT
		mib_retrive_chain(MIB_FTP_ACCOUNT_TBL);
#endif

#ifdef CONFIG_MULTI_SMBD_ACCOUNT
		mib_retrive_table(MIB_SMB_SERVER_ENABLE);
		mib_retrive_table(MIB_SMB_ANNONYMOUS);
#endif
#ifdef CONFIG_MULTI_SMBD_ACCOUNT
		mib_retrive_chain(MIB_SMBD_ACCOUNT_TBL);
#endif
#ifdef SUPPORT_WEB_REDIRECT
		mib_retrive_table(MIB_REDIRECT_IP);
		mib_retrive_table(MIB_ITMS_ADDR);
		mib_retrive_table(MIB_404_REDIRECT_URL);
		mib_retrive_table(MIB_404_REDIRECT_ENABLE);
#endif
#endif
	}

	mib_retrive_table(MIB_BRCTL_AGEINGTIME);
	mib_retrive_table(MIB_BRCTL_STP);

	return 0;
}
void reset_check(int flag)
{
	reserve_critical_setting(flag);
	mib_update(CURRENT_SETTING, CONFIG_MIB_ALL);
}
#endif

static char *get_name(char *name, char *p)
{
	while (isspace(*p))
		p++;
	while (*p) {
		if (isspace(*p))
			break;
		if (*p == ':') {	/* could be an alias */
			char *dot = p, *dotname = name;
			*name++ = *p++;
			while (isdigit(*p))
				*name++ = *p++;
			if (*p != ':') {	/* it wasn't, backup */
				p = dot;
				name = dotname;
			}
			if (*p == '\0')
				return NULL;
			p++;
			break;
		}
		*name++ = *p++;
	}
	*name = '\0';

	return p;
}

static int procnetdev_version(char *buf)
{
	if (strstr(buf, "compressed"))
		return 2;
	if (strstr(buf, "bytes"))
		return 1;
	return 0;
}

static const char *const ss_fmt[] = {
	"%n%lu%lu%lu%lu%lu%n%n%n%lu%lu%lu%lu%lu%lu",
	"%lu%lu%lu%lu%lu%lu%n%n%lu%lu%lu%lu%lu%lu%lu",
	"%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu"
};

static void get_dev_fields(char *bp, struct net_device_stats *nds, int procnetdev_vsn)
{
	memset(nds, 0, sizeof(*nds));

	sscanf(bp, ss_fmt[procnetdev_vsn],
		   &nds->rx_bytes, /* missing for 0 */
		   &nds->rx_packets,
		   &nds->rx_errors,
		   &nds->rx_dropped,
		   &nds->rx_fifo_errors,
		   &nds->rx_frame_errors,
		   &nds->rx_compressed, /* missing for <= 1 */
		   &nds->multicast, /* missing for <= 1 */
		   &nds->tx_bytes, /* missing for 0 */
		   &nds->tx_packets,
		   &nds->tx_errors,
		   &nds->tx_dropped,
		   &nds->tx_fifo_errors,
		   &nds->collisions,
		   &nds->tx_carrier_errors,
		   &nds->tx_compressed /* missing for <= 1 */
		   );

	if (procnetdev_vsn <= 1) {
		if (procnetdev_vsn == 0) {
			nds->rx_bytes = 0;
			nds->tx_bytes = 0;
		}
		nds->multicast = 0;
		nds->rx_compressed = 0;
		nds->tx_compressed = 0;
	}
}

/**
 * list_net_device_with_flags - list network devices with the specified flags
 * @flags: input argument, the network device flags
 * @nr_names: input argument, number of elements in @names
 * @names: output argument, constant pointer to the array of network device names
 *
 * Returns the number of resulted elements in @names for success
 * or negative errno values for failure.
 */
int list_net_device_with_flags(short flags, int nr_names,
				char (* const names)[IFNAMSIZ])
{
	FILE *fh;
	char buf[512];
	struct ifreq ifr;
	int nr_result, skfd;

	skfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (skfd < 0)
		goto out;

	fh = fopen(_PATH_PROCNET_DEV, "r");
	if (!fh)
		goto out_close_skfd;
	fgets(buf, sizeof(buf), fh);	/* eat line */
	fgets(buf, sizeof(buf), fh);

	nr_result = 0;
	while (fgets(buf, sizeof(buf), fh) && nr_result < nr_names) {
		char name[128];

		get_name(name, buf);

		strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		if (ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0)
			goto out_close_fh;

		if (ifr.ifr_flags & flags) {
			strncpy(names[nr_result++], name, ARRAY_SIZE(names[0]));
		}
	}

	if (ferror(fh))
		goto out_close_fh;

	fclose(fh);
	close(skfd);

	return nr_result;

out_close_fh:
	fclose(fh);
out_close_skfd:
	close(skfd);
out:
	warn("%s():%d", __FUNCTION__, __LINE__);

	return -errno;
}

/**
 * get_net_device_stats - get the statistics of the specified network device
 * @ifname: input argument, constant pointer to the network device name
 * @nds: output argument, pointer to network device statistics
 *
 * Returns 0 if not found, 1 if found
 * or negative errno values for failure.
 *
 */
int get_net_device_stats(const char *ifname, struct net_device_stats *nds)
{
	FILE *fh;
	char buf[512];
	int procnetdev_vsn, found;

	fh = fopen(_PATH_PROCNET_DEV, "r");
	if (!fh)
		goto out;
	fgets(buf, sizeof(buf), fh);	/* eat line */
	fgets(buf, sizeof(buf), fh);

	procnetdev_vsn = procnetdev_version(buf);

	memset(nds, 0, sizeof(*nds));
	found = 0;
	while (fgets(buf, sizeof(buf), fh)) {
		char *s, name[128];
		int n;

		s = get_name(name, buf);

		if (!strcmp(name, ifname)) {
			get_dev_fields(s, nds, procnetdev_vsn);
			found = 1;
			break;
		}
	}

	if (ferror(fh))
		goto out_close_fh;

	fclose(fh);

	return found;

out_close_fh:
	fclose(fh);
out:
	warn("%s():%d %s", __FUNCTION__, __LINE__, _PATH_PROCNET_DEV);

	return -errno;
}

/**
 * ethtool_gstats - get the statistics of the specified network device using ethtool
 * @ifname: input argument, constant pointer to the network device name
 *
 * Returns NULL if an error occurs, non-NULL otherwise
 */
struct ethtool_stats * ethtool_gstats(const char *ifname)
{
	struct ifreq ifr;
	int fd, err;
	struct ethtool_drvinfo drvinfo;
	struct ethtool_stats *stats = NULL;
	unsigned int n_stats;

	/* Setup our control structures. */
	memset(&ifr, 0, sizeof(ifr));
	strcpy(ifr.ifr_name, ifname);

	/* Open control socket. */
	fd = socket(AF_INET, SOCK_DGRAM, 0);
	if (fd < 0) {
		perror("Cannot get control socket");
		goto out;
	}

	drvinfo.cmd = ETHTOOL_GDRVINFO;
	ifr.ifr_data = &drvinfo;
	err = ioctl(fd, SIOCETHTOOL, &ifr);
	if (err < 0) {
		perror("Cannot get driver information");
		goto out_close_fd;
	}

	n_stats = drvinfo.n_stats;
	if (n_stats < 1) {
		fprintf(stderr, "no stats available\n");
		goto out_close_fd;
	}

	stats = calloc(1, n_stats * sizeof(uint64_t) + sizeof(struct ethtool_stats));
	if (!stats) {
		fprintf(stderr, "no memory available\n");
		goto out_close_fd;
	}

	stats->cmd = ETHTOOL_GSTATS;
	stats->n_stats = n_stats;
	ifr.ifr_data = stats;
	err = ioctl(fd, SIOCETHTOOL, &ifr);
	if (err < 0) {
		perror("Cannot get stats information");
		free(stats);
		stats = NULL;
		goto out_close_fd;
	}

out_close_fd:
	close(fd);
out:
	return stats;
}

// Kaohj
/*
 *	Get the link status about device.
 *	Return:
 *		-1 on error
 *		0 on link down
 *		1 on link up
 */
int get_net_link_status(const char *ifname)
{
	struct ifreq ifr;
	struct ethtool_value edata;
	int ret;

	strcpy(ifr.ifr_name, ifname);
	edata.cmd = ETHTOOL_GLINK;
	ifr.ifr_data = (caddr_t)&edata;

	ret = do_ioctl(SIOCETHTOOL, &ifr);
	if (ret == 0)
		ret = edata.data;
	return ret;
}

/*
 *	Get the link information about device.
 *	Return:
 *		-1 on error
 *		0 on success
 */
int get_net_link_info(const char *ifname, struct net_link_info *info)
{
	struct ifreq ifr;
	struct ethtool_cmd ecmd;
	int ret;

	memset(info, 0, sizeof(struct net_link_info));
	strcpy(ifr.ifr_name, ifname);
	ecmd.cmd = ETHTOOL_GSET;
	ifr.ifr_data = (caddr_t)&ecmd;

	ret = do_ioctl(SIOCETHTOOL, &ifr);
	if (ret == 0) {
		info->supported = ecmd.supported; // ports, link modes, auto-negotiation
		info->advertising = ecmd.advertising; // link modes, pause frame use, auto-negotiation
		info->speed = ecmd.speed; // 10Mb, 100Mb, gigabit
		info->duplex = ecmd.duplex; // Half, Full, Unknown
		info->phy_address = ecmd.phy_address;
		info->transceiver = ecmd.transceiver;
		info->autoneg = ecmd.autoneg;
	}
	return ret;
}

// MEM_UTILITY, CPU_UTILITY
enum enum_mem_info {
	DEV_MEM_TOTAL,
	DEV_MEM_AVAILABLE,
	DEV_MEM_USAGE_RATIO
};

struct dev_stats {
        unsigned int    user;    // user (application) usage
        unsigned int    nice;    // user usage with "niced" priority
        unsigned int    system;  // system (kernel) level usage
        unsigned int    idle;    // CPU idle and no disk I/O outstanding
        unsigned int    iowait;  // CPU idle but with outstanding disk I/O
        unsigned int    irq;     // Interrupt requests
        unsigned int    softirq; // Soft interrupt requests
        unsigned int    steal;   // Invol wait, hypervisor svcing other virtual CPU
        unsigned int    total;
};

int getdata(struct dev_stats *st)
{
	FILE *fp = NULL;

	if( (fp = fopen("/proc/stat","r")) == NULL)
	{
		printf("%s: getCpuTotal Failed to open file\n", __FUNCTION__);
		return -1;
	}
	
	fscanf(fp, "cpu %u %u %u %u %u %u %u %u",
		&st->user, &st->nice, &st->system, &st->idle,
		&st->iowait, &st->irq, &st->softirq, &st->steal);

	st->total = st->user + st->nice  + st->system + st->idle + st->iowait +
		st->irq  + st->steal + st->softirq;

	fclose(fp);
	return(0);
}

int get_cpu_usage(void)
{
	struct dev_stats    st, stold;
	unsigned int    curtotal, curidle, curusage;
	unsigned int    usepercent;

	getdata(&stold);
	sleep(1);
	getdata(&st);

	curtotal = st.total - stold.total;
	curidle = st.idle - stold.idle;
	curusage = curtotal - curidle;

	if (curusage > 0 && curtotal > 0)
		usepercent = curusage * 100 / curtotal;
	else
		usepercent = 0;

	return usepercent;
}

static int get_mem_info(int info)
{
	FILE* fs = NULL;
	char line[128];
	int total = 0, avail = 0, rate = 0, use = 0, real_total = 0, difference = 0;
	char *pToken = NULL,*pLast;
	int ret = 0, count = 0;
	fs = fopen( "/proc/meminfo" , "r");
	if ( fs == NULL )
		return 0;
	else
	{
		while (count < 2)
		{
			fgets(line, 128, fs);
			strtok_r(line, ":", &pLast);
			if (0 == strcasecmp(line, "MemTotal")) {
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			#ifdef WLAN_DUALBAND_CONCURRENT
				total = 524288;
			#else
				total = 262144;
			#endif
				real_total = atoi(pLast);
				if(real_total < total){
					difference = total - real_total;
				}
#else
				total = atoi(pLast);
#endif
				count++;
			} else if (0 == strcasecmp(line, "MemAvailable")) {
				avail = atoi(pLast);
				count++;
			}
		}

		switch(info) {
		case DEV_MEM_TOTAL:
			ret = total;
			break;
		case DEV_MEM_AVAILABLE:
			ret = avail+difference;
			break;
		case DEV_MEM_USAGE_RATIO:
			ret = (total > 0) ? (100*(total-avail-difference))/total : 0;
			break;
		}

		fclose(fs);
		return (int)(ret);
	}
}

int get_mem_free(void)
{
	int m = get_mem_info(DEV_MEM_AVAILABLE);
	return m;
}

int get_mem_total(void)
{
	int m = get_mem_info(DEV_MEM_TOTAL);
	return m;
}

int get_mem_usage(void)
{
	int m = get_mem_info(DEV_MEM_USAGE_RATIO);
	return m;
}

int GetWanMode(void)
{
	unsigned int wanmode = 0;

	if(!mib_get(MIB_WAN_MODE, (void *)&wanmode))
		fprintf(stderr, "Get mib value MIB_WAN_MODE failed!\n");

	return wanmode & WAN_MODE_MASK;
}

int isInterfaceMatch(unsigned int ifindex)
{
	if(WAN_MODE & MODE_ATM && MEDIA_ATM == MEDIA_INDEX(ifindex))
		return 1;
	else if(WAN_MODE & MODE_Ethernet && MEDIA_ETH == MEDIA_INDEX(ifindex))
		return 1;
	else if(WAN_MODE & MODE_PTM && MEDIA_PTM == MEDIA_INDEX(ifindex))
		return 1;

	return 0;
}
#ifdef CONFIG_YUEME
/*
* Function: get_restore_status
* Description: get RestoreStatus
* Input:
* Return:
* 0: No restore
* 1: restore by long reset button
* 2: restore by short reset button
* 3: restore by web button
* 4: restore by tr069 (itms)
* 5: dbus Restore
*/

int get_restore_status(void)
{
	/*modify by liuxm 2016.8.19*/
#if 0
	FILE *fp;
	int status=0;
	fp = fopen("/tmp/restore_status", "r");
	if(fp){
		fscanf(fp, "%d", &status);
		fclose(fp);
	}
#endif
	unsigned int status=0;
	mib_get(MIB_RESTORE_STATUS_TBL, (void *)&status);
	return status;
}

/*
 * flag
 * 0: for short reset
 * 1: for long reset
 * 2: TR-069 FactoryReset
 * 3: reset button for short reset
 * 4: reset button for long reset
 * 5: dbus Restore
 * 6: dbus LocalRecovery
 * 7: factory default : flash default cs
 */
void update_restore_status(int flag)
{
#if 0
	FILE *fp;
	int status;
	fp = fopen("/tmp/restore_status", "w");
	if(fp){
		switch(flag){
			case 0:
			case 1:
				status = 3;
				break;
			case 2:
				status = 4;
				break;
			case 3:
				status = 2;
				break;
			case 4:
				status = 1;
				break;

		}
		fprintf(fp, "%d", status);
		fclose(fp);
	}
#endif
    unsigned int status = 0;
	switch(flag){
		case 0:
		case 1:
			status = 3; //restore by web button
			break;
		case 2:
			status = 4; //restore by tr069 (itms)
			break;
		case 3:
			status = 2; //restore by short reset button
			break;
		case 4:
			status = 1; //restore by long reset button
			break;
		case 6:
			status = 3; //dbus LocalRecovery
			break;
		case 7:
			status = 3; //restore by web button (factory default, ie flash default cs)
			break;
		default:
			status = flag; //dbus
	}
    //status = flag;
    printf("Update RestoreStatus %u\n", status);
    mib_set(MIB_RESTORE_STATUS_TBL, (void *)&status);
    mib_update(CURRENT_SETTING, CONFIG_MIB_ALL);
}
#endif

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
void clean_filesystem()
{
	char cmd[512] = {0};

	printf("clean other config in file system!\n");
	sprintf(cmd, "rm -rf /var/osgi_app/* %s %s", hideErrMsg1, hideErrMsg2);
	system(cmd);
}
#endif

/*
 * flag
 * 0: for short reset
 * 1: for long reset
 * 2: TR-069 FactoryReset
 * 3: reset button for short reset
 * 4: reset button for long reset
 * 5: factory default : flash default cs
 */
int reset_cs_to_default(int flag)
{
#ifdef CONFIG_YUEME
	if(flag == 5)
		update_restore_status(7);
	else
		update_restore_status(flag);
#endif

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	clean_filesystem();
#endif

#ifdef CONFIG_RTL_WAPI_SUPPORT
	if(flag>0){
		if(opendir("/var/config/myca") != NULL)
			system("rm -rf /var/config/myca");
	}
#endif
#ifdef CU_APP_SCHEDULE_LOG 	
	unlink("/var/config/syslog_upload_path"); 	
	unlink("/var/config/syslog_schedule_upload");
#endif

#ifdef RESERVE_KEY_SETTING
	if(flag==3 || flag==4)
		flag -= 3;
	else if(flag==5)
		flag = 3;
#ifdef CONFIG_YUEME
	else if(flag==6) // dbus LocalRecovery
		flag = 0;
#endif
		
#ifdef CONFIG_YUEME
		if(flag == 1)
		{
			//restore framework configuration
			system("dbus-send --system --print-reply --dest=com.ctc.saf1 /com/ctc/saf1 com.ctc.saf1.framework.Restore");
		}
	
		FILE *fp;
		int fd;
	
		fp = fopen(RESET_CS_FLAG_FILE, "w");
			
		if(fp){
			fprintf(fp, "%d", flag);
			printf("%s %d: flag = %d\n", __func__, __LINE__, flag);
			fd = fileno(fp);
			fsync(fd);
			fclose(fp);
		}
		else
			printf("%s %d: open file failed\n", __func__, __LINE__);
#else
	reserve_critical_setting(flag);

	mib_update(CURRENT_SETTING, CONFIG_MIB_ALL);
	printf("do wait flash sync\n");
#endif

	struct timespec start, end;
  	clock_gettime(CLOCK_MONOTONIC, &start);

	while(1){
		clock_gettime(CLOCK_MONOTONIC, &end);
		//printf("wait for a while\n");
		if((end.tv_sec - start.tv_sec)>=2)
			break;
		sleep(1);
	}

#ifdef CONFIG_YUEME	
	int status;
	char command[256];
	strcpy(command, "config_lock.sh");
	status = system(command);
	if (-1 == status) { 
		fprintf(stderr, "%s %d: config_lock.sh error!", __func__, __LINE__);
	}
	else{ 
	    if ( WIFEXITED(status) ) {
	          fprintf(stderr, "%s %d: config_lock.sh return value: %d\n", __func__, __LINE__, WEXITSTATUS(status));
	    }
		else
			fprintf(stderr, "%s %d: config_lock.sh exit status = [%d]\n", __func__, __LINE__, WEXITSTATUS(status));
	}

	clock_gettime(CLOCK_MONOTONIC, &start);

	while(1){
		clock_gettime(CLOCK_MONOTONIC, &end);
		//printf("wait for a while\n");
		if((end.tv_sec - start.tv_sec)>=2){
			if(umount("/var/config")==0){
				fprintf(stderr, "umount /var/config success!\n");
				break;
			}
			else{
				perror("reset_cs_to_default umount");
			}
			if((end.tv_sec - start.tv_sec)>=10){
				fprintf(stderr, "umount /var/config timeout!\n");
				break;
			}
		}
		sleep(1);
	}
#endif

#else
	return mib_flash_to_default(CURRENT_SETTING);
#endif
	return 1;
}

#ifdef CONFIG_TR_064
int GetTR064Status(void)
{
	unsigned char tr064_st = 0;

	if(!mib_get(MIB_TR064_ENABLED, (void *)&tr064_st))
		fprintf(stderr, "Get mib value MIB_TR064_ENABLED failed!\n");

	return tr064_st;
}
#endif

#ifdef CONFIG_USER_CWMP_TR069
int SetTR069WANInterface(void) // Magician: Bind WAN interface to TR-069
{
	unsigned int cwmp_ifidx, total, i, pre_cwmp_ifidx, v_uint;
	unsigned char cwmp_flag;
	MIB_CE_ATM_VC_T entry;
	char dst_ip[20], intf_name[10], vStr[256], acsurl[256], *argv[7], dport[10];
	struct hostent *host;
	struct in_addr acsaddr;
	FILE *fp;

	va_cmd(IPTABLES, 2, 1, "-F", (char *)IPTABLE_TR069);

	if(mib_get(CWMP_FLAG, (void *)&cwmp_flag))
	{
		if(!(cwmp_flag & CWMP_FLAG_AUTORUN))  // Return if TR-069 is disabled.
			return 0;
	}

	if(!mib_get(CWMP_WAN_INTERFACE, (void *)&cwmp_ifidx))
	{
		fprintf(stderr, "Get mib value CWMP_WAN_INTERFACE failed!\n");
		return -1;
	}

	if(!mib_get(CWMP_ACS_URL, (void*)vStr))
	{
		fprintf(stderr, "Get mib value CWMP_ACS_URL failed!\n");
		return -1;
	}
	set_endpoint(acsurl, vStr);

	if(!(host = gethostbyname(acsurl)))
	{
		fprintf(stderr, "ACS URL gethostbyname failed!\n");
		return -1;
	}

	memcpy((char *) &(acsaddr.s_addr), host->h_addr_list[0], host->h_length);
	strcpy(dst_ip, inet_ntoa(acsaddr));

	total = mib_chain_total(MIB_ATM_VC_TBL);

	argv[1] = "del";
	argv[2] = "-host";
	argv[3] = dst_ip;
	argv[4] = "dev";
	argv[5] = intf_name;
	argv[6] = NULL;

	if(fp = fopen(PRE_CWMP_WAN_INTF, "r"))
	{
		fscanf(fp, "%u", &pre_cwmp_ifidx);
		fclose(fp);
		unlink(PRE_CWMP_WAN_INTF);

		if(pre_cwmp_ifidx != DUMMY_IFINDEX)
		{
			ifGetName(pre_cwmp_ifidx, intf_name, sizeof(intf_name));
			do_cmd("/bin/route", argv, 1);  // Delete pre-configured interface route rule.
		}
	}

	if( cwmp_ifidx != DUMMY_IFINDEX )
	{
		if(!mib_get(CWMP_CONREQ_PORT, (void *)&v_uint))
		{
			fprintf(stderr, "Get CWMP_CONREQ_PORT failed!\n");
			return -1;
		}

		sprintf(dport, "%u", v_uint);
		ifGetName(cwmp_ifidx, intf_name, sizeof(intf_name));
		// iptables -A tr069 ! -i vc0 -s 192.168.2.44 -p tcp --dport 7547 -j DROP
		va_cmd(IPTABLES, 13, 1, "-A", IPTABLE_TR069, "!", (char *)ARG_I, intf_name, "-s", dst_ip, "-p", "tcp", "--dport", dport, "-j", (char *)FW_DROP);

		for( i = 0; i < total; i++ )
		{
			if(mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&entry) != 1)
				continue;

			ifGetName(entry.ifIndex, intf_name, sizeof(intf_name));

			if(entry.ifIndex == cwmp_ifidx)
			{
				if(entry.cmode == CHANNEL_MODE_PPPOA || entry.cmode == CHANNEL_MODE_PPPOE || entry.cmode == CHANNEL_MODE_RT1483)
				{
					argv[1] = "add";
					do_cmd("/bin/route", argv, 1);  // Add route for ppp.
				}
				else if(entry.ipDhcp == 1)
				{
					char gwip[20];
					char buffer[50];
					sprintf(buffer, "%s.%s", DHCPC_ROUTERFILE, intf_name);

					if(!(fp = fopen(buffer, "r"))) return -1;

					fscanf(fp, "%s", gwip);
					fclose(fp);
					va_cmd("/bin/route", 7, 1, "add", "-host", dst_ip, "gw", gwip, "dev", intf_name);
				}
				else if(entry.cmode == CHANNEL_MODE_IPOE && entry.ipDhcp == 0 )
				{
					char gwip[20];
					/* Kaohj -- If ACS server is direct-connected with TR069-enabled interface(pEntry), */
					/*	we don't need to add a host route. */

					if(isDirectConnect(&acsaddr, &entry))
					{
						printf("ACS server is direct Connected.\n");
						return 0;
					}

					if(entry.remoteIpAddr[0] != 0)
					{
						strcpy(gwip, inet_ntoa(*((struct in_addr *)entry.remoteIpAddr)));
						va_cmd("/bin/route", 7, 1, "add", "-host", dst_ip, "gw", gwip, "dev", intf_name);
					}
				}
				break;
			}
		}
	}

	return 1;
}

int SetTR069WANInterfacePPP(void) // Magician: Bind WAN interface to TR-069. Special user when PPP is up.
{
	unsigned int cwmp_ifidx;
	unsigned char cwmp_flag;
	char dst_ip[20], intf_name[10], vStr[256], acsurl[256], *argv[7];
	struct hostent *host;
	struct in_addr acsaddr;

	if(mib_get(CWMP_FLAG, (void *)&cwmp_flag))
	{
		if(!(cwmp_flag & CWMP_FLAG_AUTORUN))  // Return if TR-069 is disabled.
			return 0;
	}

	if(!mib_get(CWMP_WAN_INTERFACE, (void *)&cwmp_ifidx))
	{
		fprintf(stderr, "Get mib value CWMP_WAN_INTERFACE failed!\n");
		return -1;
	}

	if( cwmp_ifidx != DUMMY_IFINDEX )
	{
		if(!mib_get(CWMP_ACS_URL, (void*)vStr))
		{
			fprintf(stderr, "Get mib value CWMP_ACS_URL failed!\n");
			return -1;
		}
		set_endpoint(acsurl, vStr);

		if(!(host = gethostbyname(acsurl)))
		{
			fprintf(stderr, "ACS URL gethostbyname failed!\n");
			return -1;
		}

		memcpy((char *) &(acsaddr.s_addr), host->h_addr_list[0], host->h_length);
		strcpy(dst_ip, inet_ntoa(acsaddr));

		argv[1] = "add";
		argv[2] = "-host";
		argv[3] = dst_ip;
		argv[4] = "dev";
		argv[5] = intf_name;
		argv[6] = NULL;

		ifGetName(cwmp_ifidx, intf_name, sizeof(intf_name));

		if((strstr(intf_name, ALIASNAME_PPP) != 0))
			do_cmd("/bin/route", argv, 1);  // Add route for ppp.
	}

	return 1;
}

int SetTR069WANInterfaceDHCP(void) // Magician: Bind WAN interface to TR-069. Special use when DHCP IP had got.
{
	unsigned int cwmp_ifidx, total, i;
	unsigned char cwmp_flag;
	MIB_CE_ATM_VC_T entry;
	char dst_ip[20], intf_name[10], vStr[256], acsurl[256], *argv[7];
	struct hostent *host;
	struct in_addr acsaddr;
	FILE *fp;

	if(mib_get(CWMP_FLAG, (void *)&cwmp_flag))
	{
		if(!(cwmp_flag & CWMP_FLAG_AUTORUN))  // Return if TR-069 is disabled.
			return 0;
	}

	if(!mib_get(CWMP_WAN_INTERFACE, (void *)&cwmp_ifidx))
	{
		fprintf(stderr, "Get mib value CWMP_WAN_INTERFACE failed!\n");
		return -1;
	}

	if( cwmp_ifidx != DUMMY_IFINDEX )
	{
		if(!mib_get(CWMP_ACS_URL, (void*)vStr))
		{
			fprintf(stderr, "Get mib value CWMP_ACS_URL failed!\n");
			return -1;
		}
		set_endpoint(acsurl, vStr);

		if(!(host = gethostbyname(acsurl)))
		{
			fprintf(stderr, "ACS URL gethostbyname failed!\n");
			return -1;
		}

		memcpy((char *) &(acsaddr.s_addr), host->h_addr_list[0], host->h_length);
		strcpy(dst_ip, inet_ntoa(acsaddr));

		total = mib_chain_total(MIB_ATM_VC_TBL);

		argv[1] = "del";
		argv[2] = "-host";
		argv[3] = dst_ip;
		argv[4] = "dev";
		argv[5] = intf_name;
		argv[6] = NULL;

		for( i = 0; i < total; i++ )
		{
			if(mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&entry) != 1)
				continue;

			ifGetName(entry.ifIndex, intf_name, sizeof(intf_name));

			if(entry.ifIndex == cwmp_ifidx)
			{
				if(entry.ipDhcp == 1)
				{
					char gwip[20];
					char buffer[50];
					sprintf(buffer, "%s.%s", DHCPC_ROUTERFILE, intf_name);

					if(!(fp = fopen(buffer, "r"))) return -1;

					fscanf(fp, "%s", gwip);
					fclose(fp);
					va_cmd("/bin/route", 7, 1, "add", "-host", dst_ip, "gw", gwip, "dev", intf_name);
				}
				break;
			}
		}
	}

	return 1;
}

int DelTR069WANInterface(char acsurl_type) // Magician: Delete WAN interface routing.
{
	unsigned int cwmp_ifidx;
	char dst_ip[20], intf_name[10], vStr[256], acsurl[256], *argv[7];
	struct hostent *host;
	struct in_addr acsaddr;

	if(!mib_get(CWMP_WAN_INTERFACE, (void *)&cwmp_ifidx))
	{
		fprintf(stderr, "Get mib value CWMP_WAN_INTERFACE failed!\n");
		return -1;
	}

	if( cwmp_ifidx != DUMMY_IFINDEX )
	{
		if(acsurl_type == Cur_ACS_URL )
		{
			if(!mib_get(CWMP_ACS_URL, (void*)vStr))
			{
				fprintf(stderr, "Get mib value CWMP_ACS_URL failed!\n");
				return -1;
			}
		}
		else if(acsurl_type == Old_ACS_URL )
			getOldACSforWAN(vStr);
		else
		{
			fprintf(stderr, "Wrong type of ACS URL!\n");
			return -1;
		}

		set_endpoint(acsurl, vStr);

		if(!(host = gethostbyname(acsurl)))
		{
			fprintf(stderr, "ACS URL gethostbyname failed!\n");
			return -1;
		}

		memcpy((char *) &(acsaddr.s_addr), host->h_addr_list[0], host->h_length);
		strcpy(dst_ip, inet_ntoa(acsaddr));

		argv[1] = "del";
		argv[2] = "-host";
		argv[3] = dst_ip;
		argv[4] = "dev";
		argv[5] = intf_name;
		argv[6] = NULL;

		ifGetName(cwmp_ifidx, intf_name, sizeof(intf_name));
		do_cmd("/bin/route", argv, 1);  // Del route.
	}

	return 1;
}
#endif  // #ifdef CONFIG_USER_CWMP_TR069

// Mason Yu. Support ddns status file.
#ifdef CONFIG_USER_DDNS
int stop_all_ddns()
{
	unsigned int entryNum, i;
	MIB_CE_DDNS_T Entry;
	char pidName[256];
	int pid = 0, n;

	entryNum = mib_chain_total(MIB_DDNS_TBL);
	for (i=0; i<entryNum; i++) {
		if (!mib_chain_get(MIB_DDNS_TBL, i, (void *)&Entry))
		{
			printf("stop_all_ddns:Get chain record error!\n");
			continue;
		}

		n = snprintf(pidName, sizeof(pidName)-1, "%s.%s.%s.%s", (char *)DDNSC_PID, Entry.provider, Entry.interface, Entry.hostname);
		pidName[n] = '\0';
		pid = read_pid((char *)pidName);
		if (pid > 0) {
			kill(pid, SIGKILL);
			unlink(pidName);
		}
	}
}

int restart_ddns(void)
{
	// Mason Yu.  create DDNS thread dynamically
	//printf("restart_ddns\n");
	// Mason Yu. Specify IP Address
#ifdef CONFIG_YUEME
	va_cmd("/bin/updateddctrl", 2, 1, "all", "1");
#else
#ifdef CONFIG_IPV6
	va_cmd("/bin/updateddctrl", 2, 1, "all", "3");
#else
	va_cmd("/bin/updateddctrl", 2, 1, "all", "1");
#endif
#endif

	return 0;
}

void remove_ddns_status(void)
{
	unsigned int entryNum, i, n;
	MIB_CE_DDNS_T Entry;
	FILE *fp;
	unsigned char filename[256];

	entryNum = mib_chain_total(MIB_DDNS_TBL);
	for (i=0; i<entryNum; i++) {

		if (!mib_chain_get(MIB_DDNS_TBL, i, (void *)&Entry))
		{
  			printf("remove_ddns_status:Get chain record error!\n");
			continue;
		}

		// Check all variables that updatedd need
		if ( strlen(Entry.username) == 0 ) {
			printf("remove_ddns_status: username/email is NULL!!\n");
			continue;
		}

		if ( strlen(Entry.password) == 0 ) {
			printf("remove_ddns_status: password/key is NULL!!\n");
			continue;
		}

		if ( strlen(Entry.hostname) == 0 ) {
			printf("remove_ddns_status: Hostname is NULL!!\n");
			continue;
		}

		if ( strlen(Entry.interface) == 0 ) {
			printf("remove_ddns_status: Interface is NULL!!\n");
			continue;
		}

		if ( Entry.Enabled != 1 ) {
			printf("remove_ddns_status: The account is disabled!!\n");
			continue;
		}

		if ( strcmp(Entry.provider, "dyndns") == 0 || strcmp(Entry.provider, "tzo") == 0) {
			// open a status file
			memset(filename, 0, sizeof(filename));
			snprintf(filename, sizeof(filename)-1,"/var/%s.%s.%s.txt", Entry.provider, Entry.username, Entry.password);
			if((fp=fopen(filename,"r")) ==NULL)
				continue;
			fclose(fp);
			unlink(filename);
		}else {
			//sprintf(account, "%s:%s", Entry.email, Entry.key);
			printf("remove_ddns_status: Not support this provider\n");
			syslog(LOG_INFO, "remove_ddns_status: Not support this provider %s\n", Entry.provider);
			continue;
		}
	}
}
#endif

// ysleu: To show diagshell RG DHCP request information.
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
void write_to_dhcpc_info(unsigned long requested_ip,unsigned long subnet_mask,unsigned long gw_addr)
{
	int fh;
	int mark;
	char buff[64];

	fh = open("/var/udhcpc/udhcpc.info", O_RDWR|O_CREAT|O_TRUNC, S_IXUSR);

	if (fh == -1) {
		printf("Create udhcpc script file %s error!\n");
		return;
	}

 	WRITE_DHCPC_FILE(fh, "\n##########################################\n");
	WRITE_DHCPC_FILE(fh, "DHCP Request Information:\n");
	sprintf(buff, "[ip_addr]:%d.%d.%d.%d\n",(requested_ip>>24)&0xff,(requested_ip>>16)&0xff,(requested_ip>>8)&0xff,(requested_ip>>0)&0xff);
	WRITE_DHCPC_FILE(fh, buff);
	sprintf(buff, "[ip_network_mask]:%d.%d.%d.%d\n",(subnet_mask>>24)&0xff,(subnet_mask>>16)&0xff,(subnet_mask>>8)&0xff,(subnet_mask>>0)&0xff);
	WRITE_DHCPC_FILE(fh, buff);
	sprintf(buff, "[gateway_ipv4_addr]:%d.%d.%d.%d\n",(gw_addr>>24)&0xff,(gw_addr>>16)&0xff,(gw_addr>>8)&0xff,(gw_addr>>0)&0xff);
	WRITE_DHCPC_FILE(fh, buff);
 	WRITE_DHCPC_FILE(fh, "##########################################\n");

	close(fh);
}
#endif

#if defined(CTC_WAN_NAME) || defined(CONFIG_USER_RTK_WAN_CTYPE)
enum RouteOP{ADD_Route, DEL_Route};
void setapplicationtype_tr069_uti(MIB_CE_ATM_VC_T *pEntry, int mode, char *urlvalue)
{
	char vStr[256+1];
	char acsurl[256+1];
	struct hostent *host;
	struct in_addr acsaddr;
	char* argv[7];
	char *operationMode[2]={"add","del"};
	char *iptablesopt[2]={"-A","-D"};
	FILE *fp;
	const char ACSIP_PATH[] = "/var/acsip";

	if(pEntry->cmode!=0)
	{
		if(urlvalue==NULL)
		{
			mib_get(CWMP_ACS_URL,(void*)vStr);
			set_endpoint(acsurl,vStr);
		}
		else
			set_endpoint(acsurl,urlvalue);

		// Read ACS IP by gethostbyname()
		if(mode==ADD_Route)
		{
			if(!(host = gethostbyname(acsurl)))
			{
				unlink(ACSIP_PATH);
				printf("Get ACS IP failed\n");
				return;
			}
			else
			{
				memcpy((char *) &(acsaddr.s_addr), host->h_addr_list[0], host->h_length);

				if(!(fp = fopen(ACSIP_PATH, "w")))
				{
					//printf("Open ACS IP file failed: %s\n", strerror(errno));
					return;
				}

				fwrite(host->h_addr_list[0], host->h_length, 1, fp);
				fclose(fp);
			}
		}

		if(mode==DEL_Route)
		{
			if(!(fp = fopen(ACSIP_PATH, "r")))
			{
				//printf("Open ACS IP file failed: %s\n", strerror(errno));
				return;
			}
			fread(&acsaddr.s_addr, sizeof(acsaddr.s_addr), 1, fp);
			fclose(fp);
			unlink(ACSIP_PATH);
		}

		if (pEntry->applicationtype&X_CT_SRV_TR069)
		{
			char interfaceName[8]={0};
			char DstIp[20]={0};

			//route del -host 192.168.2.241 dev vc0
			argv[1]=operationMode[mode];
			argv[2]="-host";
			strcpy(DstIp, inet_ntoa(acsaddr));
			argv[3]=DstIp;
			argv[4]="dev";
			ifGetName(pEntry->ifIndex, interfaceName, sizeof(interfaceName));
			argv[5]=interfaceName;
			argv[6]=NULL;

			//if(mode==ADD_Route)
			{
				// Kaohj -- If ACS server is direct-connected with
				//	TR069-enabled interface(pEntry),
				//	we don't need to add a host route.
				if((strstr(interfaceName,ALIASNAME_PPP)!=0) || (pEntry->ipDhcp==1) ) {
					if(mode==ADD_Route) {
						if (isDirectConnect(&acsaddr, NULL)) {
							printf("ACS server is direct Connected(1).\n");
							return;
						}
					}
				}

				if((strstr(interfaceName,ALIASNAME_PPP)!=0))
//				if((strstr(interfaceName,"ppp")!=0))
				{
					//DBPRINT("/bin/route %s %s %s %s %s\n",argv[1],argv[2],argv[3],argv[4],argv[5]);
					do_cmd("/bin/route",argv,1);
					return;
				}

				if(pEntry->ipDhcp==1)
				{
					char gwip[20];
					FILE *fp;
					char buffer[50];
					sprintf(buffer,"%s.%s", DHCPC_ROUTERFILE,interfaceName);
					fp=fopen(buffer,"r");

					if(!fp)
						return;

					fscanf(fp,"%s",gwip);
					fclose(fp);

					va_cmd("/bin/route",7,1,operationMode[mode],"-host",DstIp,"gw",gwip,"dev",interfaceName);
					//DBPRINT("/bin/route %s %s %s %s %s %s %s","add","-host",DstIp,"gw",gwip,"dev",interfaceName);
					return;
				}

				if(pEntry->cmode==CHANNEL_MODE_IPOE && pEntry->ipDhcp==0)
				{
					char gwip[20];
					// Kaohj -- If ACS server is direct-connected with
					//	TR069-enabled interface(pEntry),
					//	we don't need to add a host route.#if 0
					if(mode==ADD_Route) {
						if (isDirectConnect(&acsaddr, pEntry)) {
							printf("ACS server is direct Connected(2).\n");
							return;
						}
					}

					if(pEntry->remoteIpAddr[0]!=0)
					{
						strcpy(gwip, inet_ntoa(*((struct in_addr *)pEntry->remoteIpAddr)));
						va_cmd("/bin/route",7,1,operationMode[mode],"-host",DstIp,"gw",gwip,"dev",interfaceName);
						//DBPRINT("/bin/route %s %s %s %s %s %s %s","add","-host",DstIp,"gw",gwip,"dev",interfaceName);
						//printf("/bin/route %s %s %s %s %s %s %s","add","-host",DstIp,"gw",gwip,"dev",interfaceName);
					}
					return;
				}
				return;
			}
			//DBPRINT("/bin/route %s %s %s %s %s\n",argv[1],argv[2],argv[3],argv[4],argv[5]);
			//do_cmd("/bin/route",argv,1);
		}
		else
		{
			char DstIp[20]={0};
			char interfaceName[8]={0};

			strcpy(DstIp,inet_ntoa(acsaddr));

			ifGetName(pEntry->ifIndex, interfaceName, sizeof(interfaceName));


			//iptables -A OUTPUT -o vc0 -d acsip -j DROP
			printf("/bin/iptables %s %s %s %s %s %s %s %s\n",iptablesopt[mode], "OUTPUT", (char *)ARG_O, interfaceName,
				"-d", DstIp, "-j", (char *)FW_DROP);
			va_cmd(IPTABLES, 8, 1, iptablesopt[mode], "OUTPUT", (char *)ARG_O, interfaceName,	"-d", DstIp, "-j", (char *)FW_DROP);
		}
	}
	return;
}
#endif

/**************************************************************************
 * NAME:    usbRestore
 * DESC:    check if USB is mounted and config file exist. If yes, then go ahead and use it
 *          for restore configuration.
 *ARGS:     NONE
 *RETURN:   NONE
 **************************************************************************/
#ifdef _PRMT_USBRESTORE
int usbRestore(void)
{
	char buffer[16], dstname[64], usb_cfg_filename[32];
	int rv = 0, i, n;
	struct dirent **namelist;
	struct file_pipe pipe;
	unsigned char cpbuf[256];
	unsigned char vChar;
	char model[64];
	const char *config_filename;

	mib_get(MIB_USBRESTORE, &vChar);
	if (vChar == 0)
		return 0;

	fprintf(stderr, "ENTER %s\n", __FUNCTION__);
	fprintf(stderr, "check usbRestore...\n");

	// wait for usbmount successfully
	for (i = 0; i < 5; i++) {
		sleep(1);
		n = scandir("/mnt", &namelist, usb_filter, alphasort);

		/* no match */
		if (n <= 0) {
			if (n == 0)
				free(namelist);
			continue;
		} else
			break;
	}

	if (n <= 0) {
		return 0;
	}

	// make usb config filename (dst file)
	mib_get(MIB_SNMP_SYS_NAME, model);
	snprintf(usb_cfg_filename, sizeof(usb_cfg_filename), "ctce8_%s.cfg", model);

	// wait for usbmount successfully
	sleep(3);
	pipe.buffer = cpbuf;
	pipe.bufsize = sizeof(cpbuf);
	pipe.func = decode;
	for (i = 0; i < n; i++) {
		snprintf(dstname, sizeof(dstname), "/mnt/%s/%s/%s",
			 namelist[i]->d_name, BACKUP_DIRNAME, usb_cfg_filename);
		/* if not exist */
		if (access(dstname, F_OK))
			continue;

		fprintf(stderr, "USB: found %s\n", dstname);

#if defined(CONFIG_USER_XMLCONFIG) || defined(CONFIG_USE_XML)
		config_filename = CONFIG_XMLFILE;
#else
		config_filename = CONFIG_RAWFILE;
#endif
		rv = file_copy_pipe(dstname, config_filename, &pipe);
		if (rv != 0) {
			fprintf(stderr, "copy failed (%d)\n", rv);
			rv = 0;
			goto out;
		}
		// do restore here...
		fprintf(stderr, "USB: start restore...\n");
		after_download(config_filename);

		fprintf(stderr, "\n\n\nUSB: restore done\n");
		sync();
		break;
	}

out:
	for (i = 0; i < n; i++) {
		free(namelist[i]);
	}
	free(namelist);

	return rv;
}
#endif

static unsigned long sn_matrix[8][8] = {
{0x111C3D60, 0x0B5D60DC, 0x05C94DB0, 0x08A9F558, 0x154848D0, 0x001504A2, 0x0D0C652A, 0x141BE95C},
{0x034EAC58, 0x3B079DAA, 0x09FFFBFA, 0x003F9E94, 0x11618D09, 0x0D5E558A, 0x2577BE5C, 0x003E7AF8},
{0x008AE4C9, 0x0855C770, 0x34143744, 0x1AF6F0A8, 0x05686380, 0x11BCF974, 0x1F96A973, 0x0D81EFE7},
{0x2DB9F622, 0x26218B68, 0x16F02844, 0x09B62188, 0x2524312E, 0x0AF9AB28, 0x2360D510, 0x0018C501},
{0x024CCE7F, 0x0568C990, 0x03AEA55A, 0x0B6AD558, 0x0FDA28A2, 0x12F9E4FC, 0x24252765, 0x111D6B0F},
{0x15D4E175, 0x10AA5B93, 0x13C6CDA0, 0x1473DF94, 0x1AAEE3E0, 0x258EDC1B, 0x19F410CF, 0x000654B8},
{0x04D697F6, 0x141C44B1, 0x0E32F287, 0x0622CA9C, 0x1186804E, 0x0031FD64, 0x101ED862, 0x20197942},
{0x0030AC6E, 0x2A8F8EBD, 0x01918510, 0x02BDF1FC, 0x0C551F68, 0x0C330868, 0x0C0434B6, 0x08CD55A6}};

void encode(unsigned char *buf, size_t * buflen)
{
	int pd = 0;
	unsigned char *p = buf;

	if (p == NULL || buflen == 0)
		return;
	while (pd < *buflen) {
		*p ^= ((unsigned char *)sn_matrix)[pd % 256];
		p++;
		pd++;
	}
}

void decode(unsigned char *buf, size_t *buflen)
{
	encode(buf, buflen);
}

int file_copy_pipe(const char *inputfile, const char *outputfile, struct file_pipe *pipe)
{
	FILE *input=NULL, *output=NULL;
	size_t b_read, b_write;
	int quit = 0, rv = 0;

	input = fopen(inputfile, "rb");
	if (input == NULL)
		return errno;

	output = fopen(outputfile, "wb");
	if (output == NULL){
		fclose(input);
		return errno;
	}

	do {
		b_read = fread(pipe->buffer, 1, pipe->bufsize, input);
		if (b_read < pipe->bufsize) {
			quit = 1;
		}
		if (pipe->func)
			pipe->func(pipe->buffer, &b_read);

		b_write = fwrite(pipe->buffer, 1, b_read, output);
		if (b_read != b_write) {
			rv = ferror(output);
			quit = 1;
		}
	} while (!quit);

	fflush(output);
	fclose(input);
	fclose(output);

	return rv;
}

int usb_filter(const struct dirent *dirent)
{
	return !strncmp(dirent->d_name, "usb", 3);
}

int isUSBMounted(void)
{
	struct dirent **namelist;
	int i, n;

	n = scandir("/mnt", &namelist, usb_filter, alphasort);

	/* no match */
	if (n < 0)
		return -1;

	for (i = 0; i < n; i++) {
		free(namelist[i]);
	}
	free(namelist);

	return n;
}

//20080825 add by ramen to fix the special char in the html
char * fixSpecialChar(char *str,char *srcstr,int length)
{
   int i=0,j=0;
   if(!str||!srcstr)  return NULL;
   int strlength=strlen(srcstr);
   if(length<strlength) return NULL;
   char *tempstr=(char*)malloc(strlength*2);
   memset(tempstr,0,2*strlength);
    for(i=0,j=0;i<=strlength;i++)
   	{
   	  if(srcstr[i]=='"'||srcstr[i]=='\\')
   	  	{
   	  	   	  	tempstr[j++]='\\';
		}
	  	tempstr[j++]=srcstr[i];
   	}
   tempstr[j++]='\0';
   if(j>length) goto ERR;
    memcpy(str,tempstr,j);
   ERR:
    free(tempstr);
    return str;
}

// Mason Yu. 2630-e8b
int getProcessPid(const char *pidfile)
{
    	FILE *f;
	int pid=0;
	//fprintf(stderr,"pidfile=%s\n",pidfile);
	if((f = fopen(pidfile, "r")) == NULL)
		return 0;
	fscanf(f, "%d\n", &pid);
	fclose(f);
	//fprintf(stderr,"pid=%d\n",pid);
	return pid;
}

#ifdef CONFIG_CMCC_OSGIMANAGE
inline int startOsgiManage(void)

{
	return setupOsgiManage(OSGIMANAGE_ENABLED);
}

int setupOsgiManage(int type)
{
	int pid,status = 0;
	DOCMDINIT;
	//DOCMDARGVS("/bin/killall", DOWAIT, "%s", "osgiManage");
	switch (type) {
	case OSGIMANAGE_DISABLED:
		pid = getProcessPid(OSGIMANAGE_PID);
		if (pid) {
			status = DOCMDARGVS("/bin/kill", DOWAIT, "%d", pid);
			va_cmd("/bin/rm", 1, 1, OSGIMANAGE_PID);
		}
		break;
	case OSGIMANAGE_ENABLED:
		pid =  read_pid(OSGIMANAGE_PID);
		if (pid <= 0) { // renew
		DOCMDARGVS("/bin/osgiManage", UNDOWAIT, "%s", "debugall");
		}
		break;
	}
	return 1;
}
#endif


#ifdef TIME_ZONE

unsigned int check_ntp_if()
{
	unsigned char if_type = 0;
	unsigned char wan_type = 0;
	unsigned int if_wan, ifIndex = DUMMY_IFINDEX;
	MIB_CE_ATM_VC_T entry = {0};
	int total, i;

	mib_get(MIB_NTP_IF_WAN, &if_wan);
	mib_get(MIB_NTP_IF_TYPE, &if_type);
	switch(if_type)
	{
	case 0: //INTERNET
		wan_type = X_CT_SRV_INTERNET;
		break;
	case 1: //VOICE
		wan_type = X_CT_SRV_VOICE;
		break;
	case 2: //TR069
		wan_type = X_CT_SRV_TR069;
		break;
	case 3:
		wan_type = X_CT_SRV_OTHER;
		break;
	}

	total = mib_chain_total(MIB_ATM_VC_TBL);

	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
			continue;

		if(entry.applicationtype & wan_type)
		{
			// select first match
			if(ifIndex == DUMMY_IFINDEX)
				ifIndex = entry.ifIndex;

			if(entry.ifIndex == if_wan)
			{
				ifIndex = if_wan;
				break;	//specified is OK
			}
		}
	}

	//update NTP WAN
	if(ifIndex != if_wan)
	{
		mib_set(MIB_NTP_IF_WAN, &ifIndex);
		cmd_set_dns_config(NULL);
		sleep(1);	//wait a second for DNS updating
	}

	return ifIndex;
}

// Mason Yu. 2630-e8b
int setupNtp(int type)
{
	unsigned char ntpEnabled;
	unsigned char ntpServerHost1[MAX_NAME_LEN];
	unsigned char ntpServerHost2[MAX_NAME_LEN];
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	unsigned char ntpServerHost3[MAX_NAME_LEN];
	unsigned char ntpServerHost4[MAX_NAME_LEN];
	unsigned char ntpServerHost5[MAX_NAME_LEN];
#endif
	unsigned int if_wan;
	unsigned int interval;
	int pid, num, i, status = 0, sys_pid = -1;
	char ifname[IFNAMSIZ];
	MIB_CE_ATM_VC_T vc_entry;
	char argv_fmt[128];
	FILE *fp;
	unsigned int index = 0;
	unsigned char dst_enabled = 1;

	DOCMDINIT;
	switch (type) {
	case SNTP_DISABLED:
		va_cmd("/bin/killall", 1, 1, "vsntp"); 
		status |= 1;
		break;
	case SNTP_ENABLED:
		pid = getProcessPid(SNTPC_PID);
		mib_get(MIB_NTP_ENABLED, &ntpEnabled);
		if (pid == 0 && ntpEnabled) {
			if (mib_get(MIB_NTP_TIMEZONE_DB_INDEX, &index)) {
#ifdef __UCLIBC__
				if ((fp = fopen("/etc/TZ", "w")) != NULL) {
					status |= !mib_get(MIB_DST_ENABLED, &dst_enabled);
					fprintf(fp, "%s\n", get_tz_string(index, dst_enabled));
					fclose(fp);
				} else {
					status |= 1;
				}
#else
	#ifdef CONFIG_USER_GLIBC_TIMEZONE
				char cmd[128];
				char tz_location[64]={0};
				
				system("rm /var/localtime");
				mib_get(MIB_DST_ENABLED, &dst_enabled);
				if (dst_enabled || !is_tz_dst_exist(index)) {
					snprintf(tz_location,sizeof(tz_location),"%s",get_tz_location_cli(index));
					format_tz_location(tz_location);
						
					snprintf(cmd, sizeof(cmd), "ln -s /usr/share/zoneinfo/%s /var/localtime",tz_location);
				} else {
					const char * tz_offset;
					
					tz_offset = get_format_tz_utc_offset(index);
					
					snprintf(cmd, sizeof(cmd), "ln -s /usr/share/zoneinfo/Etc/GMT%s /var/localtime",tz_offset);
				}
				
				//fprintf(stderr,cmd);
				system(cmd);
	#endif
#endif
			} else {
				status |= 1;
			}

			status |= !mib_get(MIB_NTP_SERVER_HOST1, ntpServerHost1);
			status |= !mib_get(MIB_NTP_SERVER_HOST2, ntpServerHost2);
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			status |= !mib_get(MIB_NTP_SERVER_HOST3, ntpServerHost3);
			status |= !mib_get(MIB_NTP_SERVER_HOST4, ntpServerHost4);
			status |= !mib_get(MIB_NTP_SERVER_HOST5, ntpServerHost5);
#endif

			status |= !mib_get(MIB_NTP_INTERVAL, &interval);
			if (interval == 0)
				interval = 86400;

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
			if (ntpServerHost5[0])
				sprintf(argv_fmt, "-s %s -s %s -s %s -s %s -s %s -i %d", ntpServerHost1, ntpServerHost2,
						ntpServerHost3, ntpServerHost4, ntpServerHost5, interval);
			else if (ntpServerHost4[0])
				sprintf(argv_fmt, "-s %s -s %s -s %s -s %s -i %d", ntpServerHost1, ntpServerHost2,
						ntpServerHost3, ntpServerHost4, interval);
			else if (ntpServerHost3[0])
				sprintf(argv_fmt, "-s %s -s %s -s %s -i %d", ntpServerHost1, ntpServerHost2,
						ntpServerHost3, interval);
			else if (ntpServerHost2[0])
#else
			if (ntpServerHost2[0])
#endif
				sprintf(argv_fmt, "-s %s -s %s -i %d", ntpServerHost1, ntpServerHost2, interval);
			else
				sprintf(argv_fmt, "-s %s -i %d", ntpServerHost1, interval);

			//get interface name by if_wan
			if_wan = check_ntp_if();

			memset(ifname, 0, sizeof(ifname));
			if (ifGetName(if_wan, ifname, IFNAMSIZ)) {
				strcat(argv_fmt, " -d %s");
				DONICEDCMDARGVS(SNTPC, UNDOWAIT, argv_fmt, ifname);
			} else {
				// Only run SNTPC if interface is found.
				//DONICEDCMDARGVS(SNTPC, UNDOWAIT, argv_fmt);
			}
		} else {
			status = 0;
		}
		break;
	}

	// update dnsmasq config
	cmd_set_dns_config(NULL);
	restart_dnsrelay();
	return status;
}

// return value:
// 1  : successful
// -1 : failed
inline int startNTP(void)
{
	return setupNtp(SNTP_ENABLED);
}

// return value:
// 1  : successful
// -1 : failed
inline int stopNTP(void)
{
	return setupNtp(SNTP_DISABLED);
}
#endif //TIME_ZONE

// Magician: E8B security
//ql: set firewall grade
//not take effect immediately while modify/add/del pvc
WAN_STATE_T wanState;
//use fw_state_t to reserve the set state of firewall grade
FW_GRADE_INIT_St fw_state_t;

/* mac to string function */
int hex(unsigned char ch)
{
	if (ch >= 'a' && ch <= 'f')
		return ch-'a'+10;
	if (ch >= '0' && ch <= '9')
		return ch-'0';
	if (ch >= 'A' && ch <= 'F')
		return ch-'A'+10;
	return -1;
}

//mac's size must be >=17, content format:"00-16-76-D9-A6-AF"
void convert_mac(char *mac)
{
	char temp[ETH_ALEN];
	int i;
	for(i = 0; i < ETH_ALEN; i++) {
		temp[i] = hex(mac[i * 3]) * 16 + hex(mac[i * 3 + 1]);
	}
	memcpy(mac, temp, ETH_ALEN);
}

int getifIndexByWanName(const char *name)
{
	int index=0;
	int cnt=mib_chain_total(MIB_ATM_VC_TBL);
	MIB_CE_ATM_VC_T pvcEntry;
	for(index=0;index<cnt;index++)
		{
			char itfname[256]={0};
			mib_chain_get(MIB_ATM_VC_TBL,index,&pvcEntry);
			getWanName(&pvcEntry, itfname);
			if(!strncmp(name,itfname,strlen(name)))
				return pvcEntry.ifIndex;
		}
     return DUMMY_IFINDEX;
}

char *getEbtablesProtocol(int type)
{
	static char *ebproto[]={
		"",
		"PPP_DISC",
		"IPv4",
		"IPv6",
		"ATALK",
		"IPX",
		"NetBEUI",
		"IGMP"
		};
	return ebproto[type];
}

void convertMacFormat(char *str, unsigned char *mac)
{
	char tmpBuf[4];
	int i, j = 0;

	for (i = 0; i < 17; i += 3)
	{
		tmpBuf[0] = str[i];
		tmpBuf[1] = str[i+1];
		tmpBuf[2] = 0;

		if (!isxdigit(tmpBuf[0]) || !isxdigit(tmpBuf[1]))
			return;

		mac[j++] = (unsigned char)strtol(tmpBuf, (char**)NULL, 16);
	}
	//printf("%x %x %x %x %x %x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
}

int setupRouteEbtables()
{
	struct routemac_entry entry;
	int cnt,index, k;
	cnt=mib_chain_total(MIB_MAC_FILTER_ROUTER_TBL);
	DOCMDINIT;
	DOCMDARGVS(EBTABLES,DOWAIT,"-F %s",(char *)FW_MACFILTER_ROUTER);
	for(index=0;index<cnt;index++)
	{
		mib_chain_get(MIB_MAC_FILTER_ROUTER_TBL,index,&entry);
		#if defined(CONFIG_ETHWAN) || defined(CONFIG_RTL_MULTI_LAN_DEV)
		for(k=0;k<ELANVIF_NUM;k++) {
			//printf("ITF is %s\n", (char *)ELANVIF[k]);
			DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s -s %s -j DROP", (char *)FW_MACFILTER_ROUTER, (char *)ELANVIF[k], entry.mac);
		}
		#else
		DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i %s -s %s -j DROP", (char *)FW_MACFILTER_ROUTER, ELANIF, entry.mac);
		#endif
		DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -i wlan0 -s %s -j DROP", (char *)FW_MACFILTER_ROUTER, entry.mac);
	}
}

int setupMacFilterTables()
{
	MAC_FILTER_WHITELIST_WAY_T whitelist_way = WHITELIST_WAY;
	unsigned char macFilterEnable = 0;
	unsigned char macFilterMode = 0; // 0-black list, 1-white list
	char *policy=NULL;
	struct routemac_entry entry;
	int cnt,index, k;
#ifdef _PRMT_C_CU_USERACCOUNT_
	int cnt2,j;
	unsigned char zeroMac[6] ={0};
	int user_account_macfilter_mode = 0;//black list
	USER_ACCOUNT_MAC_T uEntry;
#endif
#ifdef	CONFIG_RTK_L34_ENABLE
	unsigned char smac[MAC_ADDR_LEN];
#endif

#if defined(CONFIG_YUEME) || defined(CONFIG_CMCC) || defined(CONFIG_CU)
	setup_wlan_MAC_ACL();
#endif

	cnt=mib_chain_total(MIB_MAC_FILTER_ROUTER_TBL);

	// Delete all Macfilter rule
#ifdef MAC_FILTER_SRC_ONLY
	DOCMDINIT;
	DOCMDARGVS(EBTABLES,DOWAIT,"-F %s",(char *)FW_MACFILTER_ROUTER);
#endif
	va_cmd(IPTABLES, 4, 1, "-t", "nat", "-F", (char *)FW_MACFILTER_ROUTER);

#ifdef	CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_MAC_Filters();
#endif

	mib_get(MIB_MAC_FILTER_SRC_ENABLE, &macFilterEnable);
#ifdef MAC_FILTER_SRC_WHITELIST
	// default action
	DOCMDARGVS(EBTABLES,DOWAIT,"-P %s RETURN", (char *)FW_MACFILTER_ROUTER);
#endif

	if(macFilterEnable)
	{
		if(macFilterEnable&1)//BIT0 set - black list mode. if both BIT0&BIT1 are set, only black list mode
			macFilterMode = 0;
		else if(macFilterEnable&2)//BIT1 set, BIT0 not set - white list mode.
			macFilterMode = 1;

		if (macFilterMode == 0)
			policy = (char *)FW_DROP;
		else
			policy = (char *)FW_RETURN;

		AUG_PRT("macFilterMode=%d policy=%s\n",macFilterMode,policy);

		for(index=0;index<cnt;index++)
		{
			mib_chain_get(MIB_MAC_FILTER_ROUTER_TBL,index,&entry);
			if(macFilterMode == entry.mode){
#ifdef MAC_FILTER_BLOCKTIMES_SUPPORT
				if (!entry.enable)
					continue;
#endif
#ifdef	CONFIG_RTK_L34_ENABLE
				convertMacFormat(entry.mac, smac);
#ifdef MAC_FILTER_BLOCKTIMES_SUPPORT
				AddRTK_RG_RT_MAC_Filter(smac, entry.mode, entry.instnum);
#else
				AddRTK_RG_RT_MAC_Filter(smac, entry.mode);
#endif
#endif
#ifdef MAC_FILTER_SRC_ONLY
				DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -s %s -j %s", (char *)FW_MACFILTER_ROUTER, entry.mac, policy);
#endif
				va_cmd(IPTABLES, 10, 1, "-t", "nat", (char *)FW_ADD, (char *)FW_MACFILTER_ROUTER, "-m", "mac", "--mac-source", entry.mac, "-j", policy);
			}
		}
		
#ifdef _PRMT_C_CU_USERACCOUNT_
		cnt2 = mib_chain_total(CONFIG_USER_ACCOUNT_MAC);
		for(j = 0 ; j < cnt2; j++)
		{
			if(!mib_chain_get(CONFIG_USER_ACCOUNT_MAC,j,&uEntry))
				continue;
			if(!memcmp(uEntry.macaddr,zeroMac,6))
				continue;
			
			if(macFilterMode == user_account_macfilter_mode){
				unsigned char macstr[18] = {0};
				snprintf(macstr,18,"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",uEntry.macaddr[0],uEntry.macaddr[1],
					uEntry.macaddr[2],uEntry.macaddr[3],uEntry.macaddr[4],uEntry.macaddr[5]);
#ifdef CONFIG_RTK_L34_ENABLE
#ifdef MAC_FILTER_BLOCKTIMES_SUPPORT
				AddRTK_RG_RT_MAC_Filter(uEntry.macaddr, user_account_macfilter_mode, uEntry.instNum);
#else
				AddRTK_RG_RT_MAC_Filter(uEntry.macaddr, user_account_macfilter_mode);
#endif
#endif

#ifdef MAC_FILTER_SRC_ONLY
				DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -s %s -j %s", (char *)FW_MACFILTER_ROUTER, macstr, policy);
#endif
				va_cmd(IPTABLES, 10, 1, "-t", "nat", (char *)FW_ADD, FW_MACFILTER_ROUTER, "-m", "mac", "--mac-source", macstr, "-j", policy);
			}			
		}
#endif

#ifdef	CONFIG_RTK_L34_ENABLE
		if(macFilterMode==1 && whitelist_way==WHITELIST_USING_ACL_RULE)
		{
			// Set all neccessary ACL rules for whitelist here (permit or drop)
			RTK_RG_ACL_MAC_Filter_Default_Policy(0);
		}
#endif
	}

#ifdef	CONFIG_RTK_L34_ENABLE
	if(whitelist_way==WHITELIST_USING_LUT_TBL)
	{
		// Flush dynamic MAC entries after White list updated
		if(macFilterMode == 0){//black list
			system("/bin/echo 0 > /proc/rg/whiteListState");
		}
		else if(macFilterMode == 1){//white list
			system("/bin/echo 1 > /proc/rg/whiteListState");
		}
		
		RTK_RG_Dynamic_MAC_Entry_flush();
	}
#endif
}
int convertProtocaltoEthertype(unsigned char protoType)
{

	static int ethertype_arr[]={
		0,
		0x8863, //PPP_DISC
		0x0800, //IPv4
		0x86DD, //IPv6
		0x809B, //ATALK
		0x8137, //IPX
		0x8191  //NetBEUI
		};
	return ethertype_arr[protoType];
}
int setupMacFilterEbtables()
{
	unsigned char macFilterMode=0;
	unsigned char macFilterEnable=0;
	struct brgmac_entry  entry;
	int cnt;
	int index=0;
#ifdef	CONFIG_RTK_L34_ENABLE
	unsigned char smac[MAC_ADDR_LEN];
	unsigned char dmac[MAC_ADDR_LEN];
	int ethertype;
	Flush_RTK_RG_ACL_MAC_Filters();
#endif
	DOCMDINIT;
	DOCMDARGVS(EBTABLES, DOWAIT, "-F %s", (char *)FW_MACFILTER);

	mib_get(MIB_MAC_FILTER_EBTABLES_ENABLE, &macFilterEnable);
	mib_get(MIB_MAC_FILTER_EBTABLES_MODE, &macFilterMode);

	DBPRINT(0, "macFilterEnable=%d,macFilterMode=%d\n", macFilterEnable, macFilterMode);
	if(macFilterEnable)
	{
		cnt=mib_chain_total(MIB_MAC_FILTER_EBTABLES_TBL);
		for(index=0;index<cnt;index++)
		{
			char protoParm[256]={0};
			char smacParm[256]={0};
			char dmacParm[256]={0};
			char smac2Parm[256]={0};
			char dmac2Parm[256]={0};

			memset(&entry,0,sizeof(entry));
			mib_chain_get(MIB_MAC_FILTER_EBTABLES_TBL,index,&entry);

#ifdef	CONFIG_RTK_L34_ENABLE
			convertMacFormat(entry.smac, smac);
			convertMacFormat(entry.dmac, dmac);
			ethertype = convertProtocaltoEthertype(entry.protoType);
			AddRTK_RG_BG_MAC_Filter(&entry, smac, dmac, macFilterMode, ethertype);
#endif

			if(entry.protoType)
				snprintf(protoParm,sizeof(protoParm),"-p %s", getEbtablesProtocol(entry.protoType));

			if(strlen(entry.smac)) {
				snprintf(smacParm,sizeof(smacParm),"-s %s",entry.smac);
				snprintf(dmac2Parm,sizeof(smacParm),"-d %s",entry.smac);
			}

			if(strlen(entry.dmac)) {
				snprintf(dmacParm,sizeof(dmacParm),"-d %s",entry.dmac);
				snprintf(smac2Parm,sizeof(dmacParm),"-s %s",entry.dmac);
			}

			int itfindex=0;
			for(itfindex=0;itfindex<entry.portNum;itfindex++)
			{
				char itfName[8];
				char itfParm[16]={0};
				ifGetName(PHY_INTF(entry.ifIndex[itfindex]), itfName, sizeof(itfName));
				switch(entry.direction)
				{
					case 0://lan-->wan
						snprintf(itfParm,sizeof(itfParm),"-o %s",itfName);
						DOCMDARGVS(EBTABLES,DOWAIT,"-A %s %s %s  %s %s -j %s", (char *)FW_MACFILTER,
						itfParm,protoParm,smacParm,dmacParm,(macFilterMode?"RETURN":"DROP"));
						break;
					case 1://wan-->lan
						snprintf(itfParm,sizeof(itfParm),"-i %s",itfName);
						DOCMDARGVS(EBTABLES,DOWAIT,"-A %s %s %s  %s %s -j %s", (char *)FW_MACFILTER,
						itfParm,protoParm,smacParm,dmacParm,(macFilterMode?"RETURN":"DROP"));
						break;
					case 2://lan<-->wan
						snprintf(itfParm,sizeof(itfParm),"-o %s",itfName);
						DOCMDARGVS(EBTABLES,DOWAIT,"-A %s %s %s  %s %s -j %s", (char *)FW_MACFILTER,
						itfParm,protoParm,smacParm,dmacParm,(macFilterMode?"RETURN":"DROP"));
						memset(itfParm,0,sizeof(itfParm));
						snprintf(itfParm,sizeof(itfParm),"-i %s",itfName);
						DOCMDARGVS(EBTABLES,DOWAIT,"-A %s %s %s  %s %s -j %s", (char *)FW_MACFILTER,
						itfParm,protoParm,dmac2Parm,smac2Parm,(macFilterMode?"RETURN":"DROP"));
						break;
				}
			}
		}
#ifdef	CONFIG_RTK_L34_ENABLE
		RTK_RG_MAC_Filter_Default_Policy(macFilterMode? 0:1, macFilterMode? 0:1);
#endif
		DOCMDARGVS(EBTABLES,DOWAIT,"-P %s %s",(char *)FW_MACFILTER, (macFilterMode?"DROP":"RETURN"));
	}
	else {
		DOCMDARGVS(EBTABLES,DOWAIT,"-F %s", (char *)FW_MACFILTER);
		DOCMDARGVS(EBTABLES,DOWAIT,"-P %s RETURN", (char *)FW_MACFILTER);
	}

#ifdef CONFIG_RTL8672_BRIDGE_FASTPATH
	TRACE(STA_SCRIPT,"/bin/echo 2 > /proc/fastbridge\n");
	system("/bin/echo 2 > /proc/fastbridge");
#endif

}

int addLowGradeRule(VC_STATE_Pt pEntry, int enable)
{
	if (enable) {
		//iptables -I INPUT 1 -i vc0 -p udp --dport 69 -j ACCEPT
		//va_cmd(IPTABLES, 11, 1, (char *)FW_INSERT, "fwinput", "1", (char *)ARG_I,
		//	pEntry->ifName, "-p", "udp", "--dport", "69", "-j", (char *)FW_ACCEPT);
		//iptables -I INPUT 2 -i vc0 -p tcp --dport 23 -j ACCEPT
		//va_cmd(IPTABLES, 11, 1, (char *)FW_INSERT, "fwinput", "2", (char *)ARG_I,
		//	pEntry->ifName, "-p", "tcp", "--dport", "23", "-j", (char *)FW_ACCEPT);
		//iptables -I INPUT 3 -i vc0 -p icmp --icmp-type 8 -j ACCEPT
		va_cmd(IPTABLES, 9, 1, (char *)FW_INSERT, "fwinput", "3", "-p", "icmp", "--icmp-type", "8", "-j", (char *)FW_ACCEPT);
		//iptables -I INPUT 4 -i vc0 -p tcp --dport 80 -j ACCEPT
		//va_cmd(IPTABLES, 11, 1, (char *)FW_INSERT, "fwinput", "4", (char *)ARG_I,
		//	pEntry->ifName, "-p", "tcp", "--dport", "80", "-j", (char *)FW_ACCEPT);
	} else {
		//iptables -D INPUT -i vc0 -p udp --dport 69 -j ACCEPT
		//va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, "fwinput", (char *)ARG_I,
		//	pEntry->ifName, "-p", "udp", "--dport", "69", "-j", (char *)FW_ACCEPT);
		//iptables -D INPUT -i vc0 -p tcp --dport 23 -j ACCEPT
		//va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, "fwinput", (char *)ARG_I,
		//	pEntry->ifName, "-p", "tcp", "--dport", "23", "-j", (char *)FW_ACCEPT);
		//iptables -D INPUT -i vc0 -p icmp --icmp-type 8 -j ACCEPT
		va_cmd(IPTABLES,8, 1, (char *)FW_DEL, "fwinput","-p", "icmp", "--icmp-type", "8", "-j", (char *)FW_ACCEPT);
		//iptables -D INPUT -i vc0 -p tcp --dport 80 -j ACCEPT
		//va_cmd(IPTABLES, 10, 1, (char *)FW_DEL, "fwinput", (char *)ARG_I,
		//	pEntry->ifName, "-p", "tcp", "--dport", "80", "-j", (char *)FW_ACCEPT);
	}

	return 1;
}

int startFirewall(void)
{
    unsigned char filterLevel = FW_LOW;
	unsigned char enable = 0;

	mib_get(MIB_FW_ENABLE, &enable);

    if (!mib_get(MIB_FW_GRADE, (void *)&filterLevel)) {
            printf("get fw grade fail\n");
	return 0;
    }
	changeFwGrade(enable, filterLevel);

	return 1;
}

#ifdef CONFIG_NETFILTER_XT_MATCH_PSD
int setup_psd(void)
{

	unsigned char enable = 0;

	mib_get(MIB_PSD_ENABLE, &enable);
	va_cmd(IPTABLES, 6, 1, FW_DEL, FW_INPUT, "-m", "psd", "-j", FW_DROP);

	if(enable)
		va_cmd(IPTABLES, 6, 1, FW_INSERT, FW_INPUT, "-m", "psd", "-j", FW_DROP);

	return 0;
}
#endif

int changeFwGrade(unsigned char enable, int currGrade)
{
	int low_enable;
	int mibCnt;
	int totalNum;
	MIB_CE_ATM_VC_T entry;
	VC_STATE_T vcState;

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	if(currGrade == FW_MIDDLE)
		currGrade = FW_HIGH;
#endif

	if(enable == 0)
	{
		//Prevent any rules to be added
		currGrade = FW_LOW;
	}

	/* disable tcp_stateful_tracking is for testing, we should keep  tcp_stateful_tracking is in enable state
	  * to avoid URL black/white list function will not work
	*/
#if 0
	#ifdef CONFIG_RTK_L34_ENABLE
	if(currGrade == (char)FW_HIGH)
		RG_tcp_stateful_tracking(1);
	else if(currGrade == (char)FW_LOW)
		RG_tcp_stateful_tracking(0);
	else // wrong ?! low_enable stateful tracking
		RG_tcp_stateful_tracking(1);
	#endif
#endif

	if (fw_state_t.preFwGrade == (char)FW_HIGH) {
		if (currGrade != (char)FW_HIGH)//HIGH->LOW
			low_enable = 1;
		else
			return 0;
	}
	else if (currGrade == (char)FW_HIGH) {
		if (fw_state_t.preFwGrade != FW_HIGH)//LOW->High
			low_enable = 0;
		else
			return 0;
	} else//don't change
		return 0;

	//Prevent any rules to be added
	if(enable == 0)
		low_enable = 0;

	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(mibCnt=0; mibCnt<totalNum; mibCnt++)
	{
		memset(&vcState, 0, sizeof(VC_STATE_T));

		if (!mib_chain_get(MIB_ATM_VC_TBL, mibCnt, (void *)&entry))
		{
			printf("get MIB chain error\n");
			return -1;
		}
		if ((entry.cmode == CHANNEL_MODE_BRIDGE) || !entry.enable)
			continue;


		ifGetName(entry.ifIndex, vcState.ifName, sizeof(vcState.ifName));

		addLowGradeRule(&vcState, low_enable);
	}

	fw_state_t.preFwGrade = currGrade;

	return 1;
}

//#define DOS_ENABLE_E8B	DOS_ENABLE_ALL
#define DOS_ENABLE_E8B	(DOS_ENABLE|SYSFLOODSYN|SYSFLOODFIN|SYSFLOODUDP|SYSFLOODICMP|IPFLOODSYN|\
						IPFLOODFIN|IPFLOODUDP|IPFLOODICMP|TCPUDPPORTSCAN|ICMPSMURFENABLED|\
						IPLANDENABLED|IPSPOOFENABLED|IPTEARDROPENABLED|PINGOFDEATHENABLED|\
						TCPSCANENABLED|TCPSynWithDataEnabled|UDPBombEnabled|sourceIPblock)

int setupDos()
{
	unsigned int dos_enable=0;
	unsigned char buffer[256],dosstr[256];
	int dostmpip[4],dostmpmask[4];
	int dosip,dosmask;
	FILE *dosfp;

	if (!mib_get(MIB_DOS_ENABLED,  (void *)&dos_enable)){
		printf("DOS parameter failed!\n");
	}

	//get ip
	if(!mib_get(MIB_ADSL_LAN_IP, (void *)buffer)) {
		printf("get LAN IP failed!\n");
		return -1;
	}
	sscanf(inet_ntoa(*((struct in_addr *)buffer)),"%d.%d.%d.%d",&dostmpip[0],&dostmpip[1],&dostmpip[2],&dostmpip[3]);
	dosip= dostmpip[0]<<24 | dostmpip[1]<<16 | dostmpip[2]<<8 | dostmpip[3];
	//get mask
	if(!mib_get(MIB_ADSL_LAN_SUBNET, (void *)buffer)) {
		printf("get LAN SUBNET failed!\n");
		return -1;
	}
	sscanf(inet_ntoa(*((struct in_addr *)buffer)),"%d.%d.%d.%d",&dostmpmask[0],&dostmpmask[1],&dostmpmask[2],&dostmpmask[3]);
	dosmask= dostmpmask[0]<<24 | dostmpmask[1]<<16 | dostmpmask[2]<<8 | dostmpmask[3];
	dosip &= dosmask;
	if (dos_enable) {
		//printf("dos enable:%d\n", dos_enable);
#if !defined(CONFIG_CMCC) && !defined(CONFIG_CU)			
		dos_enable = DOS_ENABLE_E8B;
#endif
	}

#ifdef CONFIG_DOS
	sprintf(dosstr,"1 %x %x %d 100 100 100 100 100 100 100 100 300\n", dosip,dosmask,dos_enable);
	//sprintf(dosstr,"1 %x %x %d 1 1 1 1 1 1 1 1 30\n", dosip,dosmask,dos_enable);
	//printf("dosstr:%s\n\n",dosstr);
	dosstr[strlen(dosstr)] = 0;
	if (dosfp = fopen("/proc/enable_dos", "w"))
	{
		fprintf(dosfp, "%s",dosstr);
		fclose(dosfp);
	}
#endif

#ifdef CONFIG_RTK_L34_ENABLE
	//setup dos
	RTK_RG_DoS_Set(dos_enable);
#endif

	return 1;
}
// End Magician: E8B security

#ifdef _PRMT_X_CT_COM_ALARM_MONITOR_
int init_alarm_numbers()
{
	int total = mib_chain_total(CWMP_CT_ALARM_TBL);
	CWMP_CT_ALARM_T alarm;
	int i;

	for(i = total - 1 ; i >= 0 ; i--)
	{
		mib_chain_get(CWMP_CT_ALARM_TBL, i, &alarm);
		if(alarm.mode == ALARM_MODE_NONE && alarm.alarmNumber != CTCOM_ALARM_DEV_RESTART
			&& alarm.alarmNumber != CTCOM_ALARM_SW_UPGRADE_FAIL)
			mib_chain_delete(CWMP_CT_ALARM_TBL, i);
	}

	return i;
}

int find_alarm_num(unsigned int alarm_num)
{
	int total = mib_chain_total(CWMP_CT_ALARM_TBL);
	CWMP_CT_ALARM_T alarm;
	int i;

	for(i = 0 ; i < total ; i++)
	{
		mib_chain_get(CWMP_CT_ALARM_TBL, i, &alarm);
		if(alarm.alarmNumber == alarm_num)
			break;
	}

	if(i >= total)
		i = -1;

	return i;
}

int get_alarm_by_alarm_num(unsigned int alarm_num, CWMP_CT_ALARM_T *entry, int *idx)
{
	int total = mib_chain_total(CWMP_CT_ALARM_TBL);
	int i;

	if(entry == NULL || idx == NULL)
		return -1;
	
	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(CWMP_CT_ALARM_TBL, i, entry) == 0)
			continue;
	
		if(entry->alarmNumber == alarm_num)
		{
			*idx = i;
			return 0;
		}
	}

	*idx = -1;
	return -1;
}

int set_ctcom_alarm(unsigned int alarm_num)
{
	int cwmp_events;
	unsigned char enable = 0;

	if(find_alarm_num(alarm_num) == -1)
	{
		CWMP_CT_ALARM_T alarm = {0};

		alarm.alarmNumber = alarm_num;
		alarm.mode = ALARM_MODE_NONE;

		mib_chain_add(CWMP_CT_ALARM_TBL, (void *)&alarm);
		mib_update(CURRENT_SETTING, CONFIG_MIB_CHAIN);

#ifdef CONFIG_YUEME
		mib_get(CWMP_CT_ALARM_ENABLE, &enable);
		if(enable && (alarm_num < 104050 || alarm_num >= 104070))
		{
			mib_get(CWMP_INFORM_USER_EVENTCODE, &cwmp_events);
			cwmp_events |=	EC_X_CT_COM_ALARM;
			mib_set(CWMP_INFORM_USER_EVENTCODE, &cwmp_events);
		}
#endif
	}

	return 0;
}

int clear_ctcom_alarm(unsigned int alarm_num)
{
	CWMP_CT_ALARM_T alarm;
	int idx;

#ifdef CONFIG_YUEME
	int cwmp_events;
	unsigned char enable = 0;
#endif

	if(get_alarm_by_alarm_num(alarm_num, &alarm, &idx) != 0)
		return -1;

	alarm.is_cleared = 1;
	mib_chain_update(CWMP_CT_ALARM_TBL, &alarm, idx);

#ifdef CONFIG_YUEME
	mib_get(CWMP_CT_ALARM_ENABLE, &enable);
	if(enable && (alarm_num < 104050 || alarm_num >= 104070))
	{
		mib_get(CWMP_INFORM_USER_EVENTCODE, &cwmp_events);
		cwmp_events |=  EC_X_CT_COM_CLEARALARM;
		mib_set(CWMP_INFORM_USER_EVENTCODE, &cwmp_events);
	}
#endif

	return 0;
}
#endif //_PRMT_X_CT_COM_ALARM_MONITOR_

#ifdef CONFIG_USER_RTK_LBD
#if defined(CONFIG_RTL9600_SERIES) && defined(CONFIG_RTK_L34_ENABLE)
void restartLBD(void)
{
	unsigned char enable = 0;
#ifdef CONFIG_EPON_FEATURE
	int i;
	char cmd[512], cmd1[512];
	int loopdetect_period=10;
	int loopdrecover_time=300;
	unsigned short ether_type=0xfffa;
	MIB_CE_LBD_VLAN_T loopdetect_vlan;
	int totalvlan;
	unsigned int pon_mode=0;
#endif
	int pid;

	mib_get(MIB_LBD_ENABLE, &enable);
#ifdef CONFIG_EPON_FEATURE
	mib_get(MIB_PON_MODE, &pon_mode);
	if(pon_mode == EPON_MODE && enable)
	{
		sprintf(cmd,"oamcli set ctc loopdetect");
		sprintf(cmd1,"oamcli set ctc loopdetect");
		mib_get(MIB_LBD_ETHER_TYPE, &ether_type);
		mib_get(MIB_LBD_EXIST_PERIOD, &loopdetect_period);
		mib_get(MIB_LBD_CANCEL_PERIOD, &loopdrecover_time);
		sprintf(cmd,"%s %d 0x%x %d %d",cmd,0, ether_type,loopdetect_period,loopdrecover_time);
		sprintf(cmd1,"%s %d 0x%x %d %d",cmd1,1, ether_type,loopdetect_period,loopdrecover_time);
		totalvlan=mib_chain_total(MIB_LBD_VLAN_TBL);
		for(i=0; i<totalvlan; i++)
		{
			if(mib_chain_get(MIB_LBD_VLAN_TBL,i,&loopdetect_vlan))
			{
				if(i==0) {
					sprintf(cmd, "%s %d", cmd, loopdetect_vlan.vid);
					sprintf(cmd1, "%s %d", cmd1, loopdetect_vlan.vid);
				} else {
					sprintf(cmd, "%s,%d", cmd, loopdetect_vlan.vid);
					sprintf(cmd1, "%s,%d", cmd1, loopdetect_vlan.vid);
				}
			}
		}
		AUG_PRT("%s\n",cmd);
		system(cmd);
		sleep(1);
		AUG_PRT("%s\n",cmd1);
		system(cmd1);
		
		return;
	}
#endif
}
#endif

void setupLBD(void)
{
	unsigned char enable = 0;
#ifdef CONFIG_EPON_FEATURE
	int i;
	char cmd[512];
	int loopdetect_period=10;
	int loopdrecover_time=300;
	unsigned short ether_type=0xfffa;
	MIB_CE_LBD_VLAN_T loopdetect_vlan;
	int totalvlan;
	unsigned int pon_mode=0;
#endif
	int pid;
#ifdef CONFIG_RTL9607C_SERIES
	int lan_remapping[4]={0};
	char remapping_cmd[256]={0};
	unsigned char re_map_tbl[4];
#endif

	mib_get(MIB_LBD_ENABLE, &enable);
#ifdef CONFIG_RTL9607C_SERIES
	//echo port remapping to loopback detect in kernel (br.c)
	if(mib_get(MIB_PORT_REMAPPING, (void *)re_map_tbl))
	{
		snprintf(remapping_cmd, sizeof(remapping_cmd), "echo \"%d %d %d %d\" > /proc/sys/loopback_detect/lan_port_remapping",
			re_map_tbl[0], re_map_tbl[1], re_map_tbl[2], re_map_tbl[3] );
		printf("%s\n", remapping_cmd);
		system(remapping_cmd);
	}	
#endif

#ifdef CONFIG_EPON_FEATURE
	mib_get(MIB_PON_MODE, &pon_mode);
	if(pon_mode == EPON_MODE)
	{
		sprintf(cmd,"oamcli set ctc loopdetect");
		mib_get(MIB_LBD_ETHER_TYPE, &ether_type);
		mib_get(MIB_LBD_EXIST_PERIOD, &loopdetect_period);
		mib_get(MIB_LBD_CANCEL_PERIOD, &loopdrecover_time);
		sprintf(cmd,"%s %d 0x%x %d %d",cmd,enable, ether_type,loopdetect_period,loopdrecover_time);
		totalvlan=mib_chain_total(MIB_LBD_VLAN_TBL);
		for(i=0; i<totalvlan; i++)
		{
			if(mib_chain_get(MIB_LBD_VLAN_TBL,i,&loopdetect_vlan))
			{
				if(i==0)
					sprintf(cmd, "%s %d", cmd, loopdetect_vlan.vid);
				else
					sprintf(cmd, "%s,%d", cmd, loopdetect_vlan.vid);
			}
		}
		printf("%s\n",cmd);
		system(cmd);
		return;
	}
#endif

	pid = read_pid("/var/run/loopback.pid");
	if(pid > 0)
	{
		kill(pid, SIGTERM);
		while(read_pid("/var/run/loopback.pid") > 0)
			usleep(200);
	}

	if(enable)
		va_niced_cmd("/bin/loopback", 0, 0);
}
#endif

int update_hosts(char *hostname, struct addrinfo *servinfo)
{
	if(!hostname || !servinfo) return 0;

	struct addrinfo *p;
	struct sockaddr_in *h;
	struct sockaddr_in6 *h6;
	struct in_addr ina;
	struct in6_addr ina6;

	FILE *fp;
	int isV4Existed = 0, isV6Existed = 0;
	char line[80], ip[64];
	int dnsrelaypid = -1;

	if(inet_pton(AF_INET6, hostname, &ina6) > 0 || inet_pton(AF_INET, hostname, &ina) > 0)
		return 0;

	fp = fopen(HOSTS, "a+");
	while(fgets(line, 80, fp) != NULL)
	{
		char *ip,*name,*saveptr1;
		ip = strtok_r(line," \n", &saveptr1);
		name = strtok_r(NULL," \n", &saveptr1);

		if(name && !strcmp(name, hostname))
		{
			if(strchr(ip, '.') != NULL)
				isV4Existed = 1;
			else
				isV6Existed = 1;
		}
	}

	// loop through all the results and connect to the first we can
	for(p = servinfo; p != NULL; p = p->ai_next)
	{
		if(p->ai_family == AF_INET)
		{
			h = (struct sockaddr_in *) p->ai_addr;
			strcpy(ip, inet_ntoa(h->sin_addr));

			if(!isV4Existed)
				fprintf(fp, "%-15s %s\n", ip, hostname);
		}
		else if(p->ai_family == AF_INET6)
		{
			h6 = (struct sockaddr_in6 *) p->ai_addr;
			inet_ntop(AF_INET6, &h6->sin6_addr, ip, sizeof(ip));

			if(!isV6Existed)
	 			fprintf(fp, "%-15s %s\n", ip, hostname);
		}
	}

	fclose(fp);

	dnsrelaypid = read_pid((char*)DNSRELAYPID);

	if(dnsrelaypid > 0)
		kill(dnsrelaypid, SIGHUP);
	

	return 1;
}

struct getaddrinfo_arg {
	char *hostname;
	IP_PROTOCOL IPVer;
	unsigned char end;
};

static void *getaddrinfo_routine(void *a)
{
	struct getaddrinfo_arg *parg = a;
	struct addrinfo hints, *servinfo = NULL;
	char *hostname = NULL;
	int rv;

	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);

	pthread_cleanup_push((void (*)(void *))freeaddrinfo, servinfo);

	memset(&hints, 0, sizeof hints);
	hints.ai_family = parg->IPVer == IPVER_IPV4 ? AF_INET : parg->IPVer == IPVER_IPV6 ? AF_INET6 : AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	hostname = strdup(parg->hostname);

	if ((rv = getaddrinfo(hostname, NULL, &hints, &servinfo)) != 0) {
		fprintf(stderr, "getaddrinfo: %s, servinfo: %p\n", gai_strerror(rv), servinfo);
	}

	free(hostname);

	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);

	parg->end = 1;

	pthread_cleanup_pop(0);

	return servinfo;
}

// IMPORTANGE NOTE: caller of this API must use freeaddrinfo() to free the returned memory.
struct addrinfo *hostname_to_ip(char *hostname, IP_PROTOCOL IPVer)
{
	pthread_t tid;
	struct getaddrinfo_arg arg = { hostname, IPVer, 0 };
	struct addrinfo *servinfo = NULL;
	int times = 0, rv;

	pthread_create(&tid, NULL, getaddrinfo_routine, &arg);

	/* wait 2 seconds at most */
	while (1) {
		if (arg.end)
			goto intime;

		if (++times >= 200)
			break;

		/* sleep for 0.01 seconds */
		usleep(10000);
	}

timeout:
	rv = pthread_cancel(tid);
	if (rv == ESRCH) {
		/*  No thread with the ID tid could be found */
		goto intime;
	}

	pthread_detach(tid);

	return NULL;
intime:
	pthread_join(tid, (void **)&servinfo);

	update_hosts(hostname, servinfo);

	return servinfo;
}

#if defined(CONFIG_IPV6) && defined(DUAL_STACK_LITE)
int query_aftr(char *aftr,  char *aftr_dst, char *aftr_addr_str)
{
	struct addrinfo hints, *res, *p;
	int status;
	char ipstr[INET6_ADDRSTRLEN];
	void *addr;

	if(!aftr||!aftr_dst||!aftr_addr_str){
		printf("%s Error! Null Input! \n",__func__);
		return 2;
	}

	memset(&hints, 0, sizeof hints);
	hints.ai_family = AF_UNSPEC;
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_STREAM;

	printf("aftr=[%s]\n",aftr);
	if ((status = getaddrinfo(aftr, NULL, &hints, &res)) != 0) {
		fprintf(stderr, "getaddrinfo:%s %s\n", aftr, gai_strerror(status));
		return 2;
	}

	printf("%s: IP addresses for [%s]:", __func__,aftr);

	p = res;
	if (p &&p->ai_family == AF_INET6) { // IPv6
		struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p->ai_addr;
		addr = &(ipv6->sin6_addr);
	}

	memcpy(aftr_dst,addr,sizeof(struct in6_addr));

	// convert the IP to a string and print it:
	inet_ntop(p->ai_family, addr, ipstr, sizeof ipstr);
	printf("[%s]\n",ipstr);

	strcpy(aftr_addr_str,ipstr);

	freeaddrinfo(res);

	return 0;
}
#endif

//return 1: registered, return 0: failed.
int check_user_is_registered()
{
#if defined(_PRMT_X_CT_COM_USERINFO_) && defined(E8B_NEW_DIAGNOSE)
	unsigned int regStatus = 99;
	unsigned int regResult = 99;
	unsigned char no_pop;

	mib_get(PROVINCE_NO_POPUP_REG_PAGE, &no_pop);
	mib_get(CWMP_USERINFO_STATUS, &regStatus);
	mib_get(CWMP_USERINFO_RESULT, &regResult);

	if(no_pop)
		return 1;

	if(regResult != 0 && regResult != 1)
	return 0;

	if(regStatus != 0 && regStatus != 5)
		return 0;

	return 1;
#else
	return 0;
#endif
}

static char* http_redirect2register_page_header =
	"HTTP/1.1 302 Object Moved\r\n"
	"Location: http://%s/usereg.asp\r\n"
	"Server: adsl-router-gateway\r\n"
	"Content-Type: text/html\r\n"
	"Content-Length: %d\r\n"
	"\r\n"
	"%s";
static char* http_redirect2register_page_content =
	"<html><head><title>Object Moved</title></head>"
	"<body><h1>Object Moved</h1>This Object may be found in "
#ifdef CONFIG_YUEME
	"<a HREF=\"http://%s:8080/usereg.asp\">here</a>.</body><html>";
#else
	"<a HREF=\"http://%s/usereg.asp\">here</a>.</body><html>";
#endif

static void gen_http_redirect2register_reply(char * content, int size)
{
	char buff[512] = {0};
	int filesize;
	unsigned char lan_ip[IP_ADDR_LEN] = {0};
	char lan_ip_str[INET_ADDRSTRLEN] = {0};

	mib_get(MIB_ADSL_LAN_IP, lan_ip);
	inet_ntop(AF_INET, lan_ip, lan_ip_str, INET_ADDRSTRLEN);

	snprintf(buff, 512, http_redirect2register_page_content, lan_ip_str);
	filesize = strlen(buff);

	snprintf(content, size, http_redirect2register_page_header, lan_ip_str, filesize, buff);
}


void enable_http_redirect2register_page(int enable)
{
#ifdef SUPPORT_WEB_REDIRECT
#ifdef CONFIG_RTK_L34_ENABLE
	FILE *fp;
	char cmdStr[100];
	char *url = "192.168.1.1";
	char contents[1024] = {0};

	if(enable)
	{
		/* when enable push web function, hwnat rule should be created at tcp handshake phase.*/
		fp = fopen("/proc/rg/tcp_hw_learning_at_syn", "w");
		if(fp)
		{
			fprintf(fp, "0\n");
			fclose(fp);
		}
		else
			fprintf(stderr, "open /proc/rg/tcp_hw_learning_at_syn fail!\n");

		RG_set_http_trap_for_bridge(1);
		gen_http_redirect2register_reply(contents, sizeof(contents));

		RG_set_redirect_http_Count(1, contents, strlen(contents), -1);
	}
	else
	{
/*
		fp = fopen("/proc/rg/tcp_hw_learning_at_syn", "w");
		if(fp)
		{
			fprintf(fp, "1\n");
			fclose(fp);
		}
		else
    			fprintf(stderr, "open /proc/rg/tcp_hw_learning_at_syn fail!\n");
*/
		RG_set_http_trap_for_bridge(0);
		//RG_set_redirect_http_all(0, content, 0, count);
		RG_set_redirect_http_Count(0, url, strlen(url), -1);
	}
#endif
#endif
}

#ifdef CONFIG_SUPPORT_CAPTIVE_PORTAL
static char* http_redirect2CaptivePortal_page_header =
	"HTTP/1.1 302 Object Moved\r\n"
	"Location: %s\r\n"
	"Server: adsl-router-gateway\r\n"
	"Content-Type: text/html\r\n"
	"Content-Length: %d\r\n"
	"\r\n"
	"%s";
static char* http_redirect2CaptivePortal_page_content =
	"<html><head><title>Object Moved</title></head>"
	"<body><h1>Object Moved</h1>This Object may be found in "
	"<a HREF=\"%s\">here</a>.</body><html>";

static void gen_http_redirect2CaptivePortalURL_reply(char * content, int size)
{
	char buff[512] = {0};
	int filesize;
	char cp_url[MAX_URL_LEN]={0};
	mib_get(MIB_CAPTIVEPORTAL_URL, (void *)cp_url);

	snprintf(buff, 512, http_redirect2CaptivePortal_page_content, cp_url);
	filesize = strlen(buff);

	snprintf(content, size, http_redirect2CaptivePortal_page_header, cp_url, filesize, buff);
}

void enable_http_redirect2CaptivePortalURL(int enable)
{
#ifdef SUPPORT_WEB_REDIRECT
	FILE *fp;
	char cmdStr[100];
	char contents[1024] = {0};
	char cp_url[MAX_URL_LEN]={0};

	if(enable)
	{
		/* when enable push web function, hwnat rule should be created at tcp handshake phase.*/
		fp = fopen("/proc/rg/tcp_hw_learning_at_syn", "w");
		if(fp)
		{
			fprintf(fp, "0\n");
			fclose(fp);
		}
		else
			fprintf(stderr, "open /proc/rg/tcp_hw_learning_at_syn fail!\n");

		RG_set_http_trap_for_bridge(1);
		gen_http_redirect2CaptivePortalURL_reply(contents, sizeof(contents));
		
		printf("<%s, %d, contents=%s>\n", __FUNCTION__, __LINE__, contents);
		RG_set_redirect_http_Count(1, contents, strlen(contents), 1);
	}
	else
	{
/*
		fp = fopen("/proc/rg/tcp_hw_learning_at_syn", "w");
		if(fp)
		{
			fprintf(fp, "1\n");
			fclose(fp);
		}
		else
    			fprintf(stderr, "open /proc/rg/tcp_hw_learning_at_syn fail!\n");
*/
		RG_set_http_trap_for_bridge(0);
		//RG_set_redirect_http_all(0, content, 0, count);
		RG_set_redirect_http_Count(0, cp_url, strlen(cp_url), -1);
	}
#endif
}
#endif

/*
 *	LAN port ifidx has been changed to VLAN-based port mapping.
 *	This routine resolve the possible port-mapping mode conflict.
 */
int sync_itfGroup(int ifidx)
{
	MIB_CE_ATM_VC_T vcEntry;
	int total, i;

	total = mib_chain_total(MIB_ATM_VC_TBL);

	for (i=0; i<total; i++) {
		mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vcEntry);
		if (vcEntry.itfGroup & (1<<ifidx)) {
			// Remove this port from port-based mapping as it is vlan-based mode now.
			vcEntry.itfGroup &= ~(1<<ifidx);
			mib_chain_update(MIB_ATM_VC_TBL, (void*)&vcEntry, i);
		}
	}
	return 0;
}

#ifdef CONFIG_GPON_FEATURE
int getGponONUState()
{
	rtk_gpon_fsm_status_t gpon_state;

	memset( &gpon_state, 0, sizeof(rtk_gpon_fsm_status_t) );
	#ifdef CONFIG_RTK_L34_ENABLE
	rtk_rg_gpon_ponStatus_get(&gpon_state);
	#else
	rtk_gpon_ponStatus_get(&gpon_state);
	#endif

	if(gpon_state <= GPON_STATE_O5)
		return gpon_state;//O1, O2, O3, O4, O5
	else
		return 0;
}
#endif

#ifdef CONFIG_EPON_FEATURE
/*****************************************************************************
     : epon_getAuthState
   : get epon auth result
 ? : llid
 ? : 
   ?  : 2 - auth not complete, 1 - auth success, 0 - auth fail
 ?  :
   :

 ??      :
  1.       : 2016325
           : ql_xu
    ?   : ?

*****************************************************************************/
int epon_getAuthState(int llid)
{
    FILE *fp;
    char cmdStr[256], line[256];
    char tmpStr[20];
    int ret=2;

    snprintf(cmdStr, 256, "oamcli get ctc auth %d > /tmp/auth.result 2>&1", llid);
    va_cmd("/bin/sh", 2, 1, "-c", cmdStr);

    fp = fopen("/tmp/auth.result", "r");
    if (fp)
    {
        fgets(line, sizeof(line), fp);
        sscanf(line, "%*[^:]: %s", tmpStr);
        if (!strcmp(tmpStr, "success"))
            ret = 1;
        else if (!strcmp(tmpStr, "fail"))
            ret = 0;

        fclose(fp);
    }
    return (ret);
}

int getEponONUState(unsigned int llidx)
{
	int ret;
	rtk_epon_llid_entry_t  llidEntry;
	rtk_epon_counter_t counter;

	memset(&llidEntry, 0, sizeof(rtk_epon_llid_entry_t));
	llidEntry.llidIdx = llidx;
#ifdef CONFIG_RTK_L34_ENABLE
	rtk_rg_epon_llid_entry_get(&llidEntry);
#else
	rtk_epon_llid_entry_get(&llidEntry);
#endif

	if(llidEntry.valid)//OLT Register successful
		return 5;

	memset(&counter, 0, sizeof(rtk_epon_counter_t));
	counter.llidIdx = llidx;
#ifdef CONFIG_RTK_L34_ENABLE
	ret = rtk_rg_epon_mibCounter_get(&counter);
#else
	ret = rtk_epon_mibCounter_get(&counter);
#endif
	if(ret == RT_ERR_OK)
	{
		if(counter.llidIdxCnt.mpcpRxGate)
			return 4;
		else if(counter.mpcpTxRegRequest)
			return 3;
		else if(counter.mpcpRxDiscGate)
			return 2;
		else
			return 1;
	}
	return 0;
}

long epon_getctcAuthSuccTime(int llid)
{
    FILE *fp;
    char cmdStr[256], line[256];
   	unsigned long authSuccTime=0;
    int ret=2;

    snprintf(cmdStr, 256, "oamcli get ctc succAuthTime %d", llid);

    fp = popen(cmdStr, "r");
    if (fp)
    {
        fgets(line, sizeof(line), fp);
        sscanf(line, "%*[^:]: %ld", &authSuccTime);

        pclose(fp);
    }
    return (authSuccTime);
}
#endif

void SaveLOIDReg()
{
	unsigned char loid[MAX_NAME_LEN];
	unsigned char password[MAX_NAME_LEN];
	unsigned char old_loid[MAX_NAME_LEN];
	unsigned char old_password[MAX_NAME_LEN];
	int changed = 0;

	mib_get(MIB_LOID, loid);
	mib_get(MIB_LOID_OLD, old_loid);
	if(strcmp(loid, old_loid) != 0)
	{
		mib_set(MIB_LOID_OLD, loid);
		changed = 1;
	}
	mib_get(MIB_LOID_PASSWD, password);
	mib_get(MIB_LOID_PASSWD_OLD, old_password);
	if(strcmp(password, old_password) != 0 || changed)
	{
		mib_set(MIB_LOID_PASSWD_OLD, password);
		#if defined(CONFIG_GPON_FEATURE) && (defined(CONFIG_CMCC) || defined(CONFIG_CU))
		mib_set(MIB_GPON_PLOAM_PASSWD, password);
		#endif
		changed = 1;
	}

#ifdef COMMIT_IMMEDIATELY
#if !defined(CONFIG_CMCC) && !defined(CONFIG_CU)
	if(changed)
#endif
		Commit();
#endif
}

#ifdef CONFIG_HTTP_DOWNLOAD_TEST
struct webserver_callout httptest_ch;
#endif

/*************************************************************************/
#ifdef SUPPORT_ACCESS_RIGHT

void flush_internet_access_right()
{
	DOCMDINIT;

	DOCMDARGVS(EBTABLES,DOWAIT,"-F %s",(char *)FW_INTERNET_ACCESSRIGHT_BRIDGE);
	va_cmd(EBTABLES, 4, 1, (char *)FW_DEL, (char *)FW_FORWARD, "-j", (char *)FW_INTERNET_ACCESSRIGHT_BRIDGE);
	va_cmd(EBTABLES, 2, 1, "-X", (char *)FW_INTERNET_ACCESSRIGHT_BRIDGE);

	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_INTERNET_ACCESSRIGHT_ROUTER);
	va_cmd(IPTABLES, 4, 1, (char *)FW_DEL, (char *)FW_FORWARD, "-j", (char *)FW_INTERNET_ACCESSRIGHT_ROUTER);
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_INTERNET_ACCESSRIGHT_ROUTER);

#ifdef	CONFIG_RTK_L34_ENABLE
	FlushRTK_RG_RT_INTERNET_ACCESS_RIGHT();
#endif
#if 0 //defined(CONFIG_YUEME)
	set_wlan_realtime_acl_mode(0, 0);
	set_wlan_realtime_acl(0, 2, NULL);
#endif
}

/* internetAccessRight value:
   0: can't access modem and internet
   1: can access modem and can't access inernet
   2: can access inernet */
void setup_internet_access_right(void)
{

	int totalNum,index;
	unsigned char macString[32] = {0};
	MIB_LAN_HOST_ACCESS_RIGHT_T entry;
	DOCMDINIT;

	totalNum = mib_chain_total(MIB_LAN_HOST_ACCESS_RIGHT_TBL);

	va_cmd(EBTABLES, 2, 1, "-N", (char *)FW_INTERNET_ACCESSRIGHT_BRIDGE);
	va_cmd(EBTABLES, 4, 1, (char *)FW_ADD, (char *)FW_FORWARD, "-j", (char *)FW_INTERNET_ACCESSRIGHT_BRIDGE);

	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_INTERNET_ACCESSRIGHT_ROUTER);
	va_cmd(IPTABLES, 4, 1, (char *)FW_INSERT, (char *)FW_FORWARD, "-j", (char *)FW_INTERNET_ACCESSRIGHT_ROUTER);
#if 0 //defined(CONFIG_YUEME)
	if(totalNum > 0) set_wlan_realtime_acl_mode(0, 2);
#endif	
	for(index=0; index<totalNum; index++)
	{
		mib_chain_get(MIB_LAN_HOST_ACCESS_RIGHT_TBL,index,&entry);
		if( entry.internetAccessRight == INTERNET_ACCESS_DENY)
		{
#ifdef	CONFIG_RTK_L34_ENABLE
			AddRTK_RG_RT_INTERNET_ACCESS_RIGHT(entry.internetAccessRight, entry.mac);
#endif
			sprintf(macString, "%02x:%02x:%02x:%02x:%02x:%02x", entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);

			DOCMDARGVS(EBTABLES,DOWAIT,"-A %s -s %s -j DROP", (char *)FW_INTERNET_ACCESSRIGHT_BRIDGE, macString);
			va_cmd(IPTABLES, 8, 1, (char *)FW_ADD, (char *)FW_INTERNET_ACCESSRIGHT_ROUTER, "-m", "mac", "--mac-source", macString, "-j", (char *)FW_DROP);
#if 0 //defined(CONFIG_YUEME)
			set_wlan_realtime_acl(0, 1, entry.mac);
#endif		
		}
		else if( entry.internetAccessRight == INTERNET_ACCESS_NO_INTERNET)
		{
#ifdef	CONFIG_RTK_L34_ENABLE
			AddRTK_RG_RT_INTERNET_ACCESS_RIGHT(entry.internetAccessRight, entry.mac);
#endif
			sprintf(macString, "%02x:%02x:%02x:%02x:%02x:%02x", entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);
			va_cmd(IPTABLES, 10, 1, (char *)FW_ADD, (char *)FW_INTERNET_ACCESSRIGHT_ROUTER, "-m", "mac", "--mac-source", macString, "-o", "!br0", "-j", (char *)FW_DROP);
		}
	}
#if defined(CONFIG_YUEME) || defined(CONFIG_CMCC) || defined(CONFIG_CU)
	setup_wlan_MAC_ACL();
#endif
}

void flush_storage_access_right()
{
	va_cmd(IPTABLES, 2, 1, "-F", (char *)FW_STORAGE_ACCESSRIGHT_ROUTER);
	va_cmd(IPTABLES, 4, 1, (char *)FW_DEL, (char *)FW_INPUT, "-j", (char *)FW_STORAGE_ACCESSRIGHT_ROUTER);
	va_cmd(IPTABLES, 2, 1, "-X", (char *)FW_STORAGE_ACCESSRIGHT_ROUTER);
}
void setup_storage_access_right(void)
{

	int totalNum,index;
	unsigned char macString[32] = {0};
	MIB_LAN_HOST_ACCESS_RIGHT_T entry;
#ifdef CONFIG_YUEME
	unsigned char cmd_buf[64];
	int limitcount = 0;
	
	memset(cmd_buf, 0x0, sizeof(cmd_buf));
#endif

	
	totalNum = mib_chain_total(MIB_LAN_HOST_ACCESS_RIGHT_TBL);

	va_cmd(IPTABLES, 2, 1, "-N", (char *)FW_STORAGE_ACCESSRIGHT_ROUTER);
	va_cmd(IPTABLES, 4, 1, (char *)FW_INSERT, (char *)FW_INPUT, "-j", (char *)FW_STORAGE_ACCESSRIGHT_ROUTER);

	for(index=0; index<totalNum; index++)
	{
		mib_chain_get(MIB_LAN_HOST_ACCESS_RIGHT_TBL,index,&entry);
		if( entry.storageAccessRight == 0 )
		{
			sprintf(macString, "%02x:%02x:%02x:%02x:%02x:%02x", entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);

			/* iptables -A FW_STORAGE_ACCESSRIGHT_ROUTER -m mac --mac-source xx:xx:xx:xx:xx:xx -p tcp --dport 21 -j DROP */
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, (char*)FW_STORAGE_ACCESSRIGHT_ROUTER, "-m", "mac", "--mac-source", macString, "-p", "tcp", "--dport", "21", "-j", (char *)FW_DROP);

			/* iptables -A FW_STORAGE_ACCESSRIGHT_ROUTER -m mac --mac-source xx:xx:xx:xx:xx:xx -p tcp --dport 139/445 -j DROP */
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, (char*)FW_STORAGE_ACCESSRIGHT_ROUTER, "-m", "mac", "--mac-source", macString, "-p", "tcp", "--dport", "139", "-j", (char *)FW_DROP);
			va_cmd(IPTABLES, 12, 1, (char *)FW_ADD, (char*)FW_STORAGE_ACCESSRIGHT_ROUTER, "-m", "mac", "--mac-source", macString, "-p", "tcp", "--dport", "445", "-j", (char *)FW_DROP);
#ifdef CONFIG_YUEME
			snprintf(cmd_buf, 46, "echo set 0 > /proc/smbshortcut\n");
			system(cmd_buf);
			limitcount ++;
#endif			
		}
	}
#ifdef CONFIG_YUEME
	if ( limitcount == 0 ){ /* That means there is no hosts to be limited. */
		snprintf(cmd_buf, 46, "echo set 1 > /proc/smbshortcut\n");
		system(cmd_buf);		
	}
#endif	
}

void apply_accessRight(uint8 enable)
{
	flush_internet_access_right();
	if(enable)
		setup_internet_access_right();

	flush_storage_access_right();
	if(enable)
		setup_storage_access_right();
}
#endif

unsigned int macAddrCmp(unsigned char *addr1, unsigned char *addr2)
{
	unsigned short *a = (unsigned short *)addr1;
	unsigned short *b = (unsigned short *)addr2;

	return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) != 0;
}

unsigned int isMacAddrInvalid(unsigned char *pMac)
{
	if (pMac == NULL)
		return 1;

	if(pMac[0]&0x01)
		return 1;

	if(0x00 == (pMac[0]|pMac[1]|pMac[2]|pMac[3]|pMac[4]|pMac[5]) )
		return 1;

	return 0;
}

#ifdef CONFIG_USER_LAN_BANDWIDTH_CONTROL
typedef struct lanport_ctlrate_info{
	unsigned int upRate;   /* in unit of kbps */
	unsigned int downRate; /* in unit of kbps */
}LANPORT_CTLRATE_INFO;

struct webserver_callout macinfo_ch;
LANPORT_CTLRATE_INFO lanPortCtlRateInfo[4];


typedef struct wifi_ctlrate_info{
	unsigned char mac[MAC_ADDR_LEN];   /* mac address */
	unsigned int upRate;   /* in unit of kbps */
	unsigned int downRate; /* in unit of kbps */
}WIFI_CTLRATE_INFO;

WIFI_CTLRATE_INFO wifiCtlRateInfo[MAX_STA_NUM+1];

char wlan_sta_buf[sizeof(WLAN_STA_INFO_T) * (MAX_STA_NUM+1)];
int isWifiMacOnline(unsigned char *mac)
{
	int i;
	WLAN_STA_INFO_Tp pInfo;

	for(i=1; i<=MAX_STA_NUM; i++)
	{
		pInfo = (WLAN_STA_INFO_Tp)&wlan_sta_buf[i*sizeof(WLAN_STA_INFO_T)];
		if (pInfo->aid && (pInfo->flag & STA_INFO_FLAG_ASOC))
		{
			if( !macAddrCmp(mac, pInfo->addr) )
				return i;
		}
	}

	return 0;
}

/*
Return:
	0 - no change in  lanPortCtlRateInfo.
	1 - policy changed in lanPortCtlRateInfo.
	others - error occured.
 */
int reCalculateLanPortRateLimitInfo(void)
{
	int i, totalNum, macidx, idx, ssid=-1;
	unsigned int ratelimit;
	MIB_LAN_HOST_BANDWIDTH_T entry;
	rtk_rg_macEntry_t macEntry;
	LANPORT_CTLRATE_INFO oldInfo[4];
	WIFI_CTLRATE_INFO oldWifiInfo[MAX_STA_NUM+1];
	WLAN_STA_INFO_Tp pInfo;
	//WIFISSID_CTLRATE_INFO oldSSIDInfo;

	//LAN
	memcpy(oldInfo, lanPortCtlRateInfo , sizeof(lanPortCtlRateInfo));
	memset(lanPortCtlRateInfo, 0, sizeof(lanPortCtlRateInfo));

	//WIFI
	memcpy(oldWifiInfo, wifiCtlRateInfo , sizeof(wifiCtlRateInfo));
	memset(wifiCtlRateInfo, 0, sizeof(wifiCtlRateInfo));

	memset(wlan_sta_buf, 0, sizeof(WLAN_STA_INFO_T) * (MAX_STA_NUM+1));
	if ( getWlStaInfo(getWlanIfName(),  (WLAN_STA_INFO_Tp)wlan_sta_buf ) < 0 ) {
		printf("Read wlan sta info failed!\n");
		return -1;
	}

	memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL);

	for(i=0; i<totalNum; i++)
	{
		if (!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL, i, (void *)&entry))
		{
			printf("[%s %d]get LAN_HOST_BANDWIDTHl chain entry error!\n", __func__, __LINE__);
			return -1;
		}

		macidx = -1;
		memset(&macEntry, 0, sizeof(rtk_rg_macEntry_t));
		memcpy(macEntry.mac.octet, entry.mac, sizeof(macEntry.mac.octet));
		//printf("[%s %d]:mac(%02x-%02x-%02x-%02x-%02x-%02x)\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);

		if(RT_ERR_RG_OK == rtk_rg_macEntry_find(&macEntry,&macidx))
		{
			if(macEntry.port_idx < RTK_RG_PORT_PON)
			{
				//Upstream
				if((0 == lanPortCtlRateInfo[macEntry.port_idx].upRate)
					||((entry.maxUsBandwidth!=0)&&(entry.maxUsBandwidth < lanPortCtlRateInfo[macEntry.port_idx].upRate)))
				{
					lanPortCtlRateInfo[macEntry.port_idx].upRate = entry.maxUsBandwidth;
				}

				//Downstream
				if((0 == lanPortCtlRateInfo[macEntry.port_idx].downRate)
					||((entry.maxDsBandwidth!=0)&&(entry.maxDsBandwidth < lanPortCtlRateInfo[macEntry.port_idx].downRate)))
				{
					lanPortCtlRateInfo[macEntry.port_idx].downRate = entry.maxDsBandwidth;
				}
			} else if(macEntry.port_idx > RTK_RG_PORT_CPU)//wifi port
			{
				idx = isWifiMacOnline(macEntry.mac.octet);
				if (idx)
				{
					pInfo = (WLAN_STA_INFO_Tp)&wlan_sta_buf[idx*sizeof(WLAN_STA_INFO_T)];
					//printf("[%s %d]:idx=%d, MAC(%02x-%02x-%02x-%02x-%02x-%02x)\n", __func__, __LINE__, idx, pInfo->addr[0], pInfo->addr[1], pInfo->addr[2], pInfo->addr[3],pInfo->addr[4], pInfo->addr[5]);

					memcpy(wifiCtlRateInfo[idx].mac, pInfo->addr, MAC_ADDR_LEN);
					wifiCtlRateInfo[idx].upRate = entry.maxUsBandwidth;
					wifiCtlRateInfo[idx].downRate = entry.maxDsBandwidth;
				}
			}
		}
		else
		{
			//printf("[%s %d]get macEntry[0x%02x-%02x-%02x-%02x-%02x-%02x] failed.\n",
				//__func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);
			//return -1;
			continue;
		}
	}


	if( ( !memcmp(oldInfo, lanPortCtlRateInfo, sizeof(lanPortCtlRateInfo)) )&&( !memcmp(oldWifiInfo, wifiCtlRateInfo, sizeof(wifiCtlRateInfo)) )  )
	{// lanPortCtlRateInfo and wifiCtlRateInfo not change
		//printf("[%s %d]:not change\n", __func__, __LINE__);
		return 0;
	}
	else
	{
		//printf("[%s %d]:change.\n", __func__, __LINE__);
		return 1;
	}

}

/* 9607 support wifi client rate limit now */
void apply_wifiRateLimit(void)
{
	int i = 0;
	char cmdBuf[64];
	char macString[20];
	char *ifName = getWlanIfName();

	for(i=1; i<=MAX_STA_NUM; i++)
	{
		memset(cmdBuf, 0, 64);
		memset(macString, 0, 20);
		if( !isMacAddrInvalid(wifiCtlRateInfo[i].mac) )
		{
			sprintf(macString, "%2x%2x%2x%2x%2x%2x",wifiCtlRateInfo[i].mac[0],wifiCtlRateInfo[i].mac[1],wifiCtlRateInfo[i].mac[2],wifiCtlRateInfo[i].mac[3],wifiCtlRateInfo[i].mac[4],wifiCtlRateInfo[i].mac[5]);
			fillcharZeroToMacString(macString);
			sprintf(cmdBuf, "/bin/iwpriv %s sta_bw_control %s,%d,%d\n", ifName, macString, wifiCtlRateInfo[i].downRate, wifiCtlRateInfo[i].upRate);
			//printf("[%s %d]:MAC(%s), upRate(%d), downRate(%d)\n", __func__, __LINE__, macString, wifiCtlRateInfo[i].upRate, wifiCtlRateInfo[i].downRate);
			system(cmdBuf);
		}
	}
}

void clear_wifiRateLimit(void)
{
	char cmdBuf[64];
	char macString[20];
	char *ifName = getWlanIfName();

	MIB_LAN_HOST_BANDWIDTH_T entry;
	int i, totalNum;

	memset(wlan_sta_buf, 0, sizeof(WLAN_STA_INFO_T) * (MAX_STA_NUM+1));
	if ( getWlStaInfo(getWlanIfName(),  (WLAN_STA_INFO_Tp)wlan_sta_buf ) < 0 ) {
		printf("Read wlan sta info failed!\n");
		return;
	}
	memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL);

	for(i=0; i<totalNum; i++)
	{
		if (!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL, i, (void *)&entry))
		{
			printf("[%s %d]get LAN_HOST_BANDWIDTHl chain entry error!\n", __func__, __LINE__);
			return;
		}

		/* not wifi client, continue */
		if( !isWifiMacOnline(entry.mac) )
			continue;

		memset(cmdBuf, 0, 64);
		memset(macString, 0, 20);
		sprintf(macString, "%2x%2x%2x%2x%2x%2x",entry.mac[0],entry.mac[1],entry.mac[2],entry.mac[3],entry.mac[4],entry.mac[5]);
		fillcharZeroToMacString(macString);
		sprintf(cmdBuf, "/bin/iwpriv %s sta_bw_control %s,0,0\n", ifName, macString);
		//printf("[%s %d]:MAC(%s), upRate(%d), downRate(%d)\n", __func__, __LINE__, macString, entry.maxUsBandwidth, entry.maxDsBandwidth);
		system(cmdBuf);
	}
}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)	
int getInternetWANItfName(char* devname,int len){
		int i =0;
		MIB_CE_ATM_VC_T vcEntry;
		int vcEntryNum = mib_chain_total(MIB_ATM_VC_TBL);
		for(i=0;i<vcEntryNum; i++)
		{
			if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vcEntry))
				continue;

			if (vcEntry.cmode == CHANNEL_MODE_BRIDGE)
				continue;
			if (!vcEntry.enable)
				continue;
			if (!((vcEntry.applicationtype&X_CT_SRV_INTERNET)))
				continue;			
			ifGetName(vcEntry.ifIndex, devname, len);	
			return 1;
		}
		return 0;

}

	//add tc rules for ProtocolStack because the stream with port 80 will enter into PS
void apply_lanPortRateLimitInPS(){
	MIB_LAN_HOST_BANDWIDTH_T entry;
	int i, totalNum;
	char s_rate[16], s_ceil[16], s_classid[16], s_quantum[16],s_handleid[16];
	char s_mac2[16], s_mac4[16];
	char d_mac2[16], d_mac4[16];
	char internetWanName[IFNAMSIZ]={0}; 
	
	memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	//clear all the old rules
	va_cmd(TC, 5, 1, "qdisc", (char *)ARG_DEL, "dev", "br0", "root");
	if(getInternetWANItfName(internetWanName,sizeof(internetWanName)-1))
		va_cmd(TC, 5, 1, "qdisc", (char *)ARG_DEL, "dev", internetWanName, "root");
	printf("%s %d internetWanName=%s\n",__FUNCTION__,__LINE__,internetWanName);
	totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL);
	if(totalNum){
		//download
		//tc qdisc add dev br0 root handle 1: htb default 10
		va_cmd(TC, 10, 1, "qdisc", (char *)ARG_ADD, "dev", "br0","root", "handle", "1:", "htb", "default", "10");
		//tc class add dev br0 parent 1: classid 1:1 htb rate 100Mbit 
		va_cmd(TC, 15, 1, "class", (char *)ARG_ADD, "dev", "br0","parent", "1:", "classid", "1:1", "htb", "rate", "102400kbit", "ceil", "102400kbit","quantum","1500");
		//tc class add dev br0 parent 1:1 classid 1:10 htb rate 100Mbit 
		va_cmd(TC, 15, 1, "class", (char *)ARG_ADD, "dev", "br0","parent", "1:", "classid", "1:10", "htb", "rate", "102400kbit", "ceil", "102400kbit","quantum","1500");
		//tc qdisc add dev br0 parent 1:10 handle 100: pfifo limit 100
		va_cmd(TC, 11, 1, "qdisc", (char *)ARG_ADD, "dev", "br0","parent", "1:10", "handle", "100:", "pfifo", "limit", "100");
		//upload
		if(strlen(internetWanName)){
			//tc qdisc add dev nas0_0 root handle 1: htb default 10
			va_cmd(TC, 10, 1, "qdisc", (char *)ARG_ADD, "dev", internetWanName,"root", "handle", "2:", "htb", "default", "10");
			//tc class add dev nas0_0 parent 1: classid 1:1 htb rate 100Mbit 
			va_cmd(TC, 15, 1, "class", (char *)ARG_ADD, "dev", internetWanName,"parent", "2:", "classid", "2:1", "htb", "rate", "102400kbit", "ceil", "102400kbit","quantum","1500");
			//tc class add dev nas0_0 parent 1:1 classid 1:10 htb rate 100Mbit 
			va_cmd(TC, 15, 1, "class", (char *)ARG_ADD, "dev", internetWanName,"parent", "2:", "classid", "2:10", "htb", "rate", "102400kbit", "ceil", "102400kbit","quantum","1500");
			//tc qdisc add dev nas0_0 parent 1:10 handle 100: pfifo limit 100
			va_cmd(TC, 11, 1, "qdisc", (char *)ARG_ADD, "dev", internetWanName,"parent", "2:10", "handle", "100:", "pfifo", "limit", "100");
		}
	}
	for(i=0; i<totalNum; i++)
	{
		if (!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL, i, (void *)&entry))
		{
			printf("[%s %d]get LAN_HOST_BANDWIDTHl chain entry error!\n", __func__, __LINE__);
			return;
		}

		if (entry.maxUsBandwidth != 0)
		{
			if(strlen(internetWanName)){
					//upload
				if(strlen(internetWanName)){
					snprintf(s_rate, 16, "%dKbit", entry.maxDsBandwidth);
					snprintf(s_ceil, 16, "%dKbit", entry.maxDsBandwidth);
					snprintf(s_classid, 16, "2:%d0", i+2);
					snprintf(s_handleid, 16, "%d00", i+2);
					snprintf(s_mac4, 16, "0x%02x%02x%02x%02x",entry.mac[2],entry.mac[3],entry.mac[4],entry.mac[5]);
					snprintf(s_mac2, 16, "0x%02x%02x",entry.mac[0],entry.mac[1]);
					//tc class add dev nas0_0 parent 1:1 classid 1:X0 htb rate 1600kbit ceil 1600kbit
					va_cmd(TC, 15, 1, "class", (char *)ARG_ADD, "dev", internetWanName,"parent", "1:1", "classid", s_classid, "htb", "rate", s_rate, "ceil", s_ceil,"quantum","1500");
					//tc qdisc add dev nas0_0 parent 1:X0 handle x00: pfifo limit 100
					va_cmd(TC, 11, 1, "qdisc", (char *)ARG_ADD, "dev", internetWanName,"parent", s_classid, "handle", s_handleid, "pfifo", "limit", "100");
					//tc filter add dev nas0_0 protocol ip parent 1:0  u32 match ip dst 192.168.1.12/32 flowid 1:X0
					//tc filter add dev nas0_0 parent 1:0 protocol ip u32 match u16 0x0800 0xffff at -2 match u32 0x00ebd99f 0xffffffff at -12 match u16 0x0857 0xffff at -14 flowid 1:10
					va_cmd(TC, 29, 1, "filter", (char *)ARG_ADD, "dev", internetWanName,"parent", "1:0", "protocol", "ip", "u32", "match", "u16",
							"0x0800","0xffff","at","-2","match","u32",s_mac4,"0xffffffff","at","-6","match","u16",s_mac2,"0xffff",
							"at","-8","flowid",s_classid);
				}
			}
			
		}

		if (entry.maxDsBandwidth != 0)
		{
			
			snprintf(s_rate, 16, "%dKbit", entry.maxDsBandwidth);
			snprintf(s_ceil, 16, "%dKbit", entry.maxDsBandwidth);
			snprintf(s_classid, 16, "1:%d0", i+2);
			snprintf(s_handleid, 16, "%d00", i+2);
			snprintf(d_mac4, 16, "0x%02x%02x%02x%02x",entry.mac[2],entry.mac[3],entry.mac[4],entry.mac[5]);
			snprintf(d_mac2, 16, "0x%02x%02x",entry.mac[0],entry.mac[1]);
			//tc class add dev br0 parent 1:1 classid 1:X0 htb rate 1600kbit ceil 1600kbit
			va_cmd(TC, 15, 1, "class", (char *)ARG_ADD, "dev", "br0","parent", "1:1", "classid", s_classid, "htb", "rate", s_rate, "ceil", s_ceil,"quantum","1400");
			//tc qdisc add dev br0 parent 1:X0 handle x00: pfifo limit 100
			va_cmd(TC, 11, 1, "qdisc", (char *)ARG_ADD, "dev", "br0","parent", s_classid, "handle", s_handleid, "pfifo", "limit", "100");
			//tc filter add dev br0 protocol ip parent 1:0  u32 match ip dst 192.168.1.12/32 flowid 1:X0
			//tc filter add dev br0 parent 1:0 protocol ip u32 match u16 0x0800 0xffff at -2 match u32 0x00ebd99f 0xffffffff at -12 match u16 0x0857 0xffff at -14 flowid 1:10
			va_cmd(TC, 29, 1, "filter", (char *)ARG_ADD, "dev", "br0","parent", "1:0", "protocol", "ip", "u32", "match", "u16",
					"0x0800","0xffff","at","-2","match","u32",d_mac4,"0xffffffff","at","-12","match","u16",d_mac2,"0xffff",
					"at","-14","flowid",s_classid);
			
		}
	}
}
void clear_lanPortRateLimitInPS(){
	char internetWanName[IFNAMSIZ]; 	
	va_cmd(TC, 5, 1, "qdisc", (char *)ARG_DEL, "dev", "br0", "root");
	if(getInternetWANItfName(internetWanName,sizeof(internetWanName)-1))
		va_cmd(TC, 5, 1, "qdisc", (char *)ARG_DEL, "dev", internetWanName, "root");
#if 0	
	MIB_LAN_HOST_BANDWIDTH_T entry;
	int i, totalNum;
	char s_rate[16], s_ceil[16], s_classid[16], s_quantum[16],s_handleid[16];
	char s_mac2[16], s_mac4[16];
	char d_mac2[16], d_mac4[16];
	char internetWanName[IFNAMSIZ]={0}; 
	
	memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	//clear all the old rules
	
	getInternetWANItfName(internetWanName,sizeof(internetWanName)-1);
	printf("%s %d internetWanName=%s\n",__FUNCTION__,__LINE__,internetWanName);
	totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL);
	
	for(i=0; i<totalNum; i++)
	{
		if (!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL, i, (void *)&entry))
		{
			printf("[%s %d]get LAN_HOST_BANDWIDTHl chain entry error!\n", __func__, __LINE__);
			return -1;
		}

		if (entry.maxUsBandwidth != 0)
		{
			if(strlen(internetWanName)){
					//upload
				if(strlen(internetWanName)){
					snprintf(s_rate, 16, "%dKbit", entry.maxDsBandwidth);
					snprintf(s_ceil, 16, "%dKbit", entry.maxDsBandwidth);
					snprintf(s_classid, 16, "2:%d0", i+2);
					snprintf(s_handleid, 16, "%d00", i+2);
					snprintf(s_mac4, 16, "0x%02x%02x%02x%02x",entry.mac[2],entry.mac[3],entry.mac[4],entry.mac[5]);
					snprintf(s_mac2, 16, "0x%02x%02x",entry.mac[0],entry.mac[1]);
					//tc class add dev nas0_0 parent 1:1 classid 1:X0 htb rate 1600kbit ceil 1600kbit
					va_cmd(TC, 15, 1, "class", (char *)ARG_DEL, "dev", internetWanName,"parent", "1:1", "classid", s_classid, "htb", "rate", s_rate, "ceil", s_ceil,"quantum","1500");
					//tc qdisc add dev nas0_0 parent 1:X0 handle x00: pfifo limit 100
					va_cmd(TC, 11, 1, "qdisc", (char *)ARG_DEL, "dev", internetWanName,"parent", s_classid, "handle", s_handleid, "pfifo", "limit", "100");
					//tc filter add dev nas0_0 protocol ip parent 1:0  u32 match ip dst 192.168.1.12/32 flowid 1:X0
					//tc filter add dev nas0_0 parent 1:0 protocol ip u32 match u16 0x0800 0xffff at -2 match u32 0x00ebd99f 0xffffffff at -12 match u16 0x0857 0xffff at -14 flowid 1:10
					va_cmd(TC, 29, 1, "filter", (char *)ARG_DEL, "dev", internetWanName,"parent", "1:0", "protocol", "ip", "u32", "match", "u16",
							"0x0800","0xffff","at","-2","match","u32",s_mac4,"0xffffffff","at","-6","match","u16",s_mac2,"0xffff",
							"at","-8","flowid",s_classid);
				}
			}
			
		}		
	}
#endif	
}

#endif

void apply_lanPortRateLimit(void)
{
#if defined(CONFIG_RTL9607C_SERIES) || defined(CONFIG_LUNA_G3_SERIES)
	MIB_LAN_HOST_BANDWIDTH_T entry;
	int i, totalNum;

	memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL);
	for(i=0; i<totalNum; i++)
	{
		if (!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL, i, (void *)&entry))
		{
			printf("[%s %d]get LAN_HOST_BANDWIDTHl chain entry error!\n", __func__, __LINE__);
			return;
		}
		
		if (entry.maxUsBandwidth != 0)
		{
			if(RT_ERR_RG_OK == RG_set_port_ingress_bandwidth_control(entry.mac, entry.maxUsBandwidth))
			{
				printf("[%s %d]Set RG_set_port_ingress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X, rate=%d\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5], entry.maxUsBandwidth);
			}
			else
			{
				printf("[%s %d]Failed to Set RG_set_port_ingress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X, rate=%d\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5], entry.maxUsBandwidth);
				continue;
			}
		}

		if (entry.maxDsBandwidth != 0)
		{
			if(RT_ERR_RG_OK == RG_set_port_egress_bandwidth_control(entry.mac, entry.maxDsBandwidth))
			{
				printf("[%s %d]Set RG_set_port_egress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X, rate=%d\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5], entry.maxDsBandwidth);
			}
			else
			{
				printf("[%s %d]Failed to Set RG_set_port_egress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X, rate=%d\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5], entry.maxDsBandwidth);
				continue;
			}
		}
	}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)	
		//clear tc rules for ProtocolStack because the stream with port 80 will enter into PS
		apply_lanPortRateLimitInPS();				
#endif
#else
	int port = 0;

	for(port=0; port<4; port++)
	{
		if(RT_ERR_RG_OK == RG_set_port_ingress_bandwidth_control(port, lanPortCtlRateInfo[port].upRate))
		{
			//printf("[%s %d]Set RG_set_port_ingress_bandwidth_control, port=%d, rate=%d\n", __func__, __LINE__, port, lanPortCtlRateInfo[port].upRate);
		}
		else
		{
			printf("[%s %d]Failed to Set RG_set_port_ingress_bandwidth_control, port=%d, rate=%d\n", __func__, __LINE__, port, lanPortCtlRateInfo[port].upRate);
			return;
		}

		if(RT_ERR_RG_OK == RG_set_port_egress_bandwidth_control(port, lanPortCtlRateInfo[port].downRate))
		{
			//printf("[%s %d]Set RG_set_port_egress_bandwidth_control, port=%d, rate=%d\n", __func__, __LINE__, port, lanPortCtlRateInfo[port].downRate);
		}
		else
		{
			printf("[%s %d]Failed to Set RG_set_port_egress_bandwidth_control, port=%d, rate=%d\n", __func__, __LINE__, port, lanPortCtlRateInfo[port].downRate);
			return;
		}
	}
#endif
}

void clear_lanPortRateLimit(void)
{
#if defined(CONFIG_RTL9607C_SERIES) || defined(CONFIG_LUNA_G3_SERIES)
	MIB_LAN_HOST_BANDWIDTH_T entry;
	int i, totalNum;

	memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL);
	for(i=0; i<totalNum; i++)
	{
		if (!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL, i, (void *)&entry))
		{
			printf("[%s %d]get LAN_HOST_BANDWIDTH_TBL chain entry error!\n", __func__, __LINE__);
			return;
		}
		
		if(RT_ERR_RG_OK == RG_set_port_ingress_bandwidth_control(entry.mac, 0))
		{
			printf("[%s %d]Clear RG_set_port_ingress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);
		}
		else
		{
			printf("[%s %d]Failed to Clear RG_set_port_ingress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);
			return;
		}

		if(RT_ERR_RG_OK == RG_set_port_egress_bandwidth_control(entry.mac, 0))
		{
			printf("[%s %d]Clear RG_set_port_egress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);
		}
		else
		{
			printf("[%s %d]Failed to Clear RG_set_port_egress_bandwidth_control, mac=%02X:%02X:%02X:%02X:%02X:%02X\n", __func__, __LINE__, entry.mac[0], entry.mac[1], entry.mac[2], entry.mac[3], entry.mac[4], entry.mac[5]);
			return;
		}
	}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)	
		//add tc rules for ProtocolStack because the stream with port 80 will enter into PS
		clear_lanPortRateLimitInPS();				
#endif
#else
	int port = 0;

	for(port=0; port<4; port++)
	{
		if(RT_ERR_RG_OK == RG_set_port_ingress_bandwidth_control(port, 0))
		{
			//printf("[%s %d]Clear portIgrBandwidthCtrlRate, port=%d\n", __func__, __LINE__, port);
		}
		else
		{
			printf("[%s %d]Failed to Clear portIgrBandwidthCtrlRate, port=%d\n", __func__, __LINE__, port);
			return;
		}

		if(RT_ERR_RG_OK == RG_set_port_egress_bandwidth_control(port, 0))
		{
			//printf("[%s %d]Clear portEgrBandwidthCtrlRate, port=%d\n", __func__, __LINE__, port);
		}
		else
		{
			printf("[%s %d]Failed to Clear portEgrBandwidthCtrlRate, port=%d\n", __func__, __LINE__, port);
			return;
		}
	}
#endif
}

void poll_macinfo(void)
{
	unsigned char lanHostBandwidthControlEnable=0;

	mib_get(MIB_LANHOST_BANDWIDTH_CONTROL_ENABLE, (void *)&lanHostBandwidthControlEnable);
	if((1==lanHostBandwidthControlEnable)&&(1 == reCalculateLanPortRateLimitInfo()))
	{
		apply_lanPortRateLimit();
		apply_wifiRateLimit();
	}

	TIMEOUT((void*)poll_macinfo, 0, 1, macinfo_ch);
}

void apply_maxBandwidth()
{
	unsigned char lanHostBandwidthControlEnable=0;

	mib_get(MIB_LANHOST_BANDWIDTH_CONTROL_ENABLE, (void *)&lanHostBandwidthControlEnable);

	reCalculateLanPortRateLimitInfo();
	if(lanHostBandwidthControlEnable)
	{
		apply_lanPortRateLimit();
		apply_wifiRateLimit();
	}
	else
	{
		clear_lanPortRateLimit();
		clear_wifiRateLimit();
	}
}

void clear_maxBandwidth()
{
	clear_lanPortRateLimit();
	clear_wifiRateLimit();
}

#endif

void changeMacFormat(char *str, char s, char d)
{
    int i=0;
    int length=strlen(str);
    for (i=0;i<length;i++)
    {
        if (str[i]==s) str[i]=d;
    }
}

void changeStringToMac(unsigned char *mac, unsigned char *macString)
{
	unsigned int mac0, mac1, mac2, mac3, mac4, mac5;
	if( (mac==NULL)||(macString==NULL) )
		return;
	sscanf(macString, "%2x-%2x-%2x-%2x-%2x-%2x",&mac0,&mac1,&mac2,&mac3,&mac4,&mac5);

	mac[0] = (unsigned char)mac0;
	mac[1] = (unsigned char)mac1;
	mac[2] = (unsigned char)mac2;
	mac[3] = (unsigned char)mac3;
	mac[4] = (unsigned char)mac4;
	mac[5] = (unsigned char)mac5;
}

void changeMacToString(unsigned char *mac, unsigned char *macString)
{
	if( (mac==NULL)||(macString==NULL) )
		return;
	sprintf(macString, "%2x-%2x-%2x-%2x-%2x-%2x",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
}

void fillcharZeroToMacString(unsigned char *macString)
{
	int i=0;
	if(macString==NULL)
		return;
	while(*(macString+i))
	{
		if(*(macString+i)==' ')
			*(macString+i)='0';
		i++;
	}
}

int flock_set(int fd, int type)
{
	struct flock lock;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 0;
	lock.l_type = type;
	lock.l_pid = getpid();

	if((fcntl(fd, F_SETLKW, &lock)) < 0)
	{
		printf("Lock failed:type = %d\n", lock.l_type);
		return 1;
	}
	return 0;
}

unsigned char isZeroMac(unsigned char *pMac) 
{
	return !(pMac[0]|pMac[1]|pMac[2]|pMac[3]|pMac[4]|pMac[5]);
}

#ifdef CONFIG_USER_LANNETINFO
/*
 * FUNCTION:GET_LAN_NET_INFO
 *
 * INPUT:
 *
 * RETURN:
 *	successful--RT_ERR_CTC_IGD1_OK
 */

#define LANNETINFOFILE	"/var/lannetinfo"
#define LANNETINFO_RUNFILE	"/var/run/lannetinfo.pid"

int get_lan_net_info(lanHostInfo_t **ppLANNetInfoData, unsigned int *pCount)
{
	struct stat status;
	int fd, i, read_size, pid;
	lanHostInfo_t *pLANNetInfoData = NULL;

	if( (ppLANNetInfoData==NULL)||(pCount==NULL) )
		return -1;

	pid = read_pid(LANNETINFO_RUNFILE);
	if( pid>0 )
		kill(pid, SIGUSR2);

	usleep(30000);//30ms

	if ( stat(LANNETINFOFILE, &status) < 0 )
		return -3;

	fd = open(LANNETINFOFILE, O_RDONLY);
	if(fd < 0)
		return -3;

	read_size = (unsigned long)(status.st_size);
	*pCount = read_size / sizeof(lanHostInfo_t);

	pLANNetInfoData = (lanHostInfo_t *) malloc(read_size);

	if(pLANNetInfoData == NULL)
		return -3;

	*ppLANNetInfoData = pLANNetInfoData;
	memset(pLANNetInfoData, 0, read_size);

	if(!flock_set(fd, F_RDLCK))
	{
		read_size = read(fd, (void*)pLANNetInfoData, read_size);
		flock_set(fd, F_UNLCK);
	}

	close(fd);
	return 0;
}

int get_online_and_offline_device_info(lanHostInfo_t **ppLANNetInfoData, unsigned int *pCount)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret, size, i, count=0;
	lanHostInfo_t *pLANNetInfoData = NULL;

	if( (ppLANNetInfoData==NULL)||(pCount==NULL) )
		return -1;
	
	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_NEW_DEVICE_INFO_GET|CMD_LEAVE_DEVICE_INFO_GET;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	memset(&qbuf, 0, sizeof(struct lanNetInfoMsg));
	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{	
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			size = sizeof(lanHostInfo_t)*5;
			pLANNetInfoData = (lanHostInfo_t *) malloc(size);

			if(pLANNetInfoData == NULL)
				return -3;

			*ppLANNetInfoData = pLANNetInfoData;
			memset(pLANNetInfoData, 0, size);
			memcpy(pLANNetInfoData, mymsg->mtext, size);

			for(i=0; i<5; i++)
			{
				if(isZeroMac(pLANNetInfoData[i].mac) == 0)
					count++;
			}

			*pCount=count;
			return 0;
			
		}
	}

	printf("[%s %d]: Get new and leave device info failed:ret=%d!\n", __func__, __LINE__, ret);
	return -4;
}

#endif

/*
 * FUNCTION:SET_ATTACH_DEVICE_RIGHT
 *
 * INPUT:
 *	macAddr:
 *		target device's MAC address
 *	internetAccessRight:
 *		internet access right, 1-ON, 0-OFF
 *  storageAccessRight:
 *		storage access right, 1-ON, 0-OFF
 *
 * RETURN:
 *	0  successful
 *	-1 Input error
 *  -2 device not find
 *  -3 Other error
 */
#ifdef SUPPORT_ACCESS_RIGHT
int32 set_attach_device_right(unsigned char *pMacAddr, unsigned char internetAccessRight, unsigned char storageAccessRight)
{
	int ret, i, totalNum;
	MIB_LAN_HOST_ACCESS_RIGHT_T entry;

	/* check input first */
	if( isMacAddrInvalid(pMacAddr) )
		return -1;

	/* get Host by macAddr */
	 totalNum = mib_chain_total(MIB_LAN_HOST_ACCESS_RIGHT_TBL);

	memset(&entry, 0, sizeof(MIB_LAN_HOST_ACCESS_RIGHT_T));
	for(i=0; i<totalNum; i++)
	{
		if(!mib_chain_get(MIB_LAN_HOST_ACCESS_RIGHT_TBL, i, (void*)&entry))
		{
			printf("Get lan host access right mib entry error.\n");
			return -3;
		}

		if( !macAddrCmp(pMacAddr, entry.mac))
		{
			if( (internetAccessRight==INTERNET_ACCESS_ALLOW) && (storageAccessRight==STORAGE_ACCESS_ALLOW) )//delete mib entry
			{
				printf("Delete the target mib entry.\n");
				mib_chain_delete(MIB_LAN_HOST_ACCESS_RIGHT_TBL, i);
				goto apply;
			}
			/* Set internetAccessRight and storageAccessRight by macAddr */
			entry.internetAccessRight = internetAccessRight;
			entry.storageAccessRight = storageAccessRight;
			mib_chain_update(MIB_LAN_HOST_ACCESS_RIGHT_TBL, (void*)&entry, i);
			goto apply;
		}
	}

	/* add an entry */
	memset(&entry, 0, sizeof(MIB_LAN_HOST_ACCESS_RIGHT_T));
	memcpy(entry.mac, pMacAddr, MAC_ADDR_LEN);

	entry.internetAccessRight = internetAccessRight;
	entry.storageAccessRight = storageAccessRight;

	ret = mib_chain_add(MIB_LAN_HOST_ACCESS_RIGHT_TBL, (void*)&entry);
	if(ret == 0)
		return -3;

apply:
#ifdef COMMIT_IMMEDIATELY
	Commit();
#endif // of #if COMMIT_IMMEDIATELY
	apply_accessRight(1);

end:
	return 0;
}
#endif

#if defined(CONFIG_USER_LAN_BANDWIDTH_MONITOR) && defined(CONFIG_USER_LANNETINFO)
/*
 * FUNCTION:QUERY_ATTACH_DEVICE_REALRATE
 *
 * INPUT:
 *	macAddr:
 *		target device's MAC address
 *
 * RETURN:
 *	0  -- successful
 *	-1 -- failed
 */
int setup_lan_bandwidth_monitor(unsigned char onoff)
{
	unsigned char lanHostBandwidthMonitorEnable=0;

	if(onoff)
		lanHostBandwidthMonitorEnable = 1;
	else
		lanHostBandwidthMonitorEnable = 0;

	if( mib_set(MIB_LANHOST_BANDWIDTH_MONITOR_ENABLE, (void*)&lanHostBandwidthMonitorEnable) )
		return 0;

	return -1;
}

int query_attach_device_realrate(unsigned char *pMacAddr, unsigned int *pUsBandWidth, unsigned int *pDsBandWidth)
{
	/* get current Us/Ds Bandwidth */
	unsigned char lanHostBandwidthMonitorEnable=0;

	lanHostInfo_t *pLanNetInfo=NULL;
	unsigned int count=0;
	int ret=-1, idx;

	/* check input first */
	if( isMacAddrInvalid(pMacAddr) )
	{
		return -1;
	}

	mib_get(MIB_LANHOST_BANDWIDTH_MONITOR_ENABLE, (void*)&lanHostBandwidthMonitorEnable);
	if(lanHostBandwidthMonitorEnable == 0)
	{
		printf("Func is off.\n");
		return	-3;
	}

	ret = get_lan_net_info(&pLanNetInfo, &count);
	if(ret<0)
	{
		if(pLanNetInfo)
			free(pLanNetInfo);
		return ret;
	}

	for(idx=0; idx<count; idx++)
	{
		if( !macAddrCmp(pLanNetInfo[idx].mac, pMacAddr) )
		{
			*pUsBandWidth = pLanNetInfo[idx].upRate;
			*pDsBandWidth = pLanNetInfo[idx].downRate;
			if(pLanNetInfo)
				free(pLanNetInfo);

			return 0;
		}
	}
	return -3;
}
#endif

/*
 * FUNCTION:SET_ATTACH_DEVICE_BANDWIDTH
 *
 * INPUT:
 *	macAddr:
 *		target device's MAC address
 *	usBandWidth:
 *		Upstream bandwidth
 *	dsBandWidth:
 *		Downstream bandwidth
 * RETURN:
 *	0  -- successful--RT_ERR_CTC_IGD1_OK
 *	-1 -- Input error
 *  -2 -- device not find
 *  -3 -- other
 */
#ifdef CONFIG_USER_LAN_BANDWIDTH_CONTROL
int set_attach_device_maxbandwidth(unsigned char *pMacAddr, unsigned int maxUsBandWidth, unsigned int maxDsBandWidth, unsigned int minUsBandWidth, unsigned int minDsBandWidth)
{
	int ret, i, totalNum;
	unsigned char lanHostBandwidthControlEnable=0;
	MIB_LAN_HOST_BANDWIDTH_T entry;

	/* check if this function is on */
	mib_get(MIB_LANHOST_BANDWIDTH_CONTROL_ENABLE, (void*)&lanHostBandwidthControlEnable);
	if(lanHostBandwidthControlEnable == 0)
		return	-3;

	/* check input first */
	if(isMacAddrInvalid(pMacAddr))
		return -1;

	if( (maxUsBandWidth>=DEFAULT_MAX_US_BANDWIDTH)||(maxUsBandWidth>=DEFAULT_MAX_US_BANDWIDTH) )
		return -1;

	clear_maxBandwidth();//clear old

	totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL);
	memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	for(i=0; i<totalNum; i++)
	{
		if(!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL, i, (void*)&entry))
		{
			printf("Get lan host bandwidth table error.\n");
			return -3;
		}

		if( !macAddrCmp(pMacAddr, entry.mac))
		{
			if( (maxUsBandWidth==0)&&(maxDsBandWidth==0) )
			{//0 mean not rate limit
				mib_chain_delete(MIB_LAN_HOST_BANDWIDTH_TBL, i);
			}
			else
			{
				/* Set usBandwidth and dsBandwidth by macAddr */
				entry.maxUsBandwidth = maxUsBandWidth;
				entry.maxDsBandwidth = maxDsBandWidth;
#if defined(CONFIG_USER_LAN_BANDWIDTH_EX_CONTROL)
				entry.minUsBandwidth = minUsBandWidth;
				entry.minDsBandwidth = minDsBandWidth;
#endif
				mib_chain_update(MIB_LAN_HOST_BANDWIDTH_TBL, (void*)&entry, i);
			}

			goto apply;
		}
	}

	if( (maxUsBandWidth != 0)||(maxDsBandWidth != 0) )
	{
		/* add an entry */
		memset(&entry, 0 , sizeof(MIB_LAN_HOST_BANDWIDTH_T));
		memcpy( entry.mac, pMacAddr, MAC_ADDR_LEN );
		entry.maxUsBandwidth = maxUsBandWidth;
		entry.maxDsBandwidth = maxDsBandWidth;

#if defined(CONFIG_USER_LAN_BANDWIDTH_EX_CONTROL)
		entry.minUsBandwidth = minUsBandWidth;
		entry.minDsBandwidth = minDsBandWidth;
#endif

		ret = mib_chain_add(MIB_LAN_HOST_BANDWIDTH_TBL, (void*)&entry);
		if (ret == 0)
			return -3;
	}

apply:
#ifdef COMMIT_IMMEDIATELY
	Commit();
#endif // of #if COMMIT_IMMEDIATELY
	apply_maxBandwidth();

#ifdef CONFIG_USER_LANNETINFO
	int set_lanhost_control_status(unsigned char *pMacAddr, unsigned char controlStatus);
	if(maxUsBandWidth > 0 || maxDsBandWidth > 0)
	{
		set_lanhost_control_status(pMacAddr, 1);
	}
#endif
	return 0;
}


/*
 * FUNCTION:GET_ATTACH_DEVICE_BANDWIDTH
 *
 * INPUT:
 *	macAddr:
 *		target device's MAC address
 *	pUsBandWidth:
 *		save upstream bandwidth
 *	pDsBandWidth:
 *		save downstream bandwidth
 * RETURN:
 *	0  -- successful--RT_ERR_CTC_IGD1_OK
 *	-1 -- Input error
 *  -2 -- device not find
 *  -3 -- other
 */
int get_attach_device_maxbandwidth(unsigned char *pMacAddr, unsigned int *pUsBandWidth, unsigned int *pDsBandWidth, unsigned int *pUsBandWidthMin, unsigned int *pDsBandWidthMin)
{
	int i, totalNum;
	unsigned char lanHostBandwidthControlEnabel;
	MIB_LAN_HOST_BANDWIDTH_T entry;

	/* check if this function is on */
	mib_get(MIB_LANHOST_BANDWIDTH_CONTROL_ENABLE, &lanHostBandwidthControlEnabel);
	if(lanHostBandwidthControlEnabel == 0){
		printf("Func is off.\n");
		return	-3;
	}
	/* check input first */
	if( (isMacAddrInvalid(pMacAddr)) ||(pUsBandWidth == NULL) || (pDsBandWidth == NULL) )
		return -1;

#if defined(CONFIG_USER_LAN_BANDWIDTH_EX_CONTROL)
	if( (pUsBandWidthMin == NULL) || (pDsBandWidthMin == NULL) )
		return -1;
#endif

	if( ( totalNum = mib_chain_total(MIB_LAN_HOST_BANDWIDTH_TBL) ) <= 0 )
	{
		printf("Lan host mib table is empty.\n");
		return -2;
	}

	memset(&entry, 0, sizeof(MIB_LAN_HOST_BANDWIDTH_T));
	for(i=0; i<totalNum; i++)
	{
		if(!mib_chain_get(MIB_LAN_HOST_BANDWIDTH_TBL,i, (void*)&entry))
			continue;

		if( !macAddrCmp(pMacAddr, entry.mac))
			break;
	}

	if( i==totalNum )
	{
		return -2;
	}
	/* Get usBandwidth and dsBandwidth by macAddr */
	*pUsBandWidth = entry.maxUsBandwidth;
	*pDsBandWidth = entry.maxDsBandwidth;

#if defined(CONFIG_USER_LAN_BANDWIDTH_EX_CONTROL)
	*pUsBandWidthMin = entry.minUsBandwidth;
	*pDsBandWidthMin = entry.minDsBandwidth;
#endif

	return 0;
}
#endif


#ifdef CONFIG_USER_LANNETINFO

#include <sys/msg.h>
int sendMessageToLanNetInfo(LANNETINFO_MSG_T *msg)
{
	int  ret, qid, cpid, ctgid;
	struct lanNetInfoMsg qbuf;
	int lannetinfo_pid = -1;

	qid = msgget((key_t)1771,  0660);
	if(qid <= 0){
		printf("[%s %d]: get lannetinfo msgqueue error!\n", __func__, __LINE__);
		return -2;
	}

	/* get lanNetInfo process pid*/
	lannetinfo_pid = read_pid(LANNETINFO_RUNFILE);

	if( (lannetinfo_pid == -1)||(0 != kill(lannetinfo_pid, 0)) )
	{
		printf("[%s %d]: There is no lanNetInfo Process!\n", __func__, __LINE__);
		return -3;
	}

	cpid = (int)syscall(SYS_gettid);
	ctgid = (int)getpid();

	/* Send a message to the queue */
	qbuf.mtype = lannetinfo_pid;
	qbuf.request = cpid;
	qbuf.tgid = ctgid;
	qbuf.msg.cmd = msg->cmd;
	qbuf.msg.arg1 = msg->arg1;
	qbuf.msg.arg2 = msg->arg2;
	memcpy(qbuf.msg.mtext, msg->mtext, MAX_DEVICE_INFO_SIZE);

	ret = msgsnd(qid, (void *)&qbuf, sizeof(struct lanNetInfoMsg)-sizeof(long), 0);
	if( ret== -1)
	{
		printf("[%s %d]:send devcie info request to lanNetInfo process error.\n", __func__, __LINE__);
		return ret;
	}
	return 0;
}


/*
	Return Value:
	Return -1 on failure;
	otherwise return the number of bytes actually copied into the mtext array.
*/
int readMessageFromLanNetInfo(struct lanNetInfoMsg *qbuf)
{
	int ret, qid, cpid, retry_count=20;

	qid = msgget((key_t)1771,  0660);
	if(qid <= 0){
		printf("[%s %d]: get lannetinfo msgqueue error!\n", __func__, __LINE__);
		return -1;
	}

	cpid = (int)syscall(SYS_gettid);
	qbuf->mtype = cpid;

rcv_retry:
	ret=msgrcv(qid, (void *)qbuf, sizeof(struct lanNetInfoMsg)-sizeof(long), cpid, 0);
	if (ret == -1) {
		switch (errno) {
				case EINTR	 :
					printf("====>>%s %d:EINTR	 \n", __func__, __LINE__);
					goto rcv_retry;
				case EACCES :
					printf("====>>%s %d:EACCES	\n", __func__, __LINE__);
					break;
				case EFAULT   :
					printf("====>>%s %d:EFAULT	 \n", __func__, __LINE__);
					break;
				case EIDRM	:
					printf("====>>%s %d:EIDRM	 \n", __func__, __LINE__);
					break;
				case EINVAL   :
					printf("====>>%s %d:EINVAL	 \n", __func__, __LINE__);
					break;
				case ENOMSG   :
					printf("====>>%s %d:ENOMSG	 \n", __func__, __LINE__);
					break;
				case E2BIG   :
					printf("====>>%s %d:E2BIG	 \n", __func__, __LINE__);
					break;
				default:
					printf("====>>%s %d:Unknown	 \n", __func__, __LINE__);
			}
	}

	return ret;
}

/*
 * FUNCTION:get new and leave device info
 *
 * INPUT:
 *	pNewDeviceInfo:
 *		target lanHostInfo_t array to store new device info
 *
 * RETURN:
 *	 0 -- successful
 *	-1 -- Input error
 *  -2 -- get msg queue error
 *  -3 -- lanNetInfo process not found
 *	-4 -- other
 */
int get_new_and_leave_device_info(lanHostInfo_t *pLanDeviceInfo, int num)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret, size;

	if(pLanDeviceInfo == NULL)
		return -1;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_NEW_DEVICE_INFO_GET|CMD_LEAVE_DEVICE_INFO_GET;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	memset(&qbuf, 0, sizeof(struct lanNetInfoMsg));
	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{	
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			//printf("[%s %d]:receive new lan net info successfully.\n", __func__, __LINE__);
			size = (sizeof(lanHostInfo_t)*num >= MAX_DEVICE_INFO_SIZE)? MAX_DEVICE_INFO_SIZE:(sizeof(lanHostInfo_t)*num);
			memcpy(pLanDeviceInfo, mymsg->mtext, size);
			return 0;
		}
	}

	printf("[%s %d]: Get new and leave device info failed:ret=%d!\n", __func__, __LINE__, ret);
	return -4;
}

/*
 * FUNCTION:SET_ATTCH_DEVICE_NAME
 *
 * INPUT:
 *	macAddr:
 *		target device's MAC address
 *	pDevName:
 *		devName to set
 *
 * RETURN:
 *	 0 -- successful
 *	-1 -- Input error
 *  -2 -- device not found
 *  -3 -- other
 */
int set_attach_device_name(unsigned char *pMacAddr, char *pDevName)
{
	int i, totalNum;
	MIB_LAN_DEV_NAME_T entry;

	if( (pMacAddr==NULL)||(pDevName==NULL) )
		return -1;

	if( ( totalNum = mib_chain_total(MIB_LAN_DEV_NAME_TBL) ) <= 0 )
	{
		printf("Lan host mib table is empty.\n");
		goto add;
	}

	memset(&entry, 0, sizeof(MIB_LAN_DEV_NAME_T));
	for(i=0; i<totalNum; i++)
	{
		if(!mib_chain_get(MIB_LAN_DEV_NAME_TBL,i, (void*)&entry))
			continue;

		if( !macAddrCmp(pMacAddr, entry.mac))
			break;
	}


	if( i!=totalNum )
	{
		strncpy(entry.devName, pDevName, MAX_LANNET_DEV_NAME_LENGTH-1);
		entry.devName[MAX_LANNET_DEV_NAME_LENGTH-1] = 0;
		if(!mib_chain_update(MIB_LAN_DEV_NAME_TBL,(void*)&entry, i))
			return -3;
		goto end;
	}

add:
	memcpy(entry.mac, pMacAddr, MAC_ADDR_LEN);
	strncpy(entry.devName, pDevName, MAX_LANNET_DEV_NAME_LENGTH-1);
	entry.devName[MAX_LANNET_DEV_NAME_LENGTH-1] = 0;
	if(!mib_chain_add(MIB_LAN_DEV_NAME_TBL,(void*)&entry))
		return -3;
end:
	return 0;
}

int get_attach_device_name(unsigned char *pMacAddr, char *pDevName)
{
	int i, totalNum;
	MIB_LAN_DEV_NAME_T entry;

	if( (pMacAddr==NULL)||(pDevName==NULL) )
		return -1;

	if( ( totalNum = mib_chain_total(MIB_LAN_DEV_NAME_TBL) ) <= 0 )
	{
		printf("Lan host mib table is empty.\n");
		return -2;
	}

	memset(&entry, 0, sizeof(MIB_LAN_DEV_NAME_T));
	for(i=0; i<totalNum; i++)
	{
		if(!mib_chain_get(MIB_LAN_DEV_NAME_TBL,i, (void*)&entry))
			continue;

		if( !macAddrCmp(pMacAddr, entry.mac))
			break;
	}

	if(i!=totalNum)
	{// find
		strncpy(pDevName, entry.devName, MAX_LANNET_DEV_NAME_LENGTH-1);
		pDevName[MAX_LANNET_DEV_NAME_LENGTH-1] = 0;
		return 0;
	}

	return -2;
}

#ifdef CONFIG_CU
int set_attach_device_type(unsigned char *pMacAddr, char *pDevType)
{
	int i, totalNum;
	MIB_LAN_DEV_NAME_T entry;

	if( (pMacAddr==NULL)||(pDevType==NULL) )
		return -1;

	if( ( totalNum = mib_chain_total(MIB_LAN_DEV_NAME_TBL) ) <= 0 )
	{
		goto add;
	}
	memset(&entry, 0, sizeof(MIB_LAN_DEV_NAME_T));
	for(i=0; i<totalNum; i++)
	{
		if(!mib_chain_get(MIB_LAN_DEV_NAME_TBL,i, (void*)&entry))
			continue;

		if( !macAddrCmp(pMacAddr, entry.mac))
			break;
	}

	if( i!=totalNum )
	{
		strncpy(entry.devType, pDevType, MAX_LANNET_DEV_NAME_LENGTH-1);
		entry.devType[MAX_LANNET_DEV_NAME_LENGTH-1] = 0;
		if(!mib_chain_update(MIB_LAN_DEV_NAME_TBL,(void*)&entry, i))
			return -3;
		goto end;
	}

add:
	memcpy(entry.mac, pMacAddr, MAC_ADDR_LEN);
	strncpy(entry.devType, pDevType, MAX_LANNET_DEV_NAME_LENGTH-1);
	entry.devType[MAX_LANNET_DEV_NAME_LENGTH-1] = 0;
	if(!mib_chain_add(MIB_LAN_DEV_NAME_TBL,(void*)&entry))
		return -3;
end:
	return 0;
}

int get_attach_device_type(unsigned char *pMacAddr, char *pDevType)
{
	int i, totalNum;
	MIB_LAN_DEV_NAME_T entry;

	if( (pMacAddr==NULL)||(pDevType==NULL) )
		return -1;

	if( ( totalNum = mib_chain_total(MIB_LAN_DEV_NAME_TBL) ) <= 0 )
	{
		return -2;
	}

	memset(&entry, 0, sizeof(MIB_LAN_DEV_NAME_T));
	for(i=0; i<totalNum; i++)
	{
		if(!mib_chain_get(MIB_LAN_DEV_NAME_TBL,i, (void*)&entry))
			continue;

		if( !macAddrCmp(pMacAddr, entry.mac))
			break;
	}

	if(i!=totalNum)
	{// find
		strncpy(pDevType, entry.devType, MAX_LANNET_DEV_NAME_LENGTH-1);
		pDevType[MAX_LANNET_DEV_NAME_LENGTH-1] = 0;
		return 0;
	}

	return -2;
}
#endif

int get_hg_dev_name(hgDevInfo_t **ppHGDevData, unsigned int *pCount)
{
	int32 ret, i, size=0;
	lanHostInfo_t *pLANHostData = NULL;
	hgDevInfo_t *pHGDevData =NULL;

	if((ppHGDevData==NULL)||(pCount == NULL))
		return -1;

	/* should get lan Client table */
	ret = get_lan_net_info(&pLANHostData, pCount);
	if(ret)
		return ret;
	++(*pCount);

	size = (*pCount) * sizeof(hgDevInfo_t);
	pHGDevData = (hgDevInfo_t *)malloc( size );
	if(pHGDevData==NULL)
		return -3;
	*ppHGDevData = pHGDevData;

	memset(pHGDevData, 0, size);
	/* get gateway MacAddr */
	if ( !mib_get(MIB_ELAN_MAC_ADDR, (void *)pHGDevData[0].mac))
		return -3;

	/* get gateway DevName */
	strcpy(pHGDevData[0].devName, DEVICE_MODEL_STR);

	/* get all lan dev name */
	for(i=1; i<(*pCount);i++)
	{
			memcpy(pHGDevData[i].mac, pLANHostData[i-1].mac, MAC_ADDR_LEN);
			strncpy(pHGDevData[i].devName, pLANHostData[i-1].devName, MAX_LANNET_DEV_NAME_LENGTH-1);
			pHGDevData[i].devName[MAX_LANNET_DEV_NAME_LENGTH-1]=0;

			get_attach_device_name(pHGDevData[i].mac, pHGDevData[i].devName);
	}

	free(pLANHostData);
	return 0;
}

int set_lanhost_max_number(unsigned int number)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;
	unsigned char max_lanHost_number = number;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_MAX_NUMBER_SET;

	mymsg->arg1 = number;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			mib_set( MIB_MAX_LAN_HOST_NUM, (void *)&max_lanHost_number);
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int get_lanhost_max_number(unsigned int * number)
{
	unsigned char max_lanHost_number;
	if(0 == mib_get( MIB_MAX_LAN_HOST_NUM, (void *)&max_lanHost_number))
		return -1;

	*number = max_lanHost_number;
	return 0;

#if 0
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	if(number == NULL)
		return -1;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_MAX_NUMBER_GET;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			//printf("[%s %d]: [%d] successfully.\n", __func__, __LINE__,mymsg->arg1);
			*number = mymsg->arg1;
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
#endif
}

int get_lanhost_number(unsigned int * number)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	if(number == NULL)
		return -1;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_NUMBER_GET;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			//printf("[%s %d]: [%d] successfully.\n", __func__, __LINE__, mymsg->arg1);
			*number = mymsg->arg1;
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int set_controllist_max_number(unsigned int number)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;
	unsigned char max_controlList_number = number;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_CONTROL_LIST_MAX_NUMBER_SET;

	mymsg->arg1 = number;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			mib_set( MIB_MAX_CONTROL_LIST_NUM, (void *)&max_controlList_number);
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int get_controllist_max_number(unsigned int * number)
{
	unsigned char max_controlList_number;
	if(0 == mib_get( MIB_MAX_CONTROL_LIST_NUM, (void *)&max_controlList_number))
		return -1;

	*number = max_controlList_number;
	return 0;

#if 0
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	if(number == NULL)
		return -1;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_CONTROL_LIST_MAX_NUMBER_GET;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			*number = mymsg->arg1;
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
#endif
}

int get_controllist_number(unsigned int * number)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	if(number == NULL)
		return -1;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_CONTROL_LIST_NUMBER_GET;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			*number = mymsg->arg1;
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int set_lanhost_control_status(unsigned char *pMacAddr, unsigned char controlStatus)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_CONTROL_STATUS_SET;

	mymsg->arg1 = controlStatus;
	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int get_lanhost_control_status(unsigned char *pMacAddr, unsigned char * controlStatus)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_CONTROL_STATUS_GET;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			*controlStatus = mymsg->arg1 ;
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int set_lanhost_access_right(unsigned char *pMacAddr, unsigned char internetAccessRight, unsigned char storageAccessRight)
{
#if 0 //def	CONFIG_YUEME
	set_attach_device_right(pMacAddr, internetAccessRight, storageAccessRight);
	return 0;
#else
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_ACCESS_RIGHT_SET;

	mymsg->arg1 = internetAccessRight;
	mymsg->arg2 = storageAccessRight;
	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
#ifdef SUPPORT_ACCESS_RIGHT
			return set_attach_device_right(pMacAddr, internetAccessRight, storageAccessRight);
#else
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
#endif
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
#endif	
}

int get_lanhost_access_right(unsigned char *pMacAddr, unsigned char * internetAccessRight, unsigned char * storageAccessRight)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_ACCESS_RIGHT_GET;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			*internetAccessRight = mymsg->arg1;
			*storageAccessRight = mymsg->arg2;
			//printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int set_lanhost_device_type(unsigned char *pMacAddr, unsigned char devType)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_DEVICE_TYPE_SET;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);
	mymsg->arg1 = devType;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int get_lanhost_device_type(unsigned char *pMacAddr, unsigned char *devType)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_DEVICE_TYPE_GET;

	if(devType==NULL)
		return -1;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			*devType = mymsg->arg1;
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int set_lanhost_brand(unsigned char *pMacAddr, unsigned char *brand)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_BRAND_SET;

	if(brand==NULL)
		return -1;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);
	strcpy(mymsg->mtext+MAC_ADDR_LEN, brand);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int get_lanhost_brand(unsigned char *pMacAddr, unsigned char *brand)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_BRAND_GET;

	if(brand==NULL)
		return -1;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			strcpy(brand, mymsg->mtext+MAC_ADDR_LEN);
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;

}

int set_lanhost_model(unsigned char *pMacAddr, unsigned char *model)
{
			struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_MODEL_SET;

	if(model==NULL)
		return -1;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);
	strcpy(mymsg->mtext+MAC_ADDR_LEN, model);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int get_lanhost_model(unsigned char *pMacAddr, unsigned char *model)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_MODEL_GET;

	if(model==NULL)
		return -1;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			strcpy(model, mymsg->mtext+MAC_ADDR_LEN);
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int set_lanhost_OS(unsigned char *pMacAddr, unsigned char *os)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_OS_SET;

	if(os==NULL)
		return -1;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);
	strcpy(mymsg->mtext+MAC_ADDR_LEN, os);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

int get_lanhost_OS(unsigned char *pMacAddr, unsigned char *os)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_OS_GET;

	if(os==NULL)
		return -1;

	memcpy(mymsg->mtext, pMacAddr, MAC_ADDR_LEN);

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			strcpy(os, mymsg->mtext+MAC_ADDR_LEN);
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}

	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;

}

/****************************************************************************/

int get_lanhost_information_change(lanHostInfo_t *pLanDeviceInfo, int num)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret, size=0;

	if(pLanDeviceInfo == NULL)
		return -1;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_INFORMATION_CHANGE_GET;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	memset(&qbuf, 0, sizeof(struct lanNetInfoMsg));
	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			size = ( (sizeof(lanHostInfo_t)*num) >= MAX_DEVICE_INFO_SIZE )? MAX_DEVICE_INFO_SIZE:(sizeof(lanHostInfo_t)*num);
			memcpy(pLanDeviceInfo, mymsg->mtext, size);
			return 0;
		}
	}

	printf("[%s %d]: Get lan host change information failed!\n", __func__, __LINE__);
	return -4;
}


int set_lanhost_linkchange_port_status(int portIdx)
{
	struct lanNetInfoMsg qbuf;
	LANNETINFO_MSG_T *mymsg;
	int  ret;
	//unsigned char max_lanHost_number = portIdx;

	mymsg = &qbuf.msg;
	mymsg->cmd = CMD_LAN_HOST_LINKCHANGE_PORT_SET;

	mymsg->arg1 = portIdx;

	ret = sendMessageToLanNetInfo(&qbuf.msg);
	if(ret != 0)
		return ret;

	ret = readMessageFromLanNetInfo(&qbuf);
	if(ret != -1)
	{
		if (qbuf.request == LANNETINFO_MSG_SUCC) {
			printf("[%s %d]: successfully.\n", __func__, __LINE__);
			return 0;
		}
	}
	printf("[%s %d]: failed!\n", __func__, __LINE__);
	return -4;
}

/****************************************************************************/
#endif

#ifdef CONFIG_USER_DBUS_PROXY
/****************************************************************************/
/**james : notify api for mib 2 dbusproxy**/
/**msg struct the same as smart defination**/

#ifndef SDK_2_DBUSPROXY_SOCK
    #define SDK_2_DBUSPROXY_SOCK   "/tmp/sdk2dbusproxy"
#endif

int dbus_proxy_uds_client_conn(const char *servername)
{
    int sock_client_fd = -1;
	fd_set fdset;
    struct timeval tv;
    int len, rval, so_error;

    struct sockaddr_un un;
	sock_client_fd = socket( AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0 ) ;
	if(sock_client_fd < 0)
	{
		fprintf(stderr,"mib client socket create error fail !\n");
		perror ("socket");
		return -1;
	}
	fcntl(sock_client_fd, F_SETFL, O_NONBLOCK);

	memset(&un, 0, sizeof(un));
	un.sun_family = AF_UNIX;

	strcpy(un.sun_path, servername);

	rval = connect(sock_client_fd, (struct sockaddr *)&un, sizeof(struct sockaddr_un));
	if(rval == 0) return sock_client_fd;
	else if(rval < 0 && errno == EINPROGRESS)
	{
		tv.tv_sec = 3;  
		tv.tv_usec = 0;
retry:
		FD_ZERO(&fdset);
		FD_SET(sock_client_fd, &fdset);
		
		rval = select(sock_client_fd + 1, NULL, &fdset, NULL, &tv);
		if(rval >= 1)
		{
			len = sizeof(so_error);
			getsockopt(sock_client_fd, SOL_SOCKET, SO_ERROR, &so_error, &len);
			if (so_error == 0) {
				return sock_client_fd;
			}
		}
		else if(rval < 0 && errno == EINTR)
		{
			if(tv.tv_sec > 0 || tv.tv_usec > 0) goto retry;
		}
	}
	close(sock_client_fd);
	
	printf("[MIB Client]: Error connect to unix_socket(%s).\n", __func__, __LINE__, servername);
	return -1;
}


int dbus_proxy_uds_send_client_msg(int sockfd,char *buf,int size)
{
    int sendbytes = 0;

	if((sendbytes = send(sockfd, buf, size, 0)) < 0)
	{
		fprintf(stderr,"[MIB Client]: Failed to send client,error:%s pid %d \n", strerror(errno), getpid());
		//close(sockfd);
		return -1;
	}

    return 0;

}

int mib_2_dbus_notify_dbus_api(mib2dbus_notify_app_t *notify_app)
{

	//Msg_proxy_t  msg;
	 int socket_fd = dbus_proxy_uds_client_conn(SDK_2_DBUSPROXY_SOCK);
	 int send_ret=0;
	 notify_app->iPid = getpid();
//fprintf(stderr,"\n [DEBUG] mib_2_dbus_notify_dbus_api  \n table_id:%d \niPid :%d \nsignal_id:%#x \nrecordNum :%d\n",
    //notify_app->table_id, notify_app->iPid, notify_app->Signal_id, notify_app->content[0]);
	 if(socket_fd < 0)
	 {
		//fprintf(stderr,"mib_2_dbus_notify_dbus_api::Failed to send client,socket id is error\n" );
		//close(socket_fd);
		return -1;
	 }else{
		 //fprintf(stderr,"mib_2_dbus_notify_dbus_api::to send client,socket id is sizeof(notify_app_t):%d\n",
                //sizeof(mib2dbus_notify_app_t) );
		send_ret = dbus_proxy_uds_send_client_msg(socket_fd,
                        (char *)notify_app,sizeof(mib2dbus_notify_app_t));

        close(socket_fd);
		if(send_ret<0)
		{
			//fprintf(stderr,"mib_2_dbus_notify_dbus_api::Failed to send client,socket id is error\n" );
			return -1;
		}

	}

    return 0;
}

void send_notify_msg_dbusproxy(int id, e_notify_mib_signal_id signal_id, int recordNum)
{
    int sDbusProxyPid = 0;
	
	if (access("/tmp/.runRestore", F_OK) == 0)
	{
		return;
	}
	
	sDbusProxyPid = read_pid(M_dbus_proxy_pid);

    /**do the pid Judgement first to protect table list initialization **/
    if ((sDbusProxyPid > 0) && (getpid() != sDbusProxyPid))
    {
        if (!mib_notify_table_list_handle_func(id, e_table_list_action_retrieve))
        {
            mib2dbus_notify_app_t notifyMsg;
            memset((char*)&notifyMsg, 0, sizeof(notifyMsg));
            notifyMsg.table_id = id;
            notifyMsg.Signal_id = signal_id;
            notifyMsg.content[0] = recordNum;
            if ( mib_2_dbus_notify_dbus_api(&notifyMsg) != 0)
            {
                printf("[MIB][ERR]mib notify to dbusproxy error \r\n tableid:  %d | signal_id %d | num %d \n",
                    id, signal_id, recordNum);
            }
            else
            {
                printf("[MIB][NTY]mib notify to dbusproxy OK \r\n tableid:  %d | signal_id %d | num %d \n",
                    id, signal_id, recordNum);
            }
        }
    }
	else if(sDbusProxyPid <= 0){
		printf("[MIB][ERR] Cannot get DBUS proxy pid\n");
	}
}


int  g_mib_notify_table_list[]=
{
    /*tableid,(mib table)   */

/**----------single object ------------ **/

/**com.ctc.igd1.DeviceInfo**/
    CWMP_USERINFO_RESULT,
    MIB_DEVICE_NAME,

/**com.ctc.igd1.NetworkInfo**/
    MIB_ADSL_LAN_IP,
    MIB_ATM_VC_TBL,

/**com.ctc.igd1.WiFiInfo**/
    MIB_MBSSIB_TBL,
    MIB_WLAN1_MBSSIB_TBL,
#if 0
#ifdef _PRMT_X_CT_COM_WLAN_
    MIB_WLAN_AUTO_CHAN_ENABLED,
#endif
    MIB_WLAN_CHAN_NUM,
    MIB_TX_POWER,
#endif
    MIB_WLAN_RATE_PRIOR,
    MIB_WLAN1_RATE_PRIOR,
    MIB_WIFI_MODULE_DISABLED,
	MIB_WLAN_DISABLED,
#if defined(WLAN_DUALBAND_CONCURRENT)
	MIB_WLAN1_DISABLED,
#endif
#if defined(WLAN_DUALBAND_CONCURRENT) && defined(CONFIG_RTL_STA_CONTROL_SUPPORT)
    MIB_WIFI_STA_CONTROL,
#endif

/**com.ctc.igd1.LANHostManager**/
    MIB_LANHOST_BANDWIDTH_MONITOR_ENABLE,
    #ifdef CONFIG_USER_LANNETINFO
    MIB_MAX_LAN_HOST_NUM,
    MIB_MAX_CONTROL_LIST_NUM,
/**com.ctc.igd1.LANHost**/
    MIB_LAN_DEV_NAME_TBL,
    MIB_LAN_HOST_ACCESS_RIGHT_TBL,
    #endif
#ifdef CONFIG_USER_LAN_BANDWIDTH_CONTROL
    MIB_LAN_HOST_BANDWIDTH_TBL,
#endif
#if 0
/**com.ctc.igd1.Redirect404**/
    MIB_404_REDIRECT_URL,
#endif
/**com.ctc.igd1.WLANConfiguration**/
   // MIB_WLAN_DISABLED,
   MIB_WLAN_AUTO_CHAN_ENABLED,
   MIB_WLAN_CHAN_NUM,
   MIB_WLAN1_AUTO_CHAN_ENABLED,
   MIB_WLAN1_CHAN_NUM,
   MIB_TX_POWER,
   MIB_WLAN_TX_POWER_HIGH,
   MIB_WLAN1_TX_POWER,
   MIB_WLAN1_TX_POWER_HIGH,
/**com.ctc.igd1.Wifitimer**/
#ifdef WIFI_TIMER_SCHEDULE
    MIB_WIFI_TIMER_TBL,
#endif
/**com.ctc.igd1.Wifitimer**/
    MIB_WIFI_TIMER_EX_TBL,

/**com.ctc.igd1.LED**/
#ifdef CONFIG_LED_INDICATOR_TIMER
    MIB_LED_INDICATOR_TIMER_TBL,
#endif
    MIB_LED_STATUS,

/**com.ctc.igd1.DHCPServer**/
#ifdef CONFIG_USER_DHCP_SERVER
    MIB_DHCP_MODE,
#endif
    MIB_DHCP_POOL_START,
    MIB_DHCP_POOL_END,
    MIB_ADSL_LAN_DHCP_LEASE,
    MIB_ADSL_LAN_SUBNET,
#if 0
/**com.ctc.igd1.UplinkQoS**/
    CTQOS_MODE,
    MIB_QOS_ENABLE_QOS,
    MIB_TOTAL_BANDWIDTH_LIMIT_EN,
    MIB_TOTAL_BANDWIDTH,
    MIB_QOS_POLICY,
    MIB_QOS_ENABLE_FORCE_WEIGHT,
    MIB_QOS_ENABLE_DSCP_MARK,
    MIB_QOS_ENABLE_1P,

/**com.ctc.igd1.UplinkQoSAPP**/
    MIB_IP_QOS_APP_TBL,

 /**com.ctc.igd1.UplinkQoSCls**/
    MIB_IP_QOS_TBL,

/**com.ctc.igd1.UplinkQoSCls**/
	MIB_IP_QOS_QUEUE_TBL,
#endif
/**com.ctc.igd1.HTTPServer**/
  //  MIB_HTTP_ENABLE,
    MIB_SUSER_PASSWORD,

/**com.ctc.igd1.SambaServer**/
    MIB_SMB_SERVER_ENABLE,
    MIB_SMB_ANNONYMOUS,

/**com.ctc.igd1.FTPServer**/
#ifdef FTP_SERVER_INTERGRATION
    MIB_FTP_ENABLE,
    MIB_FTP_ANNONYMOUS,
#else
    MIB_VSFTP_ENABLE,
    MIB_VSFTP_ANNONYMOUS,
#endif
    MIB_SMBD_ACCOUNT_TBL,
#if 0
/**com.ctc.igd1.DNSServerConfig**/
    MIB_DNS_SERVER1,
    MIB_DNS_SERVER2,
#endif
/**----------object with multi instnum------------ **/
    MIB_SLEEP_MODE_SCHED_TBL,
#if 0
/**----------com.ctc.igd1.L2TPConnection------------ **/
    MIB_L2TP_TBL,
    MIB_L2TP_ROUTE_TBL,
#endif
/**----------com.ctc.igd1.DDNSServerConfig------------ **/
    MIB_DDNS_TBL,
	MIB_VIRTUAL_SVR_TBL,
/**----------loglevel control------------ **/
	MIB_DBUS_PROXY_DEBUG,
	MIB_RESTORE_STATUS_TBL,
/**----------PlatformService------------ **/
    MIB_CWMP_MGT_APPMODEL,
    MIB_CWMP_MGT_URL,
    MIB_CWMP_MGT_PORT,
    MIB_CWMP_MGT_ABILITY,
    MIB_CWMP_MGT_LOCATEPORT,
    MIB_PLATFORM_BSSADDR_TBL,
#ifdef CTC_DNS_SPEED_LIMIT
/**----------com.ctc.igd1.DNSSpeedLimit------------ **/
    DNS_LIMIT_DEV_INFO_TBL,
#endif
/**----------com.ctc.igd1.URLFilter------------ **/
#ifdef SUPPORT_URL_FILTER
    MIB_URL_FILTER_TBL,
#endif    
/**----------com.ctc.igd1.DNSFilter------------ **/
#ifdef SUPPORT_DNS_FILTER
    MIB_DNS_FILTER_TBL,
#endif 
/**----------com.ctc.igd1.OMDiag------------ **/
#ifdef CONFIG_USER_RTK_OMD
    MIB_OMDIAG_FLASHTHRESHOLD,
    MIB_OMDIAG_PONTEMPTHRESHOLD,
    MIB_OMDIAG_CPUTEMPTHRESHOLD,
    MIB_OMDIAG_NFCONNTRACKNUM,
#endif 
	MIB_V6_RADVD_ENABLE,
	MIB_V6_MAXRTRADVINTERVAL,
	MIB_V6_MINRTRADVINTERVAL,
	MIB_V6_MANAGEDFLAG,
	MIB_V6_OTHERCONFIGFLAG,	
	MIB_DHCPV6_MODE,
	MIB_DHCPV6S_MIN_ADDRESS,
	MIB_DHCPV6S_MAX_ADDRESS,
	MIB_DHCPV6S_PREFERRED_LIFETIME,
	MIB_DHCPV6S_DEFAULT_LEASE,
	CWMP_CT_DHCP6S_CHECK_OPT_16,
	CWMP_CT_DHCP6S_SEND_OPT_17,
/**----------the end of list------------ **/
    0,
};


int mib_notify_table_list_handle_func(int table_id, e_table_list_action_T action)
{
//     static int mib_notify_table_list[128];
     int iMiblistNum = sizeof(g_mib_notify_table_list) / sizeof(int);
     int iloop = 0;

#if 0
     if (action == e_table_list_action_init)
     {
         {
             mib_notify_table_list[iMiblistNum] = table_id;
             iMiblistNum++;
         }

         if (iMiblistNum == 128)
         {
            printf("mib notify table list init error, overload num %d | table_id %d\r\n",
                iMiblistNum, table_id);

            smutex = 0;
            return -1;
         }

         if (table_id == 0)
         {
             /**if the id is 0 while initialization, it is the last one**/
             printf("invalid table id 0, total : %d \r\n", iMiblistNum);
             smutex = 0;
             return 0;
         }

         /**insert only one table id to the list per operation**/
         smutex = 0;
         return 0;
     }
     else
#endif
     if (action == e_table_list_action_retrieve)
     {
         for (iloop = 0; iloop < iMiblistNum; iloop ++)
         {
             if (table_id == g_mib_notify_table_list[iloop])
             {
                 /**bingo**/
                 return 0;
             }

             if (g_mib_notify_table_list[iloop] == 0)
             {
                 /**error record**/
                 break;
                 //printf("[MIB][NTY] WARNING, invalid table_id to dbus notification : %d \r\n", table_id);
             }
         }

         /**not found**/
         return -1;
     }
     else
     {
          printf("[MIB][NTY] WARNING, error action : %d \r\n", action);
          return -1;
     }

}
#endif
/*
 * FUNCTION:SET_NETWORK_DNS
 *
 * INPUT:
 *	dns1:
 *		Fisrt DNS server to set.
 *	dns2:
 *		Second DNS server to set.
 *
 * RETURN:
 *	0 -- successful
 *	-1 -- Input error
 *  -2 -- INETERNET WAN not found
 *  -3 -- other
 */
int set_network_dns(char *dns1, char *dns2)
{
	MIB_CE_ATM_VC_T entry;
	int total, i;
	struct sockaddr_in sa;	// used to check IP

	if(dns1 == NULL)
		return -1;

	/* Check dns1 is a valid IP */
	if(inet_pton(AF_INET, dns1, &(sa.sin_addr)) != 1)
		return -1;

	/* Find INTERNET WAN */
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
			continue;

		if(entry.enable && entry.applicationtype & X_CT_SRV_INTERNET && entry.cmode != CHANNEL_MODE_BRIDGE)
			break;
	}

	/* INTERNET WAN not found */
	if(i == total)
		return -2;

	/* Write config */
	entry.dnsMode = 2;
	strncpy(entry.v4dns1, dns1, sizeof(entry.v4dns1));
	memcpy(entry.v4dns1, &(sa.sin_addr), sizeof(entry.v4dns1));

	if(dns2 != NULL && inet_pton(AF_INET, dns2, &(sa.sin_addr)) == 1)
		memcpy(entry.v4dns2, &(sa.sin_addr), sizeof(entry.v4dns2));
	else
		memset(entry.v4dns2, 0, sizeof(entry.v4dns2));

	mib_chain_update(MIB_ATM_VC_TBL, &entry, i);

	// update dnsmasq config
	cmd_set_dns_config(NULL);
	restart_dnsrelay();
	return 0;
}


/*
 * FUNCTION:GET_NETWORK_DNS
 *
 * INPUT:
 *	dns1:
 *		Fisrt DNS server to set.
 *	dns2:
 *		Second DNS server to set.
 *
 * RETURN:
 * 	the number of DNS server got.
 *	-1 -- Input error
 *  -2 -- INETERNET WAN not found
 *  -3 -- resolv file not found
 *  -4 -- other
 */
int get_network_dns(char *dns1, char *dns2)
{
	MIB_CE_ATM_VC_T entry;
	int total, i;
	struct sockaddr_in sa;	// used to check IP
	int got = 0;
	char buf[256] = {0};
	char ifname[IFNAMSIZ] = {0};

	if(dns1 == NULL || dns2 == NULL)
		return -1;

	/* Find INTERNET WAN */
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
			continue;

		if(entry.enable && entry.applicationtype & X_CT_SRV_INTERNET && entry.cmode != CHANNEL_MODE_BRIDGE)
		{
			ifGetName(entry.ifIndex, ifname, sizeof(ifname));
			break;
		}
	}

	/* INTERNET WAN not found */
	if(i == total)
		return -2;

	/* Get config */
	switch(entry.dnsMode)
	{
	case REQUEST_DNS_NONE: //manual
	case DNS_SET_BY_API: // set by API
		{
			if(inet_ntop(AF_INET, &entry.v4dns1, buf, sizeof(buf)) != NULL)
			{
				strcpy(dns1, buf);
				got++;
			}

			if(inet_ntop(AF_INET, &entry.v4dns2, buf, sizeof(buf)) != NULL)
			{
				strcpy(dns2, buf);
				got++;
			}
		}
		break;
	case REQUEST_DNS: //auto
		{
			FILE *fresolv = NULL;
			char *p;

			if ((DHCP_T)entry.ipDhcp == DHCP_CLIENT)
				snprintf(buf, 64, "%s.%s", (char *)DNS_RESOLV, ifname);
			if (entry.cmode == CHANNEL_MODE_PPPOE || entry.cmode == CHANNEL_MODE_PPPOA)
				snprintf(buf, 64, "%s.%s", (char *)PPP_RESOLV, ifname);

			fresolv = fopen(buf, "r");
			if(fresolv == NULL)
				return -3;

			while(!feof(fresolv))
			{
				memset(buf,0,sizeof(buf));
				fgets(buf,sizeof(buf), fresolv);

				if((strlen(buf)==0))
					break;

				// Get DNS servers
				p = strchr(buf, '@');
				if (p)
				{
					if(got == 0)
					{
						memcpy(dns1, buf, p-buf);
						dns1[p-buf] = '\0';
						got++;
					}
					else if(got == 1)
					{
						memcpy(dns2, buf, p-buf);
						dns2[p-buf] = '\0';
						got++;
					}
				}

				if(got == 2)
					break;
			}
			fclose(fresolv);
		}
		break;
	default:
		return -4;
	}

	return got;
}

/* For yueme: set dns ip of lan pc which get dhcp ip from modem */
int setDnsIPForLanPC(unsigned char enable, struct in_addr ip)
{
	mib_set(MIB_DHCP_DNS_OPTION, (void *)&enable);
	mib_set(MIB_DHCPS_DNS1, (void *)&ip);
	restart_dhcp();
}

#ifdef CONFIG_RTK_HOST_SPEEDUP
#define HOST_SPEEDUP "/proc/HostSpeedUP-Info"

#if defined(CONFIG_SMP) && (CONFIG_NR_CPUS > 1)
int get_gmac_intrrupt_mapping_processor(void)
{
	FILE*fp;
	char buff[128];
	char insrName[32], fileName[32];
	unsigned int irqNo = 0, cpuset=0;
	int i;

	fp = fopen("/proc/interrupts", "r");
	if (NULL == fp)
	{
		fprintf(stderr, "open /proc/interrupts failed!");
		return (-1);
	}

	/*
	 * # cat interrupts 
		           CPU0       CPU1       
		 16:     107009          0  MIPS GIC  EXT_TIMER
		 17:          0     106803  MIPS GIC  EXT_TIMER
		 31:          2          0  MIPS GIC  apl_sw
	 */
	fgets(buff, sizeof(buff), fp);
	while (fgets(buff, sizeof(buff), fp) != NULL)
	{
		if (strstr(buff, "eth0"))
		{
			irqNo = strtoul(buff, NULL, 10);
			break;
		}
	}
	fclose(fp);

	if (0 == irqNo)
	{
		printf("can not find eth0 interrupt\n");
		return (-1);
	}

	snprintf(fileName, 32, "/proc/irq/%d/smp_affinity", irqNo);
	fp = fopen(fileName, "r");
	if (NULL == fp)
	{
		fprintf(stderr, "open %s failed!", fileName);
		return (-1);
	}
	fgets(buff, sizeof(buff), fp);
	fclose(fp);
	cpuset = strtoul(buff, NULL, 10);
	for (i=0; i<32; i++)
		if (cpuset & (1<<i))
			return i;
	return (-1);
}
#endif

/*
 * FUNCTION:ADD_HOST_SPEEDUP
 *
 * Set the IP and Port of local in/out network traffics, which you don't want to pass through netfilter.
 *
 * INPUT:
 *	RIP:
 *		remote ip.
 *	Rport:
 *		remote port.
 *	LIP:
 *		local ip.
 *	Lport:
 *		local port.
 *
 *	RETURN:
 *	0: Sucess
 *	-1: Failure
 */

int add_host_speedup(struct in_addr rip, unsigned short rport, struct in_addr lip, unsigned short lport)
{

	int ret=0;
	FILE *fp=NULL;
	char str_rip[64] = {0};
	char str_lip[64] = {0};
#if defined(CONFIG_SMP) && (CONFIG_NR_CPUS > 1)
	cpu_set_t set;
	int hostSpeedupCPU = -1;
	
	hostSpeedupCPU = get_gmac_intrrupt_mapping_processor();
	if (hostSpeedupCPU != -1)
	{
		CPU_ZERO_S(sizeof(set), &set);
		CPU_SET_S(hostSpeedupCPU, sizeof(set), &set);
		
		if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
		{
			perror("sched_setaffinity fail!");
			return 1;
		}
	}
#endif
	if(rip.s_addr==0 || lip.s_addr==0){
		printf("srcip or dstip equal to 0 is not accept!\n");
		ret = -1;
		return ret;
	}
	inet_ntop(AF_INET, (const void *) &rip, str_rip, 64);
	inet_ntop(AF_INET, (const void *) &lip, str_lip, 64);
//printf("%s-%d sip=%s, sport=%d, dip=%s, dport=%d\n",__func__,__LINE__, str_srcip,sport,str_dstip,dport);
	fp = fopen(HOST_SPEEDUP, "w");
	if(fp)
	{
		fprintf(fp, "add rip %s rport %d lip %s lport %d\n",str_rip,rport,str_lip,lport);
		fclose(fp);
		ret = 0;
	}else{
		fprintf(stderr, "open %s fail!\n",HOST_SPEEDUP);
		ret = -1;
	}

    va_cmd("/bin/sh", 2, 1, "-c", "echo 1 > /proc/HostSpeedUP");

	return ret;
}

/*
 * FUNCTION:DEL_HOST_SPEEDUP
 *
 * Delete the track of IP and Port for local in/out network traffics, which you don't want to pass through netfilter.
 *
 * INPUT:
 *	RIP:
 *		remote ip.
 *	Rport:
 *		remote port.
 *	LIP:
 *		local ip.
 *	Lport:
 *		local port.
 *
 *	RETURN:
 *	0: Sucess
 *	-1: Failure
 */

int del_host_speedup(struct in_addr rip, unsigned short rport, struct in_addr lip, unsigned short lport)
{

	int ret=0;
	FILE *fp=NULL;
	char str_rip[64] = {0};
	char str_lip[64] = {0};
#if defined(CONFIG_SMP) && (CONFIG_NR_CPUS > 1)
	cpu_set_t set;
	int hostSpeedupCPU = -1;
	
	hostSpeedupCPU = get_gmac_intrrupt_mapping_processor();
	if (hostSpeedupCPU != -1)
	{
		CPU_ZERO_S(sizeof(set), &set);
		CPU_SET_S(hostSpeedupCPU, sizeof(set), &set);
		
		if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
		{
			perror("sched_setaffinity fail!");
			return 1;
		}
	}
#endif
	inet_ntop(AF_INET, (const void *) &rip, str_rip, 64);
	inet_ntop(AF_INET, (const void *) &lip, str_lip, 64);
//printf("%s-%d sip=%s, sport=%d, dip=%s, dport=%d\n",__func__,__LINE__, str_srcip,sport,str_srcip,dport);
	fp = fopen(HOST_SPEEDUP, "w");
	if(fp)
	{
		fprintf(fp, "del info\n");
		fclose(fp);
		ret = 0;
	}else{
		fprintf(stderr, "open %s fail!\n",HOST_SPEEDUP);
		ret = -1;
	}
    va_cmd("/bin/sh", 2, 1, "-c", "echo 0 > /proc/HostSpeedUP");

	return ret;
}


#endif /*CONFIG_RTK_HOST_SPEEDUP*/

#ifdef CONFIG_USB_SUPPORT
int getUsbDeviceLabel(const char *device, char *label, char *type)
{
        FILE *fp;
        char command[100], buff[256], tmpBuf[256], *pStr;
        int i;

        snprintf(command, 100, "/bin/blkid %s > /tmp/blkid_file", device);
        system(command);


        if ((fp = fopen("/tmp/blkid_file", "r")) == NULL) {
                printf("open /tmp/blkid_file failed.\n");
                return 0;
        }
        else {
                if ( fgets(buff, sizeof(buff), fp) != NULL )
                {
                        memcpy(tmpBuf, buff, 256);
                        if ((pStr = strstr(tmpBuf, "LABEL=")) != NULL) {
                                pStr += strlen("LABEL=");

                                /* LABEL="LISI" */
                                pStr++;
                                i = 0;
                                while (pStr[i] != '"')
                                        i++;
                                pStr[i] = '\0';

                                strcpy(label, pStr);
                        }
                        else
                                strcpy(label, "Unknown");

                        memcpy(tmpBuf, buff, 256);
                        if ((pStr = strstr(tmpBuf, "TYPE=")) != NULL) {
                                pStr += strlen("TYPE=");

                                pStr++;
                                i=0;
                                while (pStr[i] != '"')
                                        i++;
                                pStr[i] = '\0';
                                strcpy(type, pStr);
                        }
                        else
                                strcpy(type, "Unknown");
                }

                fclose(fp);
                unlink("/tmp/blkid_file");
        }
        return 1;
}
#if 0
static int usb_filter(const struct dirent *dirent)
{
        char *name = dirent->d_name;
        struct stat statbuff;
        char path[32];

        if((strlen(name) == 4) && (name[0] == 's') && (name[1] == 'd')
           && (name[2] >= 'a') && (name[2] <= 'z')
           && (name[3] >= '0') && (name[3] <= '9'))
                return 1;
        else if((strlen(name) == 3) &&(name[0] == 's') && (name[1] == 'r')
                && (name[2] >= '0') && (name[2] <= '9'))
                return 1;
        else if ((strlen(name) == 3) &&(name[0] == 's') && (name[1] == 'd')
                && (name[2] >= 'a') && (name[2] <= 'z')) {
                sprintf(path, "/mnt/%s", name);
                if (stat(path, (struct stat *)&statbuff) == -1)
                        return 0;
                else if (0 == statbuff.st_blocks)
                        return 0;
                return 1;
        }

        return 0;
}
#endif
int umountUSBDevie(void)
{
        int errcode = 1;
        struct dirent **namelist;
        char device[100];
        int i, n;

        n = scandir("/mnt", &namelist, usb_filter, alphasort);

        if (n <= 0)
                return 1;

        for (i = 0; i < n; i++)
        {
                if (namelist[i]->d_name[0] == 's')
                {
                        snprintf(device, 100, "/dev/%s", namelist[i]->d_name);
                        va_cmd("/bin/umount", 1, 1, (char *)device);
                }

                free(namelist[i]);
        }
        free(namelist);

        return 1;
}


void getUSBDeviceInfo(int *disk_sum, struct usb_info * disk1,struct usb_info * disk2)
{
        struct dirent **namelist;
        char tmpLabel[100], tmpFSType[10];
        char device[2][20], type[2][100], mounton[2][512];
        int  usb_storage_num[2];
        char usb_storage_dev[2][10];
        char usb_storage_serial[2][100];
        char invert=0;
        char tmpstr1[100], tmpstr2[100];
        char usb1_serial[100], usb2_serial[100];
        char usb1_dev[10], usb2_dev[10];
        char cmd[100];
        char line[512] = {0};
        FILE *pf = NULL;
        int i, n, diskSum=0;
        unsigned long used[2],avail[2];

        n = scandir("/mnt", &namelist, usb_filter, alphasort);
        memset(type, 0, sizeof(type));
        memset(mounton,0,sizeof(mounton));
        memset(used,0,sizeof(used));
        memset(avail,0,sizeof(avail));

        /* no match */
        if (n > 0)
        {
                for (i=0; i<n; i++) {
                        if ((namelist[i]->d_name[0] == 's') && (diskSum < 2)) {
                                if (strlen(namelist[i]->d_name) == 3)
                                        namelist[i]->d_name[3] = '\0';
                                else
                                        namelist[i]->d_name[4] = '\0';
                                snprintf(device[diskSum], 20, "/dev/%s", namelist[i]->d_name);
                                memset(tmpLabel, 0, sizeof(tmpLabel));
                                memset(tmpFSType, 0, sizeof(tmpFSType));
                                getUsbDeviceLabel(device[diskSum], tmpLabel, tmpFSType);
                                snprintf(type[diskSum], 100, "%s", tmpFSType);
                                snprintf(cmd,sizeof(cmd),"df %s > /tmp/usbinfo",device[diskSum]);
                                system(cmd);
                                pf=fopen("/tmp/usbinfo","r");
                                if(pf)
                                {
                                        fgets(line,sizeof(line),pf);
                                        if(fgets(line,sizeof(line),pf))
                                        {
                                                sscanf(line,"%*s %*d %d %d %*s %s\n",&used[diskSum],&avail[diskSum],mounton[diskSum]);
                                        }
                                        fclose(pf);
                                        unlink("/tmp/usbinfo");
                                }
                                diskSum++;
                        }
                        free(namelist[i]);
                }

                free(namelist);
        }
        *disk_sum = diskSum;

        usb_storage_num[0] = usb_storage_num[1] = -1;
        memset(usb_storage_dev, 0, sizeof(usb_storage_dev));
        memset(usb_storage_serial, 0, sizeof(usb_storage_serial));

        snprintf(cmd, 100, "ls /proc/scsi/usb-storage/  > /tmp/storage.tmp 2>&1");
        system(cmd);

        pf = fopen("/tmp/storage.tmp", "r");
        if(pf) {
                i = 0;
                while(fgets(line, sizeof(line), pf)!=NULL) {
                        //printf("%s:%s", __func__, line);
                        sscanf(line, "%d", &usb_storage_num[i]);

                        i++;
                        if (i >= 2)
                                break;
                }
                //printf("usb_storage_num %d %d\n", usb_storage_num[0], usb_storage_num[1]);
                fclose(pf);
        }

        for (i=0; i<2; i++)
        {
                if (usb_storage_num[i] != -1) {
                        snprintf(cmd, 100, "ls /sys/class/scsi_device/%d:0:0:0/device/block/ > /tmp/storage.tmp 2>&1",
                                        usb_storage_num[i]);
                        system(cmd);

                        pf = fopen("/tmp/storage.tmp", "r");
                        if(pf) {
                                fgets(line, sizeof(line), pf);
                                //printf("%s\n", line);
                                sscanf(line, "%s", usb_storage_dev[i]);
                                fclose(pf);
                        }

                        snprintf(cmd, 100, "cat /proc/scsi/usb-storage/%d > /tmp/storage.tmp 2>&1", usb_storage_num[i]);
                        system(cmd);

                        pf = fopen("/tmp/storage.tmp", "r");
                        if(pf) {
                                while(fgets(line, sizeof(line), pf)!=NULL) {
                                        //printf("%s\n", line);
                                        sscanf(line, "%s %*s %s", tmpstr1, tmpstr2);
                                        if (strstr(tmpstr1, "Serial")) {
                                                strcpy(usb_storage_serial[i], tmpstr2);
                                                //printf("%s:storage_serial[%d]:%s\n", __func__, i, usb_storage_serial[i]);
                                                break;
                                        }
                                }
                                fclose(pf);
                        }
                }
        }

        memset(usb1_serial, 0, sizeof(usb1_serial));
        memset(usb2_serial, 0, sizeof(usb2_serial));
        memset(usb1_dev, 0, sizeof(usb1_dev));
        memset(usb2_dev, 0, sizeof(usb2_dev));

        pf = fopen("/sys/bus/usb/devices/2-1/serial", "r");
        if (!pf)
                pf = fopen("/sys/bus/usb/devices/2-2/serial", "r");
        if (pf) {
                fgets(line, sizeof(line), pf);
                sscanf(line, "%s", usb1_serial);
                //printf("%s:usb2_serial:%s", __func__, usb1_serial);
                fclose(pf);
        }

        pf = fopen("/sys/bus/usb/devices/1-2/serial", "r");
        if (!pf)
                pf = fopen("/sys/bus/usb/devices/1-1/serial", "r");
        if (pf) {
                fgets(line, sizeof(line), pf);
                sscanf(line, "%s", usb2_serial);
                //printf("%s:usb1_serial:%s\n", __func__, usb2_serial);
                fclose(pf);
        }

        unlink("/tmp/storage.tmp");

        if (usb1_serial[0]) {//usb1 running(USB2.0)
                for (i=0; i<2; i++) {
                        if (usb_storage_serial[i][0] && !strcmp(usb_storage_serial[i], usb1_serial)) {
                                strcpy(usb1_dev, usb_storage_dev[i]);
                                break;
                        }
                }
                //debug
                if (i >= 2)
                        printf("unknown usb1 dev name\n");
                else {
                        if (strstr(device[0], usb1_dev))
                                invert = 0;
                        else if (strstr(device[1], usb1_dev))
                                invert = 1;
                }
        }

        if (usb2_serial[0]) {//usb2 running(USB3.0)
                for (i=0; i<2; i++) {
                        if (usb_storage_serial[i][0] && !strcmp(usb_storage_serial[i], usb2_serial)) {
                                strcpy(usb2_dev, usb_storage_dev[i]);
                                break;
                        }
                }
                //debug
                if (i >= 2)
                        printf("unknown usb2 dev name\n");
                else {
                        if (strstr(device[0], usb2_dev))
                                invert = 1;
                        else if (strstr(device[1], usb2_dev))
                                invert = 0;
                }
        }

        if(usb1_dev[0])
        {
                strcpy(disk1->disk_type, usb1_dev);
                strcpy(disk1->disk_status, "Mounted");
                if(invert)
                {
                        sprintf(disk1->disk_fs, "%s", type[1]);
                        disk1->disk_used=used[1];
                        disk1->disk_available=avail[1];
                        strcpy(disk1->disk_mounton, mounton[1]);
                }
                else
                {
                        sprintf(disk1->disk_fs, "%s", type[0]);
                        disk1->disk_used=used[0];
                        disk1->disk_available=avail[0];
                        strcpy(disk1->disk_mounton,  mounton[0]);
                }
        }
        else
        {
                strcpy(disk1->disk_type, "No Device");
                strcpy(disk1->disk_status, "Disconnect");
                strcpy(disk1->disk_fs,"");
                strcpy(disk1->disk_mounton,"");
                disk1->disk_used=0;
                disk1->disk_available=0;
        }

        if(usb2_dev[0])
        {
                strcpy(disk2->disk_type, usb2_dev);
                strcpy(disk2->disk_status, "Mounted");
                if(invert)
                {
                        sprintf(disk2->disk_fs, "%s", type[0]);
                        disk2->disk_used=used[0];
                        disk2->disk_available=avail[0];
                        strcpy(disk2->disk_mounton, mounton[0]);
                }
                else
                {
                        sprintf(disk2->disk_fs, "%s", type[1]);
                        disk2->disk_used=used[1];
                        disk2->disk_available=avail[1];
                        strcpy(disk2->disk_mounton, mounton[1]);
                }
        }
        else
        {
                strcpy(disk2->disk_type, "No Device");
                strcpy(disk2->disk_status, "Disconnect");
                strcpy(disk2->disk_fs,"");
                strcpy(disk2->disk_mounton,"");
                disk2->disk_used=0;
                disk2->disk_available=0;
        }

}
#endif//end of CONFIG_USB_SUPPORT


#ifdef CTC_DNS_TUNNEL
static int find_dns_tunnel(MIB_CE_DNS_TUNNEL_T *target)
{
	int idx = -1;
	int total, i;
	MIB_CE_DNS_TUNNEL_T entry;

	if(target == NULL)
		return -1;

	total = mib_chain_total(MIB_DNS_TUNNEL_TBL);

	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_DNS_TUNNEL_TBL, i, &entry) == 0)
			continue;

		if(memcmp(target->server_ip, entry.server_ip, sizeof(entry.server_ip)) == 0
			&& strcmp(target->domain, entry.domain) == 0)
		{
			idx = i;
			break;
		}
	}

	return idx;
}

/*
 * FUNCTION:ATTACH_WAN_DNSTUNNEL
 *
 * INPUT:
 *	tunnel:
 *		Pointer of DNS tunnel to attach. Only accept one node at a time.
 *
 * RETURN:
 *	0 -- successful
 *	-1 -- Input error
 *  -2 -- out of memory
 *  -3 -- other
 */
int attach_wan_dns_tunnel(dns_tunnel_node_t *node)
{
	MIB_CE_DNS_TUNNEL_T entry;
	struct sockaddr_in sa;	// used to check IP
	char *domain = NULL, *save_ptr = NULL, *buf;

	if(node == NULL || node->server_ip == NULL || node->domain == NULL)
		return -1;

	/* Check server_ip is a valid IP */
	if(inet_pton(AF_INET, node->server_ip, &(sa.sin_addr)) != 1)
		return -1;

	memcpy(entry.server_ip, &(sa.sin_addr), sizeof(entry.server_ip));

	buf = strdup(node->domain);
	if(buf == NULL)
		return -2;

	domain = strtok_r(buf, "; ", &save_ptr);
	while(domain != NULL)
	{
		memset(entry.domain, 0, sizeof(entry.domain));
		strcpy(entry.domain, domain);
		if(find_dns_tunnel(&entry) < 0)
		{
			mib_chain_add(MIB_DNS_TUNNEL_TBL, &entry);
			//fprintf(stderr, "<%s:%d> added domain %s\n", __func__, __LINE__, domain);
		}
		domain = strtok_r(NULL, "; ", &save_ptr);
	}


	Commit();
	// update dnsmasq config
	cmd_set_dns_config(NULL);
	restart_dnsrelay();

	free(buf);
	return 0;
}

static void clear_dns_tunnel_by_domain(char *domain)
{
	int total, i;
	MIB_CE_DNS_TUNNEL_T entry;

	if(domain == NULL)
		return;

	total = mib_chain_total(MIB_DNS_TUNNEL_TBL);

	for(i = total-1 ; i >= 0; i--)
	{
		if(mib_chain_get(MIB_DNS_TUNNEL_TBL, i, &entry) == 0)
			continue;

		if(strcmp(domain, entry.domain) == 0)
			mib_chain_delete(MIB_DNS_TUNNEL_TBL, i);
	}
}

/*
 * FUNCTION: DETACH_WAN_DNSTUNNEL
 *
 * INPUT:
 *	tunnel:
 *		Pointer of DNS tunnel to dettach, only support one node at a time.
 *
 * RETURN:
 *	0 -- successful
 *	-1 -- Input error
 *  -2 -- out of memory
 *  -3 -- other
 */
int detach_wan_dns_tunnel(dns_tunnel_node_t *node)
{
	MIB_CE_DNS_TUNNEL_T entry;
	struct sockaddr_in sa;	// used to check IP
	char *domain = NULL, *save_ptr = NULL, *buf = NULL;

	if(node == NULL || node->server_ip == NULL)
		return -1;

	if(strcmp(node->server_ip, "all") == 0)
	{
		mib_chain_clear(MIB_DNS_TUNNEL_TBL);
	}
	else if(strcmp(node->server_ip, "other") == 0)
	{
		if(node->domain == NULL)
			return -1;

		buf = strdup(node->domain);
		if(buf == NULL)
			return -2;

		domain = strtok_r(buf, "; ", &save_ptr);
		while(domain != NULL)
		{
			clear_dns_tunnel_by_domain(domain);

			// get next domain
			domain = strtok_r(NULL, "; ", &save_ptr);
		}

		free(buf);
	}
	else
	{
		int idx = -1;

		/* Check server_ip is a valid IP */
		if(inet_pton(AF_INET, node->server_ip, &(sa.sin_addr)) != 1)
			return -1;

		if(node->domain == NULL)
			return -1;

		buf = strdup(node->domain);
		if(buf == NULL)
			return -2;

		memcpy(entry.server_ip, &(sa.sin_addr), sizeof(entry.server_ip));

		domain = strtok_r(buf, "; ", &save_ptr);
		while(domain != NULL)
		{
			memset(entry.domain, 0, sizeof(entry.domain));
			strcpy(entry.domain, domain);

			idx = find_dns_tunnel(&entry);
			if(idx >= 0)
				mib_chain_delete(MIB_DNS_TUNNEL_TBL, idx);

			// get next domain
			domain = strtok_r(NULL, "; ", &save_ptr);
		}

		free(buf);
	}

	Commit();

	if (access("/tmp/running_dbus_cts", F_OK) == 0)
	{
		printf("%s skip update dnsmasq\n", __FUNCTION__);
	}
	else
	{
		// update dnsmasq config
		cmd_set_dns_config(NULL);
		restart_dnsrelay();
	}
	return 0;
}

void free_dns_tunnels(dns_tunnel_node_t *tunnels)
{
	if(tunnels)
	{
		dns_tunnel_node_t *node = tunnels, *tmp = NULL;
		while(node != NULL)
		{
			tmp = node;
			node = node->next;
			if(tmp->server_ip) free(tmp->server_ip);
			if(tmp->domain) free(tmp->domain);
			free(tmp);
		}
	}
}

static char* str_realloc_and_concat(char **str, const char *format, ...)
{
	va_list ap;
	int i, n;
	char *s;

	n = strlen(*str);
	va_start(ap, format);
	i = vasprintf(&s, format, ap);
	*str = (char *)(realloc(*str, n + i + 1));
	if (*str == NULL)
		return NULL;

	strncpy(&(*str)[n], s, i);
	va_end(ap);
}


/*
 * FUNCTION: GET_WAN_DNSTUNNEL
 *
 * OUTPUT:
 *	num:
 *		Number of DNS tunnel instance
 *	tunnels:
 *		Array of dns_tunnel_node_t
 *
 * RETURN:
 *	number of dns_tunnel_node_t nodes.
 *	-1 -- out of memory
 *	-2 -- other
 *
 * NOTES:
 * Don't forget to call free_dns_tunnels().
 */
int get_wan_dns_tunnel(dns_tunnel_node_t **tunnels)
{
	MIB_CE_DNS_TUNNEL_T entry;
	int total, i, j;
	char *domain = NULL, ip_addr[40] = "";
	dns_tunnel_node_t *node = NULL, *tail = NULL;
	int num = 0;

	*tunnels = NULL;

	total = mib_chain_total(MIB_DNS_TUNNEL_TBL);
	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_DNS_TUNNEL_TBL, i, &entry) == 0)
			continue;

		if(inet_ntop(AF_INET, (void *)entry.server_ip, ip_addr, sizeof(ip_addr)) == NULL)
		{
			fprintf(stderr, "WARNNING: server_ip of index %d is invalid\n", i);
			continue;
		}

		// find existed node
		node = *tunnels;
		while(node != NULL)
		{
			if(strcmp(node->server_ip, ip_addr) == 0)
				break;

			node = node->next;
		}

		if(node == NULL)
		{
			// create & add new node
			node = malloc(sizeof(dns_tunnel_node_t));
			if(node == NULL)
				goto out_of_mem;

			memset(node, 0, sizeof(dns_tunnel_node_t));

			if(*tunnels == NULL)
				*tunnels = node;
			else
				tail->next = node;
			tail = node;
			num++;

			node->server_ip = strdup(ip_addr);
			if(node->server_ip == NULL)
				goto out_of_mem;

			node->domain = strdup(entry.domain);
			if(node->domain == NULL)
				goto out_of_mem;
		}
		else
		{
			// dynamic string concatate
			str_realloc_and_concat(&node->domain, ";%s", entry.domain);
		}
	}

	//fprintf(stderr, "<%s:%d> total dns tunnel nodes: %d\n", __func__, __LINE__, num);

	return num;

out_of_mem:
	free_dns_tunnels(*tunnels);
	*tunnels = NULL;
	return -1;
}
#endif	//CTC_DNS_TUNNEL

#if defined(CONFIG_IPV6)
/************************************************
* Propose: delOrgLanLinklocalIPv6Address
*
*    delete the original Link local IPv6 address
*      e.q: ifconfig br0 del fe80::2e0:4cff:fe86:5338/64 >/dev/null 2>&1
*
*    When modify the function, please also modify _delOrgLanLinklocalIPv6Address()
*    in src/linux/msgparser.c
* Parameter:
*	None
* Return:
*     None
* Author:
*     Alan
*************************************************/
void delOrgLanLinklocalIPv6Address()
{
	unsigned char value[64];
	struct in6_addr ip6Addr, targetIp;
	unsigned char devAddr[MAC_ADDR_LEN];
	unsigned char *p = &targetIp.s6_addr[0];
	int i=0;
	char cmdBuf[256]={0};

	if (mib_get(MIB_ELAN_MAC_ADDR, (void *)devAddr) != 0)
	{
		ipv6_linklocal_eui64(p, devAddr);
		inet_ntop(PF_INET6, &targetIp, value, sizeof(value));
		sprintf(cmdBuf, "%s %s %s %s/%d %s %s", IFCONFIG, LANIF, ARG_DEL, value, 64, hideErrMsg1, hideErrMsg2);
		//use system to prevent error message
		system(cmdBuf);
		//va_cmd(IFCONFIG, 5, 1, LANIF, ARG_DEL, value, hideErrMsg1, hideErrMsg2);
	}
}

/************************************************
* Propose: setLanLinkLocalIPv6Address()
*    set the Link local IPv6 address
*      e.q: ifconfig br0 add fe80::1/64 >/dev/null 2>&1
*
*    When modify the function, please also modify _setLanLinkLocalIPv6Address()
*    in src/linux/msgparser.c
* Parameter:
*	None
* Return:
*     None
* Author:
*     Alan
*************************************************/
void setLanLinkLocalIPv6Address()
{
	unsigned char value[64];

	if (mib_get(MIB_IPV6_LAN_IP_ADDR, (void *)value) != 0)
	{
		char cmdBuf[256]={0};
		sprintf(cmdBuf, "%s %s %s %s/%d %s %s", IFCONFIG, LANIF, ARG_ADD, value, 64, hideErrMsg1, hideErrMsg2);
		//use system to prevent error message
		system(cmdBuf);
		//va_cmd(IFCONFIG, 5, 1, LANIF, ARG_ADD, cmdBuf, hideErrMsg1, hideErrMsg2);
	}
}

/************************************************
* Propose: radvdRunningMode()
*    Get radvd running mode
* Parameter:
*	None
* Return:
*      0  :  RADVD_RUNNING_MODE_DISABLE
*      1  :  RADVD_RUNNING_MODE_STATIC
*      2  :  RADVD_RUNNING_MODE_DELEGATION
* Author:
*     Alan
*************************************************/
int radvdRunningMode()
{
	int vcTotal, i, ret;
	MIB_CE_ATM_VC_T Entry;
	int exist = 0;
	unsigned char lanIPv6PrefixMode;
	unsigned int wan_conn=0;

	if (!mib_get(MIB_PREFIXINFO_PREFIX_MODE, (void *)&lanIPv6PrefixMode))
		return -1;
	if (!mib_get(MIB_PREFIXINFO_DELEGATED_WANCONN, (void *)&wan_conn))
		return -1;

	vcTotal = mib_chain_total(MIB_ATM_VC_TBL);

	for (i = 0; i < vcTotal; i++)
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;

		if (Entry.enable == 0)
			continue;

		if ((CHANNEL_MODE_T)Entry.cmode == CHANNEL_MODE_BRIDGE)
			continue;

		if (Entry.IpProtocol == IPVER_IPV4)
			continue;

		if ((Entry.applicationtype & X_CT_SRV_INTERNET) && (lanIPv6PrefixMode ==IPV6_PREFIX_DELEGATION) &&
			((Entry.Ipv6DhcpRequest & 0x2)==0x2) && (wan_conn == Entry.ifIndex) )
			return RADVD_RUNNING_MODE_DELEGATION;

		if ((Entry.applicationtype & X_CT_SRV_INTERNET) && ( lanIPv6PrefixMode==IPV6_PREFIX_STATIC))
			return RADVD_RUNNING_MODE_STATIC;
	}

	return RADVD_RUNNING_MODE_DISABLE;
}

/************************************************
* Propose: setLinklocalIPv6Address
*
*    set thel Link local IPv6 address
*      e.q: ifconfig br0 add fe80::2e0:4cff:fe86:5338/64 >/dev/null 2>&1
*
* Parameter:
*	char* ifname              interface name
* Return:
*     None
* Author:
*     Alan
*************************************************/
void setLinklocalIPv6Address(char* ifname)
{
	unsigned char value[64];
	struct in6_addr ip6Addr, targetIp;
	unsigned char devAddr[MAC_ADDR_LEN];
	unsigned char *p = &targetIp.s6_addr[0];
	int i=0;
	char cmdBuf[256]={0};

	if (getMacAddr(ifname, devAddr) != 0)
	{
		ipv6_linklocal_eui64(p, devAddr);
		inet_ntop(PF_INET6, &targetIp, value, sizeof(value));
		sprintf(cmdBuf, "%s %s %s %s/%d %s %s", IFCONFIG, ifname, ARG_ADD, value, 64, hideErrMsg1, hideErrMsg2);
		//use system to prevent error message
		system(cmdBuf);
		//va_cmd(IFCONFIG, 5, 1, ifname, ARG_ADD, value, hideErrMsg1, hideErrMsg2);
	}
}

#endif /* #if defined(CONFIG_IPV6) */


/************************************************
* Propose: checkProcess()
*    Check process exist or not
* Parameter:
*	char* pidfile      pid file path
* Return:
*      1  :  exist
*      0  :  not exist
*      -1:  parameter error
* Author:
*     Alan
*************************************************/
int checkProcess(char* pidfile)
{
	char command[256] = {0};
	char output[256] = {0};
	int pid;

	if(pidfile==NULL || strlen(pidfile)==0){
		fprintf(stderr, "Error: [%s %s:%d] pid file is empty!!\n", __FILE__, __FUNCTION__, __LINE__);
		return -1;
	}

	pid = read_pid(pidfile);
	if(pid>0){
		return 1;
	}

	return 0;
}

/************************************************
* Propose: waitProcessTerminate()
*    wait process until process does not exist
* Parameter:
*	char* pidfile                    pid file path
*     unsigned int timeout        0: wait infinite, otherise wait timeout miliseconds(mutiple of 10)
* Return:
*      0  : success
*      -1: parameter error
* Author:
*     Alan
*************************************************/
int waitProcessTerminate(char* pidfile, unsigned int timeout)
{
	clock_t time_end;

	if(pidfile==NULL || strlen(pidfile)==0){
		fprintf(stderr, "Error: [%s %s:%d] pid file is empty!!\n", __FILE__, __FUNCTION__, __LINE__);
		return -1;
	}

	time_end = clock() + (timeout/10*10);
	while(checkProcess(pidfile)==1){
		if(timeout!=0){
			if(clock() > time_end){
				break;
			}
		}
		usleep(10);
	}
	return 0;
}

/************************************************
* Propose: getMacAddr
*
*    get MAC address
*
* Parameter:
*	char* ifname                     interface name
*     unsigned char* macaddr      mac addr
* Return:
*     -1 : fail
*       0 : success
* Author:
*     Alan
*************************************************/
int getMacAddr(char* ifname, unsigned char* macaddr)
{
	int s;
	struct ifreq ifr;

	if(ifname==NULL || strlen(ifname)==0 || macaddr==NULL){
		printf("%s: parameter error\n", __FUNCTION__);
        return -1;
	}

    s = socket(PF_PACKET, SOCK_DGRAM, 0);

    if (s < 0) {
        printf("%s: socket error\n", __FUNCTION__);
        return -1;
    }

	memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
    if (ioctl(s, SIOCGIFHWADDR, &ifr) < 0) {
        printf("%s: Interface %s not found\n", __FUNCTION__, ifname);
		close(s);
        return -1;
    }
	close(s);

	if (ifr.ifr_hwaddr.sa_family!=ARPHRD_ETHER) {
    	printf("%s: not an Ethernet interface\n", __FUNCTION__);
		return -1;
	}
	memcpy(macaddr, ifr.ifr_hwaddr.sa_data, MAC_ADDR_LEN);

	//printf("%s: %02X:%02X:%02X:%02X:%02X:%02X\n", __FUNCTION__,
    //	macaddr[0],macaddr[1],macaddr[2],macaddr[3],macaddr[4],macaddr[5]);
    return 0;
}

/************************************************
* Propose: doPreRestoreFunc
*
* Parameter:
* Return:
*     -1 : fail
*       0 : success
* Author:
*    Iulian
*************************************************/

int doPreRestoreFunc()
{
#ifdef CONFIG_USER_DBUS_PROXY
	FILE *fp = NULL;
	fp = fopen("/tmp/.runRestore", "w");
	if(fp) fclose(fp);
#endif
	system("spppctl down all &");
	
	return 0;
}

#ifdef CONFIG_USER_BEHAVIOR_ANALYSIS
#ifdef CONFIG_TR142_MODULE
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <rtk/rtk_tr142.h>

#define TR142_DEV_FILE "/dev/rtk_tr142"
#endif

const char *SNORT = "/bin/snort";
const char *SNORT_PID = "/var/run/snort.pid";

void setup_behavior_analysis(void)
{
	unsigned char enable = 0;
	int fd;
	int disable_hwnat = 0;
	char *argv[10] = {0};
	char ifname[IFNAMSIZ] = {0};
	int pid = -1;
	FILE *f = NULL;

	pid = read_pid(SNORT_PID);
	if(pid > 0)
		kill(pid, SIGTERM);

	mib_get(MIB_BA_ENABLE, &enable);
	if(enable)
	{
		int i;
		disable_hwnat = 1;

		f = fopen("/proc/rg/hwnat", "w");
		if(f)
		{
			fputs("2\n", f);
			fclose(f);
		}

		// Remove all mac entries in HW
		for(i=0; i<MAX_LUT_HW_TABLE_SIZE; i++)
			rtk_rg_macEntry_del(i);

		// snort -c /etc/snort.conf -l /tmp -A none -N -q -i br0
		va_cmd((char *)SNORT, 10, 0, "-c", "/etc/snort.conf", "-l", "/tmp", "-A", "none", "-N", "-q", "-i", "br0");
	}
	else
	{
		f = fopen("/proc/rg/hwnat", "w");
		if(f)
		{
			fputs("1\n", f);
			fclose(f);
		}
	}

#ifdef CONFIG_TR142_MODULE
	fd = open(TR142_DEV_FILE, O_WRONLY);
	if(fd >= 0)
	{
		if(ioctl(fd, RTK_TR142_IOCTL_SET_DSIABLE_HWNAT_PATCH, &disable_hwnat) != 0)
		{
			fprintf(stderr, "ERROR: RTK_TR142_IOCTL_SET_DSIABLE_HWNAT_PATCH failed\n");
		}
		close(fd);
	}
#endif
}
#endif

#if defined(CONFIG_EPON_FEATURE)||defined(CONFIG_GPON_FEATURE)
//cxy 2016-8-22: led_mode: 0:led off   1:led on 2:led state restore
int set_pon_led_state(int led_mode)
{
	unsigned int pon_mode=0;
	rtk_pon_led_pon_mode_t led_pon_mode=PON_LED_PON_MODE_END;

	mib_get(MIB_PON_MODE,&pon_mode);
	if(pon_mode==EPON_MODE)
		led_pon_mode=PON_LED_PON_MODE_EPON;
	else if(pon_mode==GPON_MODE)
		led_pon_mode=PON_LED_PON_MODE_GPON;
	else
		return -1;

	switch(led_mode)
	{
		case 0://pon led state led off
			rtk_pon_led_status_set(led_pon_mode, PON_LED_FORCE_OFF);
			break;
		case 1://pon led state led on
			rtk_pon_led_status_set(led_pon_mode, PON_LED_FORCE_ON);
			break;
		case 2://lpon led state restore
			rtk_pon_led_status_set(led_pon_mode, PON_LED_STATE_RESTORE);
			break;
		default:
			break;
	}

	return 0;
}

//cxy 2016-8-29:control los led. led_mode: 0:led off   1:led on 2:led state restore
int set_los_led_state(int led_mode)
{
	switch(led_mode)
	{
		case 0:
			rtk_pon_led_status_set(PON_LED_PON_MODE_OTHERS, PON_LED_FORCE_OFF);//LOS led off
			break;
		case 1:
			rtk_pon_led_status_set(PON_LED_PON_MODE_OTHERS, PON_LED_FORCE_ON);
			break;
		case 2:
			rtk_pon_led_status_set(PON_LED_PON_MODE_OTHERS, PON_LED_STATE_RESTORE);
			break;
		default:
			break;
	}
	return 0;
}
#endif
#if defined(CONFIG_CT_AWIFI_JITUAN_SMARTWIFI)
struct webserver_callout wifidog_timeout;
#ifdef CONFIG_CT_AWIFI_JITUAN_SMARTWIFI
int awifi_lan_enable()
{
	int idx=0;
	char cmd[256];
	unsigned char enable;

	printf("enter awifi_lan_enable!\n");
	//first add all lan rule
	{
		//system("iptables -t mangle -N LanAuth_Exclude");
		//system("iptables -t mangle -A PREROUTING -i br0 -j LanAuth_Exclude");
		for(idx=AWIFI_LAN_START_NUM;idx<AWIFI_LAN_END_NUM;idx++)
		{
			snprintf(cmd,sizeof(cmd),"iptables -t mangle -D LanAuth_Exclude -m physdev --physdev-in eth0.%d -j RETURN",idx);
			//printf("@@---%s#%d---cmd=%s----@@\n",__FUNCTION__,__LINE__,cmd);
			system(cmd);
		}
		snprintf(cmd,sizeof(cmd),"iptables -t mangle -D LanAuth_Exclude -m physdev --physdev-in wlan0 -j RETURN");
		//printf("@@---%s#%d---cmd=%s----@@\n",__FUNCTION__,__LINE__,cmd);
		system(cmd);
	}

	{
		for(idx=AWIFI_LAN_START_NUM;idx<AWIFI_LAN_END_NUM;idx++)
		{
			if(idx==AWIFI_LAN_START_NUM){
				mib_get(AWIFI_LAN1_AUTH_ENABLE,&enable);
				if(!enable)
					continue;
			}
			if(idx==(AWIFI_LAN_START_NUM+1)){
				mib_get(AWIFI_LAN2_AUTH_ENABLE,&enable);
				if(!enable)
					continue;
			}
			if(idx==(AWIFI_LAN_START_NUM+2)){
				mib_get(AWIFI_LAN3_AUTH_ENABLE,&enable);
				if(!enable)
					continue;
			}
			if(idx==(AWIFI_LAN_START_NUM+3)){
				mib_get(AWIFI_LAN4_AUTH_ENABLE,&enable);
				if(!enable)
					continue;
			}
			snprintf(cmd,sizeof(cmd),"iptables -t mangle -I LanAuth_Exclude 1  -m physdev --physdev-in eth0.%d -j RETURN",idx);
			//printf("@@---%s#%d---cmd=%s----@@\n",__FUNCTION__,__LINE__,cmd);
			system(cmd);
		}
		mib_get(AWIFI_WLAN1_AUTH_ENABLE,&enable);
		if(enable){
			snprintf(cmd,sizeof(cmd),"iptables -t mangle -I LanAuth_Exclude 1  -m physdev --physdev-in wlan0 -j RETURN");
			//printf("@@---%s#%d---cmd=%s----@@\n",__FUNCTION__,__LINE__,cmd);
			system(cmd);
		}
	}
		
	return 0;
}

int awifiAddFwRuleChain()
{
	char cmd[256];
	int idx;
	struct in_addr lanip, lanmask, lannet;
	char ipaddr[16],subnet[16];
	int maskbit=0,i=0;

	system("iptables -t mangle -F LanAuth_Exclude");
	system("iptables -t mangle -X LanAuth_Exclude");
	system("iptables -t mangle -D PREROUTING -i br0 -j LanAuth_Exclude");
	
	system("iptables -t mangle -N LanAuth_Exclude");
	system("iptables -t mangle -A PREROUTING -i br0 -j LanAuth_Exclude");

	mib_get(MIB_ADSL_LAN_IP, (void *)&lanip);
	mib_get(MIB_ADSL_LAN_SUBNET, (void *)&lanmask);
	lannet.s_addr = lanip.s_addr & lanmask.s_addr;
	strncpy(ipaddr, inet_ntoa(lannet), 16);
	ipaddr[15] = '\0';

	for(;i<32;i++)
	{
		if(lanmask.s_addr&(0x80000000>>i))
			maskbit++;
	}

	printf("awifiAddFwRuleChain:lannet=%s,maskbit=%d\n",ipaddr,maskbit);

#if 0
	for(idx=AWIFI_LAN_START_NUM;idx<AWIFI_LAN_END_NUM;idx++)
	{
			snprintf(cmd,sizeof(cmd),"iptables -t mangle -A LanAuth_Exclude -i eth0.%d -s %s/%d -j MARK --set-mark %d/%s",idx,ipaddr,maskbit,
			FW_MARK_KNOWN,CHAIN_MARK_MASK);
		//printf("@@---%s#%d---cmd=%s----@@\n",__FUNCTION__,__LINE__,cmd);
		system(cmd);
	}
	snprintf(cmd,sizeof(cmd),"iptables -t mangle -A LanAuth_Exclude -i wlan0 -s %s/%d -j MARK --set-mark %d/%s",ipaddr,maskbit,
		FW_MARK_KNOWN,CHAIN_MARK_MASK);
	//printf("@@---%s#%d---cmd=%s----@@\n",__FUNCTION__,__LINE__,cmd);
	system(cmd);
#endif
	system("iptables -t mangle -A LanAuth_Exclude  -m physdev --physdev-in wlan0-vap0 -j  RETURN");
	snprintf(cmd,sizeof(cmd), "iptables -t mangle -A LanAuth_Exclude  -m physdev --physdev-in eth0+ -s %s/%d -j MARK --set-mark 0x2/0xfff",ipaddr,maskbit);
	system(cmd);
	snprintf(cmd, sizeof(cmd), "iptables -t mangle -A LanAuth_Exclude  -m physdev --physdev-in wlan+ -s %s/%d -j MARK --set-mark 0x2/0xfff", ipaddr,maskbit);
	system(cmd);


	system("iptables -F LanAuth_Web");

	mib_get(MIB_ADSL_LAN_IP2, (void *)&lanip);
	mib_get(MIB_ADSL_LAN_SUBNET2, (void *)&lanmask);
	lannet.s_addr = lanip.s_addr & lanmask.s_addr;
	strncpy(ipaddr, inet_ntoa(lannet), 16);
	ipaddr[15] = '\0';

	for(;i<32;i++)
	{
		if(lanmask.s_addr&(0x80000000>>i))
			maskbit++;
	}

	snprintf(cmd,sizeof(cmd),"iptables -I  LanAuth_Web -i br0 -p TCP -s %s/%d --dport 80 -j DROP",ipaddr,maskbit);
	//printf("@@---%s#%d---cmd=%s----@@\n",__FUNCTION__,__LINE__,cmd);
	system(cmd);
	
}

//static struct webserver_callout fwRule_timeout;
int awifiAddFwRule()
{
	awifi_lan_enable();
}
#endif

int killWiFiDog(void)
{
	system(KILLWIFIDOGSTR);

#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_CT_AWIFI_JITUAN_SMARTWIFI)
	RTK_RG_Wifidog_Rule_set();
#endif

	return 0;
}

void startWiFiDog(void *null)
{
	int ret;
	char cmdbuf[128];
	//ret=va_cmd( WIFIDOGPATH, 2, 0,"-c",WIFIDOGCONFPATH);
	snprintf(cmdbuf,sizeof(cmdbuf),"export LD_LIBRARY_PATH=/var/config/awifi;%s",WIFIDOGPATH);
	printf("startWiFiDog:cmdbuf=%s\n",cmdbuf);
	ret=system(cmdbuf);

#if defined(CONFIG_RTK_L34_ENABLE) && defined(CONFIG_CT_AWIFI_JITUAN_SMARTWIFI)
	RTK_RG_Wifidog_Rule_set();
#endif

	UNTIMEOUT(startWiFiDog, 0, wifidog_timeout);
#ifdef CONFIG_CT_AWIFI_JITUAN_SMARTWIFI
	awifiAddFwRule();
#endif
	return;
}
void restartWiFiDog(int restart)
{
	char wifidogenable=0,ret=0;
	MIB_CE_MBSSIB_T Entry;
	ret=wlan_getEntry(&Entry, 1);
	wifidogenable=!Entry.wlanDisabled;
	if(ret)
	{
		killWiFiDog();
		if(wifidogenable)
		{
			if(restart)
			{
				UNTIMEOUT(startWiFiDog, 0, wifidog_timeout);
				TIMEOUT(startWiFiDog, 0, 2, wifidog_timeout);
			}else
			{
                void * null;
				startWiFiDog(null);
				
			}	
		}
		return;
	}
	return;
}
#endif
#ifdef CONFIG_CT_AWIFI_JITUAN_SMARTWIFI
int getDefaultGWEntry(MIB_CE_ATM_VC_T *pEntry)
{
	int total,i;
	if(pEntry == NULL)
		return 0;
#ifdef DEFAULT_GATEWAY_V2
	unsigned int dgw;
	if (mib_get(MIB_ADSL_WAN_DGW_ITF, (void *)&dgw) != 0)
	{
		if (!getWanEntrybyindex(pEntry, dgw)) {
			return 1;
		}
	}
#else
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for( i=0; i<total; i++ )
	{
		if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)pEntry ) )
			continue;
		if(pEntry->cmode == CHANNEL_MODE_BRIDGE)
			continue;
		if(pEntry->applicationtype != X_CT_SRV_INTERNET)
			continue;
		if(pEntry->dgw & IPVER_IPV4)
		{
			return 1;
		}
	}
#endif
	
	return 0;
}
	
int getWANEntryByIfName(char *pIfname, MIB_CE_ATM_VC_T *pEntry)
{
	unsigned int entryNum, i;
	char ifname[64]={0};
	
	if((pIfname == NULL) || (pEntry == NULL))
		return -1;
	
	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) {
		if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)pEntry ) )
			continue;
	
		if (pEntry->enable == 0)
			continue;

		ifGetName(pEntry->ifIndex,ifname,sizeof(ifname));
	
		if(!strcmp(ifname,pIfname)){
			break;
		}
	}
	
	if(i>= entryNum){
		return -1;
	}
	
	return 0;
}

int getdevIdFromaWiFiConf(char *devId)
{
	int ret=0;
	FILE *fp=NULL;
	
	if ((fp = fopen(WIFIDOGCONFPATH, "r"))) {
        while (!feof(fp)) {
            if (fscanf(fp, "DevID %s", devId) != 1) {
                /* Not on this line */
                while (!feof(fp) && fgetc(fp) != '\n') ;
            } else {
                /* Found it */
				ret=1;
                break;
            }
        }
        fclose(fp);
    }
	else{
		printf("Could not open file:%s\n", WIFIDOGCONFPATH);
	}

	return ret;
}

int getgwaddrFromaWiFiConf(char *gwaddr)
{
	int ret=0;
	FILE *fp=NULL;

	if ((fp = fopen(WIFIDOGCONFPATH, "r"))) {
        while (!feof(fp)) {
            if (fscanf(fp, "gatewayaddress %s", gwaddr) != 1) {
                /* Not on this line */
                while (!feof(fp) && fgetc(fp) != '\n') ;
            } else {
                /* Found it */
				ret=1;
                break;
            }
        }
        fclose(fp);
    }
	else{
		printf("Could not open file:%s\n", WIFIDOGCONFPATH);
	}

	return ret;
}

int getgwportFromaWiFiConf(int *gwport)
{
	int ret=0;
	FILE *fp=NULL;

	if ((fp = fopen(WIFIDOGCONFPATH, "r"))) {
        while (!feof(fp)) {
            if (fscanf(fp, "gatewayport %d", gwport) != 1) {
                /* Not on this line */
                while (!feof(fp) && fgetc(fp) != '\n') ;
            } else {
                /* Found it */
				ret=1;
                break;
            }
        }
        fclose(fp);
    }
	else{
		printf("Could not open file:%s\n", WIFIDOGCONFPATH);
	}

	return ret;
}

#define MAX_BUF 4096
int parse_ServerHostname(const char *filename, char *ServerStr, char *hostname)
{
	int ret=0;
	FILE *fp=NULL;
	char line[MAX_BUF];

	if((filename == NULL) || (ServerStr == NULL) || (hostname == NULL))
		return -1;

	if ((fp = fopen(filename, "r"))) {
		while (!feof(fp)) {
			fgets(line, MAX_BUF - 1, fp);
			if(strstr(line, ServerStr))
			{
checkagain:					
				if (fscanf(fp, "Hostname %s", hostname) != 1) {
                /* Not on this line */
                	while (!feof(fp) && fgetc(fp) != '\n') ;
	            } else {
	                /* Found it */
					ret=1;
	                break;
	            }
				goto checkagain;				
			}
		}
		
        fclose(fp);
    }
	else{
		printf("Could not open file:%s\n", filename);
	}

	return ret;
}

int parse_ServerHttpPort(const char *filename, char *ServerStr, int *port)
{
	int ret=0;
	FILE *fp=NULL;
	char line[MAX_BUF];

	if((filename == NULL) || (ServerStr == NULL))
		return -1;

	if ((fp = fopen(filename, "r"))) {
		while (!feof(fp)) {
			fgets(line, MAX_BUF - 1, fp);
			if(strstr(line, ServerStr))
			{
checkagain:				
				if (fscanf(fp, "HttpPort %d", port) != 1) {
                /* Not on this line */
                	while (!feof(fp) && fgetc(fp) != '\n') ;
	            } else {
	                /* Found it */
					ret=1;
	                break;
	            }
				goto checkagain;				
			}
		}
		
        fclose(fp);
    }
	else{
		printf("Could not open file:%s\n", filename);
	}

	return ret;
}

int getLineNumber(char *ServerStr, char *TypeStr)
{
	FILE *fp=NULL;
	char line[MAX_BUF], tmp1[64], tmp2[MAX_BUF];
	int count=0;
	
	if((TypeStr == NULL) || (ServerStr == NULL))
		return -1;

	if ((fp = fopen(WIFIDOGCONFPATH, "r"))) {
		while (!feof(fp)) {
			fgets(line, MAX_BUF - 1, fp);
			count++;
			if(strstr(line, ServerStr))
			{
retryagain:	
				fscanf(fp, "%s %s", tmp1, tmp2);
				if (strcmp(tmp1, TypeStr)) {
                /* Not on this line */
					count++;
                	while (!feof(fp) && fgetc(fp) != '\n') ;
	            } else {
	                /* Found it */
					count++;
	                break;
	            }
				goto retryagain;
			}
		}
		
        fclose(fp);
    }
	else{
		printf("Could not open file:%s\n", WIFIDOGCONFPATH);
	}

	return count;
}

struct default_server_setting *gServerSetting=NULL;
void addServerSetting(int linenum, char *newconf)
{
	struct default_server_setting *pServerSetting;

	pServerSetting = malloc(sizeof(struct default_server_setting));
	memset(pServerSetting, 0, sizeof(struct default_server_setting));
	pServerSetting->linenum=linenum;
	strncpy(pServerSetting->data, newconf, BUF_SIZE);
	
	if(gServerSetting==NULL)
	{
		gServerSetting=pServerSetting;
	}
	else{
		struct default_server_setting *tmp=gServerSetting;
		while(tmp->next)
			tmp=tmp->next;
		tmp->next=pServerSetting;
	}
}

struct default_server_setting *server_setting_find( int line )
{
	struct default_server_setting *p=NULL;
	
	if(gServerSetting==NULL) return NULL;
	
	p = gServerSetting;
	while(p)
	{
		if(p->linenum == line) break;
		p = p->next;
	}
	
	return p;
}

void free_server_setting()
{
	struct default_server_setting *p;

	if( (gServerSetting==NULL)) return;
	
	p = gServerSetting;
	while(p)
	{
		free(p);
		p = p->next;
	}
	gServerSetting=NULL;
}

int UpdateAwifiConfSetting()
{
	int count=0;
	FILE *fp=NULL;
	FILE *fp2=NULL;
	char line[MAX_BUF];
	struct default_server_setting *p=NULL;

	fp = fopen(WIFIDOGCONFPATH, "r");
	fp2 = fopen(WIFIDOGTMPCONFPATH, "w+");

	if(!fp || !fp2)
		return -1;

	while (!feof(fp))
	{
		fgets(line, MAX_BUF - 1, fp);
		count++;

		p=server_setting_find(count);
		if(p)
			fprintf(fp2, p->data);
		else
			fputs(line, fp2);
	}

	fclose(fp);
	fclose(fp2);

	system("cp -f /var/config/awifi/temp.conf /var/config/awifi/awifi.conf");
	system("rm -f /var/config/awifi/temp.conf");

	return 0;
}

char *geAwifiVersion(char *buf, int len)
{
	if(!buf || !len)
	{
		return NULL;
	}

	FILE *fp;
	unsigned char tmpBuf[64], *pStr;
	tmpBuf[0]=0;
	fp = fopen("/var/config/awifi/binversion", "r");
	if (fp!=NULL) {
		fgets(tmpBuf, sizeof(tmpBuf), fp);  //main version
		fclose(fp);
	}
	if(!strlen(tmpBuf))
		snprintf(buf,len,AWIFI_DEFAULT_BIN_VERSION);
	else
		snprintf(buf,len,"%s", tmpBuf);
	
	return buf;
}

#endif

#ifdef CONFIG_IPV6
/*
 * FUNCTION:SET_NETWORK_DNSV6
 *
 * INPUT:
 *	dns1:
 *		Fisrt DNSv6 server to set.
 *	dns2:
 *		Second DNSv6 server to set.
 *
 * RETURN:
 *	0 -- successful
 *	-1 -- Input error
 *  -2 -- INETERNET WAN not found
 *  -3 -- other
 */
int set_network_dnsv6(char *dns1, char *dns2)
{
	MIB_CE_ATM_VC_T entry;
	int total, i;
	struct in6_addr sa;	// used to check IP

	if(dns1 == NULL)
		return -1;

	/* Check dns1 is a valid IP */
	if(inet_pton(AF_INET6, dns1, &(sa.s6_addr)) != 1)
		return -1;

	/* Find INTERNET WAN */
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
			continue;

		if (entry.IpProtocol == IPVER_IPV4)
			continue;

		if(entry.enable && entry.applicationtype & X_CT_SRV_INTERNET && entry.cmode != CHANNEL_MODE_BRIDGE)
			break;
	}

	/* INTERNET WAN not found */
	if(i == total)
		return -2;

	/* Write config */
	entry.dnsv6Mode = DNS_SET_BY_API;
	strncpy(entry.Ipv6Dns1, dns1, sizeof(entry.Ipv6Dns1));
	memcpy(entry.Ipv6Dns1, &(sa.s6_addr), sizeof(entry.Ipv6Dns1));
	if(dns2 != NULL && inet_pton(AF_INET6, dns2, &(sa.s6_addr)) == 1)
	{
		memcpy(entry.Ipv6Dns2, &(sa.s6_addr), sizeof(entry.Ipv6Dns2));
	}
	else
	{
		memset(entry.Ipv6Dns2, 0, sizeof(entry.Ipv6Dns2));
	}

	mib_chain_update(MIB_ATM_VC_TBL, &entry, i);

	// update dnsmasq config
	cmd_set_dns_config(NULL);
	restart_dnsrelay();
	return 0;
}


/*
 * FUNCTION:GET_NETWORK_DNSv6
 *
 * INPUT:
 *	dns1:
 *		Fisrt DNSv6 server to set.
 *	dns2:
 *		Second DNSv6 server to set.
 *
 * RETURN:
 * 	the number of DNS server got.
 *	-1 -- Input error
 *  -2 -- INETERNET WAN not found
 *  -3 -- resolv file not found
 *  -4 -- other
 */
int get_network_dnsv6(char *dns1, char *dns2)
{
	MIB_CE_ATM_VC_T entry;
	int total, i;
	struct in6_addr sa;	// used to check IP
	int got = 0;
	char buf[256] = {0};
	char ifname[IFNAMSIZ] = {0};

	if(dns1 == NULL || dns2 == NULL)
		return -1;

	/* Find INTERNET WAN */
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0 ; i < total ; i++)
	{
		if(mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
			continue;

		if (entry.IpProtocol == IPVER_IPV4)
			continue;

		if(entry.enable && entry.applicationtype & X_CT_SRV_INTERNET && entry.cmode != CHANNEL_MODE_BRIDGE)
		{
			ifGetName(entry.ifIndex, ifname, sizeof(ifname));
			break;
		}
	}

	/* INTERNET WAN not found */
	if(i == total)
		return -2;

	/* Get config */
	switch(entry.dnsv6Mode)
	{
	case REQUEST_DNS_NONE: //manual
	case DNS_SET_BY_API: // set by API
		{
			if(inet_ntop(AF_INET6, &entry.Ipv6Dns1, buf, sizeof(buf)) != NULL)
			{
				strcpy(dns1, buf);
				got++;
			}

			if(inet_ntop(AF_INET6, &entry.Ipv6Dns2, buf, sizeof(buf)) != NULL)
			{
				strcpy(dns2, buf);
				got++;
			}
		}
		break;
	case REQUEST_DNS: //auto
		{
			FILE *fresolv = NULL;
			char *p;

			snprintf(buf, 64, "%s.%s", (char *)DNS6_RESOLV, ifname);

			fresolv = fopen(buf, "r");
			if(fresolv == NULL)
				return -3;

			while(fgets(buf,sizeof(buf), fresolv)!=NULL)
			{
				// Get DNS servers
				p = strchr(buf, '\n');
				if (p)
				{
					if(got == 0)
					{
						memcpy(dns1, buf, p-buf);
						dns1[p-buf] = '\0';
						got++;
					}
					else if(got == 1)
					{
						memcpy(dns2, buf, p-buf);
						dns2[p-buf] = '\0';
						got++;
					}
				}

				if(got == 2)
					break;
			}
			fclose(fresolv);
		}
		break;
	default:
		return -4;
	}

	return got;
}
#endif

static struct dbusCallout *dbusCallout = NULL;

/*
 * FUNCTION:registerDbusGetInfoCallbackFunc
 *
 * INPUT:
 *	id:
 *		Fisrt DNSv6 server to set.
 *	dns2:
 *		Second DNSv6 server to set.
 *
 * RETURN:
 *	0: register success
 *  -1: register fail
 */
int registerDbusGetInfoCallbackFunc(int type, int pid, void *arg)
{
	struct dbusCallout *callout;
	struct dbusCallout *p, **pp;
	static int id=0;

	callout = malloc(sizeof(struct dbusCallout));
	id++;
	callout->id = id;
	callout->type = type;
	callout->pid = pid;

	for (pp = &dbusCallout; (p = *pp); pp = &p->c_next)
	if (callout->id > p->id)
	    break;
    callout->c_next = p;
    *pp = callout;

	return 0;
}

void unregisterDbusGetInfoCallbackFunc(int id)
{
    struct dbusCallout *p, **pp;

	for (pp = &dbusCallout; (p = *pp); pp = &p->c_next){
		if (p->id == id) {
	    	*pp = p->c_next;
	    	break;
		}
	}

}

/*
 * calltimeout - Call any timeout routines which are now due.
 */
void callDbusGetInfoCallbackFunc(int type)
{
    struct dbusCallout *p, **pp;

	if(dbusCallout!=NULL){
		for (pp = &dbusCallout; (p = *pp); pp = &p->c_next){
			if (p->type == type){
				kill(p->pid, SIGUSR1);
			}
		}
	}
}

int getIPaddrInfo(MIB_CE_ATM_VC_Tp entryp, char *ipaddr, char *netmask, char *gateway)
{
	int flags, flags_found, isPPP;
	struct in_addr inAddr;
	char ifname[IFNAMSIZ], *str_ipv4;
	int maskbits;

	strcpy(ipaddr, "");
	strcpy(netmask, "");
	strcpy(gateway, "");
	if ((entryp->IpProtocol & IPVER_IPV4) == 0)
		return -1;

	ifGetName(entryp->ifIndex, ifname, sizeof(ifname));
	flags_found = getInFlags(ifname, &flags);

	switch (entryp->cmode) {
		case CHANNEL_MODE_BRIDGE:
			isPPP = 0;
			break;
		case CHANNEL_MODE_IPOE:
			isPPP = 0;
			break;
		case CHANNEL_MODE_PPPOE:	//patch for pppoe proxy
			isPPP = 1;
			break;
		case CHANNEL_MODE_PPPOA:
			isPPP = 1;
			break;
		default:
			isPPP = 0;
			break;
	}
	strcpy(ipaddr, "");
#ifdef EMBED
	if (flags_found && getInAddr(ifname, IP_ADDR, &inAddr) == 1) {
		str_ipv4 = inet_ntoa(inAddr);
		// IP Passthrough or IP unnumbered
		if (flags & IFF_POINTOPOINT && (strcmp(str_ipv4, "10.0.0.1") == 0))
			strcpy(ipaddr, STR_UNNUMBERED);
		else
			strcpy(ipaddr, str_ipv4);
	}
#endif

	strcpy(netmask, "");
	if (flags_found && getInAddr(ifname, SUBNET_MASK, &inAddr) == 1) {
		for ( maskbits=32 ; (inAddr.s_addr & (1L<<(32-maskbits))) == 0 ; maskbits-- ){
			//do nothing
		}
		sprintf(netmask, "%d", maskbits);
	}

	strcpy(gateway, "");
	if (flags_found)
	{
		if(isPPP)
		{
			if(getInAddr(ifname, DST_IP_ADDR, &inAddr) == 1)
				strcpy(gateway, inet_ntoa(inAddr));
		}
		else
		{
			if(entryp->ipDhcp == (char)DHCP_CLIENT)
			{
				FILE *fp = NULL;
				char fname[128] = {0};

				sprintf(fname, "%s.%s", MER_GWINFO, ifname);

				if(fp = fopen(fname, "r"))
				{
					fscanf(fp, "%s", gateway);
					fclose(fp);
				}
			}
			else
			{
				unsigned char zero[IP_ADDR_LEN] = {0};
				if(memcmp(entryp->remoteIpAddr, zero, IP_ADDR_LEN))
					strcpy(gateway, inet_ntoa(*((struct in_addr *)entryp->remoteIpAddr)));
			}
		}
	}

	return 0;
}

#ifdef CONFIG_IPV6
int getIPv6addrInfo(MIB_CE_ATM_VC_Tp entryp, char *ipaddr, char *netmask, char *gateway)
{
	char ifname[IFNAMSIZ];
	int flags, k, flags_found, isPPP;
	struct ipv6_ifaddr ipv6_addr[6];
	unsigned char zero[IP6_ADDR_LEN] = {0};

	strcpy(ipaddr, "");
	strcpy(netmask, "");
	strcpy(gateway, "");
	if ((entryp->IpProtocol & IPVER_IPV6) == 0)
		return -1;

	ifGetName(entryp->ifIndex, ifname, sizeof(ifname));
	flags_found = getInFlags(ifname, &flags);

	switch (entryp->cmode) {
		case CHANNEL_MODE_BRIDGE:
			isPPP = 0;
			break;
		case CHANNEL_MODE_IPOE:
			isPPP = 0;
			break;
		case CHANNEL_MODE_PPPOE:	//patch for pppoe proxy
			isPPP = 1;
			break;
		case CHANNEL_MODE_PPPOA:
			isPPP = 1;
			break;
		default:
			isPPP = 0;
			break;
	}

	k = getifip6(ifname, IPV6_ADDR_UNICAST, ipv6_addr, 6);
	if(k > 0){
		inet_ntop(AF_INET6, &ipv6_addr[0].addr, ipaddr, INET6_ADDRSTRLEN);
		sprintf(netmask, "%d\0", ipv6_addr[0].prefix_len);
	}

	if(entryp->cmode != CHANNEL_MODE_BRIDGE && entryp->IpProtocol & IPVER_IPV6)
	{
		if(memcmp(entryp->RemoteIpv6Addr, zero, IP6_ADDR_LEN)){
			inet_ntop(AF_INET6, &entryp->RemoteIpv6Addr, gateway, INET6_ADDRSTRLEN);
		}
	}

	return 0;
}
#endif

#ifdef CONFIG_USER_MONITORD
/* action:
 *        0 - Remove process
 *        1 - Add process
 */
int update_monitor_list_file(char *process_name, int action)
{
	FILE *fp = NULL, *fp_new = NULL;
	char *tmpFileName = "/var/monitor_list_tmp";
	char *p = NULL;
	char p_name[16] = {0};
	int monitord_pid = 0, is_Find = 0;
	printf("[%s:%d] process_name = %s, action = %d\n", __FUNCTION__, __LINE__, process_name, action);

	fp = fopen(MONITOR_LIST, "r");
	if (fp) {
		fp_new = fopen(tmpFileName, "w+");
		if (fp_new) {
			while (fgets(p_name, sizeof(p_name), fp)) {
				p = strchr(p_name, '\n');
				if (p) {
					*p = '\0';
				}

				if (strncmp(p_name, process_name, strlen(process_name)) == 0) {
					is_Find = 1;
					if (action == 0) {
						continue;
					}
				}
				fprintf(fp_new, "%s\n", p_name);
			}

			if (action == 1 && is_Find == 0) {
				fprintf(fp_new, "%s\n", process_name);
			}
			fclose(fp_new);
		}
		fclose(fp);
	}

	unlink(MONITOR_LIST);
	rename(tmpFileName, MONITOR_LIST);

	/* reload monitor list */
	monitord_pid = read_pid(MONITORD_PID);
	if (monitord_pid > 0) {
		kill(monitord_pid, SIGUSR1);
		usleep(1000);
	}

	return 0;
}
#endif

#ifdef CONFIG_YUEME
void collect_debug_info(char *category, char *dir_name, char *fw_dir_name, int first)
{
	char cmd[256];

	if(!strcmp(category, "INTERNET") || !strcmp(category, "ALL")){
		snprintf(cmd, 256, "cat /proc/rg/fwd_statistic >> /tmp/%s/rg_fwd_statistic", dir_name);
		system(cmd);
		snprintf(cmd, 256, "diag mib dump counter port 0-6 nonZero >> /tmp/%s/mib_dump_counter", dir_name);
		system(cmd);
	}

	if(!strcmp(category, WAN_VOIP_VOICE_NAME) || !strcmp(category, "ALL")){
		snprintf(cmd, 256,"cp /var/log/maserati.log /tmp/%s/maserati.log", dir_name);
		system(cmd);
	}

	if(!strcmp(category, "IPTV") || !strcmp(category, "ALL")){
		snprintf(cmd, 256, "cat /proc/rg/igmpSnooping >> /tmp/%s/rg_igmpSnooping", dir_name);
		system(cmd);
		snprintf(cmd, 256, "cat /proc/dump/sw_lut >> /tmp/%s/rg_sw_lut", dir_name);
		system(cmd);
	}

	if(!strcmp(category, "WIFI") || !strcmp(category, "ALL")){
		snprintf(cmd, 256, "cat /proc/wlan0/mib_all >> /tmp/%s/wlan0_mib_all", dir_name);
		system(cmd);
#ifdef WLAN_DUALBAND_CONCURRENT
		snprintf(cmd, 256, "cat /proc/wlan1/mib_all >> /tmp/%s/wlan1_mib_all", dir_name);
		system(cmd);
#endif
	}

	if(!strcmp(category, "SYSTEM") || !strcmp(category, "ALL")){
		if(first){
			stopLog();
			//start slogd
			system("/bin/slogd -n -l 7 -L -w &");
#ifdef USE_BUSYBOX_KLOGD
			system("/bin/klogd -n &");
#endif
		}
		snprintf(cmd, 256, "cp /var/log/messages /tmp/%s/syslog", dir_name);
		system(cmd);
	}

	if(!strcmp(category, "FRAMEWORK") || !strcmp(category, "ALL")){
		//TODO
	}

}

void stop_collect_debug_info(char *category)
{
	if(!strcmp(category, "SYSTEM") || !strcmp(category, "ALL")){
		//restore slogd
		stopLog();
		startLog();
	}
}
/*
* Function: start_collection_debug_info
* Description: collection debug info into a zip file and upload to a specific url path
* Input:
* 	uploadURL: format as: http://username:password@host:port/path
* 	timeout: in minute
* 	category: ALL, INTERNET, WAN_VOIP_VOICE_NAME, IPTV, WIFI, SYSTEM, FRAMEWORK
* Return: 0: success; -1: failed
*/
int start_collection_debug_info(char *uploadURL, unsigned short timeout, char *category)
{
	struct itimerspec new_value;
	struct timespec start;
	struct timespec curr;
	int fd;
	uint64_t exp;
	ssize_t s;
	int first_call = 1;
	int secs, nsecs;
	int max_time = timeout * 60;
	time_t tm;
	struct tm tm_time;
	char strbuf[64];
	char dir_name[128], fw_dir_name[128];
	char command[256];
	unsigned char mac[6];
	char username[64]={0}, password[64]={0};
	char url_path[128]={0};

	new_value.it_value.tv_sec = 0;
	new_value.it_value.tv_nsec = 1;
	new_value.it_interval.tv_sec = 5; //call collect_debug_info every 5 sec
	new_value.it_interval.tv_nsec = 0;

	//use mac address and time as zip file name
	time(&tm);
	memcpy(&tm_time, localtime(&tm), sizeof(tm_time));
	strftime(strbuf, 64, "%y%m%d%H%M%S", &tm_time);
	mib_get(MIB_ELAN_MAC_ADDR, (void *)mac);

	//mkdir for GW
	if(strcmp(category, "FRAMEWORK")){
		snprintf(dir_name, 128, "RTK_9607_%02x%02x%02x%02x%02x%02x_GW_%s_debuginfo", mac[0], mac[1], mac[2],
																	mac[3], mac[4], mac[5], strbuf);
		snprintf(command, 256, "mkdir -p /tmp/%s", dir_name);
		system(command);
	}
	//mkdir for FW
	if(!strcmp(category, "FRAMEWORK") || !strcmp(category, "ALL")){

		snprintf(fw_dir_name, 128, "RTK_9607_%02x%02x%02x%02x%02x%02x_FW_%s_debuginfo", mac[0], mac[1], mac[2],
																	mac[3], mac[4], mac[5], strbuf);
		snprintf(command, 256, "mkdir -p /tmp/%s", fw_dir_name);
		system(command);
	}

	fd = timerfd_create(CLOCK_MONOTONIC, 0);
	if (fd == -1){
		printf("create timer error\n");
		return -1;
	}

	if (timerfd_settime(fd, 0, &new_value, NULL) == -1){
		printf("set timer error\n");
		return -1;
	}

	printf("start to collect debug info\n");

	while( s = read(fd, &exp, sizeof(uint64_t))){
		if (s != sizeof(uint64_t)){
			printf("read timer error\n");
			return -1;
		}

		collect_debug_info(category, dir_name, fw_dir_name, first_call);

		if(first_call){
			first_call = 0;
			if (clock_gettime(CLOCK_MONOTONIC, &start) == -1){
				printf("get time error\n");
				return -1;
			}
		}
		if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1){
		   printf("get time error\n");
		   return -1;
		}

		secs = curr.tv_sec - start.tv_sec;
		nsecs = curr.tv_nsec - start.tv_nsec;

		//time is up
		if(secs >= max_time)
			break;

	}

	if(strcmp(category, "FRAMEWORK")){
		snprintf(command, 256, "cd /tmp; 7za a -tzip -sdel %s.zip %s; cd /", dir_name, dir_name);
		system(command);
	}
	if(!strcmp(category, "FRAMEWORK") || !strcmp(category, "ALL")){
		snprintf(command, 256, "cd /tmp; 7za a -tzip -sdel %s.zip %s; cd /", fw_dir_name, fw_dir_name);
		system(command);
	}

	stop_collect_debug_info(category);

	//upload zip file to the specific url path
	sscanf(uploadURL, "http://%[^:]:%[^@]@%s", username, password, url_path);

	if(strcmp(category, "FRAMEWORK")){
		//snprintf(command, 256, "curl -i -X POST \"Content-Type: multipart/form-data\" -F \"file=@/tmp/%s.zip\" http://192.168.1.7:8000/uploaded", dir_name);
		snprintf(command, 256, "curl -T /tmp/%s.zip -u %s:%s http://%s", dir_name, username, password, url_path);
		printf("%s\n", command);
		system(command);
	}
	if(!strcmp(category, "FRAMEWORK") || !strcmp(category, "ALL")){
		//snprintf(command, 256, "curl -i -X POST \"Content-Type: multipart/form-data\" -F \"file=@/tmp/%s.zip\" http://192.168.1.7:8000/uploaded", fw_dir_name);
		snprintf(command, 256, "curl -T /tmp/%s.zip -u %s:%s http://%s", fw_dir_name, username, password, url_path);
		printf("%s\n", command);
		system(command);
	}

	return 0;

}
#ifdef CONFIG_USER_DBUS_PROXY
int DBUS_epon_getAuthState(int llid)
{
    FILE *fp;
    char cmdStr[256], line[256];
    char tmpStr[20];
    int ret=2;

    snprintf(cmdStr, 256, "oamcli get ctc auth %d > /tmp/auth.result 2>&1", llid);
    va_cmd("/bin/sh", 2, 1, "-c", cmdStr);

    fp = fopen("/tmp/auth.result", "r");
    if (fp)
    {
        fgets(line, sizeof(line), fp);
        sscanf(line, "%*[^:]: %s", tmpStr);
        if (!strcmp(tmpStr, "success"))
            ret = 1;
        else if (!strcmp(tmpStr, "fail"))
            ret = 0;

        fclose(fp);
    }
    return (ret);
}

int DBUS_ifponstate(void)
{
    int ret = 0;
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
	unsigned int pon_mode;
	mib_get(MIB_PON_MODE, &pon_mode);
	if(pon_mode == 1)
	{
	    rtk_gpon_fsm_status_t onu;
	#if defined(CONFIG_RTK_L34_ENABLE)
	    rtk_rg_gpon_ponStatus_get(&onu);
	#else
	    rtk_gpon_ponStatus_get(&onu);
	#endif

	    if(onu == 5)
	        ret = 1;
	}
	else if(pon_mode == 2)
	{
		unsigned int pon_mode;
		rtk_epon_llid_entry_t llid_entry;
		llid_entry.llidIdx = 0;
	#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_epon_llid_entry_get(&llid_entry);
	#else
		rtk_epon_llid_entry_get(&llid_entry);
	#endif
		if (llid_entry.valid)
	    {
			int rett;
			rett = DBUS_epon_getAuthState(llid_entry.llidIdx);
			if (1 == rett)
			{
				ret = 1;
			}
			else
				ret = 2;
	    }
	    else
	    {
			ret = 0;
	    }
	}
#endif
	return ret;
}

void DBUS_poninfo(int s,double *buffer)
{
	get_poninfo(s, buffer);
}

#define CMD_MAX_LEN (256)
int do_samba_update(char *newpasswd)
{
	unsigned int totalEntry = 0, num1 = 0 ;
	unsigned char samba_enable=0;
	char cmd_buff[CMD_MAX_LEN];
	MIB_CE_SMB_ACCOUNT_T samba_account_t1, samba_account_t;
	FILE *fp_pass;

	memset(&samba_account_t, 0, sizeof(MIB_CE_SMB_ACCOUNT_T));
	strcpy(samba_account_t.username, "useradmin");
	strcpy(samba_account_t.password, newpasswd);

	totalEntry = mib_chain_total(MIB_SMBD_ACCOUNT_TBL);

	for(num1 = 0; num1< totalEntry; num1++)
	{
	    if (mib_chain_get(MIB_SMBD_ACCOUNT_TBL, num1, (void *)&samba_account_t1))
	    {
	        if(!strcmp(samba_account_t1.username,"useradmin"))
	        {
	            break;
	        }
	    }
	}
	if(num1 == totalEntry)
	{
        return -1;
    }
	samba_account_t.index = num1 +1;
	if(mib_chain_update(MIB_SMBD_ACCOUNT_TBL,(void *)&samba_account_t,num1))
	{
		;
	}
	else
	{
		return -1;
	}
	mib_update(CURRENT_SETTING, CONFIG_MIB_CHAIN);

	mib_get(MIB_SMB_SERVER_ENABLE, (void *)&samba_enable);

	fp_pass = fopen("/tmp/.pass", "w");
	if(fp_pass == NULL )
	{
		return -1;
	}
	fprintf(fp_pass, "%s\n",newpasswd);
	fprintf(fp_pass, "%s\n",newpasswd);
	fclose(fp_pass);

	//sprintf(cmd_buff, "smbpasswd useradmin %s", newpasswd);
	//sprintf(cmd_buff, "cat /tmp/.pass | smbpasswd -a useradmin -s");
	sprintf(cmd_buff, "cat /tmp/.pass | pdbedit -a useradmin -t");
	system(cmd_buff);
	#if 0
	if(samba_enable != 0)
	{
		sprintf(cmd_buff,"killall -SIGKILL smbd");
		system(cmd_buff);
		sprintf(cmd_buff,"/bin/smbd -D");
		system(cmd_buff);
	}
	#endif
	return 0;
}

int startNetlink(void)
{
	va_cmd("/bin/netlink", 0, 0);
	return 0;
}
int startHomeNas(void)
{
    int ret = 0;

    //va_cmd("/bin/nas", 0, 0);
	va_niced_cmd(NAS, 0, 0);

	return ret;
}
#endif
int get_ftpUserAccount(char *username, char *password)
{
#ifdef FTP_SERVER_INTERGRATION
	MIB_CE_FTP_ACCOUNT_T ftp_account;
#else
	MIB_CE_VSFTP_ACCOUNT_T ftp_account;
#endif
#ifdef FTP_SERVER_INTERGRATION
	if(mib_chain_get(MIB_FTP_ACCOUNT_TBL, 0, (void *)&ftp_account)==0)
#else
	if(mib_chain_get(MIB_VSFTP_ACCOUNT_TBL, 0, (void *)&ftp_account)==0)
#endif
		return -1;
	if(username)
		strcpy(username, ftp_account.username);
	if(password)
		strcpy(password, ftp_account.password);
	return 0;
}

int set_ftpUserAccount(char *username, char *password)
{
#ifdef FTP_SERVER_INTERGRATION
	MIB_CE_FTP_ACCOUNT_T ftp_account;	
	if(mib_chain_get(MIB_FTP_ACCOUNT_TBL, 0, (void *)&ftp_account)==0)
#else
	MIB_CE_VSFTP_ACCOUNT_T ftp_account;	
	if(mib_chain_get(MIB_VSFTP_ACCOUNT_TBL, 0, (void *)&ftp_account)==0)
#endif
		return -1;
	if(username)
		strcpy(ftp_account.username, username);
	if(password)
		strcpy(ftp_account.password, password);

#ifdef FTP_SERVER_INTERGRATION
	if(mib_chain_update(MIB_VSFTP_ACCOUNT_TBL, (void *)&ftp_account, 0)==0)
#else
	if(mib_chain_update(MIB_VSFTP_ACCOUNT_TBL, (void *)&ftp_account, 0)==0)
#endif
		return -1;

	mib_update(CURRENT_SETTING, CONFIG_MIB_CHAIN);
	return 0;
}
int get_ftp_enable(void)
{
	unsigned char enable=0;
#ifdef FTP_SERVER_INTERGRATION
	mib_get(MIB_FTP_ENABLE, &enable);
#else
	mib_get(MIB_VSFTP_ENABLE, &enable);
#endif
	return (enable==3);
}
int set_ftp_enable(int data)
{
	unsigned char enable=data;
#ifdef FTP_SERVER_INTERGRATION
	mib_set(MIB_FTP_ENABLE, &enable);
#else
	mib_set(MIB_VSFTP_ENABLE, &enable);
#endif
	return 1;
}
#endif

#ifdef CONFIG_E8B
void power_led_control_operation(enum PWR_LED_CTRL_OP_t operation)
{
	FILE *fppwrled=NULL;
	fppwrled = fopen("/proc/led_power","w");


	if (!fppwrled) {
		printf(" %s %d open file FAIL !\n", __func__, __LINE__);
		return;
	}

	switch(operation)
	{
		case PWR_LED_OFF:
			fprintf(fppwrled, "0\n");
			break;
		case PWR_LED_ON:
			#ifdef CONFIG_YUEME
			if(get_sleepmode_state() == 0 && get_ledctrl_state() != 0)
			#endif
				fprintf(fppwrled, "1\n");
			#ifdef CONFIG_YUEME
			else
				fprintf(fppwrled, "0\n");
			#endif
			break;
		case PWR_LED_BLINKING:
			fprintf(fppwrled, "2\n");
			break;
		case PWR_LED_STOP_BLINKING:
			fprintf(fppwrled, "3\n");
			break;
		default:
			printf(" %s %d Invalid operation !", __func__, __LINE__);
	}

	fclose(fppwrled);
}
#endif

#ifdef CONFIG_USER_RTK_OMD
#define REBOOT_LOG	"/opt/upt/apps/omd_log.reboot"
#ifdef CONFIG_CLASSFY_MAGICNUM_SUPPORT
#define WATCHDOG_MAGIC_KEY 0xF7F6F5F4
#endif
int is_watchdog_reboot()
{
	unsigned int val = 0, ret = 0;
#ifdef CONFIG_CLASSFY_MAGICNUM_SUPPORT
	rtk_switch_softwareMagicKey_get(&val);
	if(val == WATCHDOG_MAGIC_KEY) ret = 1;
	else rtk_switch_softwareMagicKey_set(WATCHDOG_MAGIC_KEY);
#elif defined(CONFIG_LUNA_WDT_KTHREAD)
	FILE *fp = NULL;
	if((fp = fopen("/proc/luna_watchdog/previous_wdt_reset", "r"))){
		fscanf(fp, "%u", &val);
		fclose(fp);
	}
	ret = (val == 1) ? 1:0;
#endif
	return ret;
}
int is_terminal_reboot()
{
	if( access(REBOOT_LOG, 0)!=0 )  
		return 1;
	else
		return 0;
}

/***********************************************
  * Note:
  *		no this file    ---create and write flag in file
  *		have this file ---read and write
  *
  **********************************************/
int write_omd_reboot_log(unsigned int flag)
{
	FILE *fp;
	int fd, hasExcep = 0;
	unsigned int reboot_flag=0;
	time_t rtime=0;

	if (flag != REBOOT_FLAG)
	{ 
		if(access(REBOOT_LOG, F_OK) != 0)
		{
			fp = fopen(REBOOT_LOG, "w+");
			
			if(fp){
				time(&rtime);
				fprintf(fp, "%d %lu", flag, rtime);

				printf("[%s %d]: no file,flag = %x , time = %lu\n", __func__, __LINE__, flag, rtime);
				fd = fileno(fp);
				fsync(fd);

				fclose(fp);
			}
		}
	}
	else 
	{	
		if(is_watchdog_reboot()) hasExcep |= 1;
		if(access( "/opt/upt/apps/oops",  F_OK) == 0) hasExcep |= 1;
		
		if((hasExcep || access(REBOOT_LOG, F_OK) != 0) && (fp = fopen(REBOOT_LOG, "w+")) != NULL)
		{
			time(&rtime);
			if(hasExcep){
				flag |= EXCEP_REBOOT;
			}
			else flag |= POWER_REBOOT;
			fprintf(fp, "%d %lu", flag, rtime);
			printf("[%s %d]: flag = %x, time = %lu\n", __func__, __LINE__, flag, rtime);
			fd = fileno(fp);
			fsync(fd);
			fclose(fp);
		}
		else 
		{
			fp=fopen(REBOOT_LOG, "r+");
			if(fp)
			{
				fscanf(fp, "%d %lu", &reboot_flag, &rtime);
				fseek(fp, 0, SEEK_SET);
				flag |= reboot_flag;
				fprintf(fp, "%d %lu", flag, rtime);

				printf("[%s %d]: have file,reboot_flag =%d, flag = %x, time = %lu\n", __func__, __LINE__, reboot_flag, flag, rtime);
				fd = fileno(fp);
				fsync(fd);

				fclose(fp);
			}
		}
	}
	
	return 1;
}
#endif

#if defined(CONFIG_E8B) && defined(CONFIG_PON_CONFIGURATION_COMPLETE_EVENT)
#include <sys/ipc.h> 
#include <sys/shm.h>
unsigned int get_omci_complete_event_shm( void )
{
	key_t shm_key;
	int shm_id; // shared memory ID
	char *shm_start; // attaching address
#ifdef CONFIG_EPON_FEATURE
	unsigned int pon_mode=0;

	mib_get(MIB_PON_MODE, &pon_mode);
	if(pon_mode == EPON_MODE)
	{
		return 1;
	}
#endif

	shm_key = ftok("/proc/omci", 'o');

	if ((shm_id = shmget((key_t)shm_key, 32, 0644 | IPC_CREAT)) == -1) {
		perror("shmget");
		return 0;
	}
	if ((shm_start = (char *)shmat ( shm_id , NULL , 0 ) )==(char *)(-1)) {
		perror("shmat");
		return 0;
	}

	if(shm_start[0] == '\0' || strcmp(shm_start, OMCI_CONFIG_COMPELETE_STR)){
		shmdt(shm_start);
		return 0;
	}
	else{
		shmdt(shm_start);
		return 1;
	}

}
#endif

/*
 *	Convert the mib data mib_buf, from mib_get(), to a string representation.
 *	Return:
 		string
 */
int mib_to_string(char *string, const void *mib, TYPE_T type, int size)
{
	char tmp[16];
	int array_size, i, ret = 0;

	switch (type) {
	case IA_T:
		if (inet_ntop(AF_INET, mib, string, INET_ADDRSTRLEN) == NULL) {
			string[0] = '\0';
			ret = -1;
		}
		break;
#ifdef CONFIG_IPV6
	case IA6_T:
		if (inet_ntop(AF_INET6, mib, string, INET6_ADDRSTRLEN) == NULL) {
			string[0] = '\0';
			ret = -1;
		}
		break;
#endif
	case BYTE_T:
		sprintf(string, "%hhu", *(unsigned char *)mib);
		break;

	case WORD_T:
		sprintf(string, "%hu", *(unsigned short *)mib);
		break;

	case DWORD_T:
		sprintf(string, "%u", *(unsigned int *)mib);
		break;

	case INTEGER_T:
		sprintf(string, "%d", *(int *)mib);
		break;

	case BYTE5_T:
	case BYTE6_T:
	case BYTE13_T:
		string[0] = '\0';
		for (i = 0; i < size; i++) {
			sprintf(tmp, "%02x", ((unsigned char *)mib)[i]);
			strcat(string, tmp);
		}
		break;

	case BYTE_ARRAY_T:
		string[0] = '\0';
		for (i = 0; i < size; i++) {
			sprintf(tmp, "%02x", ((unsigned char *)mib)[i]);
			if (i != (size - 1))
				strcat(tmp, ",");
			strcat(string, tmp);
		}
		break;

	case WORD_ARRAY_T:
		array_size = size / sizeof(short);

		string[0] = '\0';
		for (i = 0; i < array_size; i++) {
			sprintf(tmp, "%04x", ((unsigned short *)mib)[i]);

			if (i != (array_size - 1))
				strcat(tmp, ",");

			strcat(string, tmp);
		}
		break;

	case INT_ARRAY_T:
		array_size = size / sizeof(int);

		string[0] = '\0';
		for (i = 0; i < array_size; i++) {
			sprintf(tmp, "%08x", ((unsigned int *)mib)[i]);

			if (i != (array_size - 1))
				strcat(tmp, ",");

			strcat(string, tmp);
		}
		break;
	case STRING_T:
		strcpy(string, mib);
		break;

	default:
		ret = -1;
		printf("%s: Unknown data type %d!\n", __FUNCTION__, type);
	}

	return ret;
}

/*
 *	Remove comma and blank in the string
 */
static char *to_hex_string(char *string)
{
	char *tostr;
	int i, k;
	size_t len = strlen(string);

	tostr = malloc(len + 1);
	if (tostr == NULL)
		return NULL;

	for (i = 0, k = 0; i < len; i++) {
		if (string[i] != ',' && string[i] != ' ')
			tostr[k++] = string[i];
	}
	tostr[k] = '\0';

	return tostr;
}

static int string_to_hex(char *string, unsigned char *key, int len)
{
	char tmpBuf[4];
	int idx, ii = 0;

	if (string == NULL || key == NULL)
		return 0;

	for (idx = 0; idx < len; idx += 2) {
		tmpBuf[0] = string[idx];
		tmpBuf[1] = string[idx + 1];
		tmpBuf[2] = 0;

		if (!isxdigit(tmpBuf[0]) || !isxdigit(tmpBuf[1]))
			return 0;

		key[ii++] = strtoul(tmpBuf, NULL, 16);
	}

	return 1;
}

static int string_to_short(char *string, unsigned short *key, int len)
{
	char tmpBuf[5];
	int idx, ii = 0, j;

	if (string == NULL || key == NULL)
		return 0;

	for (idx = 0; idx < len; idx += 4) {
		for (j = 0; j < 4; j++) {
			tmpBuf[j] = string[idx + j];
			if (!isxdigit(tmpBuf[j]))
				return 0;
		}

		tmpBuf[4] = 0;

		key[ii++] = strtoul(tmpBuf, NULL, 16);
	}

	return 1;
}

static int string_to_integer(char *string, unsigned int *key, int len)
{
	char tmpBuf[9];
	int idx, ii = 0, j;

	if (string == NULL || key == NULL)
		return 0;

	for (idx = 0; idx < len; idx += 8) {
		for (j = 0; j < 8; j++) {
			tmpBuf[j] = string[idx + j];
			if (!isxdigit(tmpBuf[j]))
				return 0;
		}

		tmpBuf[8] = 0;

		key[ii++] = strtoul(tmpBuf, NULL, 16);
	}

	return 1;
}

int string_to_mib(void *mib, const char *string, TYPE_T type, int size)
{
	struct in_addr *ipAddr;
#ifdef CONFIG_IPV6
	struct in6_addr *ip6Addr;
#endif
	unsigned char *vChar;
	unsigned short *vShort;
	unsigned int *vUInt;
	int *vInt;
	int ret;

	ret = 0;
	switch (type) {
	case IA_T:
		if (!strlen(string)) {
			string = "0.0.0.0";
		}
		ipAddr = mib;
		if (inet_pton(AF_INET, string, ipAddr) == 0)
			ret = -1;
		break;
#ifdef CONFIG_IPV6
	case IA6_T:
		if (!strlen(string)) {
			string = "::";
		}
		ip6Addr = mib;
		if (inet_pton(AF_INET6, string, ip6Addr) == 0)
			ret = -1;
		break;
#endif
	case BYTE_T:
		vChar = mib;
		*vChar = strtoul(string, NULL, 0);
		break;
	case WORD_T:
		vShort = mib;
		*vShort = strtoul(string, NULL, 0);
		break;
	case DWORD_T:
		vUInt = mib;
		*vUInt = strtoul(string, NULL, 0);
		break;
	case INTEGER_T:
		vInt = mib;
		*vInt = strtol(string, NULL, 0);
		break;
	case BYTE_ARRAY_T:
		string = to_hex_string((char*)string);	// remove comma and blank
		string_to_hex((char*)string, mib, size * 2);
		free((void*)string);
		break;
	case BYTE5_T:
	case BYTE6_T:
	case BYTE13_T:
		string_to_hex((char*)string, mib, size * 2);
		break;
	case STRING_T:
		strncpy(mib, string, size);
		break;
	case WORD_ARRAY_T:
		string = to_hex_string((char*)string);	// remove comma and blank
		string_to_short((char*)string, mib, size * 2);
		free((void*)string);
		break;
	case INT_ARRAY_T:
		string = to_hex_string((char*)string);	// remove comma and blank
		string_to_integer((char*)string, mib, size * 2);
		free((void*)string);
		break;
	default:
		printf("Unknown data type !\n");
		break;
	}

	return ret;
}

int before_upload(const char *fname)
{
	int ret = 1;

#ifdef CONFIG_USER_XMLCONFIG
	if (ret = va_cmd(shell_name, 3, 1, "/etc/scripts/config_xmlconfig.sh", "-s", fname)) {
		fprintf(stderr, "exec /etc/scripts/config_xmlconfig.sh error!\n");
	}
#else
#ifdef CONFIG_USE_XML
	if (ret = va_cmd("/bin/saveconfig", 4, 1, "-f", fname, "-t", "xml")) {
		fprintf(stderr, "exec /bin/saveconfig error!\n");
	}
#else
	if (ret = va_cmd("/bin/saveconfig", 4, 1, "-f", fname, "-t", "raw")) {
		fprintf(stderr, "exec /bin/saveconfig error!\n");
	}
#endif
#endif

	return ret;
}

int after_download(const char *fname)
{
	int ret = 1;

#ifdef CONFIG_USER_XMLCONFIG
	if (ret = va_cmd(shell_name, 3, 1, "/etc/scripts/config_xmlconfig.sh", "-l", fname)) {
		fprintf(stderr, "exec /etc/scripts/config_xmlconfig.sh error!\n");
	}
#else
#ifdef CONFIG_USE_XML
	if (ret = va_cmd("/bin/loadconfig", 4, 1, "-f", fname, "-t", "xml")) {
		fprintf(stderr, "exec /bin/loadconfig error!\n");
	}
#else
	if (ret = va_cmd("/bin/loadconfig", 4, 1, "-f", fname, "-t", "raw")) {
		fprintf(stderr, "exec /bin/loadconfig error!\n");
	}
#endif
#endif

	return ret;
}

#include <dal/rtl9607c/dal_rtl9607c_switch.h>
int getCPUClass(char *buf, int len)
{
	unsigned int chipId, rev, subType;

	if(buf == NULL)
		return -1;

	rtk_switch_version_get(&chipId, &rev, &subType);
	switch(chipId)
	{
		case RTL9601B_CHIP_ID:
			snprintf(buf, len, "Realtek RTL9601B");
			break;
		case RTL9602C_CHIP_ID:
			snprintf(buf, len, "Realtek RTL9602C");
			break;
		case RTL9607C_CHIP_ID:
			switch(subType)
			{
			case RTL9607C_CHIP_SUB_TYPE_RTL9607CP:
				snprintf(buf, len, "Realtek RTL9607CP");	
				break;
			case 0x10:
				snprintf(buf, len, "Realtek RTL9603CP");
				break;
			case RTL9607C_CHIP_SUB_TYPE_RTL9603C_VA4:
			case RTL9607C_CHIP_SUB_TYPE_RTL9603C_VA5:
			case RTL9607C_CHIP_SUB_TYPE_RTL9603C_VA6:
				snprintf(buf, len, "Realtek RTL9603C");
				break;
			case RTL9607C_CHIP_SUB_TYPE_RTL9607C_VA6:
			case RTL9607C_CHIP_SUB_TYPE_RTL9607C_VA7:
			default:
				snprintf(buf, len, "Realtek RTL9607C");
				break;
			}
			break;
		case APOLLOMP_CHIP_ID:
			snprintf(buf, len, "Realtek RTL%04X", chipId>>16);
			break;
		default:
			return -1;
	}

	return 0;
}

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
//iulian send socket Message to OSGI management server
//Return : 0  suceed
//Return : -1 fail 
int sendMessageOSGIManagement(char* bundleName, char* jsonMessageInChar)
{
	int clientSocket, portNum, nBytes, ret;
	char buffer[1024];
	char result[16];
	struct sockaddr_in serverAddr;
	socklen_t addr_size;

	struct timeval tv; /* timeval and timeout stuff */ 
	int timeouts = 0; 
	tv.tv_sec = 1;
	tv.tv_usec = 0;
	//DEBUG
	//printf("=======[%s:%d]======== bundleName=%s jsonMessageInChar=%s\n",__FUNCTION__, __LINE__, bundleName, jsonMessageInChar);
	clientSocket = socket(PF_INET, SOCK_STREAM, 0);
	if (clientSocket < 0) {
		perror("socket error");
		return -1;
	}
	if (setsockopt(clientSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof tv)){
		close(clientSocket);
		perror("setsockopt");
		return -1;
	}
	portNum = 9080; //OSGI management server 

	serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(portNum);
	serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	memset(serverAddr.sin_zero, '\0', sizeof serverAddr.sin_zero);	

	addr_size = sizeof serverAddr;
	if (connect(clientSocket, (struct sockaddr *) &serverAddr, addr_size)<0) {
		close(clientSocket);
		perror("connect");
		return -1;	
	}

	sprintf(buffer, "BundleName:%s.SetMsgConfig\nMessage:%s\n", bundleName, jsonMessageInChar);
	nBytes = strlen(buffer) + 1;

	if (send(clientSocket,buffer,nBytes,0) <0 ){
		close(clientSocket);
		perror("send");
		return -1;			
	}

	while (((nBytes=recv(clientSocket, buffer, 1024, 0)) == -1) && (++timeouts < 3)) 
	{ /* loop to retry in case it timed out */ 
		perror("recv"); 
		printf("[%s:%d] After timeout #%d, trying again:\n", __FUNCTION__, __LINE__, timeouts);
	} 
	//printf("numbytes = %d\n", nBytes);
	if (nBytes < 0) {
		close(clientSocket);
		return -1;
	}
	sscanf(buffer, "%[^:]:%d\n", &result, &ret);
	//printf("Received from server:%s result=%s ret=%d\n",buffer, result, ret);
	if ( strcmp(result, "result") != 0) {	
		//Return unexpected string
		close(clientSocket);	
		return -1;
	}
	close(clientSocket);
	return ret;

}
#endif

#ifdef _PRMT_WT107_
int getTimeStatus(void)
{
	FILE *fp;
	char line[64];
	int status=0;
	
	fp=fopen("/tmp/timeStatus","r");
	if(fp){
		fgets(line, 12, fp);
		sscanf(line, "%d", &status);
		fclose(fp);
	}	
	return status;
}
#endif

void formatPloamPasswordToHex(char *src, char* dest)
{
	char tmp[10] = {0};
	int i = 0;

	for(i=0; i < strlen(src) ; i++){
		sprintf(tmp, "%x", src[i]);
		strcat(dest, tmp);
	}

	if(strlen(src) < 10){
		for(i=0; i < (10-strlen(src)); i++){
			strcat(dest, "00");
		}
	}
}

#ifdef CONFIG_USER_LANNETINFO
void restartlanNetInfo()
{
	printf("killall lanNetInfo");
	va_cmd("/bin/killall",1,1,"lanNetInfo");
	printf("restart lanNetInfo");
	va_cmd( "/bin/lanNetInfo", 0, 0 );
}
#endif

void get_poninfo(int s,double *buffer)
{
    rtk_transceiver_data_t transceiver, readableCfg;
    if(s == 1)
    {
        memset(&transceiver, 0, sizeof(transceiver));
        memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
        rtk_rg_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver);
        _get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver, &readableCfg);
#else
        rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver);
#endif
        _get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver, &readableCfg);
        strtok(readableCfg.buf, " ");
        *buffer = atof(readableCfg.buf);
    }
    else if(s == 2)
    {
        memset(&transceiver, 0, sizeof(transceiver));
        memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE,  &transceiver);
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE, &transceiver, &readableCfg);
#else
		rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE,&transceiver);
#endif
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE, &transceiver, &readableCfg);
				strtok(readableCfg.buf, " ");
        *buffer = atof(readableCfg.buf);
    }
    else if(s == 3)
    {
        memset(&transceiver, 0, sizeof(transceiver));
        memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver);
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver, &readableCfg);
#else
		rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver);
#endif
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver, &readableCfg);
				strtok(readableCfg.buf, " ");
        *buffer = atof(readableCfg.buf);
    }
    else if(s == 4)
    {
        memset(&transceiver, 0, sizeof(transceiver));
        memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver);
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver, &readableCfg);
#else
		rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER,&transceiver);
#endif
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver, &readableCfg);
				strtok(readableCfg.buf, " ");
        *buffer = atof(readableCfg.buf);
    }
    else if(s == 5)
    {
        memset(&transceiver, 0, sizeof(transceiver));
        memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver);
		 _get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver, &readableCfg);
#else
		rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver);
#endif
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver, &readableCfg);
				strtok(readableCfg.buf, " ");
        *buffer = atof(readableCfg.buf);
    }
}

#ifdef CONFIG_E8B
void setupUniPortCapability(void)
{
	FILE *fp = NULL;
	char line[64] = {0};
	fp = fopen(PROC_UNI_CAPABILITY, "r");
	if (fp == NULL)
		return;

	char *delim = ";";
	char *pch = NULL;
	int portIdx = 0;
	rtk_port_phy_ability_t ability;
	rtk_port_phyAutoNegoAbility_get(portIdx, &ability);

	while (fgets(line, 64, fp))
	{
		if (line[0] == '#')
		{
			continue;
		}
		fclose(fp);

		printf("%s:%d line is %s\n", __FUNCTION__, __LINE__, line);
		pch = strtok(line, delim);
		while (pch != NULL)
		{
	  		printf("%s:%d pch is %s, port %d\n",__FUNCTION__, __LINE__, pch, portIdx);
			if (atoi(pch) == UNI_PORT_NONE)
			{
				ability.Half_10 = 0;
				ability.Full_10 = 0;
				ability.Half_100 = 0;
				ability.Full_100 = 0;
				ability.Half_1000 = 0;
				ability.Full_1000 = 0;
				rtk_port_phyAutoNegoAbility_set(portIdx, &ability);
			}
			else if (atoi(pch) == UNI_PORT_FE)
			{
				ability.Half_10 = 1;
				ability.Full_10 = 1;
				ability.Half_100 = 1;
				ability.Full_100 = 1;
				ability.Half_1000 = 0;
				ability.Full_1000 = 0;
				rtk_port_phyAutoNegoAbility_set(portIdx, &ability);
			}
			else if (atoi(pch) == UNI_PORT_GE)
			{
				ability.Half_10 = 1;
				ability.Full_10 = 1;
				ability.Half_100 = 1;
				ability.Full_100 = 1;
				ability.Half_1000 = 1;
				ability.Full_1000 = 1;
				rtk_port_phyAutoNegoAbility_set(portIdx, &ability);
			}

	  		pch = strtok(NULL, delim);
			portIdx++;
		} 
		break;
	}
}

int getUniPortCapability(int logPortId)
{
	FILE *fp = NULL;
	char line[64] = {0};
	fp = fopen(PROC_UNI_CAPABILITY, "r");
	if (fp == NULL)
		return -1;

	char *delim = ";";
	char *pch = NULL;
	int portIdx = RG_get_lan_phyPortId(logPortId);
	int i = 0;

	while (fgets(line, 64, fp))
	{
		if (line[0] == '#')
		{
			continue;
		}
		fclose(fp);

		printf ("%s:%d line is %s\n", __FUNCTION__, __LINE__, line);
		pch = strtok(line, delim);
		while (pch != NULL)
		{
	  		//printf ("%s:%d pch is %s\n",__FUNCTION__, __LINE__,pch);
	  		if (i == portIdx)
			{
				printf("%s:%d pch is %s, port is %d\n",__FUNCTION__, __LINE__,pch, portIdx);
				return atoi(pch);
	  		}
			
	  		pch = strtok(NULL, delim);
			i++;
		} 
		break;
	}
	return -1;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_SEREnable_
static unsigned long long pon_counter_ECPL_old[4];
static unsigned long long pon_counter_total_old[4];

enum {PON_COUNTER_SER=0, PON_COUNTER_PLR=1, PON_COUNTER_PacketLost=2, PON_COUNTER_ErrorCode=3,PON_COUNTER_MAX};
void reset_pon_stat_counters(){
	int i=0;
	for(i=0;i<PON_COUNTER_MAX;i++){
		pon_counter_total_old[i]=0;
		pon_counter_ECPL_old[i]=0;
	}
}
unsigned int get_pon_stat_counters(rtk_stat_port_cntr_t *counters)
{
#ifndef CONFIG_RTK_L34_ENABLE
	unsigned int port_pon_idx = 1;
	rtk_switch_phyPortId_get(RTK_PORT_PON, &port_pon_idx);
#endif
#ifdef CONFIG_RTK_L34_ENABLE
	rtk_rg_stat_port_getAll(RTK_RG_PORT_PON, counters);
#else
	rtk_stat_port_getAll(port_pon_idx, counters);
#endif
	return counters->etherStatsFragments+counters->etherStatsJabbers+counters->etherStatsRxOversizePkts+
		counters->etherStatsRxPkts64Octets+counters->etherStatsRxPkts512to1023Octets+counters->etherStatsRxPkts65to127Octets+
		counters->etherStatsRxPkts256to511Octets+counters->etherStatsRxPkts1519toMaxOctets+counters->etherStatsRxPkts128to255Octets+
		counters->etherStatsRxPkts1024to1518Octets;
}

void start_record_ser_errorCode(int flag)
{
	rtk_stat_port_cntr_t counters;
	memset(&counters, 0, sizeof(counters));
	switch(flag)
	{
		case PON_COUNTER_SER:
			pon_counter_total_old[PON_COUNTER_SER] = get_pon_stat_counters(&counters);
			pon_counter_ECPL_old[PON_COUNTER_SER] = counters.dot3StatsSymbolErrors;
			break;
		case PON_COUNTER_ErrorCode:
			pon_counter_total_old[PON_COUNTER_ErrorCode] = get_pon_stat_counters(&counters);
			pon_counter_ECPL_old[PON_COUNTER_ErrorCode] = counters.dot3StatsSymbolErrors;
			break;
		case PON_COUNTER_PLR:
			pon_counter_total_old[PON_COUNTER_PLR] = get_pon_stat_counters(&counters);
			pon_counter_ECPL_old[PON_COUNTER_PLR] = counters.dot1dTpPortInDiscards;
			break;
		case PON_COUNTER_PacketLost:
			pon_counter_total_old[PON_COUNTER_PacketLost] = get_pon_stat_counters(&counters);
			pon_counter_ECPL_old[PON_COUNTER_PacketLost] = counters.dot1dTpPortInDiscards;
			break;
		default:
			break;
	}
	
}

unsigned int getSER(int clear)
{
	rtk_stat_port_cntr_t counters;
	memset(&counters, 0, sizeof(counters));
	unsigned int total = get_pon_stat_counters(&counters);
	unsigned int ser = 0;
	if(total){
		if(total<=pon_counter_total_old[PON_COUNTER_SER]){
			reset_pon_stat_counters();
		}
		ser = (counters.dot3StatsSymbolErrors-pon_counter_ECPL_old[PON_COUNTER_SER])* 100 / (total-pon_counter_total_old[PON_COUNTER_SER]);
	}else
		ser = 0;	
	//printf("SER  %d  %d\n",ECPL_old[SER], total_old[SER]);
	if(clear)
		start_record_ser_errorCode(PON_COUNTER_SER);
	//printf("SER  %d  %d\n",ECPL_old[SER], total_old[SER]);
	return ser;
}
#endif
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_ErrorCodeEnable_
unsigned int getErrorCode(int clear)
{
	rtk_stat_port_cntr_t counters;
	memset(&counters, 0, sizeof(counters));
	unsigned int total = get_pon_stat_counters(&counters);
	if(total<=pon_counter_total_old[PON_COUNTER_ErrorCode]){
			reset_pon_stat_counters();
	}
	unsigned int error_code = counters.dot3StatsSymbolErrors - pon_counter_ECPL_old[PON_COUNTER_ErrorCode];
	//printf("ERRORCODE  %d  %d\n",ECPL_old[ErrorCode], total_old[ErrorCode]);
	if(clear)
		start_record_ser_errorCode(PON_COUNTER_ErrorCode);
	//printf("ERRORCODE  %d  %d\n",ECPL_old[ErrorCode], total_old[ErrorCode]);
	return error_code;
}
#endif
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_PLREnable_
unsigned int getPLR(int clear)
{
	rtk_stat_port_cntr_t counters;
	memset(&counters, 0, sizeof(counters));
	unsigned int total = get_pon_stat_counters(&counters);
	unsigned int plr = 0;
	if(total){
		if(total<=pon_counter_total_old[PON_COUNTER_PLR]){
			reset_pon_stat_counters();
		}
		plr=(counters.dot1dTpPortInDiscards-pon_counter_ECPL_old[PON_COUNTER_PLR]) * 100 / (total-pon_counter_total_old[PON_COUNTER_PLR]);
	}else
		plr = 0;
	//printf("PLR  %d  %d\n",ECPL_old[PLR], total_old[PLR]);
	if(clear)
		start_record_ser_errorCode(PON_COUNTER_PLR);
	//printf("PLR  %d  %d\n",ECPL_old[PLR], total_old[PLR]);
	return plr;
}
#endif
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_PacketLostEnable_
unsigned int getPacketLost(int clear)
{
	rtk_stat_port_cntr_t counters;
	memset(&counters, 0, sizeof(counters));
	unsigned int total = get_pon_stat_counters(&counters);
	if(total<=pon_counter_total_old[PON_COUNTER_PacketLost]){
			reset_pon_stat_counters();
	}
	unsigned int packet_lost = counters.dot1dTpPortInDiscards - pon_counter_ECPL_old[PON_COUNTER_PacketLost];
	//printf("PacketLost  %d  %d\n",ECPL_old[PacketLost], total_old[PacketLost]);
	if(clear)
		start_record_ser_errorCode(PON_COUNTER_PacketLost);
	//printf("PacketLost  %d  %d\n",ECPL_old[PacketLost], total_old[PacketLost]);
	return packet_lost;
}
#endif

#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_AllWirelessChannelEnable_) || defined(_PRMT_X_CT_COM_WirelessTestDiagnostics_)
int getWlan0AllChannel(char *allChannelBuf, int size)
{
	if(NULL == allChannelBuf)
	{
		printf("%s,error: parameter is NULL!\n", __FUNCTION__);
		return -1;
	}

	if(size < 64)
	{
		printf("%s,error: buffer should larger than 64!\n", __FUNCTION__);
		return -1;
	}

	char tmpBuf[64];
	char *pBuf = NULL;
	FILE *fp_tmp = NULL;
	int tmpLen = 0;
	
	if(!(fp_tmp = fopen("/var/wireless_neighbor_info", "r+")))
	{		
		printf("%s,error: can't open wireless_neighbor_info!\n", __FUNCTION__);
		return -1;
	}

	memset(tmpBuf, 0, sizeof(tmpBuf));
	fgets(tmpBuf, sizeof(tmpBuf), fp_tmp);
	pBuf = tmpBuf;
	pBuf = strstr(tmpBuf, "##");
	
	if(pBuf)
	{
		tmpLen = pBuf - tmpBuf - 1;
		strncpy(allChannelBuf, tmpBuf, tmpLen);
		allChannelBuf[tmpLen] = '\0';
		
	}
	else
	{
		strncpy(allChannelBuf, tmpBuf, sizeof(tmpBuf));
	}

	fprintf(stderr, "%s %d allChannelBuf=%s!\n",__FUNCTION__,__LINE__,allChannelBuf);
	fclose(fp_tmp);
	return 0;
}
#endif

#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_BestWirelessChannelEnable_) || defined(_PRMT_X_CT_COM_WirelessTestDiagnostics_)
int getWlan0BestChannel(char* bestChannelBuf, int size)
{
	if(NULL == bestChannelBuf)
	{
		printf("%s,error: parameter is NULL!\n", __FUNCTION__);
		return -1;
	}

	if(size < 8)
	{
		printf("%s,error: buffer should larger than 8!\n", __FUNCTION__);
		return -1;
	}

	char tmpBuf[64];
	char *pBuf = NULL;
	FILE *fp_tmp = NULL;
	
	if(!(fp_tmp = fopen("/var/wireless_neighbor_info", "r+")))
	{		
		printf("%s,error: can't open wireless_neighbor_info!\n", __FUNCTION__);
		return -1;
	}

	fgets(tmpBuf, sizeof(tmpBuf), fp_tmp);
	pBuf = strstr(tmpBuf, "##");

	if(pBuf)
	{
		strncpy(bestChannelBuf, pBuf + 2, 8);
	}
	else
	{
		fclose(fp_tmp);
		printf("bestChannel not Found in wireless_neighbor_info!\n", __FUNCTION__);
		return -1;
	}

	fprintf(stderr, "%s %d bestChannelBuf=%s!\n",__FUNCTION__,__LINE__,bestChannelBuf);
	fclose(fp_tmp);
	return 0;
}
#endif 

#ifdef  _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WirelessBandwidthEnable_
int getWlan0BandWidth(void)
{
	char vBandwidth, vTmpChar;
	int result;

	if(!check_wlan_module())
	{
		return -1;
	}
	mib_get( MIB_WLAN_CHANNEL_WIDTH, (void *)&vBandwidth);
	if(vBandwidth==1)
	{
		mib_get( MIB_WLAN_11N_COEXIST, (void *)&vTmpChar);
		if(vTmpChar)
			vBandwidth=3;
	}

	if(vBandwidth == 0) 
	{
		result = 20;
	}
	else
	{
		result = 40;
	}
fprintf(stderr, "%s %d result=%d!\n",__FUNCTION__,__LINE__,result);
	return result;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WirelessChannelNumberEnable_
int getWlan0CurChannel(char *curChannel)
{	
	if(NULL == curChannel)
	{
		printf("%s,error: parameter is NULL!\n", __FUNCTION__);
		return -1;
	}
		
	if(!check_wlan_module())
	{
		printf("%s,error: wlan0 module disabled!\n", __FUNCTION__);
		return -1;
	}
	
	bss_info	bss;
	getWlBssInfo(WLANIF[0], &bss);
	sprintf(curChannel, "%d", bss.channel);
		fprintf(stderr, "%s %d curChannel=%s!\n",__FUNCTION__,__LINE__,curChannel);
	return 0;
}
#endif

#ifdef  _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WirelessPowerEnable_
int getWlan0Power(void)
{
	unsigned char txpowerscale, phyband;
	int txpowervalue;

	if(!check_wlan_module())
	{
		return -1;
	}
	
	mib_local_mapping_get(MIB_TX_POWER, 0, (void *)&txpowerscale);
	mib_local_mapping_get(MIB_WLAN_PHY_BAND_SELECT, 0, (void *)&phyband);
	txpowervalue = get_TxPowerValue(phyband,txpowerscale);
fprintf(stderr, "%s %d txpowervalue=%d!\n",__FUNCTION__,__LINE__, txpowervalue);
	return txpowervalue;
}
#endif

#ifdef  _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_QosTypeEnable_
int getWlan0QosType(void)
{
	MIB_CE_MBSSIB_T Entry;
	mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry);
fprintf(stderr, "%s %d wmmEnabled=%d!\n",__FUNCTION__,__LINE__, Entry.wmmEnabled);
	return Entry.wmmEnabled;
}
#endif

#ifdef  _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WirelessTypeEnable_
int getWlan0SpecialBand(unsigned int wlanBand)
{
	switch (wlanBand) 
	{
		case 1: 
			return 0;		
		case 2: 
			return 1;
		case 3: 
			return 2;
		case 8: 
			return 3;
		case 10: 
			return 4;
		case 11: 
			return 5;
		default:
			return 6;
	}
}
const char* wlan0ModeStr[7] = {"b", "g", "bg", "n", "gn", "bgn","x" };
int getWlan0WirelessType(char* curWirlessType, int size)
{
	if(NULL == curWirlessType)	
	{
		printf("%s,error: parameter is NULL!\n", __FUNCTION__);
		return -1;
	}

	if(size < 4)
	{
		printf("%s,error: buffer should larger than 3!\n", __FUNCTION__);
		return -1;
	}

	if(!check_wlan_module())
	{
		return -1;
	}
	
	int index;
	MIB_CE_MBSSIB_T Entry;
	mib_chain_get(MIB_MBSSIB_TBL, 0, (void *)&Entry);
	index = getWlan0SpecialBand(Entry.wlanBand); 
	if(index > 6)
	{
		printf("%s,error: get invalid wlan0 band!\n", __FUNCTION__);
		return -1;
	}

	strcpy(curWirlessType, wlan0ModeStr[index]);
fprintf(stderr, "%s %d curWirlessType=%s!\n",__FUNCTION__,__LINE__,curWirlessType);
	return 0;	
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WorkingTimeEnable_
int getSysWorkingTime(void)
{
	struct sysinfo info;
	int upminutes;
	sysinfo(&info);		
	upminutes = (int) info.uptime / 60;
fprintf(stderr, "%s %d upminutes=%d!\n",__FUNCTION__,__LINE__,upminutes);
	return upminutes;
}
#endif

#ifdef _PRMT_SC_CT_COM_GroupCompanyService_Plugin_
int getPluginNameAndState(int instnum, char *pluginName, unsigned int *pluginState)
{
	FILE *fp;
	unsigned int stats, count = 0;
	char tmpbuf[1024], appname[1024];
	int nFound = 0;

	va_cmd("/bin/get_plugin_module", 0, 1);

	if(NULL == pluginName)
	{
		printf("%s,error:parameter pluginName is NULL!\n", __FUNCTION__);
		return -1;
	}

	if(NULL == pluginState)
	{
		printf("%s,error:parameter pluginState is NULL!\n", __FUNCTION__);
		return -1;
	}
	
	if ((fp = fopen("/tmp/applist_query", "r")) == NULL)
	{
		printf("error:%s can't open File applist_query!\n", __FUNCTION__);
		return -1;
	}
	
	while (fgets(tmpbuf, sizeof(tmpbuf), fp))
	{
		count ++;
		tmpbuf[strlen(tmpbuf) - 1] = '\0';
		memset(appname, '\0', 1024);
		sscanf(tmpbuf, "%s %u", appname, &stats);
		if(count == instnum)
		{
			strcpy(pluginName, appname);
			*pluginState = stats;
			nFound = 1;
			break;
		}
	}
	
	fclose(fp);

	if(nFound  == 1)
	{
		return 0;
	}
	return -2;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_PluginUpNumberEnable_
unsigned int getPluginUpNumber(void)
{
	FILE *fp;
	unsigned int stats, count = 0;
	char tmpbuf[1024], appname[1024];

	va_cmd("/bin/get_plugin_module", 0, 1);

	if ((fp = fopen("/tmp/applist_query", "r")) == NULL)
	{
		printf("error:%s can't open File applist_query!\n", __FUNCTION__);
		return 0;
	}

	while (fgets(tmpbuf, sizeof(tmpbuf), fp))
	{
		tmpbuf[strlen(tmpbuf) - 1] = '\0';
		memset(appname, '\0', 1024);
		sscanf(tmpbuf, "%s %u", appname, &stats);
		if(stats)
		{
			count++;
		}
	}

	fclose(fp);
fprintf(stderr, "%s %d count=%u!\n",__FUNCTION__,__LINE__,count);
	return count;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_PluginAllNumberEnable_
unsigned int getPluginAllNumber(void)
{
	FILE *fp;
	unsigned int count = 0;
	char tmpbuf[1024];
	
	va_cmd("/bin/get_plugin_module", 0, 1);
	
	if ((fp = fopen("/tmp/applist_query", "r")) == NULL)
	{
		printf("error:%s can't open File applist_query!\n", __FUNCTION__);
		return 0;
	}

	while (fgets(tmpbuf, sizeof(tmpbuf), fp))
	{
		count++;
	}

	fclose(fp);
fprintf(stderr, "%s %d PluginAllNum=%u!\n",__FUNCTION__,__LINE__,count);
	return count;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_
int IS_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_ON(int item_bit) {
	unsigned char val[8];
	if(mib_get(PROVINCE_CWMP_PERFORMANCE_REPORT_SUBITEM,&val)){
		if(val[item_bit/8]&(1<<(item_bit%8)))
			return 1;
	}
	return 0;
}

int SET_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM(int item_bit, int enable) {
	unsigned char val[8];
	if(mib_get(PROVINCE_CWMP_PERFORMANCE_REPORT_SUBITEM,&val)){
		if(enable)
		{
			val[item_bit/8] = val[item_bit/8] | (1 << (item_bit%8));
		}
		else
		{
			val[item_bit/8] = val[item_bit/8] & ~(1 << (item_bit%8));
		}
		mib_set(PROVINCE_CWMP_PERFORMANCE_REPORT_SUBITEM,(void *) &val);
	}
	return 0;
}
#endif
#ifdef CONFIG_USER_OPENJDK8
/*
	Edit /var/osgi_app/config.properties before java start
*/
int setupOsgiAutoStart(void)
{
	MIB_CMCC_OSGI_PLUGIN_T Entry;
	int i, mibtotal;
	char cmd[2048]={0};
	char cmd1[512]={0};
	int configured = 0;
	char osgi_web_enable = 0;
	
	mibtotal = mib_chain_total(MIB_CMCC_OSGI_PLUGIN_TBL);

	mib_get(MIB_OSGI_APACHE_WEB_ENABLE, (void *)&osgi_web_enable);
	if(osgi_web_enable==1){
		system("/bin/touch /tmp/osgi_web_apache_enable");
	}
	system("cp -rf /usr/local/class/felix/conf/config.properties /var/osgi_app/config.properties");
	
	//put non-preinstall bundles in the start level 3, because preinstall bundles will stuck other bundles
	for(i=0;i<mibtotal;i++){
		if(!mib_chain_get(MIB_CMCC_OSGI_PLUGIN_TBL, i, (void *)&Entry))
			continue;
		if(configured==0){
			sprintf(cmd, "echo \"felix.auto.start.3= \"");
			configured=1;
		}

		if(strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.andlink") !=0 && 
			strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.cmccdpi") !=0 && 
			strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.cmccdpi2") !=0 &&
			strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.appcore") !=0 && 
			Entry.auto_start==1){
			if(i != (mibtotal-1))
				sprintf(cmd1, " \"file:%s \"", Entry.path);
			else
				sprintf(cmd1, " \"file:%s\"", Entry.path);
			strcat(cmd, cmd1);
		}
	}

	if(cmd[0]){
		sprintf(cmd1, " >> /var/osgi_app/config.properties");
		strcat(cmd, cmd1);
		//printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### 1 cmd %s\033[m\n", cmd);
		system(cmd);
	}

	//put preinstall bundles in the start level 4
	configured = 0;
	for(i=0;i<mibtotal;i++){
		if(!mib_chain_get(MIB_CMCC_OSGI_PLUGIN_TBL, i, (void *)&Entry))
			continue;
		if(configured==0){
			sprintf(cmd, "echo \"felix.auto.start.4= \"");
			configured=1;
		}

		if((strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.andlink") ==0 || 
			strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.cmccdpi") ==0 || 
			strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.cmccdpi2") ==0 || 
			strcmp(Entry.symbolic_name, "com.chinamobile.smartgateway.appcore") ==0) &&
			Entry.auto_start==1){
			if(i != (mibtotal-1))
				sprintf(cmd1, " \"file:%s \"", Entry.path);
			else
				sprintf(cmd1, " \"file:%s\"", Entry.path);
			strcat(cmd, cmd1);
		}
	}
	
	if(cmd[0]){
		sprintf(cmd1, " >> /var/osgi_app/config.properties");
		strcat(cmd, cmd1);
		//printf("\033[1;33;40m @@@@@@@@@@@@@@@@@########### 2 cmd %s\033[m\n", cmd);
		system(cmd);
	}
}
#endif

unsigned int getInternetIPv4WANIfindex(void)
{
	int totalNum=0;
	int i,ret=0;
	MIB_CE_ATM_VC_T Entry={0};

	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{ 
			continue;
		}

		if((Entry.enable == 1)&&(Entry.applicationtype&X_CT_SRV_INTERNET)&&
			(Entry.IpProtocol & IPVER_IPV4)&&(Entry.cmode != CHANNEL_MODE_BRIDGE))
		{
			return Entry.ifIndex;
		}
	}
	return DUMMY_IFINDEX;
}

#ifdef CONFIG_CMCC_IPV6_SECURITY_SUPPORT
void del_bridge_ip6sec_prefix_info(MIB_CE_ATM_VC_T*old, MIB_CE_ATM_VC_T*new)
{
	if((old->cmode == CHANNEL_MODE_BRIDGE) && (old->IpProtocol&IPVER_IPV6) && old->itfGroup)
	{
		int portmask=0;
		char cmdstr[64];
		unsigned short delitfgroup=0;

		if(!new || (old->cmode != new->cmode) || !(new->IpProtocol &IPVER_IPV6))
			delitfgroup = old->itfGroup;
		else if(old->itfGroup != new->itfGroup)
			delitfgroup = ((old->itfGroup)^(new->itfGroup))&(old->itfGroup);
		if(delitfgroup)
		{
#if defined(CONFIG_LUNA) && defined(CONFIG_RTK_L34_ENABLE)
			portmask = RG_get_lan_phyPortMask(delitfgroup&0xf)|((delitfgroup&0x1f0)?(1<<RTK_RG_EXT_PORT0):0)|((delitfgroup&0x3e00)?(1<<RTK_RG_EXT_PORT1):0);
#endif
			sprintf(cmdstr, "/bin/ip6sec_ctrl -D -p 0x%x", portmask);
			system(cmdstr);
		}
	}
}
#endif

#if defined(CONFIG_CMCC_MULTICAST_CROSS_VLAN_SUPPORT) && defined(CONFIG_RTK_L34_ENABLE)
int set_multicast_cross_vlan()
{
	int ret = 0;
	MIB_MULTICAST_CROSS_VLAN_T entry;

	RG_flush_multicastCrossVlan();
	if(mib_chain_get(MIB_MULTICAST_CROSS_VLAN_TBL, 0, (void*)&entry))
	{
		if(entry.cross_vlan0 > 0)
			RG_add_multicastCrossVlan(entry.cross_vlan0, 1);
		if(entry.cross_vlan1 > 0)
			RG_add_multicastCrossVlan(entry.cross_vlan1, 2);
		if(entry.cross_vlan2 > 0)
			RG_add_multicastCrossVlan(entry.cross_vlan2, 4);
		if(entry.cross_vlan3 > 0)
			RG_add_multicastCrossVlan(entry.cross_vlan3, 8);
	}
	return ret;
}
#endif

#if (defined(CONFIG_CMCC) || defined(CONFIG_CU)) && defined(CONFIG_IPV6)
int ipv6_binding_update(void)
{
	int i, entryTotal, totalEntry, rg_wan_idx = 0, ret = 0;
	MIB_IPV6_BINDING_T entry;
	MIB_CE_ATM_VC_T Entry;

	totalEntry = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<totalEntry; i++) { 
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			return -1;
		if (Entry.dgw == 1) {
			rg_wan_idx = Entry.rg_wan_idx;
			break;
		}
	}
	//clear rules
	RG_flush_ipv6_binding_rules();
	entryTotal = mib_chain_total(MIB_IPV6_BINDING);
	//add rules
	for(i=0 ; i<entryTotal ; i++)
	{
		if (!mib_chain_get(MIB_IPV6_BINDING, i, (void *)&entry)) {
			printf("get mib chain error!\n");
			return 0;
		}
		RG_add_ipv6_binding_rules(&entry, rg_wan_idx);
	}
	if(entryTotal > 0)
		RG_add_drop_all_rules();
	return 1;
}

int set_vlan_cfg_action(int v4OldID, int v6OldID)
{
	char ipv6_vlan_enable;
	int ret;
	int v4ID, v6ID;	
	if(mib_get(MIB_IPV6_VLAN_ENABLE,(void *)&ipv6_vlan_enable)==0)
	{
		printf("get mib error!/n");
		return 0;
	}
	mib_get(MIB_IPV4_VLAN_ID, (void *)&v4ID);
	mib_get(MIB_IPV6_VLAN_ID, (void *)&v6ID);
	if(ipv6_vlan_enable == 0)
	{
		//clear cvlan and acl rules
		ret = Clear_Vlan_Cfg();//disable vlan 
		RG_WAN_CVLAN_DEL(v4ID);
		RG_WAN_CVLAN_DEL(v6ID);
	}
	else
	{
		//clear cvlan and acl rules 
		ret = Clear_Vlan_Cfg();
		RG_WAN_CVLAN_DEL(v4OldID);
		RG_WAN_CVLAN_DEL(v6OldID);
		//add vlan and acl rule
		Add_Cvlan_IPv4_IPv6(v4ID, v6ID);	
		Add_ACL_Vlan_Cfg(v4ID, v6ID);
	}
	return ret;
}
#endif

#ifdef SUPPORT_URL_FILTER
void DeleteSplitcharFromURLFilter(char *macstring, char *macstring2)
{
	char *pch = NULL;
	char tmp[20]={0};
	char tmpmacstring[512]={0};
	char backmacstring[512]={0};
	unsigned char macAddr[MAC_ADDR_LEN];
	
	if((macstring == NULL) || (macstring2 == NULL) || (strlen(macstring) == 0))
		return ;

	strncpy(backmacstring, macstring, sizeof(backmacstring)-1);
	if(strstr(backmacstring, ","))
	{
		pch = strtok(backmacstring, ",");
		while (pch != NULL)
		{	
			changeMacFormat(pch,':','-');
			changeStringToMac(macAddr, pch);
			snprintf(tmp, sizeof(tmp), "%02x%02x%02x%02x%02x%02x,", 
				macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
			strcat(tmpmacstring, tmp);
			pch = strtok(NULL, ",");
		} 

		strncpy(macstring2, tmpmacstring, strlen(tmpmacstring)-1);
	}
	else
	{
		changeMacFormat(backmacstring,':','-');
		changeStringToMac(macAddr, backmacstring);
		snprintf(macstring2, 512, "%02x%02x%02x%02x%02x%02x", 
				macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
	}
}

void changeMacstringForURUFilter(char *macstring, char *macstring2)
{
	char *pch = NULL;
	char tmp[20]={0};
	char tmpmacstring[512]={0};
	char backmacstring[512]={0};
	unsigned char macAddr[MAC_ADDR_LEN];
	
	if((macstring == NULL) || (macstring2 == NULL))
		return ;

	strncpy(backmacstring, macstring, sizeof(backmacstring)-1);
	if(strstr(backmacstring, ","))
	{
		pch = strtok(backmacstring, ",");
		while (pch != NULL)
		{	
			string_to_hex(pch, macAddr, 12);
			snprintf(tmp, sizeof(tmp), "%02x:%02x:%02x:%02x:%02x:%02x,", 
				macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
			strcat(tmpmacstring, tmp);
			pch = strtok(NULL, ",");
		} 

		strncpy(macstring2, tmpmacstring, strlen(tmpmacstring)-1);
	}
	else
	{
		string_to_hex(backmacstring, macAddr, 12);
		snprintf(macstring2, 512, "%02x:%02x:%02x:%02x:%02x:%02x", 
		macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
	}
}
#endif

#ifdef SUPPORT_DNS_FILTER
int UpdateDNSFilterBlocktime(char *name, char *url, int blocktime)
{
	int len=0, ret = 0;
	FILE *fp=NULL;
	FILE *fp2=NULL;
	char line[512]={0};
	char buf[512]={0};
	struct stat st;

	if(url == NULL || name == NULL)
		return -1;
	
	if(stat(DNSFILTERFILENAME, &st) && st.st_size == 0) 
	{
		fp = fopen(DNSFILTERFILENAME, "w");
		if(fp)
		{
			fprintf(fp, "%s|%s|%d\n", name, url, blocktime);
			fclose(fp);
			return 0;
		}
	}
	
	fp = fopen(DNSFILTERFILENAME, "r");
	fp2 = fopen(TMPDNSFILTERFILENAME, "w");

	if(!fp || !fp2){
		if(fp) fclose(fp);
		if(fp2) fclose(fp2);
		return -1;
	}
	sprintf(buf, "%s|%s|", name, url);
	len = strlen(buf);
	while (!feof(fp))
	{
		fgets(line, sizeof(line)-1, fp);
		
		if(ret == 0 && strncmp(line, buf, len) == 0)
		{
			fprintf(fp2, "%s|%s|%d\n", name, url, blocktime);
			ret = 1;
		}
		else
		{
			fputs(line, fp2);
		}
	}

	if(ret == 0)
	{
		fprintf(fp2, "%s|%s|%d\n", name, url, blocktime);
	}

	fclose(fp);
	fclose(fp2);
	
	unlink(DNSFILTERFILENAME);
	rename(TMPDNSFILTERFILENAME, DNSFILTERFILENAME);

	return 1;
}

int getDNSFilterBlockedTimes(char *name, char *url)
{
	int len, ret = 0;
	FILE *fp;
	char line[512]={0};
	char buf[512]={0}, *tmp;
	struct stat st;

	if(name == NULL || url == NULL)
		return 0;
	
	if(stat(DNSFILTERFILENAME, &st) && st.st_size == 0) 
	{
		return 0;
	}

	fp = fopen(DNSFILTERFILENAME, "r");
	if (fp == NULL)
	{
		printf("ERROR: error to file open %s.\n", DNSFILTERFILENAME);
		return 0;
	}
	else
	{
		sprintf(buf, "%s|%s|", name, url);
		len = strlen(buf);
		while (!feof(fp))
		{
			fgets(line, sizeof(line)-1, fp);
			
			if(strncmp(line, buf, len) == 0)
			{
				tmp = strrchr(line, '|');
				if(tmp) ret = atoi(tmp+1);
				break;
			}
		}
	}
	fclose(fp);

	return (ret<0)?0:ret;
}
#endif

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
int getWebLoidPageEnable(void)
{
	char enable;
	mib_get(MIB_WEB_LOID_PAGE_ENABLE,(void *)&enable);
	if(enable==1){
		return 1;
	}
	else{
		return 0;
	}
}

int getWebPasswordPageEnable()
{
	char enable;
	mib_get(CWMP_GUI_PASSWORD_ENABLE,(void *)&enable);
	if(enable==1){
		return 1;
	}
	else{
		return 0;
	}
}
#endif

#ifdef CONFIG_USER_OPENJDK8
void setupOsgiPrebundlePath(void)
{
	char cmccdpiPath[128] = {0};
	char appcorePath[128] = {0};
	char andlinkPath[128] = {0};
	char cmd[512] = {0};

	mib_get(MIB_OSGI_BUNDLE_CMCCDPI_PATH,(void *)cmccdpiPath);
	mib_get(MIB_OSGI_BUNDLE_APPCORE_PATH,(void *)appcorePath);
	mib_get(MIB_OSGI_BUNDLE_ANDLINK_PATH,(void *)andlinkPath);

	if(cmccdpiPath[0] != '#'){
		system("rm -rf /var/osgi_app/bundle/com.chinamobile.smartgateway.cmccdpi.jar");
		sprintf(cmd, "ln -s %s /var/osgi_app/bundle/com.chinamobile.smartgateway.cmccdpi.jar", cmccdpiPath);
		system(cmd);
	}

	if(appcorePath[0] != '#'){
		system("rm -rf /var/osgi_app/bundle/com.chinamobile.smartgateway.appcore.jar");
		sprintf(cmd, "ln -s %s /var/osgi_app/bundle/com.chinamobile.smartgateway.appcore.jar", appcorePath);
		system(cmd);
	}

	if(andlinkPath[0] != '#'){
		system("rm -rf /var/osgi_app/bundle/com.chinamobile.smartgateway.andlink.jar");
		sprintf(cmd, "ln -s %s /var/osgi_app/bundle/com.chinamobile.smartgateway.andlink.jar", andlinkPath);
		system(cmd);
	}
}
#endif

#ifdef CONFIG_YUEME
//cxy 2018-4-2: patch for webinspect scan: Parameter Based Redirection to unknow url
int checkValidRedirect(char*redirecturl, char** checklist)
{
	if(redirecturl == NULL || checklist == NULL)
		return 1;
	while(*checklist != NULL)
	{
		if(strstr(redirecturl, *checklist))//valid redirect
			return 1;
		checklist++;
	}
	return 0;
}
#endif

#ifdef DOMAIN_BLOCKING_SUPPORT
char *accept_query_url_list[]= 
{
	"example.com",
	NULL
};
void filter_set_domain_default(void)
{
	int i;
	unsigned char sdest[MAX_DOMAIN_LENGTH];
	int j, k;
	unsigned char *needle_tmp, *str;
	char len[MAX_DOMAIN_GROUP];
	unsigned char seg[MAX_DOMAIN_GROUP][MAX_DOMAIN_SUB_STRING];
	unsigned char cmpStr[MAX_DOMAIN_LENGTH]="\0";
	unsigned char temp_accept_query_url[MAX_DOMAIN_SUB_STRING];
	unsigned char root_NS_query[10] = {0x00, 0x00, 0x02, 0x00, 0x01, 0xff};

	// Add policy to domainblk chain
	for (i=0; accept_query_url_list[i]; i++) {		
		sprintf(temp_accept_query_url, "%s", accept_query_url_list[i]);
		needle_tmp = temp_accept_query_url;
		for (j=0; (str =strchr(needle_tmp, '.'))!= NULL; j++)
		{
			*str = '\0';
			strncpy(seg[j]+1, needle_tmp, (MAX_DOMAIN_SUB_STRING - 1));
			seg[j][MAX_DOMAIN_SUB_STRING - 1]='\0';
			//printf(" seg[%d]= %s...(1)\n", j, seg[j]);

			//seg[j][0]= len[j];
			seg[j][0] = strlen(needle_tmp);
			//printf(" seg[%d]= %s...(2)\n", j, seg[j]);

			needle_tmp = str+1;
		}

		// calculate the laster domain sub string lengh and form the laster compare sub string
		strncpy(seg[j]+1, needle_tmp, (MAX_DOMAIN_SUB_STRING - 1));
		seg[j][MAX_DOMAIN_SUB_STRING - 1]='\0';

		seg[j][0]= strlen(needle_tmp);
		//printf(" seg[%d]= %s...(3)\n", j, seg[j]);
		
		// Merge the all compare sub string into a final compare string.
		for ( k=0; k<=j; k++) {
			//printf(" seg[%d]= %s", k, seg[k]);
			strcat(cmpStr, seg[k]);
			//printf(" cmpStr=%s\n", cmpStr);
		}
		//printf("\n");

	 	// iptables -A domainblk -p udp --dport 53 -m string --domain yahoo.com -j DROP
		va_cmd(IPTABLES, 14, 1, (char *)FW_ADD, "domainblk", "-p", "udp", "--dport", "53", "-m", "string", "--domain", cmpStr, "--algo", "bm", "-j", (char *)FW_DROP);
#ifdef CONFIG_IPV6
		va_cmd(IP6TABLES, 14, 1, (char *)FW_ADD, "domainblk", "-p", "udp", "--dport", "53", "-m", "string", "--domain", cmpStr, "--algo", "bm", "-j", (char *)FW_DROP);
#endif
		cmpStr[0] = '\0';
	}

	// Add policy to domainblk chain for root NS query
	// iptables -A domainblk -p udp --dport 53 -m string --hex-string "|001000010000000000000000020001|" --algo bm -j DROP
	system("iptables -A domainblk -p udp --dport 53 -m string --hex-string \"|001000010000000000000000020001|\" --algo bm -j DROP");
#ifdef CONFIG_IPV6
	system("ip6tables -A domainblk -p udp --dport 53 -m string --hex-string \"|001000010000000000000000020001|\" --algo bm -j DROP");
#endif
}
#endif

#if defined _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_UpDataEnable_ || defined _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_DownDataEnable_
static int getLanPortApplication(int pmap, char* application, int size)
{
	int i = 0;
	int apptype = 0;
	int total_entries = 0;
	int found = 0;
	MIB_CE_ATM_VC_T vc_entry;

	total_entries = mib_chain_total(MIB_ATM_VC_TBL);

	for(i = 0; i < total_entries; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&vc_entry))
		continue;

		if(vc_entry.itfGroup & (1 << pmap))
		{
			found = 1;
			break;	
		}
	}

	if(found)
	{
		switch(vc_entry.applicationtype)
		{
			case	X_CT_SRV_OTHER:
				snprintf(application, size, "iTV");
				break;
			default:
				snprintf(application, size, "Internet");
		}
	}
	else
		snprintf(application, size, "Internet");

	return 0;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_UpDataEnable_
unsigned long lan_rx_old[ELANVIF_NUM] = {0};
unsigned long wlan_rx_old = 0;
int getUpData(char *data, int size, int clear)
{
	unsigned long rx_bytes_cycle = 0;
	int logicPortId = 0;
	int offset = 0;
	char apptype[32] = {0};
	float bytes = 0, base = 1048576;
	unsigned long tx_pkts,tx_drops,tx_errs,rx_pkts,rx_drops,rx_errs;
	unsigned long long int tx_bytes,rx_bytes;
	struct net_device_stats nds;

	if(NULL == data)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 64)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;	
	}

	get_wlan_net_device_stats(getWlanIfName(), &nds);
	rx_bytes_cycle =  nds.rx_bytes - wlan_rx_old;
	bytes = rx_bytes_cycle/base;
	if(clear)
		wlan_rx_old = nds.rx_bytes;
	getLanPortApplication(PMAP_WLAN0, apptype, sizeof(apptype));
	snprintf(data+offset, size-offset, "WLAN:%s:%.3f-", apptype, bytes);
	offset = strlen(data);	

	for(logicPortId = 0 ; logicPortId < ELANVIF_NUM; logicPortId++)
	{

		if(RG_get_portCounter(logicPortId,&tx_bytes,&tx_pkts,&tx_drops,&tx_errs,&rx_bytes,&rx_pkts,&rx_drops,&rx_errs) == 0 ){
			// get fail , assign all counter to 0
			tx_pkts = tx_drops = tx_errs = rx_pkts = rx_drops = rx_errs = 0;
			tx_bytes = rx_bytes = 0;
		}

		//printf("%s, rx_bytes is %d, lan_tx_old[logicPortId] is %d\n", __FUNCTION__, rx_bytes, lan_rx_old[logicPortId]);
		rx_bytes_cycle = rx_bytes - lan_rx_old[logicPortId];
		//printf("%s, rx_bytes_cycle is %d\n", __FUNCTION__, rx_bytes_cycle);
		bytes = rx_bytes_cycle/base;
		if(clear)
			lan_rx_old[logicPortId] = rx_bytes;
		getLanPortApplication(logicPortId, apptype, sizeof(apptype));
		snprintf(data+offset, size-offset, "LAN%d:%s:%.3f-", logicPortId+1, apptype, bytes);
		offset = strlen(data);
	}

	data[offset-1] = 0;
fprintf(stderr, "%s %d updata=%s!\n",__FUNCTION__,__LINE__,data);
	return 0;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_DownDataEnable_
unsigned long lan_tx_old[ELANVIF_NUM] = {0};
unsigned long wlan_tx_old = 0;
int getDownData(char *data, int size, int clear)
{
	unsigned long tx_bytes_cycle = 0;
	int logicPortId = 0;
	int offset = 0;
	char apptype[32] = {0};
	float bytes = 0, base = 1048576;
	unsigned long tx_pkts,tx_drops,tx_errs,rx_pkts,rx_drops,rx_errs;
	unsigned long long int tx_bytes,rx_bytes;
	struct net_device_stats nds;

	if(NULL == data)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 64)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;
	}

	get_wlan_net_device_stats(getWlanIfName(), &nds);
	tx_bytes_cycle =  nds.tx_bytes - wlan_tx_old;
	bytes = tx_bytes_cycle/base;
	if(clear)
		wlan_tx_old = nds.tx_bytes;
	getLanPortApplication(PMAP_WLAN0, apptype, sizeof(apptype));
	snprintf(data+offset, size-offset, "WLAN:%s:%.3f-", apptype, bytes);
	offset = strlen(data);


	for(logicPortId = 0 ; logicPortId < ELANVIF_NUM; logicPortId++)
	{

		if(RG_get_portCounter(logicPortId,&tx_bytes,&tx_pkts,&tx_drops,&tx_errs,&rx_bytes,&rx_pkts,&rx_drops,&rx_errs) == 0 ){
			// get fail , assign all counter to 0
			tx_pkts = tx_drops = tx_errs = rx_pkts = rx_drops = rx_errs = 0;
			tx_bytes = rx_bytes = 0;
		}

		//printf("%s, tx_bytes is %d, lan_tx_old[logicPortId] is %d\n", __FUNCTION__, tx_bytes, lan_tx_old[logicPortId]);
		tx_bytes_cycle = tx_bytes - lan_tx_old[logicPortId];
		//printf("%s, tx_bytes_cycle is %d\n", __FUNCTION__, tx_bytes_cycle);
		bytes = tx_bytes_cycle/base;
		if(clear)
			lan_tx_old[logicPortId] = tx_bytes;
		getLanPortApplication(logicPortId, apptype, sizeof(apptype));
		snprintf(data+offset, size-offset, "LAN%d:%s:%.3f-", logicPortId+1, apptype, bytes);
		offset = strlen(data);
	}

	data[offset-1] = 0;
fprintf(stderr, "%s %d downdata=%s!\n",__FUNCTION__,__LINE__,data);
	return 0;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_LANxStateEnable_
int getLANxState(char *state, int size)
{
	rtk_port_linkStatus_t eStatus;
	int offset = 0;
	int LogicPort = 0;
	int phyPort = 0;
	int wlan_enable = 0;
	unsigned char vchar;

	if(NULL == state)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 64)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;	
	}

	//OUTPUT sample:"LANw:1-LAN1:1-LAN2:0-LAN3:0-LAN4:0"

	mib_get(MIB_WIFI_MODULE_DISABLED, (void *)&vchar);
	snprintf(state+offset, size-offset, "LANw:%d-", vchar?0:1);
	offset = strlen(state);
	
	for(LogicPort = 0; LogicPort < ELANVIF_NUM; LogicPort++)
	{
		phyPort = RG_get_lan_phyPortId(LogicPort);
		rtk_port_link_get(phyPort, &eStatus);
		snprintf(state+offset, size-offset, "LAN%d:%d-", LogicPort+1, eStatus);

		offset = strlen(state);
	}

	state[offset-1] = 0;
fprintf(stderr, "%s %d state=%s!\n",__FUNCTION__,__LINE__,state);
	return 0;

}
#endif

#ifdef TERMINAL_INSPECTION_SC
int getLANxStateTerminal(char *state, int size)
{
	rtk_port_linkStatus_t eStatus;
	int offset = 0;
	int LogicPort = 0;
	int phyPort = 0;
	int wlan_enable = 0;
	unsigned char vchar;

	if(NULL == state)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 64)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;	
	}
	
	for(LogicPort = 0; LogicPort < ELANVIF_NUM; LogicPort++)
	{
		phyPort = RG_get_lan_phyPortId(LogicPort);
		rtk_port_link_get(phyPort, &eStatus);
		snprintf(state+offset, size-offset, "LAN%d:%s  ", LogicPort+1, eStatus?"":"");

		offset = strlen(state);
	}

	state[offset-1] = 0;

	return 0;

}

#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_LANxWorkBandwidthEnable_
int getLANxWorkBandwidth(char *bandwith, int size)
{
	int offset = 0;
	int logicPort = 0;
	int uni_capability = 0;
	int speed = 0;

	if(NULL == bandwith)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 64)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;
	}

	for(logicPort = 0; logicPort < ELANVIF_NUM; logicPort++)
	{
		uni_capability =  getUniPortCapability(logicPort);

		switch(uni_capability)
		{
			case	UNI_PORT_FE:
				speed = 100;
				break;
			case 	UNI_PORT_GE:
				speed = 1000;
				break;
		}

		snprintf(bandwith+offset, size-offset, "LAN%d:%d-",logicPort+1, speed);

		offset = strlen(bandwith);

		//printf("%s, offset is %d, bandwith is %s\n", __FUNCTION__, offset, bandwith);

		
		if(offset > size)	
		{
			printf("%s,error: buffer should larger than 64!", __FUNCTION__);
			return -1;
		}
	}

	bandwith[offset-1] = 0;
fprintf(stderr, "%s %d bandwidth=%s!\n",__FUNCTION__,__LINE__,bandwith);
	return 0;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_AllDeviceNumberEnable_
int getAllDeviceNumber(void)
{
	int logicPortId = 0;
	int macidx = 0;
	int i = 0;
	unsigned int count=0, lanNetCnt = 0;
	rtk_rg_macEntry_t macEntry;
	lanHostInfo_t *pLanNetInfo=NULL;

	//add Lan port client
	for(logicPortId = 0; logicPortId < ELANVIF_NUM; logicPortId++)
	{
		macidx = 0;
		while (RT_ERR_RG_OK == rtk_rg_macEntry_find(&macEntry, &macidx))
		{
			if (macEntry.port_idx == RG_get_lan_phyPortId(logicPortId)) {
				count++;
			}
			macidx++;
			memset(&macEntry, 0, sizeof(rtk_rg_macEntry_t));
		}
	}

	//add wlan client
	get_lan_net_info(&pLanNetInfo, &lanNetCnt);

	for(i = 0; i < lanNetCnt; i++)
	{
		if(pLanNetInfo[i].connectionType != 1)
			continue;

		count++;
	}

	if(pLanNetInfo)
		free(pLanNetInfo);

	fprintf(stderr, "%s %d alldeviceNum=%u!\n",__FUNCTION__,__LINE__,count);
	
	return count;
}
#endif

#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WLANDeviceMACEnable_) || defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_LANDeviceMACEnable_) 
unsigned int sessCnt[256] = {0};
static int getEveryClientSessionCnt(void)
{
	int i = 0, retval = 0;
	rtk_l34_naptInbound_entry_t asic_intcpudp;

	memset(sessCnt, 0, sizeof(int)*256);

	for(i = 0; i < MAX_NAPT_IN_HW_TABLE_SIZE; i++)
	{
       retval = rtk_l34_naptInboundTable_get(i, &asic_intcpudp);
        if (retval == FAIL)
            continue;

        if (asic_intcpudp.valid != 0)
        {
			sessCnt[asic_intcpudp.intIp&0x000000ff]++;
        }		
	}

	return 0;
}


//struct stClientDhcpOptions content should follow the write_leases(files.c) in udhcpd 
struct stClientDhcpOptions   
{
	u_int8_t chaddr[16];
	u_int32_t yiaddr;		/* network order */
	u_int32_t expires;		/* host order */
	u_int32_t interfaceType;
	u_int8_t hostName[64];
	int category;
	int isCtcVendor;
	char szVendor[36];
	char szModel[36];
	char szFQDN[64];
};

//caller should free client_options if it is not null.
static int getEveryClientOptions(struct stClientDhcpOptions **client_options)
{
	char *buf = NULL;
	int lockfd = -1;
	FILE *fp;
	int pid;
	int lease_cnt = 0;
	struct stat status;
	unsigned long leaseFileSize;

	// siganl DHCP server to update lease file
	pid = read_pid(DHCPSERVERPID);
	if (pid > 0) {
		kill(pid, SIGUSR1);
		usleep(1000);
	}

	if ((lockfd = lock_file_by_flock(DHCPSERVERPID, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		goto err;
	}

	if (stat(DHCPD_LEASE, &status) < 0)
		goto err;

	// read DHCP server lease file
	leaseFileSize = (unsigned long)(status.st_size);
	//printf("leasefilesize is %d\n", leaseFileSize);
	
	buf = malloc(leaseFileSize);
	if (buf == NULL)
		goto err;

	fp = fopen(DHCPD_LEASE, "r");

	if (fp == NULL)
		goto err;

	fread(buf, leaseFileSize, 1, fp);
	fclose(fp);

	*client_options = (struct stClientDhcpOptions *)buf;
	lease_cnt = leaseFileSize/sizeof(struct stClientDhcpOptions);
	//printf("lease_cnt is %d\n", lease_cnt);
	
	if(-1 != lockfd)
		unlock_file_by_flock(lockfd);
	
	return lease_cnt;

	err:
		if (buf)
			free(buf);

		if(-1 != lockfd)
			unlock_file_by_flock(lockfd);
	
	return 0;
}

enum DeviceType
{
	CTC_Computer=0,
	CTC_Camera,
	CTC_HGW,
	CTC_STB,
	CTC_PHONE,
	CTC_UNKNOWN=100
};

static int getCategoryString(int type, char *name, int size)
{
	if(NULL == name)
		return -1;
	
	switch(type)
	{
		case CTC_Computer:
			snprintf(name, size, "Computer");
			break;
		case CTC_Camera:
			snprintf(name, size, "Camera");
			break;
		case CTC_HGW:
			snprintf(name, size, "HGW");
			break;
		case CTC_STB:
			snprintf(name, size, "STB");
			break;
		case CTC_PHONE:
			snprintf(name, size, "PHONE");
			break;
		case CTC_UNKNOWN:
		default:
			snprintf(name, size, "NONE");
	}

	return 0;
}

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WLANDeviceMACEnable_
int  signalStrength[256] = {0};
static int getEveryClientSignalStrength(void)
{
	int i = 0, j = 0;
	int x = 0, y = 0;
	char *buff;
	unsigned int count;
	lanHostInfo_t *pLanNetInfo=NULL;
	WLAN_STA_INFO_Tp pInfo;
	char ifname[16];

	get_lan_net_info(&pLanNetInfo, &count);

	buff = calloc(1, sizeof(WLAN_STA_INFO_T) * (MAX_STA_NUM + 1));

	for (x=0; x<NUM_WLAN_INTERFACE; x++)
	{
		for(y=0; y<=WLAN_MBSSID_NUM; y++)
		{
			memset(buff, 0, sizeof(WLAN_STA_INFO_T) * (MAX_STA_NUM + 1));
			if(y==0)
				snprintf(ifname, 16, "%s", WLANIF[x]);
			else
				snprintf(ifname, 16, "%s-vap%d", WLANIF[x], y-1);

			if (getInFlags(ifname, 0)==0){
				continue;
			}
			if (getWlStaInfo(ifname, (WLAN_STA_INFO_Tp) buff) < 0) {
				printf("Read wlan sta info failed!\n");
				continue;
			}

			for (i = 1; i <= MAX_STA_NUM; i++) {
				pInfo = (WLAN_STA_INFO_Tp) & buff[i * sizeof(WLAN_STA_INFO_T)];
				if (pInfo->aid && (pInfo->flag & STA_INFO_FLAG_ASOC))
				{
					/*printf("[%s]wireless client MAC:%02X:%02X:%02X:%02X:%02X:%02X", __FUNCTION__,
							pInfo->addr[0], pInfo->addr[1],pInfo->addr[2],pInfo->addr[3],
							pInfo->addr[4], pInfo->addr[5]);*/

					for(j = 0; j < count; j++)
					{
						if(0 == memcmp(pLanNetInfo[j].mac, pInfo->addr, MAC_ADDR_LEN))
						{
							signalStrength[ntohl(pLanNetInfo[j].ip)&0x000000ff] = pInfo->rssi - 100;
							break;
						}
					}
				}
			}
		}
	}

	if(buff)
		free(buff);

	return 0;
}
#endif

static int moveNotLetterOrNumber(unsigned char *string, int len)
{
	int i = 0, j = 0, move_cnt = 0;
	int cur_len = len;
	
	while(0 != string[i])
	{
		if(((string[i] >= '0') && (string[i] <= '9')) ||
			((string[i] >= 'A') && (string[i] <= 'Z')) ||
			((string[i] >= 'a') && (string[i] <= 'z')))
		{
			i++;
			continue;
		}

		j = i;
			
		cur_len--;
		printf("%s, move %c\n", __FUNCTION__, string[i]);

		while(0 != string[j])
		{
			string[j] = string[j+1];
			j++;
		}
	}

	return cur_len;
}


#define DHCP_CTC_FIELD_LEN 36
#define DHCP_CTC_FQDN_LEN 64

static int addDeviceOptions
(
	char *postion, 
	int size, 
	int dhcp_lease_cnt, 
	struct stClientDhcpOptions *pclientOptions, 
	u_int32_t ip
)
{
	int j = 0;
	int found_options = 0;
	int offset = 0;
	char op60_vendor[DHCP_CTC_FIELD_LEN] = {0};
	char op60_model[DHCP_CTC_FIELD_LEN] = {0};
	char op81_fqdn[DHCP_CTC_FQDN_LEN] = {0};
	char categoryName[32] = {0};

	if ((dhcp_lease_cnt > 0) && (NULL != pclientOptions))
	{
		for(j = 0; j < dhcp_lease_cnt; j++)
		{
			//printf("%s, dhcp ip is 0x%x, client ip is 0x%x\n", __FUNCTION__, pclientOptions[j].yiaddr, ip);
			if(pclientOptions[j].yiaddr == ip)
			{
				found_options = 1;
	
				if(0 == pclientOptions[j].isCtcVendor) //this option 60 is not china telecom enterprise type
				{
					//add Vendor
					if(pclientOptions[j].szVendor[0] != 0)
					{
						strncpy(op60_vendor, pclientOptions[j].szVendor, DHCP_CTC_FIELD_LEN);
						moveNotLetterOrNumber(op60_vendor, strlen(op60_vendor));
						snprintf(postion+offset, size - offset, "%s_", op60_vendor);
						offset += strlen(op60_vendor) + 1;
					}
					else
					{
						snprintf(postion+offset, size - offset, "NONE_");
						offset += 5;
					}							
				}
				else  // this option 60 is china telecom enterprise type
				{
					//add Vendor
					if(pclientOptions[j].szVendor[0] != 0)
					{
						strncpy(op60_vendor, pclientOptions[j].szVendor, DHCP_CTC_FIELD_LEN);
						moveNotLetterOrNumber(op60_vendor, strlen(op60_vendor));
						snprintf(postion+offset, size - offset, "%s&", op60_vendor);
						offset += strlen(op60_vendor) + 1;
					}
					else
					{
						snprintf(postion+offset, size - offset, "NONE&");
						offset += 5;
					}
					
					//add Category
					getCategoryString(pclientOptions[j].category, categoryName, sizeof(categoryName));
					snprintf(postion+offset, size - offset, "%s&", categoryName);
					offset += strlen(categoryName)+1;
	
					//add Model
					if(pclientOptions[j].szModel[0] != 0)
					{
						strncpy(op60_model, pclientOptions[j].szModel, DHCP_CTC_FIELD_LEN);
						moveNotLetterOrNumber(op60_model, strlen(op60_model));
						snprintf(postion+offset, size - offset, "%s_", op60_model);
						offset += strlen(op60_model) + 1;
					}
					else
					{
						snprintf(postion+offset, size - offset, "NONE_");
						offset += 5;
					}
				}
	
				//add FQDN(option 81)
				if(pclientOptions[j].szFQDN[0] != 0)
				{
					strncpy(op81_fqdn, pclientOptions[j].szFQDN, DHCP_CTC_FQDN_LEN);
					moveNotLetterOrNumber(op81_fqdn, strlen(op81_fqdn));
					snprintf(postion+offset, size - offset, "%s+", op81_fqdn);
					offset += strlen(op81_fqdn) + 1;
				}
				else
				{
					snprintf(postion+offset, size - offset, "NONE+");
					offset += 5;
				}
				
				break;
			}
		}
	}
	if(0 == found_options)
	{
		snprintf(postion+offset, size - offset, "NONE_NONE+");
		offset += 10;
	}

	return offset;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_WLANDeviceMACEnable_
int getWLANDeviceMAC(char *deviceInfo, int size)
{
	lanHostInfo_t *pLanNetInfo=NULL;
	unsigned int count=0;
	int i = 0, report_cnt = 0;
	int offset = 0, len = 0;
	int dhcp_lease_cnt = 0;
	struct stClientDhcpOptions *pclientOptions = NULL;
	char op12_devname[MAX_LANNET_DEV_NAME_LENGTH] = {0};

	if(NULL == deviceInfo)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 1024)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;
	}

	get_lan_net_info(&pLanNetInfo, &count);
	getEveryClientSessionCnt();
	getEveryClientSignalStrength();
	
	dhcp_lease_cnt = getEveryClientOptions(&pclientOptions);

	for(i = 0; i < count; i++)
	{
		if(pLanNetInfo[i].connectionType != 1)
			continue;
		
		snprintf(deviceInfo+offset, size - offset, "%02X:%02X:%02X:%02X:%02X:%02X+",
				pLanNetInfo[i].mac[0], pLanNetInfo[i].mac[1],pLanNetInfo[i].mac[2],pLanNetInfo[i].mac[3],
				pLanNetInfo[i].mac[4], pLanNetInfo[i].mac[5]);
		offset += 18;

		//add option 12, this is store in RG, so do not use dhcp lease content.
		if(pLanNetInfo[i].devName[0] != 0)
		{
			strncpy(op12_devname, pLanNetInfo[i].devName, MAX_LANNET_DEV_NAME_LENGTH);
			moveNotLetterOrNumber(op12_devname, strlen(op12_devname));
			snprintf(deviceInfo+offset, size - offset, "%s_", op12_devname);
			offset += strlen(op12_devname) + 1;
		}
		else
		{
			snprintf(deviceInfo+offset, size - offset, "NONE_");
			offset += 5;
		}
		
		//add dhcp options
		len = addDeviceOptions(deviceInfo+offset, size - offset, dhcp_lease_cnt, pclientOptions, pLanNetInfo[i].ip);
		offset += len;
		
		snprintf(deviceInfo+offset, size - offset, "%d", sessCnt[ntohl(pLanNetInfo[i].ip)&0x000000ff]);
		offset = strlen(deviceInfo);

		snprintf(deviceInfo+offset, size - offset, "+%d", signalStrength[ntohl(pLanNetInfo[i].ip)&0x000000ff]);
		offset = strlen(deviceInfo);

		snprintf(deviceInfo+offset, size - offset, "-");
		offset++;

		report_cnt++;
		if(report_cnt > 10)  //should not report larger than 10 client info.
			break;
	}

	if(report_cnt > 0)
		deviceInfo[offset-1] = 0;
	else
		snprintf(deviceInfo, size, "NONE");

	if(pLanNetInfo)
		free(pLanNetInfo);

	if(pclientOptions)
		free(pclientOptions);

	fprintf(stderr, "%s %d deviceInfo=%s!\n",__FUNCTION__,__LINE__,deviceInfo);

	return 0;
}
#endif


#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_LANDeviceMACEnable_
int getLANDeviceMAC(char *deviceInfo, int size)
{
	int logicPortId = 0;
	int macidx = 0;
	int report_cnt = 0;
	int offset = 0, len = 0;
	rtk_rg_macEntry_t macEntry;
	lanHostInfo_t *pLanNetInfo=NULL;
	unsigned int count=0;
	int i = 0, found_lannetinfo = 0;
	int dhcp_lease_cnt = 0;
	struct stClientDhcpOptions *pclientOptions = NULL;
	char op12_devname[MAX_LANNET_DEV_NAME_LENGTH] = {0};

	if(NULL == deviceInfo)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 1024)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;
	}

	get_lan_net_info(&pLanNetInfo, &count);
	getEveryClientSessionCnt();
	dhcp_lease_cnt = getEveryClientOptions(&pclientOptions);

	memset(&macEntry, 0, sizeof(rtk_rg_macEntry_t));

	for(logicPortId = 0; logicPortId < ELANVIF_NUM; logicPortId++)
	{
		macidx = 0;
		while (RT_ERR_RG_OK == rtk_rg_macEntry_find(&macEntry, &macidx))
		{
			if (macEntry.port_idx == RG_get_lan_phyPortId(logicPortId)) {				
				snprintf(deviceInfo+offset, size - offset, "LAN%d+", logicPortId+1);
				offset += 5;
				snprintf(deviceInfo+offset, size - offset, "%02X:%02X:%02X:%02X:%02X:%02X_",
						(unsigned char)macEntry.mac.octet[0], (unsigned char)macEntry.mac.octet[1], (unsigned char)macEntry.mac.octet[2],
						(unsigned char)macEntry.mac.octet[3], (unsigned char)macEntry.mac.octet[4], (unsigned char)macEntry.mac.octet[5]);
				offset += 18;

				for(i = 0; i < count; i++)
				{
					found_lannetinfo = 0;
					if(0 == memcmp(macEntry.mac.octet, pLanNetInfo[i].mac, ETHER_ADDR_LEN))		
					{
						//add option 12, this is store in RG, so do not use dhcp lease content.
						if(pLanNetInfo[i].devName[0] != 0)
						{
							strncpy(op12_devname, pLanNetInfo[i].devName, MAX_LANNET_DEV_NAME_LENGTH);
							moveNotLetterOrNumber(op12_devname, strlen(op12_devname));
							snprintf(deviceInfo+offset, size - offset, "%s_", op12_devname);
							offset += strlen(op12_devname) + 1;
						}
						else
						{
							snprintf(deviceInfo+offset, size - offset, "NONE_");
							offset += 5;
						}

						//add dhcp options
						len = addDeviceOptions(deviceInfo+offset, size - offset, dhcp_lease_cnt, pclientOptions, pLanNetInfo[i].ip);
						offset += len;

						//add session count
						snprintf(deviceInfo+offset, size - offset, "%d", sessCnt[ntohl(pLanNetInfo[i].ip)&0x000000ff]);
						offset = strlen(deviceInfo);

						snprintf(deviceInfo+offset, size - offset, "-");
						offset++;
						
						found_lannetinfo = 1;
						break;
					}
				}

				if(0 == found_lannetinfo)
				{
					snprintf(deviceInfo+offset, size - offset, "NONE_NONE_NONE+0-");
					offset += 17;
				}

				report_cnt++;
				if(report_cnt > 10)  //should not report larger than 10 client info.
					break;
			}

			macidx++;
			memset(&macEntry, 0, sizeof(rtk_rg_macEntry_t));
		}

		if(report_cnt > 10)  //should not report larger than 10 client info.
			break;
	}

	if(report_cnt > 0)
		deviceInfo[offset-1] = 0;
	else
		snprintf(deviceInfo, size, "NONE");

	if(pLanNetInfo)
		free(pLanNetInfo);

	if(pclientOptions)
		free(pclientOptions);

	fprintf(stderr, "%s %d deviceInfo=%s!\n",__FUNCTION__,__LINE__,deviceInfo);

	return 0;	
}
#endif
#if 1
#define LAN_DEVICE_PKT_LOSS_LOCKFILE	"/var/run/lan_device_pkt_losss.lock"
#define PPPOE_DIALING_INFO_LOCKFILE		"/var/run/pppoe_dialing_info.lock"

/* operations for bsd flock(), also used by the kernel implementation */
#define LOCK_SH		1	/* shared lock */
#define LOCK_EX		2	/* exclusive lock */
#define LOCK_NB		4	/* or'd with one of the above to prevent
				   blocking */
#define LOCK_UN		8	/* remove lock */

#define LOCK_MAND	32	/* This is a mandatory flock ... */
#define LOCK_READ	64	/* which allows concurrent read operations */
#define LOCK_WRITE	128	/* which allows concurrent write operations */
#define LOCK_RW		192	/* which allows concurrent read & write ops */

int unlock_file_by_flock(int lockfd)
{
	while (flock(lockfd, LOCK_UN) == -1 && errno==EINTR) {
		usleep(1000);
		printf("pkt loss write unlock failed by flock. errno=%d\n", errno);
	}
	close(lockfd);
	return 0;
}

int lock_file_by_flock(const char *filename, int wait)
{
	int lockfd;

	if ((lockfd = open(filename, O_RDWR|O_CREAT)) == -1) {
		perror("open shm lockfile");
		return lockfd;
	}

	if(wait)
	{
		 while (flock(lockfd, LOCK_EX) == -1 && errno==EINTR) {  //wait util lock can been use.
		 	usleep(1000);
		 	printf("file %s write lock failed by flock. errno=%d\n", filename, errno);
		 }		
	}
	else
	{
		if(flock(lockfd, LOCK_EX|LOCK_NB) == -1)
		{
			close(lockfd);  //if failed to lock it. close lockfd.
			printf("fail to lock file %s\n", filename);
			return -1;
		}
	}

	return lockfd;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_DevicePacketLossEnable_
int getDevicePacketLoss(char *pktLoss, int size)
{
	FILE *fp;
	int i = 0;
	int lockfd = 0;
	unsigned long deviceInfoFileSize = 0;
	char *buf = NULL;
	struct stat status;
	unsigned int deviceCnt = 0, offset = 0;
	struct stLanDevicePktLoss *pDevPktLoss = NULL;
	struct in_addr addr;

	if(NULL == pktLoss)
	{
		printf("%s,error: parameter is NULL!", __FUNCTION__);
		return -1;
	}

	if (size < 1024)
	{
		printf("%s,error: buffer should larger than 64!", __FUNCTION__);
		return -1;
	}

	//printf("getDevicePacketLoss==============lock file=======================\n");

	if ((lockfd = lock_file_by_flock(LAN_DEVICE_PKT_LOSS_LOCKFILE, 0)) == -1)
	{
		printf("%s, the file have been locked\n", __FUNCTION__);
		return -1;
	}

	if (stat(LAN_DEVICE_PKT_LOSS_FILENAME, &status) < 0)
		goto err;

	deviceInfoFileSize = (unsigned long)(status.st_size);
	
	buf = malloc(deviceInfoFileSize);
	if (buf == NULL)
		goto err;

	fp = fopen(LAN_DEVICE_PKT_LOSS_FILENAME, "r");
	if (fp == NULL)
		goto err;

	fread(buf, deviceInfoFileSize, 1, fp);
	fclose(fp);

	//printf("getDevicePacketLoss45213==============unlock file=======================\n");
	unlock_file_by_flock(lockfd);

	deviceCnt = deviceInfoFileSize/sizeof(struct stLanDevicePktLoss);
	pDevPktLoss = (struct stLanDevicePktLoss *)buf;

	for(i = 0; i < deviceCnt; i++)
	{
		snprintf(pktLoss+offset, size-offset, "%02X:%02X:%02X:%02X:%02X:%02X+", 
				pDevPktLoss[i].clinetMac[0], pDevPktLoss[i].clinetMac[1], pDevPktLoss[i].clinetMac[2],
				pDevPktLoss[i].clinetMac[3], pDevPktLoss[i].clinetMac[4], pDevPktLoss[i].clinetMac[5]);
		offset += 18;

		addr.s_addr = pDevPktLoss[i].ip;
		snprintf(pktLoss+offset, size-offset, "%s+", inet_ntoa(addr));
		offset = strlen(pktLoss);

		snprintf(pktLoss+offset, size-offset, "%d+", pDevPktLoss[i].pktLoss);
		offset = strlen(pktLoss);

		snprintf(pktLoss+offset, size-offset, "%d-", pDevPktLoss[i].averagDelay);
		offset = strlen(pktLoss);
	}

	if(deviceCnt > 0)
		pktLoss[offset-1] = 0;
	else
		snprintf(pktLoss, size, "NONE");
	fprintf(stderr, "%s %d pktLoss=%s!\n",__FUNCTION__,__LINE__,pktLoss);
	if (buf)
		free(buf);
	return 0;
	
err:
	//printf("getDevicePacketLoss45243==============unlock file=======================\n");
	unlock_file_by_flock(lockfd);
	if (buf)
		free(buf);

	return -1;
}
#endif

#ifdef  _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_CPURateEnable_
int getCPURate(unsigned int *CPURate)
{
	char cmd[100], buff[256], *ptr;
	FILE *fp;
	char filename[128];
	sprintf(filename, "/tmp/top.cpu.%08x", filename);
	sprintf(cmd, "top -n 1 | grep CPU > %s", filename);
	
//	sprintf(cmd, "top -n 1 | grep CPU > /tmp/top.cpu");
	va_cmd("/bin/sh", 2, 1, "-c", cmd);
	if ((fp = fopen(filename, "r")) == 0) {
		printf("%s can not open %s\n", __func__,filename);
		return -1;
	}
	fgets(buff, 256, fp);
	if ((ptr = strstr(buff, "CPU")) == NULL) 
		goto err;	
					
	if (sscanf(ptr, "CPU: %u .%*s", CPURate) < 1 ){
		printf("can not parse cpu used val.\n");
		goto err;
	}
	
	fclose(fp);
	unlink(filename);			
//	printf("CPURate= %u,filename=%s\n", *CPURate,filename);
//	printf("CPURate%s %s\n", __func__,CPURate);
	return 0;

	err:
		fclose(fp);
		unlink(filename);	
		return -1;
}
#endif

#ifdef  _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_MemRateEnable_
int getMemRate(unsigned int *MemRate)
{
	char cmd[100], buff[256], *ptr;
	unsigned int memUsed,memFree;
	unsigned long memTotal;
	
	FILE *fp;
	char filename[128];
	sprintf(filename, "/tmp/top.mem.%08x", filename);
	sprintf(cmd, "top -n 1 | grep Mem > %s", filename);
	
//	sprintf(cmd, "top -n 1 | grep Mem > /tmp/top.mem");
	va_cmd("/bin/sh", 2, 1, "-c", cmd);
	if ((fp = fopen(filename, "r")) == 0) {
		printf("%s can not open filename %s\n", __func__,filename);
		return -1;
	}
	fgets(buff, 256, fp);
	if ((ptr = strstr(buff, "Mem")) == NULL) 
		goto err;
	
	if (sscanf(ptr, "Mem: %uK%*s", &memUsed) < 1 ){
		printf("can not parse mem used val.\n");
		goto err;
	}
	
	if ((ptr = strstr(buff, "used")) == NULL) 
		goto err;	
	
	if (sscanf(ptr, "used, %uK%*s", &memFree) < 1 ){
		printf("can not parse mem free val.\n");
		goto err;
	}
	fclose(fp);
	unlink(filename);
	memTotal=memUsed+memFree;
	*MemRate = memUsed*100/memTotal;
	//printf("MemRate= %u filename= %s\n",*MemRate,filename);
	
	return 0;

err:
	fclose(fp);
	unlink(filename);	
	return -1;
}
#endif

#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_DialingNumberEnable_) \
|| defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_DialingErrorEnable_)
const char PPPOE_DIALING_INFO[] = "/tmp/ppp_dialing_info";
int getPppoeDialingNumber(void)
{
	char tmp[64]="";
	FILE *fp;
	int DialingNumber = 0,Error678,Error676,Error691,Error999,padiSendFlag;
	int lockfd = 0;

	if ((lockfd = lock_file_by_flock(PPPOE_DIALING_INFO_LOCKFILE, 0)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, PPPOE_DIALING_INFO_LOCKFILE);
		return -1;
	}
	if(fp = fopen(PPPOE_DIALING_INFO, "r")){
		if(fgets(tmp, sizeof(tmp), fp) != NULL){
			sscanf(tmp, "%d:%d:%d:%d:%d:%d",&DialingNumber,&Error678,&Error676,&Error691,&Error999,&padiSendFlag);
		}
		fclose(fp);
	}
	else{ 
		printf("fail to open file %s\n",PPPOE_DIALING_INFO);
	}	
	unlock_file_by_flock(lockfd);
	
	fprintf(stderr, "%s %d DialingNumber=%d!\n",__FUNCTION__,__LINE__,DialingNumber);
	return DialingNumber;
}

int getPppoeDialingError(char *DialingError)
{
	char tmp[64]="";
	FILE *fp;
	int DialingNumber,padiSendFlag;
	int	Error678 =0,Error676=0 ,Error691 = 0,Error999 = 0;
	int lockfd = 0;

	if ((lockfd = lock_file_by_flock(PPPOE_DIALING_INFO_LOCKFILE, 0)) == -1)
	{
		printf("%s, the file %s have been locked\n", __FUNCTION__, PPPOE_DIALING_INFO_LOCKFILE);
		return -1;
	}

	if(fp = fopen(PPPOE_DIALING_INFO, "r")){
		if(fgets(tmp, sizeof(tmp), fp) != NULL){
			sscanf(tmp, "%d:%d:%d:%d:%d:%d",&DialingNumber,&Error678,&Error676,&Error691,&Error999,&padiSendFlag);
		}
		fclose(fp);
	}else{ 
		printf("fail to open file %s\n",PPPOE_DIALING_INFO);
	}	
	unlock_file_by_flock(lockfd);
	
	sprintf(DialingError,"678:%d+676:%d+691:%d+999:%d",Error678,Error676,Error691,Error999);
	fprintf(stderr, "%s %d DialingError=%s!\n",__FUNCTION__,__LINE__,DialingError);
	return 0;
}
#endif
int isDhcpProcessExist(unsigned int ifIndex)
{
    int pid;
    unsigned char ifname[IFNAMSIZ];
    unsigned char pid_file[32];

    ifGetName(PHY_INTF(ifIndex),ifname,sizeof(ifname));
    snprintf(pid_file, 32, "%s.%s", (char*)DHCPC_PID, ifname);
    pid = read_pid((char*)pid_file);
    if(pid>0)
    {
        if(kill(pid, 0) == 0) //send a meaasge "zero" to PID, if process exist, return 0
        {
            return 1;
        }
        else
        {
            //pid file exist but process has been killed.
            return 0;
        }
    }
    else
    {
        //pid file not exist.
        return 0;
    }
}

#if defined(CONFIG_USER_RTK_VOIP)
int get_register(int port)
{
	FILE *fh;
	char buf[MAX_VOIP_PORTS * MAX_PROXY];
	char p0_reg_st, p1_reg_st;
	int ret=0;	
	fh = fopen(_PATH_TMP_STATUS, "r");
	if (!fh) {
		printf("Warning: cannot open %s. Limited output.\n", _PATH_TMP_STATUS);
		printf("\nerrno=%d\n", errno);
		return 0;
	}

	memset(buf, 0, sizeof(buf));
	if (fread(buf, sizeof(buf), 1, fh) == 0) {
		printf("Web: The content of /tmp/status is NULL!!\n");
		printf("\nerrno=%d\n", errno);
		ret=0;
	}
	else {

		p0_reg_st = buf[port * MAX_PROXY];
		p1_reg_st = buf[port * MAX_PROXY + 1];
		if((p0_reg_st == '1')||(p1_reg_st == '1'))
		{
			ret=1;
		}
		else{
			ret=0;
		}
	}
	fclose(fh);
	return ret;
}

#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_VoiceInfoEnable_)
int voip_e8c_getInfo(char* voiceInfo, int size)
{
	voipCfgParam_t *pVoIPCfg;
	voipCfgPortParam_t *pCfg1;
	voipCfgPortParam_t *pCfg;
	int i,state,offset = 0;
	int voip_port,voip_port_temp;
	if(!voiceInfo||!size)
		return -1;
	if (voip_flash_get(&pVoIPCfg) != 0){
		printf("%s,error: parameter is NULL!\n", __FUNCTION__);
		return -1;
	}
	memset(voiceInfo,0,size);

	pCfg1 = &pVoIPCfg->ports[0];
	
	FILE *fh;
		char buf[MAX_VOIP_PORTS];
		
		fh = fopen(_PATH_TMP_E8C_STATUS, "r");
		if (!fh) {						
			printf("%s,error: File can't be read!\n", __FUNCTION__);
			return -1;
		}
		memset(buf, 0, sizeof(buf));
		if ((fread(buf, sizeof(buf), 1, fh) == 0) || (2 == pVoIPCfg->X_CT_servertype) || (pVoIPCfg->ports[voip_port].proxies[0].number == NULL)) {		
			printf("%s,error: File or number is NULL!\n", __FUNCTION__);
			fclose(fh);
			return -1;
		}
		else {
			for (voip_port=0; voip_port< VOIP_PORTS; voip_port++)
			{
				char p_reg_st;
				if((pVoIPCfg->ports[voip_port].proxies[0].enable & PROXY_ENABLED)==0)
				{
					state = 7;	
				}
				else
				{
					if(get_register(voip_port)==1)
					{
						state = 7;
					}else{
					p_reg_st=buf[voip_port];
					//fprintf(stderr,"p_reg_st=%c voip_port=%d\n", p_reg_st, voip_port);
					//fprintf(stderr, "buf is %s\n", buf);
					switch (p_reg_st) {
				case '0'://VOIP_STATUS_INIT
					state = 7;
					break;
				case '1'://VOIP_STATUS_SUCCESS
					state = 0;
					break;
				case '2'://VOIP_NOVALID_CONNECTION
					state = 1;
					break;
				case '3'://VOIP_STATUS_IADERROR
					state = 7;
					break;
				case '4'://VOIP_STATUS_NOROUTE
					state = 1;
					break;
				case '5'://VOIP_STATUS_NORESPONSE
					state = 1;
					break;
				case '6'://VOIP_STATUS_ACCOUNTERR
					state = 3;
					break;
				case '7'://VOIP_STATUS_UNKNOWN
					state = 7;
					break;
				case '8'://VOIP_STATUS_LINE_DISABLED
					state = 1;
					break;
				case '9'://VOIP_STATUS_ADDR_UNKNOW_HOST
					state = 2;
					break;						
				default:
					state = 7;
					break;
					}
				}
			}
			if(pVoIPCfg->ports[voip_port].proxies[0].number[voip_port] != '\0')
			{
				printf("[%s %d]number=%s\n", __func__, __LINE__, pVoIPCfg->ports[voip_port].proxies[0].number);
				voip_port_temp = voip_port + 1;
				snprintf(voiceInfo+offset, size-offset, "%d+%s+%d-",voip_port_temp,pVoIPCfg->ports[voip_port].proxies[0].number, state);
				offset = strlen(voiceInfo);
			}
		}
		voiceInfo[offset-1] = 0;
fprintf(stderr, "%s %d voiceInfo=%s!\n",__FUNCTION__,__LINE__,voiceInfo);
		}
		fclose(fh);	
	return 0;

}
#endif

int VoiceStateValue(unsigned int port)
{
	int PortStatus=0;
	voip_state_share_t *g_shmVoIPstate;
	voip_line_state_init_variables();
    voip_line_state_share_get(&g_shmVoIPstate);
	
	if (g_shmVoIPstate)
	{
	
		if(g_shmVoIPstate->VOIPLineStatus[port].voipVoiceServerStatus==REGISTER_ONGOING)
			return 0;

		if(g_shmVoIPstate->HookState[port]==0)
			return 0;	//idle

		if((g_shmVoIPstate->HookState[port]==1) && (g_shmVoIPstate->VOIPLineStatus[port].voip_Port_status==PORT_IDEL))
			return 3;

		switch(g_shmVoIPstate->VOIPLineStatus[port].voip_Port_status){
			case PORT_IDEL:
				PortStatus=0;
				break;
			case PORT_DIALING:
				PortStatus=2;
				break;
			case PORT_RINGING:
				PortStatus=3;
				break;
			case PORT_RINGBACKTONE:
				PortStatus=4;
				break;
			case PORT_CONNECTING:
				PortStatus=5;
				break;
			case PORT_CONNECTED:
				PortStatus=6;
				break;
			case PORT_RELEASE_CONNECTED:
			case PORT_DISABLE:
				PortStatus=9;
				break;		
			default:
				PortStatus=10;
		}

	}
	return PortStatus;
}

#if defined(_PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_VoiceStateEnable_)
int voip_e8c_getState(char*voiceState,int size )
{	
	voipCfgParam_t *pVoIPCfg;
	int i,offset=0;
	unsigned int status = 0;
	int voip_port, voip_port_temp;
	if(!voiceState||!size)
		return -1;
	if (voip_flash_get(&pVoIPCfg) != 0){
		printf("%s,error: parameter is NULL!\n", __FUNCTION__);
		return -1;
	}
	memset(voiceState,0,size);
	if (2 != pVoIPCfg->X_CT_servertype)
	{
		for (voip_port=0; voip_port< VOIP_PORTS; voip_port++)
		{
			status = VoiceStateValue(voip_port);
			if(pVoIPCfg->ports[voip_port].proxies[0].number != NULL)
			{
				voip_port_temp = voip_port + 1;
				//boaWrite(wp, "<td>%d:%d-</td>",voip_port_temp,portstatus); 
				snprintf(voiceState+offset, size-offset, "%d:%d-",voip_port_temp,status);
				offset = strlen(voiceState);
			}
		}
		voiceState[offset-1] = 0;
	}
	return 0;
}

#endif
#endif //end defined(CONFIG_USER_RTK_VOIP)

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_TEMPEnable_
int getTEMP(double *buf)
{
	rtk_transceiver_data_t transceiver, readableCfg;
	memset(&transceiver, 0, sizeof(transceiver));
	memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get
		(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver);
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get
		(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver);
		_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver, &readableCfg);
#endif
	*buf = atof(readableCfg.buf);
	fprintf(stderr, "%s %d temp=%.2lf!\n",__FUNCTION__,__LINE__, *buf);
	return 0;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_OpticalInPowerEnable_
int getOpticalInPower(char *buf)
{
	rtk_transceiver_data_t transceiver, readableCfg;
	memset(&transceiver, 0, sizeof(transceiver));
	memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get
			(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver);
	 _get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver, &readableCfg);
#endif
	strcpy(buf, readableCfg.buf);
	fprintf(stderr, "%s %d buf=%s!\n",__FUNCTION__,__LINE__,buf);
	return 0;
}
#endif
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_OpticalOutPowerEnable_
int getOpticalOutPower(char *buf)
{
	rtk_transceiver_data_t transceiver, readableCfg;
	memset(&transceiver, 0, sizeof(transceiver));
	memset(&readableCfg, 0, sizeof(readableCfg));
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get
		(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER,
		&transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver, &readableCfg);
#endif
	strcpy(buf, readableCfg.buf);
	fprintf(stderr, "%s %d buf=%s!\n",__FUNCTION__,__LINE__,buf);
	return 0;
}
#endif
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_RoutingModeEnable_
int getRoutingMode()
{
    unsigned int entryNum, i;
	MIB_CE_ATM_VC_T Entry;
	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<entryNum; i++) 
	{
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
		{
  			printf("Get chain record error!\n");
			return -1;
		}
		if (Entry.enable == 0)
			continue;
		if (Entry.applicationtype&X_CT_SRV_INTERNET)
		{
			if(Entry.cmode == CHANNEL_MODE_BRIDGE)
				return 1; //bridge
			else
				return 0; //routing
		}
	}
	if(i==entryNum)
		return -1;
}
#endif

#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_RegisterNumberEnable_
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_RegisterSuccessNumberEnable_
static const char REGISTER_NUM_FILE[] = "/tmp/oam_register_num";
static const char REGISTER_NUM_FILE_LAST[] = "/tmp/oam_register_num_last";

int getOLTNumberInFile(const char *fname, int *regNum, int *regSuccNum)
{
	int fd;
	char buf[256]={};
	char *tmp;
	
	fd = lock_file_by_flock(fname, 1);
	if(fd<0)
	{
		printf("%s %d: File lock error\n", __FUNCTION__, __LINE__);
		return -1;
	}
	if(read(fd, buf, sizeof(buf))<0)
	{
		printf("%s %d: read error!\n", __FUNCTION__, __LINE__);
		unlock_file_by_flock(fd);
		return -1;
	}
	buf[255]='\0';
	if(tmp = strstr(buf, "registerNum="))
	{
		sscanf(tmp, "registerNum=%d\n%*s", regNum);
	}
	if(tmp = strstr(buf, "registerSuccNum="))
	{
		sscanf(tmp, "registerSuccNum=%d\n%*s", regSuccNum);
	}
	unlock_file_by_flock(fd);
	return 0;
}

int getRegisterOLTNumber()
{
	int regNum = 0, regSuccNum = 0;
	int lstRegNum = 0, lstRegSuccNum = 0;
	system("/bin/oamcli get ctc registernum 1"); /* save current number to /tmp/oam_register_num */
	if(getOLTNumberInFile(REGISTER_NUM_FILE, &regNum, &regSuccNum)<0)
	{
		printf("%s %d: getCurOLTRegistertime failed!\n", __FUNCTION__, __LINE__);
		return -1;
	}
	if(getOLTNumberInFile(REGISTER_NUM_FILE_LAST, &lstRegNum, &lstRegSuccNum)<0)
	{
		printf("%s %d: getCurOLTRegistertime failed!\n", __FUNCTION__, __LINE__);
		lstRegNum=0; // When boa first start up, REGISTER_NUM_FILE_LAST may not exist!!
	}
	return regNum - lstRegNum; //Must clear to 0 for a new day!
}
int getRegisterOLTSuccNumber()
{
	int regNum = 0, regSuccNum = 0;
	int lstRegNum = 0, lstRegSuccNum = 0;
	system("/bin/oamcli get ctc registernum 1"); /* save current number to /tmp/oam_register_num */
	if(getOLTNumberInFile(REGISTER_NUM_FILE, &regNum, &regSuccNum)<0)
	{
		printf("%s %d: getCurOLTRegistertime failed!\n", __FUNCTION__, __LINE__);
		return -1;
	}
	if(getOLTNumberInFile(REGISTER_NUM_FILE_LAST, &lstRegNum, &lstRegSuccNum)<0)
	{
		printf("%s %d: getCurOLTRegistertime failed!\n", __FUNCTION__, __LINE__);
		lstRegSuccNum=0; // When boa first start up, REGISTER_NUM_FILE_LAST may not exist!!
	}
	return regSuccNum - lstRegSuccNum; //Must clear to 0 for a new day!
}
#endif
#endif
#ifdef _PRMT_X_CT_COM_PERFORMANCE_REPORT_SUBITEM_MulticastNumberEnable_
int getMulticastNumber()
{
	FILE *fd;
	char line[256] = {};
	char *tmp;
	int v1Grp=0, v2Grp=0, v3Grp=0;
	char cmd[100];
	const char partern[]="igmp list: ";
	char fileName[128] = {};
	sprintf(fileName, "/tmp/mcgrp.%08x", fileName);
	const char fname[] = "/proc/rg/igmpSnooping";
	sprintf(cmd, "cat %s | grep \"%s\" > %s", fname, partern, fileName);
	va_cmd("/bin/sh", 2, 1, "-c", cmd);

	fd = fopen(fileName, "r");
	if(!fd)
	{
		printf("%s %d: open file failed!\n", __FUNCTION__, __LINE__);
		return -1;
	}
	while(fgets(line, 256, fd));
	{
		if(tmp = strstr(line, partern))
		{
			sscanf(tmp+strlen(partern), "V1=%d, V2=%d, V3=%d", &v1Grp, &v2Grp, &v3Grp);
		}
	}
	fclose(fd);
	unlink(fileName);
	fprintf(stderr, "%s %d multNum=%d!\n",__FUNCTION__,__LINE__, v1Grp+v2Grp+v3Grp);
	return v1Grp+v2Grp+v3Grp;
}
#endif

#ifdef _PRMT_X_CT_COM_MULTICAST_DIAGNOSIS_

int setMcastVidToSmux(char *ifname, int vid)
{
	int ret;
	char buf[50] = {0};
	
	sprintf(buf, "%d", vid);
	ret = va_cmd("/bin/ethctl", 5, 1, "setsmux", ALIASNAME_NAS0, ifname, "mvid", buf);
	
	return (ret == 0 )?1:0;
}
#endif

#if defined(CONFIG_RTL9600_SERIES) && defined(CONFIG_RTK_L34_ENABLE)
#define INTERNAL_VID_START	2000
#define INTERNAL_VID_END	3000
int mib_internal_vid_list[] = {MIB_LAN_VLAN_ID1, MIB_LAN_VLAN_ID2, MIB_UNTAG_WAN_VLAN_ID, MIB_FWD_CPU_VLAN_ID, MIB_FWD_PROTO_BLOCK_VLAN_ID, MIB_FWD_BIND_INTERNET_VLAN_ID, MIB_FWD_BIND_OTHER_VLAN_ID, 0};
int checkVlanConfictWithMib(int internalVid, int mibId)
{
	unsigned int atmVcEntryNum, i;
	MIB_CE_ATM_VC_T atmVcEntry;
	unsigned int pbNum, k;
	MIB_CE_PORT_BINDING_T pbEntry;
	struct v_pair *vid_pair;
	

	if(!internalVid)
		return 0;
	
	/* WAN config or MVLAN */
	atmVcEntryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i=0; i<atmVcEntryNum; i++) 
	{
		if (mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&atmVcEntry))
		{
			if (atmVcEntry.enable == 0)
				continue;

			if(mibId==MIB_FWD_BIND_OTHER_VLAN_ID) 
			{
				if(atmVcEntry.vlan && (atmVcEntry.vid >= internalVid && atmVcEntry.vid <= (internalVid+DEFAULT_BIND_LAN_OFFSET))){
					return 1;
				}

				if(atmVcEntry.mVid >= internalVid && atmVcEntry.mVid <= (internalVid+DEFAULT_BIND_LAN_OFFSET)){
					return 1;
				}
			}
			else
			{
				if(atmVcEntry.vlan && atmVcEntry.vid == internalVid){
					return 1;
				}

				if(atmVcEntry.mVid == internalVid){
					return 1;
				}
			}
		}
	}

	/* VLAN binding */
	pbNum = mib_chain_total(MIB_PORT_BINDING_TBL);
	for (i=0; i<pbNum; i++)
	{
		if (mib_chain_get(MIB_PORT_BINDING_TBL, i, (void*)&pbEntry))
		{
			if(pbEntry.pb_mode != (unsigned char)VLAN_BASED_MODE)
				continue;

			vid_pair = (struct v_pair *)&pbEntry.pb_vlan0_a;
			for (k=0; k<4; k++)
			{			
				//Be sure the content of vlan-mapping exsit!
				if ((vid_pair[k].vid_b==internalVid || vid_pair[k].vid_a==internalVid) && vid_pair[k].vid_a!=0)
				{
					return 1;
				}
			}
		}
	}

	return 0;
}

int checkVlanConfictWithInternal(int internalVid, int mibId)
{
	int i, vlan_id;

	if(!internalVid)
		return 0;
	
	for(i=0 ; mib_internal_vid_list[i] ; i++)
	{
		if(mib_internal_vid_list[i]==mibId)
			continue;
	
		if(mib_get(mib_internal_vid_list[i], (void *)&vlan_id) != 0)
		{
			if(mib_internal_vid_list[i]==MIB_FWD_BIND_OTHER_VLAN_ID) {
				if(internalVid >= vlan_id && internalVid <= (vlan_id+DEFAULT_BIND_LAN_OFFSET)){
					return 1;
				}
			} else if(mibId==MIB_FWD_BIND_OTHER_VLAN_ID) {
				if(vlan_id >= internalVid && vlan_id <= (internalVid+DEFAULT_BIND_LAN_OFFSET)){
					return 1;
				}
			} else {
				if(vlan_id == internalVid){
					return 1;
				}
			}
		}
	}

	return 0;
}

int decideInternalVlan(int mibId)
{
	int vlan_id;

	for(vlan_id=INTERNAL_VID_START ; vlan_id<=INTERNAL_VID_END ; vlan_id++)
	{
		if(!checkVlanConfictWithMib(vlan_id, mibId) && !checkVlanConfictWithInternal(vlan_id, mibId))
			return vlan_id;
	}

	return -1;
}

void restartup_RG(void) 
{
	va_cmd(STARTUP, 1, 1, "RG");
}

void checkVlanConfict(void)
{
	int conflictHappend = 0;
	int i, vlan_id, new_vlan_id;
	int bind_other_vlan_id;

	for(i=0 ; mib_internal_vid_list[i] ; i++)
	{
		if(mib_get(mib_internal_vid_list[i], (void *)&vlan_id) != 0)
		{
			if(checkVlanConfictWithMib(vlan_id, mib_internal_vid_list[i]) || checkVlanConfictWithInternal(vlan_id, mib_internal_vid_list[i]))
			{
				new_vlan_id = decideInternalVlan(mib_internal_vid_list[i]);				
				if(new_vlan_id != -1) {
					mib_set(mib_internal_vid_list[i], (void *)&new_vlan_id);
					conflictHappend = 1;
				}
			}
		}
	}

	if(conflictHappend)
	{
		AUG_PRT(" NOTE: VLAN ID conflict happend !!\n");
		restartup_RG();
#if defined(CONFIG_EPON_FEATURE) && defined(CONFIG_USER_RTK_LBD)
		restartLBD();
#endif
	}
}

void restartOMCI(void)
{
#ifdef CONFIG_GPON_FEATURE
	unsigned int pon_mode=0;
#endif

#ifdef CONFIG_GPON_FEATURE
	mib_get(MIB_PON_MODE, &pon_mode);
	if(pon_mode == GPON_MODE)
	{
		va_cmd(OMCICLI, 2, 1, "debug", "reactive");
	}
#endif
}
#endif

#ifdef CTC_TELNET_SCHEDULED_CLOSE
struct webserver_callout sch_telnet_ch;

void schTelnetCheck()
{
#ifdef REMOTE_ACCESS_CTL
	MIB_CE_ACC_T Entry;
	static unsigned char telnet_enable = 0;
	static time_t startTime;
	time_t curTime;

	if (!mib_chain_get(MIB_ACC_TBL, 0, (void *)&Entry)) 
	{
		printf("mib chain get MIB_ACC_TBL failed!");
	}else{
		if(Entry.telnet == 0)
		{
			if(telnet_enable)
				telnet_enable = 0;
		}else{
			if(telnet_enable ==0) 
			{
				time(&startTime);
				telnet_enable = 1;
			}

			time(&curTime);
			if((curTime - startTime) > CTC_TELNET_SCHEDULED_CLOSE_TIME) 
			{
				//close telnet
				printf("%s %d close telnet\n",__FUNCTION__,__LINE__);

				filter_set_remote_access(0);

				Entry.telnet = 0;
				mib_chain_update(MIB_ACC_TBL, (void *)&Entry, 0);

				filter_set_remote_access(1);
			}
		}
	}
#endif

	TIMEOUT((void*)schTelnetCheck, 0, 10, sch_telnet_ch); 
}
#endif

int getWANIfindexFromIfName(char *wanName)
{
	int i, mibtotal, ifindex=-1;
	MIB_CE_ATM_VC_T tmpEntry;
	char Ifname[64]={0};

	mibtotal = mib_chain_total(MIB_ATM_VC_TBL);
	for(i=0; i< mibtotal; i++)
	{
		mib_chain_get(MIB_ATM_VC_TBL, i, &tmpEntry);
		generateWanName(&tmpEntry, Ifname);
		if(strcmp(wanName, Ifname) == 0)
		{
			ifindex = tmpEntry.ifIndex;
			break;
		}
	}

	return ifindex;
}

MIB_CE_ATM_VC_T* getDefaultRouteATMVCEntry(MIB_CE_ATM_VC_T *pEntry)
{
	int total,i;

#ifdef DEFAULT_GATEWAY_V2
	{
		unsigned int dgw;
		if (mib_get(MIB_ADSL_WAN_DGW_ITF, (void *)&dgw) != 0)
		{
			return getATMVCEntryByIfIndex(dgw, pEntry);
		}
	}
#else
	total = mib_chain_total(MIB_ATM_VC_TBL);
	for( i=0; i<total; i++ )
	{
		if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)pEntry ) )
			continue;
		if(pEntry->cmode == CHANNEL_MODE_BRIDGE)
			continue;
		if(!(pEntry->applicationtype & X_CT_SRV_INTERNET))
			continue;
		if(pEntry->dgw==1)
		{
			if( pEntry->connDisable==0 )
			{
				return pEntry;
			}else
				return NULL;

		}
	}
#endif
	return NULL;
}

#ifdef CONFIG_USER_CUSPEEDTEST
int speedtestdoneflag=0;
int cwmp_speedtestdoneflag=0;

int getSpeedtestDoneFlag()
{
	return speedtestdoneflag;
}

int setSpeedtestDoneFlag(int flag)
{
	speedtestdoneflag = flag;
}

int getCWMPSpeedtestDoneFlag()
{
	return cwmp_speedtestdoneflag;
}

int setCWMPSpeedtestDoneFlag(int flag)
{
	cwmp_speedtestdoneflag = flag;
}

static void ResetCU_SpeedTestResultValues(struct CU_SpeedTest_Diagnostics *p)
{
	if(p)
	{
		p->status = 0;
		p->Cspeed = 0;
		p->Aspeed = 0;
		p->Bspeed = 0;
		p->maxspeed = 0;
		p->Totalsize = 0;
		p->backgroundsize = 0;
		p->Failcode = 0;

		p->http_pid=0;
	
		memset( &p->starttime, 0, sizeof(p->starttime) );	
		memset( &p->endtime, 0, sizeof(p->endtime) );
/*
		if( p->pInterface && p->pInterface[0] && (transfer2IfName( p->pInterface, p->IfName )==0) )
		{
#ifdef DUAL_STACK_LITE
			MIB_CE_ATM_VC_T wan;
			int idx;

			if(getATMVCEntry(p->pInterface, &wan, &idx) == 0 && wan.dslite_enable)
				strcpy(p->IfName, "tun1");
#endif

			LANDEVNAME2BR0(p->IfName);
		}else
			p->IfName[0]=0;
*/	
		if(p->testMode != eserverMode)
		{
			if(p->prealURL){
				free(p->prealURL);
				p->prealURL=NULL;
			}
		}
		if(p->wanip){
			free(p->wanip);
			p->wanip=NULL;
		}
		if(p->pppoename){
			free(p->pppoename);
			p->pppoename=NULL;
		}

#ifdef CONFIG_E8B
		unsigned char max_sampled = MAX_SAMPLED;
		p->max_sampled = max_sampled;

		if(p->SampledValues)
			free(p->SampledValues);
		p->SampledValues = NULL;

		if(p->SampledTotalValues)
			free(p->SampledTotalValues);
		p->SampledTotalValues = NULL;

		if(max_sampled > 0)
		{
			p->SampledValues = malloc(sizeof(double) * max_sampled);
			memset(p->SampledValues, 0, (sizeof(double) * max_sampled));
			p->SampledTotalValues = malloc(sizeof(double) * max_sampled);
			memset(p->SampledTotalValues, 0, (sizeof(double) * max_sampled));
	}
#endif
	}
}

void StopCU_SpeedTestDiag(void)
{
#if 1
#if defined(CONFIG_E8B) && defined(CONFIG_USER_AXEL)
	system("/bin/killall axel");
#endif
#else
#if defined(CONFIG_E8B) && defined(CONFIG_USER_AXEL)
	unsigned char use_axel = 0;
	mib_get(PROVINCE_TR143_SPEED_UP, &use_axel);
	if(use_axel)
	{
		system("/bin/killall axel");
	}
	else
#endif
	{
		TR143StopHttpDiag( &gDownloadDiagnostics );
#ifdef CONFIG_USER_FTP_FTP_FTP
		TR143StopFtpDiag( &gDownloadDiagnostics );
		unlink(FTPDIAG_DOWNLOADFILE);
		unlink(FTPDIAG_DOWNLOADFILE_RESULT);
#endif //CONFIG_USER_FTP_FTP_FTP
	}
#endif
}

#if defined(CONFIG_E8B) && defined(CONFIG_USER_AXEL)

#ifdef CONFIG_SUPPORT_AUTO_DIAG

void cleanup_speedtest_interface()
{
	char ifname[IFNAMSIZ] = {0};
	char ifname_simu[IFNAMSIZ] = {0};
	int i, totalNum;
	MIB_CE_ATM_VC_T simuEntry;

	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			continue;

		memset(ifname, 0, IFNAMSIZ);
		if(111 == simuEntry.mbs)
			break;
	}

	if(i == totalNum)
		return;

	ifGetName(PHY_INTF(simuEntry.ifIndex), ifname, sizeof(ifname));
	snprintf(ifname_simu, IFNAMSIZ,  "%s_0", ifname);

	va_cmd("/bin/spppctl", 2, 1, "del", "7");
	va_cmd("/bin/ethctl", 4, 1, "remsmux", "ipoe", ALIASNAME_NAS0, ifname_simu);
	printf("DEL interface, ifname=%s, wan_idx=%d, acl_idx=%d\n", ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
	RG_Del_Simu_Trap_ACL(simuEntry.cdvt);
	RG_WAN_Interface_Del(simuEntry.rg_wan_idx);
	mib_chain_delete(MIB_SIMU_ATM_VC_TBL, i);
}
#endif

static int get_or_create_speedtest_interface(struct CU_SpeedTest_Diagnostics *p, unsigned char auto_create_wan, char *test_if)
{
	int i;
	int totalNum;
	MIB_CE_ATM_VC_T Entry;
	MIB_CE_ATM_VC_T simuEntry;
	char ifname[IFNAMSIZ] = {0};
	struct in_addr addr  = {0};
	char ifname_simu[IFNAMSIZ];
	struct data_to_pass_st msg;
	int idx = 0;
	int def_wan_idx=-1;
	int ret;
	char *specified_if = p->IfName;
	char *pppusername = p->Eupppoename;
	char *ppppassword = p->Eupassword;

	if(specified_if == NULL || specified_if[0] == '\0' || test_if == NULL)
	{
		printf( "Use default route\n");
#ifdef CONFIG_GPON_FEATURE
        routeInternetWanCheck();
#endif
		return -1;
	}

	// find specified WAN
	totalNum = mib_chain_total(MIB_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry))
			continue;

		if(Entry.enable == 0)
			continue;

			ifGetName(Entry.ifIndex, ifname, sizeof(ifname));
		if(strcmp(ifname, specified_if) == 0)
			break;
        
#ifdef CONFIG_GPON_FEATURE
        if (-1 == def_wan_idx)
        {
            if ((Entry.cmode != CHANNEL_MODE_BRIDGE) && (Entry.applicationtype & X_CT_SRV_INTERNET) &&
                    getInFlags(ifname, &ret) && (ret & IFF_UP) &&
                    getInAddr(ifname, IP_ADDR, &addr))
                def_wan_idx = i;
        }
#endif
		}

	if(i == totalNum)
	{
		printf( "%s not found, use default route\n", specified_if);
#ifdef CONFIG_GPON_FEATURE
		if (-1 != def_wan_idx)
		{
			mib_chain_get(MIB_ATM_VC_TBL, def_wan_idx, (void *)&Entry);
			set_speedup_usflow(&Entry);
		}
#endif
		return -1;
	}

#ifdef CONFIG_GPON_FEATURE
	/* host speedup must assign stream id for quickly ack*/
	set_speedup_usflow(&Entry);
#endif

#ifdef CONFIG_SUPPORT_AUTO_DIAG
	//Specified WAN has IP, use it to do diagnostics
		if(getInAddr(ifname, IP_ADDR, (void *)&addr) == 1)
		{
			strcpy(test_if, ifname);
			if(p->wanip)
				free(p->wanip);
			p->wanip = strdup(inet_ntoa(addr));
			printf( "%s has an IP addres, use it\n", test_if);
			return 0;
		}

	if(!auto_create_wan)
	{
		strcpy(test_if, ifname);
		return 0;
	}

	//Create new WAN
	totalNum = mib_chain_total(MIB_SIMU_ATM_VC_TBL);
	for(i = 0; i < totalNum; i++)
	{
		if(!mib_chain_get(MIB_SIMU_ATM_VC_TBL, i, (void *)&simuEntry))
			continue;

		if(111 == simuEntry.mbs)
			break;
	}

	memcpy(&simuEntry, &Entry, sizeof(MIB_CE_ATM_VC_T));
	simuEntry.applicationtype = X_CT_SRV_INTERNET;
	simuEntry.cmode = CHANNEL_MODE_PPPOE;
	simuEntry.brmode = BRIDGE_DISABLE;
	simuEntry.mbs = 111;	//create for TR-143
	simuEntry.MacAddr[MAC_ADDR_LEN-1] = (simuEntry.MacAddr[MAC_ADDR_LEN-1] + 8);
	simuEntry.MacAddr[MAC_ADDR_LEN-2]++;
	simuEntry.mtu = Entry.mtu - 8;
	simuEntry.pppCtype = CONTINUOUS;
	simuEntry.AddrMode = IPV6_WAN_AUTO;
	simuEntry.Ipv6DhcpRequest = 2;
	simuEntry.itfGroup = 0;
	if(i != totalNum)
	{
		mib_chain_update(MIB_SIMU_ATM_VC_TBL, &simuEntry, i);
	}
	else
	{
		mib_chain_add(MIB_SIMU_ATM_VC_TBL, &simuEntry);
	}

	// convert pppx to nas0_x
	ifGetName(PHY_INTF(Entry.ifIndex), ifname, sizeof(ifname));
	snprintf(ifname_simu, IFNAMSIZ,  "%s_0", ifname);
#ifdef CONFIG_RTK_RG_INIT
	RG_Add_Simu_Trap_ACL(simuEntry.MacAddr, &simuEntry.cdvt);
	RG_add_simu_wan(&simuEntry, i);
	printf( "ADD ifname=%s, wan_idx=%d, acl_idx=%d\n", ifname_simu, simuEntry.rg_wan_idx, simuEntry.cdvt);
#endif

	addSimuEthWANdev(&simuEntry, 0);
	setup_simu_ethernet_config(&simuEntry, ifname_simu);

	//Start to dial
	p->status = eSpeedTest_STAT_PPPOE_DIALING;
	idx += snprintf(&msg.data[idx], BUF_SIZE - idx, "spppctl add 7 ipt 0 pppoe %s", ifname_simu);
	if(pppusername && pppusername[0] != '\0')
	{
		if(p->pppoename)
			free(p->pppoename);
		p->pppoename = strdup(pppusername);
		idx += snprintf(&msg.data[idx], BUF_SIZE - idx, " username %s", pppusername);
	}
	if(ppppassword && ppppassword[0] != '\0')
	{
		idx += snprintf(&msg.data[idx], BUF_SIZE - idx, " password %s", ppppassword);
	}
	idx += snprintf(&msg.data[idx], BUF_SIZE - idx, " gw 1");

	printf( "%s\n", msg.data);
	write_to_pppd(&msg);

	// Check ppp7 is up
	i = 0;
	while(getInAddr("ppp7", IP_ADDR, (void *)&addr) != 1)
	{
		sleep(1);
		i++;

		if(i >= 30)
		{
			cleanup_speedtest_interface();
#ifdef CONFIG_GPON_FEATURE
			if (-1 != def_wan_idx)
			{
				mib_chain_get(MIB_ATM_VC_TBL, def_wan_idx, (void *)&Entry);
				set_speedup_usflow(&Entry);
			}
#endif
			return -1;
		}
	}
	if(p->wanip)
		free(p->wanip);
	p->wanip = strdup(inet_ntoa(addr));
	strcpy(test_if, "ppp7");
#ifdef CONFIG_GPON_FEATURE
    /* host speedup must assign stream id for quickly ack*/
    set_speedup_usflow(&simuEntry);
#endif
#endif

	printf( "Return 0\n");
	return 0;
}


#define CU_SPEED_RESULT_FILE "/tmp/CU_axel_result"
static void parse_axel_speedtest_results(struct CU_SpeedTest_Diagnostics*p)
{
	FILE *f;
	int cnt = 0;
	char line[1024] = {0};

	if(p == NULL)
		return;
again:
	f = fopen(CU_SPEED_RESULT_FILE, "r");
	if(f == NULL)
	{
		cnt++;
		usleep(500000);
		if(cnt > 3)
		{
			printf( "Open "CU_SPEED_RESULT_FILE" failed, give up\n");
			return;
		}
		else
		{
			printf( "Open "CU_SPEED_RESULT_FILE" failed, try again. cnt=%d\n", cnt);
			goto again;
	}
	}

	while(fgets(line, sizeof(line), f) != NULL)
	{
		char name[16] = {0};
		char value[128] = {0};
		sscanf(line, "%[^=]=%[^\n]", name, value);

		printf( "name=%s, value=%s\n", name ,value);

		if(strcmp(name, "result") == 0)
		{
			p->DiagnosticsState = atoi(value);
		}
		else if(strcmp(name, "bom_sec") == 0)
		{
			sscanf(value, "%ld", &p->starttime.tv_sec);
		}
		else if(strcmp(name, "bytes_recv") == 0)
		{
			sscanf(value, "%lu", &p->Totalsize);
		}
		else if(strcmp(name, "eom_sec") == 0)
		{
			sscanf(value, "%ld", &p->endtime.tv_sec);
		}
		else if(strcmp(name, "total_bytes") == 0)
		{
			sscanf(value, "%lu", &p->backgroundsize);
		}
		else if(strcmp(name, "sampled_cnt") == 0)
		{
			int cnt = atoi(value);
			int i;
			unsigned long bytes_per_sec;
			unsigned long max_speed=0,bytes_five_sec=0,totalbytes_five_sec=0;

			if(cnt > p->max_sampled)
				cnt = p->max_sampled;

			for(i = 0 ; i < cnt ; i++)
			{
				fgets(line, sizeof(line), f);
				sscanf(line, "%lu", &bytes_per_sec);
				if(p->SampledValues){
					p->SampledValues[i] = bytes_per_sec;
					if(i < 5)
						bytes_five_sec += bytes_per_sec;
					else{
						if(max_speed < bytes_per_sec)
							max_speed = bytes_per_sec;
					}
				}

				fgets(line, sizeof(line), f);
				sscanf(line, "%lu", &bytes_per_sec);
				if(p->SampledTotalValues){
					p->SampledTotalValues[i] = bytes_per_sec;
					if(i < 5)
						totalbytes_five_sec += bytes_per_sec;
				}
			}

			p->maxspeed = max_speed;
			p->Totalsize -= bytes_five_sec;
			p->backgroundsize -= totalbytes_five_sec;
			p->backgroundsize -= p->Totalsize;
			p->Aspeed = (p->Totalsize/10);
			p->Cspeed = 0;
			break;
		}
		else
		{
			printf( "FIXME: unknown name: %s\n", name);
		}
	}

	if(p->endtime.tv_sec > 10)
		p->starttime.tv_sec = p->endtime.tv_sec-10;

	printf("%s:starttime=%ld,endtime=%ld,size=%lu,backgroup=%lu,Aspeed=%lu,maxspeed=%lu\n",
		__func__,p->starttime.tv_sec,p->endtime.tv_sec,p->Totalsize,p->backgroundsize,p->Aspeed,p->maxspeed);

	fclose(f);
}

void *CU_SpeedTestAxelThread(void *data)
{
	struct CU_SpeedTest_Diagnostics *p=data;
	if(!data) return NULL;
	int ret = 1;
	int timer = 0;
	unsigned long cur_tx_bytes = 0, cur_rx_bytes = 0;
	unsigned char auto_create_wan = 1;
	char test_if[IFNAMSIZ] = {0};
	char str_max_sampled[8] = "0";
	char *testURL;
	int shm_id;
	unsigned 	int *pCspeed=NULL;
	int newwanflag=0;
	MIB_CE_ATM_VC_T wanentry;

	sprintf(str_max_sampled, "%d", p->max_sampled);

	unlink(CU_SPEED_RESULT_FILE);

	// /bin/axel -n 10 -Z -q -o /tmp http://192.168.1.100:80/iqiyi.pgf &
	if(get_or_create_speedtest_interface(p, auto_create_wan, test_if) == 0)
	{
		printf( "/bin/axel -n 4 -y -q -o /tmp -t %s -i %s %s\n", str_max_sampled, test_if, p->prealURL);
		va_cmd("/bin/axel", 11, 0, "-n", "4", "-y", "-q", "-o", "/tmp", "-t", str_max_sampled, "-i", test_if, p->prealURL);
		newwanflag = 1;
	}
	else
	{
		printf( "/bin/axel -n 4 -y -q -o /tmp -t %s %s\n", str_max_sampled, p->prealURL);
		va_cmd("/bin/axel", 9, 0, "-n", "4", "-y", "-q", "-o", "/tmp", "-t", str_max_sampled, p->prealURL);
	}

	p->status = eSpeedTest_STAT_SPEED_TESTING;

	shm_id = shmget((key_t)0x5252, sizeof(unsigned int), 0644 | IPC_CREAT);
	if(shm_id != -1){
		pCspeed = (unsigned int *)shmat ( shm_id , NULL , 0 );
		if(pCspeed == (unsigned int *)(-1))
			pCspeed = NULL;
	}

	printf( "p->max_sampled=%d\n", p->max_sampled);
	while(access(CU_SPEED_RESULT_FILE, F_OK) != 0)
	{
		sleep(1);
		timer++;
		if(pCspeed)
			p->Cspeed = *pCspeed;
		else
			p->Cspeed = 0;

		// 30 is addtional timeout
		if(p->max_sampled > 0 && timer >= p->max_sampled + 30)
		{
			printf( "Max sampled count reached\n");
			break;
		}
	}

	shmdt(pCspeed);
	shmctl(shm_id, IPC_RMID, NULL);
	
	system("/bin/killall axel");
	parse_axel_speedtest_results(p);

#ifdef CONFIG_SUPPORT_AUTO_DIAG
	if(auto_create_wan)
		cleanup_speedtest_interface();
#endif

	if(p->DiagnosticsState == eSpeedTest_Requested)
		p->DiagnosticsState = eSpeedTest_Completed;

	if(p->source == esource_RMS)
		setCWMPSpeedtestDoneFlag(1);
	else
		setSpeedtestDoneFlag(1);
	p->http_pid=0;
#ifdef CONFIG_GPON_FEATURE
	clear_speedup_usflow();
#endif
	if(newwanflag){
		//p->wanip has got in get_or_create_speedtest_interface()
		if(!p->pppoename){
			if(getATMVCEntryByIfName(p->IfName, &wanentry)){
				if(wanentry.cmode == CHANNEL_MODE_PPPOE)
					p->pppoename = strdup(wanentry.pppUsername);
			}
		}
	}else{
		if(!p->wanip || !p->pppoename){
			if(getDefaultRouteATMVCEntry(&wanentry)){
				if(!p->wanip){
					char ifname[32];
					struct in_addr addr;
					ifGetName(wanentry.ifIndex, ifname, sizeof(ifname));
					if(getInAddr(ifname, IP_ADDR, (void *)&addr) == 1)
					{
						p->wanip = strdup(inet_ntoa(addr));
					}
				}
				if(!p->pppoename){
					if(wanentry.cmode == CHANNEL_MODE_PPPOE)
						p->pppoename = strdup(wanentry.pppUsername);
				}
			}
		}
	}
	
	return NULL;
}

void StartCU_SpeedTestDiagAxel(struct CU_SpeedTest_Diagnostics *pCU_SpeedTestDiagnostics)
{
	pthread_t pid;

	if( pthread_create( &pid, NULL, CU_SpeedTestAxelThread, pCU_SpeedTestDiagnostics) != 0 )
	{
		pCU_SpeedTestDiagnostics->DiagnosticsState=eSpeedTest_Completed;
		if(pCU_SpeedTestDiagnostics->source == esource_RMS)
			setCWMPSpeedtestDoneFlag(1);
		else
			setSpeedtestDoneFlag(1);
		return;
	}
	pCU_SpeedTestDiagnostics->http_pid=pid;
	pthread_detach(pid);
	return;
}

#define CURL_GET_SPEED_RESULT_FILE "/tmp/curl_get_speed_result_file"
#define CURL_REPORT_SPEED_RESULT_FILE "/tmp/curl_report_speed_result_file"

int getTimeFormat(struct timeval *pTime, char *timestring)
{
	struct tm m;
	if((pTime == NULL) || (timestring == NULL))
		return 0;
	
	localtime_r(&pTime->tv_sec, &m);
	sprintf(timestring, "%04d%02d%02d%02d%02d%02d", m.tm_year+1900, m.tm_mon+1, m.tm_mday, m.tm_hour, m.tm_min, m.tm_sec);
	return 1;
}	

int URLEncode(const char* str, const int strSize, char* result, const int resultSize)  
{  
    int i;  
    int j = 0;//for result index  
    char ch;  
  
    if ((str==NULL) || (result==NULL) || (strSize<=0) || (resultSize<=0)) {  
        return 0;  
    }  
  
    for ( i=0; (i<strSize)&&(j<resultSize); ++i) {  
        ch = str[i];  
        if (((ch>='A') && (ch<='Z')) ||  
            ((ch>='a') && (ch<='z')) ||  
            ((ch>='0') && (ch<='9'))) {  
            result[j++] = ch;  
        } else if (ch == ' ') {  
		continue;
        } else if (ch == '.' || ch == '-' || ch == '_' || ch == '*' || ch == ':' || ch == ',') {  
            result[j++] = ch;  
        } else {  
            if (j+3 < resultSize) {  
                sprintf(result+j, "%%%02X", (unsigned char)ch);  
                j += 3;  
            } else {  
                return 0;  
            }  
        }  
    }  
  
    result[j] = '\0';  
    return j;  
} 

void RequestSpeedDownloadURL(struct CU_SpeedTest_Diagnostics *pCU_SpeedTestDiagnostics)
{
	int diatype=0, mode=0;
	char diatypestr[32]={0}, wanip[32] = {0}, mac[32]={0};
	char requeststring[512]={0}, obj[512]={0};
	char softver[64] = {0};
	char hwver[64] = {0};
	char productclass[64] =  {0};
	char request[512]={0};
	unsigned char macAddr[MAC_ADDR_LEN];
	unsigned char pppUsername[MAX_PPP_NAME_LEN+1]={0};
	MIB_CE_ATM_VC_T wanentry;
	unsigned int srclength;

	if(getDefaultRouteATMVCEntry(&wanentry))
	{
		char ifname[32];
		struct in_addr addr;
		ifGetName(wanentry.ifIndex, ifname, sizeof(ifname));
		if(getInAddr(ifname, IP_ADDR, (void *)&addr) == 1)
			strcpy(wanip, inet_ntoa(addr));

		if(wanentry.cmode == CHANNEL_MODE_PPPOE)
			strncpy(pppUsername, wanentry.pppUsername, MAX_PPP_NAME_LEN);

		diatype=1;
	}
	sprintf(diatypestr, "%d", diatype);

	mib_get(MIB_PON_MODE, &mode);
	if(mode == EPON_MODE)
	{
		mib_get( MIB_ELAN_MAC_ADDR, (void *)macAddr);
		sprintf (mac, "%02X-%02X-%02X-%02X-%02X-%02X", macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
	}
	else if(mode == GPON_MODE)
	{
		getMIB2Str(MIB_GPON_SN, mac);
	}

	getSYS2Str(SYS_FWVERSION, softver);
	mib_get(MIB_HW_HWVER, hwver);
	mib_get( MIB_HW_CWMP_PRODUCTCLASS, productclass);
	
	cJSON *otherPara = cJSON_CreateObject();

	cJSON_AddStringToObject(otherPara,"name", pppUsername);
	cJSON_AddStringToObject(otherPara, "ip", wanip); 
	cJSON_AddStringToObject(otherPara, "diatype", diatypestr); 
	cJSON_AddStringToObject(otherPara, "mac", mac); 
	cJSON_AddStringToObject(otherPara, "hardwareversion", hwver); 
	cJSON_AddStringToObject(otherPara, "softwareversion", softver); 
	cJSON_AddStringToObject(otherPara, "productclass", productclass); 

	strcpy(requeststring, cJSON_Print(otherPara));
	srclength = strlen(requeststring);  
    	URLEncode(requeststring, srclength, obj, 512); 

	sprintf(request, "%s?info=%s", pCU_SpeedTestDiagnostics->ptestURL, obj);

	cJSON_Delete(otherPara);

	int curl_status=va_cmd("/bin/curl", 5, 1, "-X", "GET", request, "-o", CURL_GET_SPEED_RESULT_FILE);

}

void parse_curl_get_results(char* download, char *ip, char *port, struct CU_SpeedTest_Diagnostics *pCU_SpeedTestDiagnostics)
{
	int speed, ret;
	FILE *f;
	char *code=NULL;
	char *speedstring=NULL;
	char *identify=NULL;
	char *threadcount=NULL;
	char result[256]={0};
	cJSON* result_json=NULL;
	cJSON* temp=NULL;
       char buf[4096]={0};

	f = fopen(CURL_GET_SPEED_RESULT_FILE, "r");
	if (f == NULL)
	{
		fprintf(stderr,
			"FAIL: unable to open %s: %s\n",
			CURL_GET_SPEED_RESULT_FILE, strerror(errno));
	}else{
#if 0
		strcpy(result, "{\"speed\":\"200M\",\"download\":\"Dat/1G.rar\",\"identify\":\"17b82539-052a-43dc-9550-246f591f2121\",\"ip\":\"112.225.241.62\",\"port\":\"8080\"}");
		result_json = cJSON_Parse(result);
#else
		ret=fread(buf, 1, 4096, f);
		result_json = cJSON_Parse(buf);
#endif
		//record error code
		temp = cJSON_GetObjectItem(result_json, "code");
		if(temp)
		{
			code = temp->valuestring;
		}
		
		if(code)
		{
		
		}
		else
		{
			temp = cJSON_GetObjectItem(result_json, "speed");
			if(temp && temp->valuestring)
				speedstring = temp->valuestring;
	
			if(speedstring)
			{
				sscanf(speedstring , "%.2fM", &speed);
				pCU_SpeedTestDiagnostics->Bspeed= speed*1024*1024;
			}

			temp = cJSON_GetObjectItem(result_json, "identify");
			if(temp)
				identify = temp->valuestring;
			if(identify)
				pCU_SpeedTestDiagnostics->identify = strdup(identify);

			temp = cJSON_GetObjectItem(result_json, "threadcount");
			if(temp)
				threadcount = temp->valuestring;

			temp = cJSON_GetObjectItem(result_json, "download");
			if(temp && temp->valuestring)
				strcpy(download, temp->valuestring);

			temp = cJSON_GetObjectItem(result_json, "ip");
			if(temp && temp->valuestring)
				strcpy(ip, temp->valuestring);

			temp = cJSON_GetObjectItem(result_json, "port");
			if(temp && temp->valuestring)
				strcpy(port, temp->valuestring);

		}

		fclose(f);
	}

	cJSON_Delete(result_json);

}

void ReportTestSpeedResult(struct CU_SpeedTest_Diagnostics *pCU_SpeedTestDiagnostics)
{
	int ifindex=-1;
	char wanitf[256]={0};
	char source[32]={0};
	char percent[32]={0}, aspeed[32]={0}, bspeed[32]={0};
	int speed=0, curl_status;
	char result[1024]={0};
	char obj[1024] = {0};  
	char reportResult[1024]={0};
	char starttime[32]={0}, endtime[32]={0}, totalsize[32]={0}, maxspeed[32]={0};
	unsigned int srclength;

	cJSON *otherPara = cJSON_CreateObject();

	if(pCU_SpeedTestDiagnostics->pppoename)
	{
		cJSON_AddStringToObject(otherPara,"name", pCU_SpeedTestDiagnostics->pppoename);
	}
	else
	{
		cJSON_AddStringToObject(otherPara,"name", "");
	}

	ifindex = getifIndexByWanName(pCU_SpeedTestDiagnostics->IfName);
	transfer2WANterface( ifindex, wanitf );
	cJSON_AddStringToObject(otherPara,"WANInterface", wanitf);

	sprintf(aspeed,"%.2f",((double)pCU_SpeedTestDiagnostics->Aspeed)/(1024.0*1024.0));
	cJSON_AddStringToObject(otherPara,"average", aspeed);

	cJSON_AddStringToObject(otherPara,"ip", pCU_SpeedTestDiagnostics->wanip);

	sprintf(bspeed,"%dM",(pCU_SpeedTestDiagnostics->Bspeed)/(1024*1024));
	cJSON_AddStringToObject(otherPara,"speed", bspeed);

	getTimeFormat(&(pCU_SpeedTestDiagnostics->starttime), starttime);
	cJSON_AddStringToObject(otherPara,"startTime", starttime);

	getTimeFormat(&(pCU_SpeedTestDiagnostics->endtime), endtime);
	cJSON_AddStringToObject(otherPara,"stopTime", endtime);

	sprintf(maxspeed,"%.2f",((double)pCU_SpeedTestDiagnostics->maxspeed)/(1024.0*1024.0));
	cJSON_AddStringToObject(otherPara,"maxSpeed", maxspeed);

	sprintf(totalsize,"%.2f",((double)pCU_SpeedTestDiagnostics->Totalsize)/1024.0);
	cJSON_AddStringToObject(otherPara,"downfilelarge", totalsize);

	if(pCU_SpeedTestDiagnostics->Bspeed)
		sprintf(percent,"%.2f",((double)pCU_SpeedTestDiagnostics->Aspeed)*100/(pCU_SpeedTestDiagnostics->Bspeed));
	cJSON_AddStringToObject(otherPara,"percent", percent);

	if(pCU_SpeedTestDiagnostics->source == esource_APP)
		strcpy(source, "APP");
	else if(pCU_SpeedTestDiagnostics->source == esource_PLATFORM)
		strcpy(source, "Platform");
	cJSON_AddStringToObject(otherPara,"Source", source);

	if(pCU_SpeedTestDiagnostics->identify)
		cJSON_AddStringToObject(otherPara,"identify", pCU_SpeedTestDiagnostics->identify);
	else
		cJSON_AddStringToObject(otherPara,"identify", "");

	strcpy(reportResult, cJSON_Print(otherPara));
	srclength = strlen(reportResult);  
    	URLEncode(reportResult, srclength, obj, 1024); 

	sprintf(result, "%s?info=%s", pCU_SpeedTestDiagnostics->preportURL, obj);

	cJSON_Delete(otherPara);

	curl_status=va_cmd("/bin/curl", 5, 1, "-X", "GET", result, "-o", CURL_REPORT_SPEED_RESULT_FILE);	

}

void StartCU_SpeedTestDiag_General(struct CU_SpeedTest_Diagnostics *pCU_SpeedTestDiagnostics)
{
	char download[64]={0}, ip[32]={0}, port[32]={0};
	char realDownloadUrl[256]={0};
	StopCU_SpeedTestDiag();
	ResetCU_SpeedTestResultValues(pCU_SpeedTestDiagnostics);

	if(pCU_SpeedTestDiagnostics->testMode == eserverMode){
		RequestSpeedDownloadURL(pCU_SpeedTestDiagnostics);
		pCU_SpeedTestDiagnostics->status = eSpeedTest_STAT_SERVER_CONNECTING;
		parse_curl_get_results(download, ip, port, pCU_SpeedTestDiagnostics);
		if(strlen(pCU_SpeedTestDiagnostics->pdownloadURL) == 0)
		{
			if(strlen(ip) && strlen(port))
				pCU_SpeedTestDiagnostics->status = eSpeedTest_STAT_SERVER_CONNECTED;
			sprintf(realDownloadUrl, "http://%s:%s/%s", ip, port, download);
			pCU_SpeedTestDiagnostics->prealURL = strdup(realDownloadUrl);
		}
		else
			pCU_SpeedTestDiagnostics->prealURL = strdup(pCU_SpeedTestDiagnostics->pdownloadURL);
	}else{
		pCU_SpeedTestDiagnostics->prealURL = strdup(pCU_SpeedTestDiagnostics->pdownloadURL);
	}
#if defined(CONFIG_E8B) && defined(CONFIG_USER_AXEL)
	StartCU_SpeedTestDiagAxel(pCU_SpeedTestDiagnostics);

	while(pCU_SpeedTestDiagnostics->DiagnosticsState != eSpeedTest_Completed)
	{
		sleep(1);
	}
	
	if(pCU_SpeedTestDiagnostics->testMode == eserverMode)
	{
		pCU_SpeedTestDiagnostics->status = eSpeedTest_STAT_UPLOAD_TEST_RESULT;
		ReportTestSpeedResult(pCU_SpeedTestDiagnostics);
		pCU_SpeedTestDiagnostics->status = eSpeedTest_STAT_TEST_FINISHED;
	}
	else if(pCU_SpeedTestDiagnostics->testMode == edownloadMode)
	{
		pCU_SpeedTestDiagnostics->status = eSpeedTest_STAT_TEST_FINISHED;
	}
	return;
#endif
}

#endif

#endif

#ifdef CONFIG_USER_CUMANAGEDEAMON
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
static const char IF_CONNET[] = "connecting";
#endif
struct wan_status_info {
	char protocol[10];
	char ipAddr[INET_ADDRSTRLEN];
	char *strStatus;
	char servName[MAX_WAN_NAME_LEN];
	unsigned short vlanId;
	unsigned char igmpEnbl;
	char qosEnbl;
	char servType[20];
	char encaps[8];
	char netmask[INET_ADDRSTRLEN];
	char gateway[INET_ADDRSTRLEN];
	char dns1[INET_ADDRSTRLEN];
	char dns2[INET_ADDRSTRLEN];
	char ipv6Addr[64];	/* With Prefix Length */
	char ipv6Prefix[64];	/* With Prefix Length */
	char ipv6Gateway[INET6_ADDRSTRLEN];
	char ipv6Dns1[INET6_ADDRSTRLEN];
	char ipv6Dns2[INET6_ADDRSTRLEN];
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	unsigned char ipv6PrefixOrigin;
	unsigned char addrMode;
#endif
};
int get_wan_status(int ifindex, struct wan_status_info *reEntry)
{
	char ifname[IFNAMSIZ], *str_ipv4;
	char vprio_str[20];
	char MacAddr[20];
	char cmode_str[20];
	int flags, i, k, entryNum, flags_found, isPPP;
#ifdef EMBED
	int spid;
#endif
	MIB_CE_ATM_VC_T entry;
	struct in_addr inAddr;
#ifdef CONFIG_DEV_xDSL
	Modem_LinkSpeed vLs;
	int adslflag;
	MEDIA_TYPE_T mType;
#endif
	int pon_mode = 0;
	FILE * pFile;
	char tmpFile[32], dhcpState[1024];

	struct wan_status_info sEntry[MAX_VC_NUM + MAX_PPP_NUM] = { 0 };
	int count = 0;

#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
	mib_get(MIB_PON_MODE, &pon_mode);
#endif

#ifdef CONFIG_GPON_FEATURE
	rtk_gpon_fsm_status_t onu;
	#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_gpon_ponStatus_get(&onu);
	#else
		rtk_gpon_ponStatus_get(&onu);
	#endif
#endif

#ifdef EMBED
	if ((spid = read_pid(PPP_PID)) > 0)
		kill(spid, SIGUSR2);
	else
		fprintf(stderr, "spppd pidfile not exists\n");
#endif

#ifdef CONFIG_DEV_xDSL
	// check for xDSL link
	if (!adsl_drv_get
	    (RLCM_GET_LINK_SPEED, (void *)&vLs, RLCM_GET_LINK_SPEED_SIZE)
	    || vLs.upstreamRate == 0)
		adslflag = 0;
	else
		adslflag = 1;
#endif
	entryNum = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < entryNum; i++) {
		if (!mib_chain_get(MIB_ATM_VC_TBL, i, &entry)) {
			printf("get MIB chain error\n");
			return -1;
		}
		if(entry.ifIndex != ifindex) continue;
		//record the index.
		count = i;
#ifdef CONFIG_IPV6
		if ((entry.IpProtocol & IPVER_IPV4) == 0)
			continue;	// not IPv4 capable
#endif
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		if (entry.omci_configured==1 && entry.applicationtype&X_CT_SRV_VOICE)
			continue;   
#endif

		ifGetName(entry.ifIndex, ifname, sizeof(ifname));
		flags_found = getInFlags(ifname, &flags);

		switch (entry.cmode) {
		case CHANNEL_MODE_BRIDGE:
			strcpy(sEntry[i].protocol, "br1483");
			isPPP = 0;
			break;
		case CHANNEL_MODE_IPOE:
			#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
				if(entry.ipDhcp == 0){
					strcpy(sEntry[i].protocol, "Static");
					}
				else{
					strcpy(sEntry[i].protocol, "DHCP");
					}
			#else
				strcpy(sEntry[i].protocol, "IPoE");
				
			#endif			
			isPPP = 0;			
			break;
		case CHANNEL_MODE_PPPOE:	//patch for pppoe proxy
			strcpy(sEntry[i].protocol, "PPPoE");
			isPPP = 1;
			break;
		case CHANNEL_MODE_PPPOA:
			strcpy(sEntry[i].protocol, "PPPoA");
			isPPP = 1;
			break;
		default:
			isPPP = 0;
			break;
		}

		strcpy(sEntry[i].ipAddr, "");
#ifdef EMBED
		if (flags_found && getInAddr(ifname, IP_ADDR, &inAddr) == 1) {
			str_ipv4 = inet_ntoa(inAddr);
			// IP Passthrough or IP unnumbered
			if (flags & IFF_POINTOPOINT && (strcmp(str_ipv4, "10.0.0.1") == 0))
				strcpy(sEntry[i].ipAddr, STR_UNNUMBERED);
			else
				strcpy(sEntry[i].ipAddr, str_ipv4);
		}
#endif

		strcpy(sEntry[i].netmask, "");
		if (flags_found && getInAddr(ifname, SUBNET_MASK, &inAddr) == 1) {
			strcpy(sEntry[i].netmask, inet_ntoa(inAddr));
		}

		strcpy(sEntry[i].gateway, "");
		if (flags_found)
		{
			if(isPPP)
			{
				if(getInAddr(ifname, DST_IP_ADDR, &inAddr) == 1)
					strcpy(sEntry[i].gateway, inet_ntoa(inAddr));
			}
			else
			{
				if(entry.ipDhcp == (char)DHCP_CLIENT)
				{
					FILE *fp = NULL;
					char fname[128] = {0};

					sprintf(fname, "%s.%s", MER_GWINFO, ifname);

					if(fp = fopen(fname, "r"))
					{
					fscanf(fp, "%s", sEntry[i].gateway);
					fclose(fp);
				}
				}
				else
				{
					unsigned char zero[IP_ADDR_LEN] = {0};
					if(memcmp(entry.remoteIpAddr, zero, IP_ADDR_LEN))
						strcpy(sEntry[i].gateway, inet_ntoa(*((struct in_addr *)entry.remoteIpAddr)));
				}
			}
		}

		strcpy(sEntry[i].dns1, "");
		strcpy(sEntry[i].dns2, "");
		get_dns_by_wan(&entry, sEntry[i].dns1, sEntry[i].dns2);

		k = getInAddr(ifname, IP_ADDR, &inAddr);
		// set status flag
		if (flags_found) {
			if (flags & IFF_UP) {
#ifdef CONFIG_DEV_xDSL
				mType = MEDIA_INDEX(entry.ifIndex);

				if (!adslflag &&
#ifdef CONFIG_PTMWAN
				(
#endif
				mType == MEDIA_ATM
#ifdef CONFIG_PTMWAN
				|| mType == MEDIA_PTM)
#endif
						)
					sEntry[i].strStatus = (char *)IF_DOWN;
				else {
#endif
						
					if(!k){
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
						if (
#ifdef CONFIG_GPON_FEATURE
						((pon_mode == GPON_MODE && onu == 5) && strcmp(sEntry[i].protocol, "br1483") == 0)||
						#endif
						(pon_mode != GPON_MODE && strcmp(sEntry[i].protocol, "br1483") == 0))
#else
						if (strcmp(sEntry[i].protocol, "br1483") == 0)
#endif
						sEntry[i].strStatus =(char *)IF_UP;
						else if (pon_mode == GPON_MODE && onu == 5)
						sEntry[i].strStatus =(char *)IF_CONNET;
						else
						sEntry[i].strStatus =(char *)IF_DOWN;
					}
					else
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
						if(pon_mode == GPON_MODE && onu == 5)
						sEntry[i].strStatus =(char *)IF_UP;
						else
#endif
						sEntry[i].strStatus =(char *)IF_DOWN;
#ifdef CONFIG_DEV_xDSL
				}
#endif
			}else
				#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
				if((pon_mode == GPON_MODE && onu == 5)&&(strcmp(sEntry[i].protocol, "br1483") != 0))
				sEntry[i].strStatus =(char *)IF_CONNET;
				else
				#endif
				sEntry[i].strStatus = (char *)IF_DOWN;
		} else
			sEntry[i].strStatus = (char *)IF_NA;

		if (isPPP && strcmp(sEntry[i].strStatus, (char *)IF_UP)) {
			sEntry[i].ipAddr[0] = '\0';
		}

		getWanName(&entry, sEntry[i].servName);

#if defined(CONFIG_EXT_SWITCH) || defined(CONFIG_RTL_MULTI_ETH_WAN) || (defined(ITF_GROUP_1P) && defined(ITF_GROUP))
		sEntry[i].vlanId = entry.vid;
#endif

#ifdef CONFIG_IGMPPROXY_MULTIWAN
		sEntry[i].igmpEnbl = entry.enableIGMP;
#endif

#if defined(IP_QOS) || defined(NEW_IP_QOS_SUPPORT)
		sEntry[i].qosEnbl = entry.enableIpQos;
#endif

		if (entry.qos == 0) {
			if (entry.svtype == 0) {
				strcpy(sEntry[i].servType, "UBR Without PCR");
			} else {
				strcpy(sEntry[i].servType, "UBR With PCR");
			}
		} else if (entry.qos == 1) {
			strcpy(sEntry[i].servType, "CBR");
		} else if (entry.qos == 2) {
			strcpy(sEntry[i].servType, "Non Realtime VBR");
		} else if (entry.qos == 3) {
			strcpy(sEntry[i].servType, "Realtime VBR");
		}

		if (entry.encap == 1) {
			strcpy(sEntry[i].encaps, "LLC");
		} else {
			strcpy(sEntry[i].encaps, "VCMUX");
		}
		//found in mit

#ifdef BR_ROUTE_ONEPVC
		if (entry.cmode == CHANNEL_MODE_BRIDGE && entry.br_route_flag == 1) {
			strcpy(sEntry[i].protocol, "br1483");
			sEntry[i].igmpEnbl = 0;
			strcpy(sEntry[i].ipAddr, "");
		}
#endif

		if (entry.cmode == CHANNEL_MODE_IPOE && entry.ipDhcp == DHCP_CLIENT) {
			if(strlen(sEntry[i].ipAddr) < 2) {
				ifGetName(entry.ifIndex, ifname, sizeof(ifname));
				sprintf(tmpFile, "%s.%s", DEFAULT_STATE_FILE, ifname);
				pFile = fopen (tmpFile,"r");
				if (pFile!=NULL)
				{
					memset(dhcpState,0,sizeof(dhcpState));
					fgets(dhcpState, sizeof(dhcpState), pFile);
					sprintf(sEntry[i].ipAddr, "%s", dhcpState);
					fclose (pFile);
				}
			}
		}

		memcpy(reEntry,&sEntry[count],sizeof(struct wan_status_info));
		return 1;
	}

	return 0;
}

void get_pon_temperature(char * xString)
{
	rtk_transceiver_data_t transceiver, readableCfg;
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get
	    (RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get
	    (RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TEMPERATURE, &transceiver, &readableCfg);
#endif
	char* c_str=NULL;
	if(c_str=strstr(readableCfg.buf,"C")){
		printf("c_str=%s\n",c_str);
		printf("readableCfg.buf=%s len=%d\n",readableCfg.buf,strlen(readableCfg.buf));
		(*c_str)='\0';
		printf("readableCfg.buf=%s len=%d\n",readableCfg.buf,strlen(readableCfg.buf));
	    sprintf(xString, "%s", readableCfg.buf);
	}
}

void get_pon_voltage(char * xString)
{
	rtk_transceiver_data_t transceiver, readableCfg;
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE,
				      &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE,
				   &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_VOLTAGE, &transceiver, &readableCfg);
#endif
	sprintf(xString, "%s", readableCfg.buf);
}

void get_pon_current(char * xString)
{
	rtk_transceiver_data_t transceiver, readableCfg;
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get
	    (RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get
	    (RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_BIAS_CURRENT, &transceiver, &readableCfg);
#endif
	sprintf(xString, "%s", readableCfg.buf);
}

void get_pon_txpower(char *xString)
{
	rtk_transceiver_data_t transceiver, readableCfg;
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get
	    (RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER,
				   &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_TX_POWER, &transceiver, &readableCfg);
#endif
	sprintf(xString, "%s", readableCfg.buf);
}

void get_pon_rxpower(char *xString)
{
	rtk_transceiver_data_t transceiver, readableCfg;
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_ponmac_transceiver_get
	    (RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver);
	 _get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver, &readableCfg);
#else
	rtk_ponmac_transceiver_get(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER,
				   &transceiver);
	_get_data_by_type(RTK_TRANSCEIVER_PARA_TYPE_RX_POWER, &transceiver, &readableCfg);
#endif
	sprintf(xString, "%s", readableCfg.buf);
}

void get_pon_traffic(unsigned long long  *tx_value, unsigned long long  *rx_value)
{
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_stat_port_get(RTK_RG_PORT_PON, IF_OUT_OCTETS_INDEX, tx_value);
#else
	rtk_stat_port_get(RTK_PORT_PON, IF_OUT_OCTETS_INDEX, tx_value);
#endif

#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_stat_port_get(RTK_RG_PORT_PON, IF_IN_OCTETS_INDEX, rx_value);
#else
	rtk_stat_port_get(RTK_PORT_PON, IF_IN_OCTETS_INDEX, rx_value);
#endif
}

#if defined(PON_HISTORY_TRAFFIC_MONITOR)
#define PON_TRAFFIC_RECORD		"/tmp/pon_traffic_record"
#define PON_TRAFFIC_RECORD_TMP	"/tmp/pon_traffic_record_tmp"

#define PON_TRAFFIC_RECORD_REVERSE 1

#ifdef PON_TRAFFIC_RECORD_REVERSE
void set_pon_traffic_his(unsigned long long  tx, unsigned long long  rx)
{
	FILE *fp;
	char buf[64]={0};
	int rec_num=0;

	if (access(PON_TRAFFIC_RECORD, F_OK)== -1) {
		fp = fopen(PON_TRAFFIC_RECORD, "w+");
		if(fp){
			sprintf(buf,"%llu %llu\n", tx, rx);
			fprintf(fp, buf);
			fclose(fp);
		}
	}
	else {
		fp=fopen(PON_TRAFFIC_RECORD,"r");
		if(fp) {
			char rc;
			unsigned long long  tx_bytes=0;
			unsigned long long  rx_bytes=0;
			FILE *fp2;
			
			fp2=fopen(PON_TRAFFIC_RECORD_TMP,"w");
			while (fp2 && !(feof(fp))) {
				if(rec_num == 0){
					sprintf(buf,"%llu %llu\n", tx, rx);
					fprintf(fp2, buf);
					rec_num++;
				}

				rc = fscanf(fp, "%llu %llu", &tx_bytes, &rx_bytes);
				if (2 == rc && EOF != rc) {
					rec_num++;

					if(rec_num > PON_HISTORY_TRAFFIC_MONITOR_ITEM_MAX) {
						break;
					} else {
						sprintf(buf,"%llu %llu\n", tx_bytes, rx_bytes);
						fprintf(fp2, buf);
					}
				}
			}

			fclose(fp);

			if(fp2) {
				fclose(fp2);

				char cmd[256];
				snprintf(cmd, 256, "cp -f %s %s", PON_TRAFFIC_RECORD_TMP, PON_TRAFFIC_RECORD);
				system(cmd);
				
				unlink(PON_TRAFFIC_RECORD_TMP);
			}
		}
	}
}
#else
void set_pon_traffic_his(unsigned long long  tx, unsigned long long  rx)
{
	FILE *fp;
	char buf[64]={0};
	int rec_num=0;

	fp=fopen(PON_TRAFFIC_RECORD,"a+");
	if(fp) {
		sprintf(buf,"%llu %llu\n", tx, rx);
		fprintf(fp, buf);
		fclose(fp);
	}
	
	fp=fopen(PON_TRAFFIC_RECORD,"r");
	if(fp) {
		char rc;
		unsigned long long  tx_bytes=0;
		unsigned long long  rx_bytes=0;
		FILE *fp2;
		
		fp2=fopen(PON_TRAFFIC_RECORD_TMP,"w");
		while (fp2 && !(feof(fp))) {
			rc = fscanf(fp, "%llu %llu", &tx_bytes, &rx_bytes);
			if (2 == rc && EOF != rc) {
				rec_num++;

				//remove first line
				if(rec_num > 1) {
					sprintf(buf,"%llu %llu\n", tx_bytes, rx_bytes);
					fprintf(fp2, buf);
				}
			}
		}

		fclose(fp);

		if(fp2) {
			fclose(fp2);
		
			if(rec_num > PON_HISTORY_TRAFFIC_MONITOR_ITEM_MAX) {
				char cmd[256];
				snprintf(cmd, 256, "cp -f %s %s", PON_TRAFFIC_RECORD_TMP, PON_TRAFFIC_RECORD);
				system(cmd);
			}
			unlink(PON_TRAFFIC_RECORD_TMP);
		}
	}
}
#endif

void get_pon_traffic_by_index(unsigned long long  *tx, unsigned long long  *rx, int index)
{
	unsigned long long  tx_bytes=0;
	unsigned long long  rx_bytes=0;
	FILE *fp;
	char buf[64]={0};
	char rc;
	int rec_num=0;

	fp=fopen(PON_TRAFFIC_RECORD,"r");
	if(fp) {
		while ((!(feof(fp))) && (rec_num !=index)) {
			rc = fscanf(fp, "%llu %llu", &tx_bytes, &rx_bytes);
			if (2 == rc && EOF != rc) {
				rec_num++;
			}
		}
		fclose(fp);
	}

	if(rec_num ==index)
	{
		*tx = tx_bytes;
		*rx = rx_bytes;
	}
}

void get_pon_traffic_base(char *xString, int start)
{
	unsigned long long  tx_bytes=0;
	unsigned long long  rx_bytes=0;
	
	if(start < PON_HISTORY_TRAFFIC_MONITOR_ITEM_MAX && start >=0) {
		get_pon_traffic_by_index(&tx_bytes, &rx_bytes, start);
		sprintf(xString, "%llu/%llu", tx_bytes/1024, rx_bytes/1024);
	}
}

void get_pon_traffic_history(char *xString, int start, int num, int len)
{
	int i, k=0;
	unsigned long long  tx_value = 0, rx_value = 0;
	unsigned long long  tx_value_last = 0, rx_value_last = 0;
	unsigned long long  delta_tx_value = 0, delta_rx_value = 0;

	snprintf (xString, len, "%s", "[");

	if(start < PON_HISTORY_TRAFFIC_MONITOR_ITEM_MAX && start >=0 && num >1) {
		for(i=start+1; (i< PON_HISTORY_TRAFFIC_MONITOR_ITEM_MAX && k<=num); i++) {
			tx_value = 0;
			rx_value = 0;
			tx_value_last = 0;
			rx_value_last = 0;

			get_pon_traffic_by_index(&tx_value, &rx_value, i);

#if 0
			if(tx_value ==0 && rx_value==0)
				break;
#endif			
			get_pon_traffic_by_index(&tx_value_last, &rx_value_last, i-1);

#ifdef PON_TRAFFIC_RECORD_REVERSE
			delta_tx_value = tx_value_last - tx_value;
			delta_rx_value = rx_value_last - rx_value;
#else
			delta_tx_value = tx_value - tx_value_last;
			delta_rx_value = rx_value - rx_value_last;
#endif
		
			snprintf(xString, len, "%s%s\"%llu/%llu\"", xString, (k==0)?"":",",delta_tx_value/1024, delta_rx_value/1024);
			k++;
		}
	}

	snprintf(xString, len, "%s]", xString);
}

struct webserver_callout pon_traffic_monitor_ch;
void pon_traffic_monitor(void *dummy)
{
	unsigned long long  tx_bytes;
	unsigned long long  rx_bytes;

	get_pon_traffic(&tx_bytes, &rx_bytes);
	
	set_pon_traffic_his(tx_bytes, rx_bytes);
	
	TIMEOUT(pon_traffic_monitor, 0, PON_HISTORY_TRAFFIC_MONITOR_INTERVAL, pon_traffic_monitor_ch);
}
#endif

#ifdef CONFIG_RTL_WAPI_SUPPORT
struct webserver_callout ntp_ch;
void ntpSechedule_wapi(void *null)
{	
	time_t timep;
	struct tm *p;

	if(opendir("/var/config/myca") != NULL)
		return;
	time(&timep);
	p = localtime(&timep);
 	if(p->tm_year<100){
		TIMEOUT(ntpSechedule_wapi, 0, 10, ntp_ch);	
		return;
 	}
	if(opendir("/var/wifi_wapi") == NULL)  //if use wapi auth
	{
		TIMEOUT(ntpSechedule_wapi, 0, 10, ntp_ch);
		return;
	}
	system("/bin/wifi_wapi/general_cert.sh > /var/wifi_wapi/general_cert_log");
	return;
}
#endif


#ifdef CONFIG_EPON_FEATURE
void show_epon_status(char * xString)
{
	unsigned int pon_mode;
	rtk_epon_llid_entry_t llid_entry;

	if (mib_get(MIB_PON_MODE, &pon_mode) != 0) {
		if (pon_mode != EPON_MODE) {
			fprintf(stderr, "not EPON_MODE Error!");
			return;
		}
	} else {
		fprintf(stderr, "mib_get Error!");
		return;
	}

	llid_entry.llidIdx = 0;
#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_epon_llid_entry_get(&llid_entry);
#else
	rtk_epon_llid_entry_get(&llid_entry);
#endif
    if (llid_entry.valid)
    {
        int ret;

        ret = epon_getAuthState(llid_entry.llidIdx);
        if (1 == ret)
            //nBytesSent += boaWrite(wp, "");
            sprintf(xString,"PON_STATUS_REG_AUTH");
        else
            //nBytesSent += boaWrite(wp, "");
            sprintf(xString,"PON_STATUS_REG_NO_AUTH");
    }
    else
    {
        //nBytesSent += boaWrite(wp, "");
        sprintf(xString,"PON_STATUS_NO_REG_NO_AUTH");
    }

}
#endif

void show_gpon_status(char * xString)
{
	unsigned int pon_mode;
	rtk_gpon_fsm_status_t onu;
	int nBytesSent = 0;

	if (mib_get(MIB_PON_MODE, &pon_mode) != 0) {
		if (pon_mode != GPON_MODE) {
			fprintf(stderr, "not GPON_MODE Error!");
			return;
		}
	} else {
		fprintf(stderr, "mib_get Error!");
		return;
	}

#if defined(CONFIG_RTK_L34_ENABLE)
	rtk_rg_gpon_ponStatus_get(&onu);
#else
	rtk_gpon_ponStatus_get(&onu);
#endif

	if(onu == 5)
		//nBytesSent += boaWrite(wp, "");
		sprintf(xString,"PON_STATUS_REG_AUTH");
	else
		if(onu == 2 || onu ==3 || onu == 4)
			//nBytesSent += boaWrite(wp, "");
			sprintf(xString,"PON_STATUS_REG_NO_AUTH");
		else
			//nBytesSent += boaWrite(wp, "");
			sprintf(xString,"PON_STATUS_NO_REG_NO_AUTH");
}

void getWanSrcIP(struct in_addr server_addr, char *ipaddr)
{
	char buf[256];
	char *tmpfile="/tmp/wansrcip_tmp";
	FILE *fp;

	sprintf(buf,"ip route get %s > %s",inet_ntoa(server_addr),tmpfile);
	system(buf);

	fp=fopen(tmpfile,"r");
	if(fp){
		if(fgets(buf,sizeof(buf),fp)){
			unsigned char *ptr=strstr(buf,"src ");
			if(ptr){
				sscanf(ptr,"src %s \n",ipaddr);
			}
		}
		fclose(fp);
	}
	unlink(tmpfile);
}

void getWanPPPoEUsername(char *pppoename, int namelen)
{
	MIB_CE_ATM_VC_T Entry; 

	if(getDefaultRouteATMVCEntry(&Entry)){
		strncpy(pppoename,Entry.pppUsername,namelen);
	}

}

/******CU Manage Tool LOID Resigter API START******/
unsigned long regstarttime=0;
unsigned int regstart=0;
unsigned int regresult=eUserReg_REGISTER_DEFAULT;

void resetRegStatus(int flag)
{
	regstarttime = 0;
	regstart = 0;
	regresult = flag;
}

void startRegStatus()
{
	regstarttime = getSYSInfoTimer(); 
	regstart = 1;
	regresult = eUserReg_REGISTER_DEFAULT;
}

void startUserReg(unsigned char *loid, unsigned char *password) //same as formUserReg()
{	
	char *s;
	unsigned char vChar;
	unsigned char enable4StageDiag;
	unsigned int regLimit;
	unsigned int regTimes;
	unsigned int regStatus;
	unsigned int regResult;
	unsigned int lineno;
	pid_t cwmp_pid;
	int num_done;
#if defined(CONFIG_GPON_FEATURE)
	int i=0;
#endif
#if defined(CONFIG_EPON_FEATURE)
	int index, entryNum;
	char cmdBuf[64] = {0};
#endif
	int sleep_time = 3;
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
	unsigned int pon_mode;
	mib_get(MIB_PON_MODE, &pon_mode);
#endif
	unsigned char reg_type;
	unsigned char password_hex[MAX_NAME_LEN]={0};
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	unsigned char gui_passauth_enable = 1;
#endif

	mib_get(PROVINCE_DEV_REG_TYPE, &reg_type);
	mib_get(CWMP_USERINFO_LIMIT, &regLimit);
	mib_get(CWMP_USERINFO_TIMES, &regTimes);
	mib_get(CWMP_USERINFO_STATUS, &regStatus);
	mib_get(CWMP_USERINFO_LIMIT, &regLimit);
	mib_get(CWMP_USERINFO_TIMES, &regTimes);
	mib_get(CWMP_USERINFO_RESULT, &regResult);
	
	if (regTimes >= regLimit) {
		vChar = CWMP_REG_IDLE;
		mib_set(CWMP_REG_INFORM_STATUS, &vChar);
		goto FINISH;
	}
	if((regStatus == 0 && regResult == 1) || regStatus ==5){
		goto check_err;
	}

	if (loid[0]) {
		mib_set(MIB_LOID, loid);
		if(reg_type != DEV_REG_TYPE_DEFAULT)
			mib_set(MIB_LOID_OLD,loid);
		#ifdef CONFIG_USER_RTK_ONUCOMM
		//init_onucomm_sock();
		onucomm_pon_loid(loid);
		//close_onucomm_sock();
		#endif
	}
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	else{
		mib_set(MIB_LOID, loid);
		if(reg_type != DEV_REG_TYPE_DEFAULT)
			mib_set(MIB_LOID_OLD,loid);
	}
#else
	else {
		fprintf(stderr, "get LOID error!\n");
		goto check_err;
	}
#endif

	mib_set(MIB_LOID_PASSWD, password);
	if(reg_type != DEV_REG_TYPE_DEFAULT)
		mib_set(MIB_LOID_PASSWD_OLD,password);

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)		
	mib_set(CWMP_GUI_PASSWORD_ENABLE, &gui_passauth_enable);
#endif

/*xl_yue:20081225 record the inform status to avoid acs responses twice for only once informing*/
	vChar = CWMP_REG_REQUESTED;
	mib_set(CWMP_REG_INFORM_STATUS, &vChar);
	/* reset to zero */
	num_done = 0;
	mib_set(CWMP_USERINFO_SERV_NUM_DONE, &num_done);
	mib_set(CWMP_USERINFO_SERV_NAME_DONE, "");
/*xl_yue:20081225 END*/

#if defined(CONFIG_GPON_FEATURE)
	if(pon_mode == 1)
	{
	// Deactive GPON
	// do not use rtk_rg_gpon_deActivate() becuase it does not send link down event.

		system("diag gpon reg-set page 1 offset 0x10 value 0x1");

		system("omcicli mib reset &");

#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
		if(loid[0])
#endif
		{
			if (password[0]) {
				va_cmd("/bin/omcicli", 4, 1, "set", "loid", loid, password);
			} else {
				va_cmd("/bin/omcicli", 3, 1, "set", "loid", loid);
			}
		}

#if (defined(CONFIG_CMCC) || defined(CONFIG_CU)) && defined(CONFIG_PON_LINKCHANGE_EVENT)
		//because we deactivate the gpon
		//we need CONFIG_CMCC_OSGIMANAGE=y
		system("/bin/diag gpon deactivate");
		if (password[0]) {
			//diag gpon set password xxxx
			formatPloamPasswordToHex(password, password_hex);
			va_cmd("/sbin/diag", 4, 1, "gpon", "set", "password-hex", password_hex);
		}
		else {
			va_cmd("/sbin/diag", 4, 1, "gpon", "set", "password", "0000000000");
		}
		system("/bin/diag gpon activate init-state o1");
#endif
//		while(i++ < 10)
			system("diag gpon reg-set page 1 offset 0x10 value 0x3");
	}
#endif
#if defined(CONFIG_EPON_FEATURE)
	if(pon_mode == 2)
	{
		/* Martin ZHU add: release all wan connection IP */
		va_cmd("/bin/ethctl", 2, 1, "enable_nas0_wan", "0");

		va_cmd("/bin/ethctl", 2, 1, "enable_nas0_wan", "1");

#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_epon_llidEntryNum_get(&entryNum);
#else
		rtk_epon_llidEntryNum_get(&entryNum);
#endif

		/* Martin ZHU: 2016-3-24  */
		mib_get(PROVINCE_PONREG_4STAGEDIAG, (void *) &enable4StageDiag);
		for (index = 0; index < entryNum; index++) {
			if(enable4StageDiag)
			{
				system("diag epon reset mib-counter");
			}

			memset(cmdBuf, 0, sizeof(cmdBuf));

			if (password[0]) {
				sprintf(cmdBuf, "/bin/oamcli set ctc loid %d %s %s\n",index, loid, password);
			} else {
				sprintf(cmdBuf, "/bin/oamcli set ctc loid %d %s\n",index, loid);
			}
			system(cmdBuf);

			/* 2016-04-29 siyuan: oam needs to register again using new loid and password */
			sprintf(cmdBuf,"/bin/oamcli trigger register %d", index);
			system(cmdBuf);
		}
	}
#endif

	if(reg_type == DEV_REG_TYPE_JSU)
	{
		int result = NOW_SETTING;
		int status = 99;
		mib_set(CWMP_USERINFO_RESULT, &result);
		mib_set(CWMP_USERINFO_STATUS, &status);
		unlink("/var/inform_status");
	}

#ifdef CONFIG_MIDDLEWARE
	mib_get(CWMP_TR069_ENABLE,(void *)&vChar);
	if(!vChar)
	{	// Martin_ZHU:send CTEVENT_BIND to MidProcess
		vChar = CTEVENT_BIND;
		sendInformEventMsg2MidProcess( vChar );
	}else
#endif
	{
		{
			pid_t tr069_pid;

			// send signal to tr069
			tr069_pid = read_pid("/var/run/cwmp.pid");
			if ( tr069_pid > 0){
#ifdef CONFIG_MIDDLEWARE
				vChar = CTEVENT_BIND;
				mib_set(MIB_MIDWARE_INFORM_EVENT,(void*)&vChar);
				kill(tr069_pid, SIGUSR1);	//SIGUSR2 is used by midware
#else
				kill(tr069_pid, SIGUSR2);
#endif
			}
		}
	}

	// Purposes:
	// 1. Wait for PON driver ready.
	// 2. Wait for old IP release.
	//while(sleep_time)
	//	sleep_time = sleep(sleep_time);

FINISH:
#ifdef COMMIT_IMMEDIATELY
#if defined(CONFIG_CMCC) || defined(CONFIG_CU)
	SaveLOIDReg(); //save LOID and PASSWORD directly, SaveLOIDReg() already has Commit() function
#else
	Commit();
#endif
#endif

check_err:
	return;
}

int getUserRegResult(char *para1, char *para2)
{
	static int rebootTime = 0;
	int i, total, ret;
	MIB_CE_ATM_VC_T entry;
	struct in_addr inAddr;
	FILE *fp;
	char buf[256], serviceName[32];
	unsigned int regStatus;
	unsigned int regLimit;
	unsigned int regTimes;
	unsigned char regInformStatus;
	unsigned int regResult;
	unsigned char needReboot;
	unsigned char enable4StageDiag;
	int serviceNum;
	unsigned char cwmp_status = CWMP_STATUS_NOT_CONNECTED;
	/* Set defautl to JSU becuase mib_get may fail before reboot. */
	/* To prevent show progress bar with FW for JSU. */
	unsigned char reg_type = DEV_REG_TYPE_JSU;
#ifdef CONFIG_RTK_OMCI_V1
	PON_OMCI_CMD_T msg;
#endif
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
	unsigned int pon_mode=0, pon_state=0;
	mib_get(MIB_PON_MODE, &pon_mode);
#endif

	mib_get(PROVINCE_DEV_REG_TYPE, &reg_type);

	mib_get(CWMP_USERINFO_STATUS, &regStatus);
	mib_get(CWMP_USERINFO_LIMIT, &regLimit);
	mib_get(CWMP_USERINFO_TIMES, &regTimes);
	mib_get(CWMP_REG_INFORM_STATUS, &regInformStatus);
	mib_get(CWMP_USERINFO_RESULT, &regResult);
	mib_get(CWMP_USERINFO_NEED_REBOOT, &needReboot);
	mib_get(CWMP_USERINFO_SERV_NUM, &serviceNum);
	mib_get(RS_CWMP_STATUS, &cwmp_status);

	if(regstart == 0){
		return regresult;
	}else{
		if(regTimes >= regLimit){
			resetRegStatus(eeUserReg_REGISTER_FAIL);
			return eeUserReg_REGISTER_FAIL;
		}
		if((regStatus == 0 && regResult == 1) || regStatus ==5){
			resetRegStatus(eUserReg_REGISTER_REGISTED);
			return eUserReg_REGISTER_REGISTED;
		}
		if((getSYSInfoTimer()-regstarttime)<3){ //wait boa task to start reg
			return regresult;
		}
	}

	if (regInformStatus != CWMP_REG_RESPONSED) {	//ACS not returned result
		total = mib_chain_total(MIB_ATM_VC_TBL);

		for (i = 0; i < total; i++) {
			if (mib_chain_get(MIB_ATM_VC_TBL, i, &entry) == 0)
				continue;

			if ((entry.applicationtype & X_CT_SRV_TR069) &&
					ifGetName(entry.ifIndex, buf, sizeof(buf)) &&
					getInFlags(buf, &ret) &&
					(ret & IFF_UP) &&
					getInAddr(buf, IP_ADDR, &inAddr))
				break;
		}

#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
		if(pon_mode == 1)
		{
#if !defined(CONFIG_CMCC) && !defined(CONFIG_CU)
#ifdef CONFIG_RTK_OMCI_V1
			/* During deactivate, the IP may not be cleared in a small period of time.*/
			/* So check gpon state first. */
			memset(&msg, 0, sizeof(msg));
			msg.cmd = PON_OMCI_CMD_LOIDAUTH_GET_RSP;
			ret = omci_SendCmdAndGet(&msg);

			if (ret != GOS_OK || (msg.state != 0 && msg.state != 1)) {
				resetRegStatus(eUserReg_REGISTER_OLT_FAIL);
				return eUserReg_REGISTER_OLT_FAIL;
			}
			pon_state = msg.state;
#endif
#endif
#if defined(CONFIG_E8B) && defined(CONFIG_PON_CONFIGURATION_COMPLETE_EVENT)
			pon_state = get_omci_complete_event_shm();
#endif
#if (defined(CONFIG_CMCC) || defined(CONFIG_CU)) && defined(CONFIG_E8B) && defined(CONFIG_GPON_FEATURE)
			if(getGponONUState()==GPON_STATE_O5){
				pon_state = 1;
				printf("%s:%d pon_state is O5\n", __FUNCTION__, __LINE__);
			}
			else{
				pon_state = 0;
				printf("%s:%d pon_state is %d\n", __FUNCTION__, __LINE__, getGponONUState());
			}
#endif
		}
		else if(pon_mode == 2)
		{
			rtk_epon_llid_entry_t  llidEntry;

			memset(&llidEntry, 0, sizeof(rtk_epon_llid_entry_t));
			llidEntry.llidIdx = 0;
#ifdef CONFIG_RTK_L34_ENABLE
			rtk_rg_epon_llid_entry_get(&llidEntry);
#else
			rtk_epon_llid_entry_get(&llidEntry);
#endif
			pon_state = llidEntry.valid;//OLT Register successful
		}
#endif

		if ((getSYSInfoTimer()-regstarttime)>= 120)
		{
			/* 120 seconds, timeout */
			if (i == total) {
				/* The interface for TR069 is not ready */
				resetRegStatus(eUserReg_REGISTER_TIMEOUT);
				return eUserReg_REGISTER_TIMEOUT;
			} else {
				resetRegStatus(eeUserReg_REGISTER_FAIL);
				return eeUserReg_REGISTER_FAIL;
			}
		} else {
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
			if (pon_state == 0) {
				strcpy(para1,"20");
				return eUserReg_REGISTER_OLT;
			}

#endif

			if (i == total) {
				/* The interface for TR069 is not ready */
#if defined(CONFIG_GPON_FEATURE) || defined(CONFIG_EPON_FEATURE)
				if(pon_state == 1)
				{
					strcpy(para1,"30");
					return eUserReg_REGISTER_OLT;
				}
#else
				strcpy(para1,"20");
				return eUserReg_REGISTER_OLT;
#endif
			} else {
				strcpy(para1,"40");
				return eUserReg_REGISTER_OLT;
			}
		}
/*star:20080827 END*/
	} else {
		if (regStatus == 0) {
REG_RESULT_RECHECK:
			switch (regResult) {
			case NO_SET:
				strcpy(para1,"50");
				return eUserReg_REGISTER_OK_DOWN_BUSINESS;
			case NOW_SETTING:
				mib_get(CWMP_USERINFO_SERV_NAME, serviceName);
				if (!strstr(serviceName, "IPTV") &&
					!strstr(serviceName, "INTERNET") &&
					!strstr(serviceName, "VOIP")
				   ) {
				} else {
					strcpy(para2,serviceName);
				}
				mib_get(CWMP_USERINFO_SERV_NUM_DONE, &i);

				if(serviceNum > 0)
				{
					if(i>0)
					{
						sprintf(para1,"%d",60 + 40 * (i-1) / serviceNum);
					}
					else
					{
						strcpy(para1,"60");
					}
				}
				else
				{
					strcpy(para1,"60");
				}
				return eUserReg_REGISTER_OK_DOWN_BUSINESS;
			case SET_SUCCESS:
				if(cwmp_status == CWMP_STATUS_CONNETED)
				{
					regResult = NOW_SETTING;
					goto REG_RESULT_RECHECK;
				}
				if (needReboot) {
					if(serviceNum)
					{
						strcpy(para2,serviceName);
					}
					resetRegStatus(eUserReg_REGISTER_OK_NOW_REBOOT);
					return eUserReg_REGISTER_OK_NOW_REBOOT;
				} else {
					if(serviceNum)
					{
						strcpy(para2,serviceName);
					}
					resetRegStatus(eUserReg_REGISTER_OK);
					return eUserReg_REGISTER_OK;
				}
				break;
			case SET_FAULT:
				resetRegStatus(eUserReg_REGISTER_POK);
				return eUserReg_REGISTER_POK;
			}
		}else if (regStatus == 1) {
			if (regTimes < regLimit) {
				resetRegStatus(eUserReg_REGISTER_NOUSER_NOLIMITED);
				sprintf(para1,"%d", regLimit-regTimes);
				return eUserReg_REGISTER_NOUSER_NOLIMITED;
			} else {
				resetRegStatus(eUserReg_REGISTER_NOUSER_LIMITED);
				return eUserReg_REGISTER_NOUSER_LIMITED;
			}
		}else if (regStatus == 2) {
			if (regTimes < regLimit) {
				resetRegStatus(eUserReg_REGISTER_NOACCOUNT_NOLIMITED);
				sprintf(para1,"%d", regLimit-regTimes);
				return eUserReg_REGISTER_NOACCOUNT_NOLIMITED;
			} else {
				resetRegStatus(eUserReg_REGISTER_NOACCOUNT_LIMITED);
				return eUserReg_REGISTER_NOACCOUNT_LIMITED;
			}
		}else if (regStatus == 3) {
			if (regTimes < regLimit) {
				resetRegStatus(eUserReg_REGISTER_NOMATCH_NOLIMITED);
				sprintf(para1,"%d", regLimit-regTimes);
				return eUserReg_REGISTER_NOMATCH_NOLIMITED;
			} else {
				resetRegStatus(eUserReg_REGISTER_NOACCOUNT_LIMITED);
				return eUserReg_REGISTER_NOACCOUNT_LIMITED;
			}
		}else if (regStatus == 4) {
			resetRegStatus(eUserReg_REGISTER_TIMEOUT);
			return eUserReg_REGISTER_TIMEOUT;
		} else if (regStatus == 5) {
			resetRegStatus(eUserReg_REGISTER_REGISTED);
			return eUserReg_REGISTER_REGISTED;
		} else {
			resetRegStatus(eeUserReg_REGISTER_FAIL);
			return eeUserReg_REGISTER_FAIL;
		}
	}

	return eUserReg_REGISTER_DEFAULT;
}

void cuRestartWAN()
{
	restartWAN(CONFIGALL, NULL);
}

void checkGUESTSSID()
{
    FILE *fp;
    char buf[64];
    int restartwlan = -1;
    static int timecount = 0;
    unsigned long guest_ssid_endtime;
    int duration = 0;
    char guest_ssid_2g,guest_ssid_5g;
    char ifname[16];
    static int wlanstopflag = 0;

    fp=fopen(CUMANAGE_GUESTSSID_FILE,"r");
    if(fp)
    {
        if(fgets(buf,64,fp))
        {
            sscanf(buf,"restart:%d\n",&restartwlan);
        }

        printf("%s:restart wlan for guest ssid(%d) 0-stop  1-2Grestart  2-allstop 3-allRestart\n",__func__,restartwlan);

        mib_get(MIB_WLAN_GUEST_SSID, (void *)&guest_ssid_2g);
        mib_get(MIB_WLAN1_GUEST_SSID, (void *)&guest_ssid_5g);
        guest_ssid_2g--;// remap to mib index
        guest_ssid_5g--;// remap to mib index

        switch(restartwlan){
            case 3:
                config_WLAN(ACT_RESTART_5G, guest_ssid_5g);
                mib_get(MIB_WLAN1_GUEST_SSID, (void *)&guest_ssid_5g);
                get_ifname_by_ssid_index(guest_ssid_5g+1, ifname);	
                va_cmd(IWPRIV, 3, 1, ifname, "set_mib", "func_off=0");
            case 1:
                config_WLAN(ACT_RESTART_2G, guest_ssid_2g);
                mib_get(MIB_WLAN_GUEST_SSID, (void *)&guest_ssid_2g);
                // Turn off the guest SSID directly by func_off=1
                get_ifname_by_ssid_index(guest_ssid_2g+1, ifname);	
                va_cmd(IWPRIV, 3, 1, ifname, "set_mib", "func_off=0");
                break;
            case 2:
                config_WLAN(ACT_STOP_5G, guest_ssid_5g);
            case 0:
                config_WLAN(ACT_STOP_2G, guest_ssid_2g);
                break;
            default:
                printf("wlan restart unknown flag:%d 0-stop  1-2Grestart  2-allstop 3-allRestart\n",restartwlan);
                break;
        }

        unlink(CUMANAGE_GUESTSSID_FILE);
    }

    return;
}

void cuRestartLan(int flag)
{
	if(flag & 0x1)
	{
		restart_lanip();
		//setupIngressSetting();
#ifdef CONFIG_RTK_RG_INIT
		//QL if LAN IP changed, ACL rule should be modified synchronously.
		//I just want to call RTK_RG_ACL_IPPort_Filter_Allow_LAN_to_GW().
		restart_IPFilter_DMZ_MACFilter();
#endif
	}
	if(flag & 0x2)
		restart_dhcp();
}

struct webserver_callout cuManage_ch;
void cuManageSechedule(void *dummy)
{
	FILE *fp;
	char buf[64];
	unsigned char userid[64]={0},password[64]={0};
	int wanIndex = -1;
	int restartlan = -1;
	

	fp=fopen(CUMANAGE_LOID_FILE,"r");
	if(fp)
	{
		if(fgets(buf,64,fp))
		{
			sscanf(buf,"userid=%s\n",userid);
		}
		if(fgets(buf,64,fp))
		{
			sscanf(buf,"password=%s\n",password);
		}

		printf("%s:get userid=%s,password=%s\n",__func__,userid,password);

		startUserReg(userid,password);

		unlink(CUMANAGE_LOID_FILE);
	}
	
	fp=fopen(CUMANAGE_PPPOEACCOUNT_FILE,"r");
	if(fp)
	{
		if(fgets(buf,64,fp))
		{
			sscanf(buf,"restart:%d\n",&wanIndex);
		}

		printf("%s:restartflag:%d\n",__func__,wanIndex);

		cuRestartWAN();

		unlink(CUMANAGE_PPPOEACCOUNT_FILE);
	}
	fp=fopen(CUMANAGE_LANPARM_FILE,"r");
	if(fp)
	{
		if(fgets(buf,64,fp))
		{
			sscanf(buf,"restart:%d\n",&restartlan);
		}

		printf("%s:restart lan param : %d  bit0-restartlanip bit1-restartdhcp \n",__func__,restartlan);

		cuRestartLan(restartlan);

		unlink(CUMANAGE_LANPARM_FILE);
	}

	checkGUESTSSID();


	TIMEOUT(cuManageSechedule, 0, 1, cuManage_ch);

}

#ifdef CU_APP_SCHEDULE_LOG
void GenerateScheduledLog(time_t ts, time_t te)
{
	struct tm tm_log;
	time_t tl = 0;
	FILE *fp = NULL, *fp_w = NULL; 
	int jump_file_header_lines = 0;
	char buf[256] ={0};
	
	fp=fopen("/var/config/syslogd.txt","r");
	if(!fp)
		goto END;

	fp_w = fopen("/var/config/sched_syslog","w");
	if(!fp_w)
		goto END;
	
	while(!feof(fp) && fgets(buf,256,fp))
	{
		//printf("%s\n",buf);
		jump_file_header_lines ++;
		if(jump_file_header_lines <= 7)
		{
			fputs(buf,fp_w);
			continue;
		}

		memset(&tm_log,0,sizeof(struct tm));
		sscanf(buf,"%04d-%02d-%02d %02d:%02d:%02d %*s",&tm_log.tm_year,&tm_log.tm_mon,&tm_log.tm_mday,
		&tm_log.tm_hour,&tm_log.tm_min,&tm_log.tm_sec);
		tm_log.tm_year -= 1900;
		tm_log.tm_mon -= 1;	
		tl = mktime(&tm_log);	

		//printf("[%lu - %lu]  time_log = %lu\n",ts,te,tl);	
		if(tl >= ts && tl <= te)
			fputs(buf,fp_w);
	}

END:
	if(fp)
		fclose(fp);
	if(fp_w)
		fclose(fp_w);
	
}

void UploadScheduledLog()
{	
	FILE * fp_sched = NULL;

	fp_sched = fopen("/var/config/syslog_upload_path","r");
	if(fp_sched)
	{
		char upload_path[256]={0}, cmd[256] ={0};
		fgets(upload_path,256,fp_sched);
		printf("[%s]  %s\n",__FUNCTION__,upload_path);
		if(!strncmp(upload_path,"http",4))
		{
			//path like http://software:software@172.29.38.4/
			snprintf(cmd,sizeof(cmd),"curl -T /var/config/sched_syslog %s",upload_path);
			system(cmd);			
		}
		else if(!strncmp(upload_path,"ftp",3))
		{
			//path like ftp://software:software@172.29.38.4/
			snprintf(cmd,sizeof(cmd),"curl -T /var/config/sched_syslog %s",upload_path);
			system(cmd);
		}
		
		fclose(fp_sched);
	}	
}
#endif

/******CU Manage Tool LOID Resigter API END******/

int getLanNetInfoEx(char *pMacAddr, int *num, char *info)
{
	int i, count, ret, specifyMac=0;
	lanHostInfo_t *pLanNetInfo=NULL;
	unsigned char macString[32]={0};
	char ConnectInterface[20]={0};
	char DeviceInfo[128]={0};
	struct in_addr lanIP;
	int powerlevel=0, devNum=0;
	char pDevName[MAX_LANNET_DEV_NAME_LENGTH]={0};
	int speedup=0;

	if((num == NULL) || (info == NULL))
		return -1;

	if(pMacAddr && strlen(pMacAddr) != 0)
		specifyMac = 1;

	ret = get_lan_net_info(&pLanNetInfo, &count);
	if(ret<0)
	{
		goto end;
	}

	for(i=0; i<count; i++)
	{
		sprintf(macString, "%2X%2X%2X%2X%2X%2X", (pLanNetInfo[i].mac)[0], (pLanNetInfo[i].mac)[1],(pLanNetInfo[i].mac)[2], 
			(pLanNetInfo[i].mac)[3],(pLanNetInfo[i].mac)[4], (pLanNetInfo[i].mac)[5]);
		fillcharZeroToMacString(macString);
		if(specifyMac && (!strstr(pMacAddr, macString)))
			continue;

		if(get_attach_device_name(pLanNetInfo[i].mac, pDevName) != 0)
			strcpy(pDevName, pLanNetInfo[i].devName);

		devNum++;

		lanIP.s_addr = pLanNetInfo[i].ip;	
		if(pLanNetInfo[i].connectionType==0){
			sprintf(ConnectInterface, "LAN%d", RG_get_lan_logPortId(pLanNetInfo[i].port-1));
		}
		else if(pLanNetInfo[i].connectionType==1){
			sprintf(ConnectInterface, "SSID%d", pLanNetInfo[i].port);
		}
		
		if(get_acl_rule_for_dscp_mark(pLanNetInfo[i].mac))
			speedup=1;
		else
			speedup=0;
		
		if(i !=(count-1) && (specifyMac == 0))
			sprintf(DeviceInfo, "%s:%s:%s:%s:%d:%d:%d/", pDevName, macString, inet_ntoa(lanIP), ConnectInterface, speedup, powerlevel, pLanNetInfo[i].onLineTime);
		else
			sprintf(DeviceInfo, "%s:%s:%s:%s:%d:%d:%d", pDevName, macString, inet_ntoa(lanIP), ConnectInterface, speedup, powerlevel, pLanNetInfo[i].onLineTime);
		strcat(info, DeviceInfo);
	}

	*num = devNum;


end:
	if(pLanNetInfo)
		free(pLanNetInfo);

	return 0;
	
}

void getAttachWifiDevInfo(int port, char *Protocol, char *RadioType, char *Width, char *Antenna,char *Speed)
{
	MIB_CE_MBSSIB_T Entry;
	unsigned char vChar;
	
	if(mib_chain_get(MIB_MBSSIB_TBL, port-1, &Entry) == 0)
		return;

	if( Entry.wlanBand==BAND_11B)
		strcpy(Protocol, "802.11b");
	else if( Entry.wlanBand==BAND_11A)
		strcpy(Protocol, "802.11a");
	else if( Entry.wlanBand==BAND_11N)
		strcpy(Protocol, "802.11n");
	else if(Entry.wlanBand>=BAND_5G_11AC)
		strcpy(Protocol, "802.11ac");
	else if(Entry.wlanBand>=BAND_11BG)
		strcpy(Protocol, "802.11g");

	if(port > (1+WLAN_MBSSID_NUM))
		strcpy(RadioType, "5G");
	else
		strcpy(RadioType, "2.4G");

#if defined(CONFIG_USB_RTL8192SU_SOFTAP) || defined(CONFIG_RTL8192CD)	//11n only
	if(wl_isNband(Entry.wlanBand))
	{
		mib_get(MIB_WLAN_CHANNEL_WIDTH, &vChar);
		if(vChar)
			strcpy(Width, "40MHz");
		else
			strcpy(Width, "20MHz");
	}
	else
#endif
		strcpy(Width, "20MHz");

	//todo
	strcpy(Antenna, "2*2");	
	strcpy(Speed, "140M"); 
		
}

int getDevWifiInfo(char *pMacAddr, int *num, char *info)
{
	char ConnectInterface[20]={0}, DeviceInfo[128]={0}, Width[32]={0};
	char Protocol[32]={0}, RadioType[32]={0};
	char Antenna[20]={0}, Speed[32]={0};
	unsigned char macString[32]={0};
	int i, count, ret, specifyMac=0, devNum=0;
	lanHostInfo_t *pLanNetInfo=NULL;
	struct in_addr lanIP;
	char pDevName[MAX_LANNET_DEV_NAME_LENGTH]={0};

	if((num == NULL) || (info == NULL))
		return -1;

	if(pMacAddr && (strlen(pMacAddr) != 0))
		specifyMac = 1;

	ret = get_lan_net_info(&pLanNetInfo, &count);
	if(ret<0)
	{
		goto end;
	}

	for(i=0; i<count; i++)
	{
		sprintf(macString, "%2X%2X%2X%2X%2X%2X", (pLanNetInfo[i].mac)[0], (pLanNetInfo[i].mac)[1],(pLanNetInfo[i].mac)[2],
			(pLanNetInfo[i].mac)[3],(pLanNetInfo[i].mac)[4], (pLanNetInfo[i].mac)[5]);
		fillcharZeroToMacString(macString);
		if(specifyMac && (!strstr(pMacAddr, macString)))
			continue;

		if(pLanNetInfo[i].connectionType==0)
			continue;

		if(get_attach_device_name(pLanNetInfo[i].mac, pDevName) != 0)
			strcpy(pDevName, pLanNetInfo[i].devName);

		devNum++;

		lanIP.s_addr = pLanNetInfo[i].ip;	
		sprintf(ConnectInterface, "SSID%d", pLanNetInfo[i].port);
		getAttachWifiDevInfo(pLanNetInfo[i].port, Protocol, RadioType, Width, Antenna, Speed);
		if(i !=(count-1) && (specifyMac == 0))
			sprintf(DeviceInfo, "%s:%s:%s:%s:%s:%s:%s:%s:%s/", pDevName, macString, inet_ntoa(lanIP), ConnectInterface, Protocol, RadioType, Width, Antenna, Speed);
		else
			sprintf(DeviceInfo, "%s:%s:%s:%s:%s:%s:%s:%s:%s", pDevName, macString, inet_ntoa(lanIP), ConnectInterface, Protocol, RadioType, Width, Antenna, Speed);
		strcat(info, DeviceInfo);
	}

	*num = devNum;


end:
	if(pLanNetInfo)
		free(pLanNetInfo);

	return 0;
	
}

unsigned char *DevTypeString[3] = {
	"Other",
	"Phone",
	"PC",
};

int getAttachDevInfo(char *info)
{
	int i, ret, count=0, port=0;
	lanHostInfo_t *pLanNetInfo=NULL;
	unsigned char macString[32]={0};
	char DeviceInfo[128]={0};
	struct in_addr lanIP;
	char DevName[MAX_LANNET_DEV_NAME_LENGTH]={0};
	char DevType[32]={0};
	char Action[32]={0};

	if(info == NULL)
		return 0;

	ret = get_online_and_offline_device_info(&pLanNetInfo, &count);
	if(ret<0)
	{
		goto end;
	}

	for(i=0; i<count; i++)
	{
		sprintf(macString, "%2X%2X%2X%2X%2X%2X", (pLanNetInfo[i].mac)[0], (pLanNetInfo[i].mac)[1],
			(pLanNetInfo[i].mac)[2], (pLanNetInfo[i].mac)[3],(pLanNetInfo[i].mac)[4], (pLanNetInfo[i].mac)[5]);
		fillcharZeroToMacString(macString);
		
		if(get_attach_device_name(pLanNetInfo[i].mac, DevName) != 0)
			strcpy(DevName, pLanNetInfo[i].devName);

		lanIP.s_addr = pLanNetInfo[i].ip;		
		if(pLanNetInfo[i].connectionType==0){
			port = RG_get_lan_logPortId(pLanNetInfo[i].port-1);
		}
		else if(pLanNetInfo[i].connectionType==1){
			port = 0;
		}	

		if(get_attach_device_name(pLanNetInfo[i].mac, DevName) != 0)
		{
			if(pLanNetInfo[i].connectionType==0)
				strcpy(DevType, "PC");
			else
			{	
				if((pLanNetInfo[i].devType >= 0) && (pLanNetInfo[i].devType < 3))
					strcpy(DevType, DevTypeString[pLanNetInfo[i].devType]);
				else
					strcpy(DevType, "Other");
			}
		}

		if(pLanNetInfo[i].firstConnect == 1)
			strcpy(Action, "Online");
		else if(pLanNetInfo[i].disConnect == 1) 
			strcpy(Action, "Offline");
		
		if(i != (count-1))
			sprintf(DeviceInfo, "%s:%s:%s:%s:%d:%d:%s:%s:%s/", DevName, DevType, macString, inet_ntoa(lanIP), pLanNetInfo[i].connectionType, port, pLanNetInfo[i].brand, pLanNetInfo[i].os, Action);
		else
			sprintf(DeviceInfo, "%s:%s:%s:%s:%d:%d:%s:%s:%s", DevName, DevType, macString, inet_ntoa(lanIP), pLanNetInfo[i].connectionType, port, pLanNetInfo[i].brand, pLanNetInfo[i].os, Action);
		strcat(info, DeviceInfo);
	}

end:
	if(pLanNetInfo)
		free(pLanNetInfo);

	return count;
	
}

void restart_cumanage(void)
{
	system("killall cumanagedaemon");	
	va_cmd("/bin/cumanagedaemon",0,0);
}
#endif

#ifdef CONFIG_E8B
unsigned int WANDEVNUM_ATM = 2;
unsigned int WANDEVNUM_PTM = 3;
unsigned int WANDEVNUM_ETH = 1;
#else
unsigned int WANDEVNUM_ATM = 1;
unsigned int WANDEVNUM_PTM = 2;
unsigned int WANDEVNUM_ETH = 3;
#endif

static unsigned int getWanInstFromMediaType(MEDIA_TYPE_T type)
{
	unsigned int wanInst;

	if (type == MEDIA_ETH)
		wanInst = WANDEVNUM_ETH;
	else if (type == MEDIA_PTM)
		wanInst = WANDEVNUM_PTM;
	else			//default
		wanInst = WANDEVNUM_ATM;

	return wanInst;
}

int transfer2WANterface( unsigned int ifindex, char *name )
{
	int total,i;
	MIB_CE_ATM_VC_T *pEntry, vc_entity;

	if( ifindex==DUMMY_IFINDEX ) return -1;
	if( name==NULL ) return -1;
	name[0]=0;

	total = mib_chain_total(MIB_ATM_VC_TBL);
	for( i=0; i<total; i++ )
	{
		pEntry = &vc_entity;
		if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)pEntry ) )
			continue;
		if(pEntry->ifIndex==ifindex)
		{
			char strfmt[]="InternetGatewayDevice.WANDevice.%u.WANConnectionDevice.%u.%s.%u"; //wt-121v8-3.33, no trailing dot
			char ipstr[]="WANIPConnection";
			char pppstr[]="WANPPPConnection";
			char *pconn=NULL;
			unsigned int instnum=0;

			if( (pEntry->cmode==CHANNEL_MODE_PPPOE) ||
#ifdef PPPOE_PASSTHROUGH
			    ((pEntry->cmode==CHANNEL_MODE_BRIDGE)&&(pEntry->brmode==BRIDGE_PPPOE)) ||
#endif
			    (pEntry->cmode==CHANNEL_MODE_PPPOA) )
			{
				pconn = pppstr;
				instnum = pEntry->ConPPPInstNum;
			}else{
				pconn = ipstr;
				instnum = pEntry->ConIPInstNum;
			}

			if( pEntry->connDisable==0 )
			{
				unsigned int waninst;
				waninst=getWanInstFromMediaType(MEDIA_INDEX(pEntry->ifIndex));
				sprintf( name, strfmt, waninst, pEntry->ConDevInstNum , pconn, instnum );

				break;
			}else
				return -1;
		}
	}
	return 0;
}

int check_default_route_exist(void)
{
	int vcTotal=-1, i;
	MIB_CE_ATM_VC_T Entry, rm_Entry;
	
	vcTotal = mib_chain_total(MIB_ATM_VC_TBL);
	for (i = 0; i < vcTotal; i++)
	{
		if (mib_chain_get(MIB_ATM_VC_TBL, i, (void *)&Entry)) {
			if(Entry.dgw == 1 && Entry.cmode) {
				if(Entry.applicationtype & X_CT_SRV_INTERNET) {
					return 1;
				}
			}
		}
	}
	return 0;
}

int is_default_route(char *ifname)
{
	MIB_CE_ATM_VC_T vc_entry = {0};
	unsigned int i,num;
	int wan_ifIndex;
	int ret;
	
	wan_ifIndex = getIfIndexByName(ifname);
	if (wan_ifIndex == -1) return 0;
	
	if(wan_ifIndex==DUMMY_IFINDEX) return 0;
	num = mib_chain_total(MIB_ATM_VC_TBL);
	for( i=0; i<num; i++ )
	{
		if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vc_entry))
			continue;

		if(!vc_entry.cmode)
			continue;
		
		if(!(vc_entry.applicationtype & X_CT_SRV_INTERNET))
			continue;

		if( vc_entry.ifIndex==wan_ifIndex && vc_entry.dgw)
		{
			return 1;
		}
	}
	return 0;
}

int set_default_route(char *ifname, int set)
{
	unsigned char 	Ipv6AddrStr[48], RemoteIpv6AddrStr[48];
	MIB_CE_ATM_VC_T vc_entry = {0};
	struct in_addr inAddr;
	unsigned int i,num;
	int wan_ifIndex;
	int ret;
	
	wan_ifIndex = getIfIndexByName(ifname);
	if (wan_ifIndex == -1) return 0;
	
	if(wan_ifIndex==DUMMY_IFINDEX) return 0;
	num = mib_chain_total(MIB_ATM_VC_TBL);
	for( i=0; i<num; i++ )
	{
		if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vc_entry))
			continue;

		if(!vc_entry.cmode)
			continue;
		
		if(!(vc_entry.applicationtype & X_CT_SRV_INTERNET))
			continue;

		if( vc_entry.ifIndex==wan_ifIndex )
		{
			if(set) {
				vc_entry.dgw = 1;
				if(vc_entry.IpProtocol & IPVER_IPV4) {
					if(getInAddr( ifname, IP_ADDR, (void *)&inAddr) == 1) {
						if(vc_entry.cmode == CHANNEL_MODE_PPPOE) {					
							va_cmd(ROUTE, 3, 1, ARG_ADD, "default", ifname);
						} else if(vc_entry.cmode == CHANNEL_MODE_IPOE) {
							FILE *fp = NULL;
							char fname[128] = {0};
							char gateway[64] = {0};						
							sprintf(fname, "%s.%s", MER_GWINFO, ifname);
							if(fp = fopen(fname, "r"))
							{
								fscanf(fp, "%s", gateway);
								va_cmd(ROUTE, 6, 1, ARG_ADD, "default", "gw", gateway, "dev", ifname);
								fclose(fp);
							}					
						}
					}
				}
				if(vc_entry.IpProtocol & IPVER_IPV6) {
					if(vc_entry.AddrMode & IPV6_WAN_STATIC) {
						inet_ntop(PF_INET6, (struct in6_addr *)vc_entry.RemoteIpv6Addr, RemoteIpv6AddrStr, sizeof(RemoteIpv6AddrStr));
						va_cmd(ROUTE, 7, 1, FW_ADD, "inet6", ARG_ADD, "::/0", "gw", RemoteIpv6AddrStr, ifname);
					}
				}
			} else {
				vc_entry.dgw = 0;				
				va_cmd(ROUTE, 3, 1, ARG_DEL, "default", ifname);
				if(vc_entry.IpProtocol & IPVER_IPV6) {
					if(vc_entry.AddrMode & IPV6_WAN_STATIC) {
						inet_ntop(PF_INET6, (struct in6_addr *)vc_entry.RemoteIpv6Addr, RemoteIpv6AddrStr, sizeof(RemoteIpv6AddrStr));
						va_cmd(ROUTE, 7, 1, FW_ADD, "inet6", ARG_DEL, "::/0", "gw", RemoteIpv6AddrStr, ifname);
					}
				}
			}
			mib_chain_update(MIB_ATM_VC_TBL, &vc_entry, i);
			return 1;
		}
	}
	return 0;
}

int update_default_route(char *ifname)
{
	unsigned char 	Ipv6AddrStr[48], RemoteIpv6AddrStr[48];
	MIB_CE_ATM_VC_T vc_entry = {0};
	unsigned int i,num;
	int wan_ifIndex;
	int ret;
	
	wan_ifIndex = getIfIndexByName(ifname);
	if (wan_ifIndex == -1) return 0;
	
	if(wan_ifIndex==DUMMY_IFINDEX) return 0;
	num = mib_chain_total(MIB_ATM_VC_TBL);
	for( i=0; i<num; i++ )
	{
		if( !mib_chain_get(MIB_ATM_VC_TBL, i, (void*)&vc_entry))
			continue;

		if(!vc_entry.cmode)
			continue;
		
		if(!(vc_entry.applicationtype & X_CT_SRV_INTERNET))
			continue;

		if( vc_entry.ifIndex!=wan_ifIndex )
		{
			unsigned char new_ifname[IFNAMSIZ];
			struct in_addr inAddr;
			
			vc_entry.dgw = 1;
			mib_chain_update(MIB_ATM_VC_TBL, &vc_entry, i);
			ifGetName(vc_entry.ifIndex, new_ifname, sizeof(new_ifname));
			AUG_PRT(" default route updated to %s \n", new_ifname);
			if(vc_entry.IpProtocol & IPVER_IPV4) {
				if(getInAddr( new_ifname, IP_ADDR, (void *)&inAddr) == 1) {
					if(vc_entry.cmode == CHANNEL_MODE_PPPOE) {					
						va_cmd(ROUTE, 3, 1, ARG_ADD, "default", new_ifname);
					} else if(vc_entry.cmode == CHANNEL_MODE_IPOE) {
						FILE *fp = NULL;
						char fname[128] = {0};
						char gateway[64] = {0};						
						sprintf(fname, "%s.%s", MER_GWINFO, new_ifname);
						if(fp = fopen(fname, "r"))
						{
							fscanf(fp, "%s", gateway);
							va_cmd(ROUTE, 6, 1, ARG_ADD, "default", "gw", gateway, "dev", new_ifname);
							fclose(fp);
						}
					}
#ifdef CONFIG_RTK_L34_ENABLE
					RG_update_default_route();
#endif
					AUG_PRT(" default route updated to %s \n", new_ifname);
				}
			}
			if(vc_entry.IpProtocol & IPVER_IPV6) {
				if(vc_entry.AddrMode & IPV6_WAN_STATIC) {
					inet_ntop(PF_INET6, (struct in6_addr *)vc_entry.RemoteIpv6Addr, RemoteIpv6AddrStr, sizeof(RemoteIpv6AddrStr));
					va_cmd(ROUTE, 7, 1, FW_ADD, "inet6", ARG_ADD, "::/0", "gw", RemoteIpv6AddrStr, ifname);
				}
#ifdef CONFIG_RTK_L34_ENABLE
				RG_update_default_route_v6();
#endif
			}
			return 1;
		}
	}
	return 0;
}

int remove_and_update_default_route(char *ifname)
{
	if(is_default_route(ifname)) {
		AUG_PRT(" %s is default route \n", ifname);
		if(set_default_route(ifname, 0)) {
			AUG_PRT(" default route %s removed \n", ifname);
		}
		if(!check_default_route_exist()) {
			AUG_PRT(" default route not exist \n");
			return update_default_route(ifname);
		} else {
			AUG_PRT(" default route exist \n");
		}
	} else {
		AUG_PRT(" %s is not default route \n", ifname);
	}
	
	return 0;
}

#ifdef CONFIG_SUPPORT_PON_LINK_DOWN_PROMPT
int getPONLinkState()
{
	unsigned int pon_mode;
	rtk_gpon_fsm_status_t onu;
	rtk_epon_llid_entry_t llid_entry;
	mib_get(MIB_PON_MODE, &pon_mode);

	if(pon_mode == GPON_MODE)
	{
#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_gpon_ponStatus_get(&onu);
#else
		rtk_gpon_ponStatus_get(&onu);
#endif
		if(onu == 5)
		{
			return 1;
		}
	}
	else if(pon_mode == EPON_MODE)
	{
#if defined(CONFIG_RTK_L34_ENABLE)
		rtk_rg_epon_llid_entry_get(&llid_entry);
#else
		rtk_epon_llid_entry_get(&llid_entry);
#endif
		if (llid_entry.valid)
		{
			int ret;

			ret = epon_getAuthState(llid_entry.llidIdx);
			if (1 == ret)
			{
				return 1;
			}
		}
	}

	return 0;
}
#endif

#ifdef _PRMT_C_CU_LOGALARM_
int isAlarmEnable()
{   
	int vInt=0;
	mib_get(MIB_ALARM_ENABLE,&vInt);
	if (vInt==1)
		return 1;
	return 0;
}

int getAlarmLevel()
{
	int vInt=0;
	mib_get(MIB_ALARM_LEVEL,&vInt);
	return vInt;
}

unsigned int findMaxAlarmid()
{
	unsigned int ret=0, i,count;
	ALARMRECORD_TP alarmRecord=NULL;
	ret = getAlarmInfo(&alarmRecord, &count);
	
	if((count > 0) && (ret >= 0) && alarmRecord)
	{
		for(i=0; i<count; i++)
		{
			if(alarmRecord[i].alarmid >= ret)
			{
				ret = alarmRecord[i].alarmid;
			}
		}
	}	

	if(alarmRecord)
	{
		free(alarmRecord);
		alarmRecord=NULL;
	}

	return ret;
}

int getAlarmInfo(ALARMRECORD_TP *info, int *count)
{
    ALARMRECORD_TP finfo = NULL;
    ALARMRECORD_T entry;
    FILE *fp=NULL;
    int alarmid, alarmcode, raisetime, cleartime;
    int perceivedseverity, alarmstatus, idx=0, len;
    char logStr[64]={0};
    char *tmpBuf=NULL;	
    char line[512]={0};	

    memset(&entry, 0, sizeof(ALARMRECORD_T));
    finfo = (ALARMRECORD_TP) malloc(sizeof(ALARMRECORD_T) * 100);
    if (finfo == NULL) {
        return -1;
    }
	
    *info = (ALARMRECORD_TP) finfo;
    memset(finfo, 0, sizeof(ALARMRECORD_T) * 100);

    fp = fopen(LOG_ALARM_PATH, "r");
    if(fp == NULL)
    {
        printf( "Open %s failed\n", LOG_ALARM_PATH);
        return -1;
    }
    else
    {
        while(fgets(line, sizeof(line), fp) != NULL)
        {
            sscanf(line, "%d %d %d %d %d %d [%s]", &alarmid, &alarmcode, &alarmstatus, &perceivedseverity, &raisetime, &cleartime, logStr);
            tmpBuf = strstr(line, "[")+1;
            len = strlen(tmpBuf);		
            tmpBuf[len-2]='\0';	 
            entry.alarmid = alarmid;
            entry.alarmcode = alarmcode;
            entry.alarmstatus = alarmstatus;
            entry.perceivedseverity = perceivedseverity;
            entry.alarmRaisedTime = raisetime;
            entry.cleartime = cleartime;
            strcpy(entry.logStr, tmpBuf);		
			
            memcpy(&finfo[idx], &entry, sizeof(ALARMRECORD_T));
            idx++;
        }
		
        *count=idx;
		
        fclose(fp);
    }

    return 0;
}

int syslogAlarm(int code, int status, int severity, char *AlarmDetail, int flag)                         
{                                         
	char buf[512]={0};  
	char line[512]={0};     
	int alarmlevel, alarmcode, alarmstatus;
	int id=0, raisetime=0, cleartime=0;
	int perceivedseverity;
   	char logStr[64]={0};
	int find=0;
	FILE *fp = NULL,  *fp_tmp = NULL; 
	                           
	if(!isAlarmEnable())
		return -1;
	
	alarmlevel=getAlarmLevel();
	if(severity > alarmlevel)
		return -1;

	fp = fopen(LOG_ALARM_PATH,"r");
	if(fp == NULL)
	{
		fp = fopen(LOG_ALARM_PATH,"w");
		if(fp == NULL)
		{
			printf("open %s failed!", LOG_ALARM_PATH);
			return -1;
		}

		id = findMaxAlarmid() + 1;
		raisetime = time(NULL);
		sprintf(buf,"%d %d %d %d %d %d [%s]\n", id, code, status, severity, raisetime, cleartime, AlarmDetail);
		fputs(buf, fp);
		fclose(fp);
	}
	else
	{
		fp_tmp = fopen(TEMP_LOG_ALARM_PATH,"w");
		if(fp_tmp == NULL)
		{
			printf("open %s failed!", TEMP_LOG_ALARM_PATH);
			return -1;
		}

		while(fgets(line, sizeof(line), fp) != NULL)
		{
			sscanf(line, "%d %d %d %d %d %d %[%s]\n", &id, &alarmcode, &alarmstatus, &perceivedseverity, &raisetime, &cleartime, logStr);
			if(alarmcode != code) {
				fprintf(fp_tmp, line);
			} else {
				find = 1;
				if(flag == 0)
				{
					raisetime = time(NULL);
					sprintf(buf,"%d %d %d %d %d %d [%s]\n", id, code, status, severity, raisetime, 0, AlarmDetail);
				}
				else
				{
					status = ALARM_RECOVERED;
					cleartime = time(NULL);
					sprintf(buf,"%d %d %d %d %d %d [%s]\n", id, code, status, severity, raisetime, cleartime, AlarmDetail);
				}

				fputs(buf, fp_tmp);
			}
			
		}

		if(find == 0)
		{
			id = findMaxAlarmid() + 1;
			raisetime = time(NULL);
			sprintf(buf,"%d %d %d %d %d %d [%s]\n", id, code, status, severity, raisetime, 0, AlarmDetail);
			fputs(buf, fp_tmp);
		}

		fclose(fp);
		fclose(fp_tmp);
		unlink(LOG_ALARM_PATH);
		rename(TEMP_LOG_ALARM_PATH, LOG_ALARM_PATH);
	}
	return 0;
}

void clearAlarm(unsigned int code)
{
	int i, ret, count=0;
	ALARMRECORD_TP alarmRecord=NULL;
	ret = getAlarmInfo(&alarmRecord, &count);

	if((count > 0) && (ret >= 0) && alarmRecord)
	{
		for(i=0; i<count; i++)
		{
			if(alarmRecord[i].alarmcode == code)
			{
				syslogAlarm(alarmRecord[i].alarmcode, alarmRecord[i].alarmstatus, alarmRecord[i].perceivedseverity, alarmRecord[i].logStr, 1);
				break;
			}
		}
	}	

	if(alarmRecord)
	{
		free(alarmRecord);
		alarmRecord=NULL;
	}
}

#endif

void checkIGMPMLDProxySnooping(int isIGMPenable, int isMLDenable, int isIGMPProxyEnable, int isMLDProxyEnable)
{
	AUG_PRT("isIGMPenable=%d, isMLDenable=%d, isIGMPProxyEnable=%d, isMLDProxyEnable=%d\n", isIGMPenable, isMLDenable, isIGMPProxyEnable, isMLDProxyEnable);
	if(isIGMPProxyEnable && isMLDProxyEnable)
	{
		if(isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 1 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 1 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 1 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 1 > /proc/rg/mld_trap_to_PS");
		}
	}
	else if(!isIGMPProxyEnable && isMLDProxyEnable)
	{
		if(isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 1 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 2 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 2 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 1 > /proc/rg/mld_trap_to_PS");
		}
	}
	else if(isIGMPProxyEnable && !isMLDProxyEnable)
	{
		if(isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 1 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 1 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 1 > /proc/rg/mcast_protocol");
			system("/bin/echo 1 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
	}
	else if(!isIGMPProxyEnable && !isMLDProxyEnable)
	{
		if(isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 1 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && isMLDenable)
		{
			system("/bin/echo 1 > /proc/rg/igmpSnooping");
			system("/bin/echo 2 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
		else if (!isIGMPenable && !isMLDenable)
		{
			system("/bin/echo 0 > /proc/rg/igmpSnooping");
			system("/bin/echo 0 > /proc/rg/mcast_protocol");
			system("/bin/echo 0 > /proc/rg/igmp_trap_to_PS");
			system("/bin/echo 0 > /proc/rg/mld_trap_to_PS");
		}
	}
}

